###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  20:53:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\APP\AES\aes_ige.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\AES\aes_ige.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -D RELEASE -D IMAGE_A -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\List\aes_ige.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\Obj\aes_ige.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\AES\aes_ige.c
      1          /** crypto/aes/aes_ige.c -*- mode:C; c-file-style: "eay" -*- */
      2          /** ====================================================================
      3           * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          
     52          #include <aes.h>
     53          #include "aes_locl.h"
     54          
     55          #define N_WORDS (AES_BLOCK_SIZE / sizeof(unsigned long))
     56          typedef struct {
     57                  unsigned long data[N_WORDS];
     58          } aes_block_t;
     59          
     60          /** XXX: probably some better way to do this */
     61          #if defined(__i386__) || defined(__x86_64__)
     62          #define UNALIGNED_MEMOPS_ARE_FAST 1
     63          #else
     64          #define UNALIGNED_MEMOPS_ARE_FAST 0
     65          #endif
     66          
     67          #if UNALIGNED_MEMOPS_ARE_FAST
     68          #define load_block(d, s)        (d) = *(const aes_block_t *)(s)
     69          #define store_block(d, s)       *(aes_block_t *)(d) = (s)
     70          #else
     71          #define load_block(d, s)        memcpy((d).data, (s), AES_BLOCK_SIZE)
     72          #define store_block(d, s)       memcpy((d), (s).data, AES_BLOCK_SIZE)
     73          #endif
     74          
     75          /** N.B. The IV for this mode is _twice_ the block size */
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void AES_ige_encrypt(const unsigned char *in, unsigned char *out,
     78          					 const unsigned long length, const AES_KEY *key,
     79          					 unsigned char *ivec, const int enc)
     80          	{
   \                     AES_ige_encrypt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB090             SUB      SP,SP,#+64
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x461E             MOV      R6,R3
     81          	unsigned long n;
     82          	unsigned long len;
     83          
     84          	OPENSSL_assert(in && out && key && ivec);
     85          	OPENSSL_assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));
     86          	OPENSSL_assert((length%AES_BLOCK_SIZE) == 0);
     87          
     88          	len = length / AES_BLOCK_SIZE;
   \   0000000C   0xEA4F 0x1812      LSR      R8,R2,#+4
   \   00000010   0x9F18             LDR      R7,[SP, #+96]
     89          
     90          	if (AES_ENCRYPT == enc)
   \   00000012   0x9819             LDR      R0,[SP, #+100]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xF040 0x8093      BNE.W    ??AES_ige_encrypt_0
     91          		{
     92          		if (in != out &&
     93          		    (UNALIGNED_MEMOPS_ARE_FAST || ((size_t)in|(size_t)out|(size_t)ivec)%sizeof(long)==0))
   \   0000001A   0x42AC             CMP      R4,R5
   \   0000001C   0xD03A             BEQ.N    ??AES_ige_encrypt_1
   \   0000001E   0xEA45 0x0004      ORR      R0,R5,R4
   \   00000022   0x4338             ORRS     R0,R7,R0
   \   00000024   0xF010 0x0F03      TST      R0,#0x3
   \   00000028   0xD134             BNE.N    ??AES_ige_encrypt_1
     94          			{
     95          			aes_block_t *ivp = (aes_block_t *)ivec;
   \   0000002A   0x4639             MOV      R1,R7
     96          			aes_block_t *iv2p = (aes_block_t *)(ivec + AES_BLOCK_SIZE);
   \   0000002C   0xF107 0x0910      ADD      R9,R7,#+16
   \   00000030   0xE00F             B.N      ??AES_ige_encrypt_2
     97          
     98          			while (len)
     99          				{
    100          				aes_block_t *inp = (aes_block_t *)in;
    101          				aes_block_t *outp = (aes_block_t *)out;
    102          
    103          				for(n=0 ; n < N_WORDS; ++n)
    104          					outp->data[n] = inp->data[n] ^ ivp->data[n];
    105          				AES_encrypt((unsigned char *)outp->data, (unsigned char *)outp->data, key);
    106          				for(n=0 ; n < N_WORDS; ++n)
    107          					outp->data[n] ^= iv2p->data[n];
   \                     ??AES_ige_encrypt_3: (+1)
   \   00000032   0xF855 0x1020      LDR      R1,[R5, R0, LSL #+2]
   \   00000036   0xF859 0x2020      LDR      R2,[R9, R0, LSL #+2]
   \   0000003A   0x4051             EORS     R1,R2,R1
   \   0000003C   0xF845 0x1020      STR      R1,[R5, R0, LSL #+2]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_4: (+1)
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xD3F5             BCC.N    ??AES_ige_encrypt_3
    108          				ivp = outp;
   \   00000046   0x4629             MOV      R1,R5
    109          				iv2p = inp;
   \   00000048   0x46A1             MOV      R9,R4
    110          				--len;
   \   0000004A   0xF1A8 0x0801      SUB      R8,R8,#+1
    111          				in += AES_BLOCK_SIZE;
   \   0000004E   0x3410             ADDS     R4,R4,#+16
    112          				out += AES_BLOCK_SIZE;
   \   00000050   0x3510             ADDS     R5,R5,#+16
   \                     ??AES_ige_encrypt_2: (+1)
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD012             BEQ.N    ??AES_ige_encrypt_5
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE007             B.N      ??AES_ige_encrypt_6
   \                     ??AES_ige_encrypt_7: (+1)
   \   0000005C   0xF854 0x2020      LDR      R2,[R4, R0, LSL #+2]
   \   00000060   0xF851 0x3020      LDR      R3,[R1, R0, LSL #+2]
   \   00000064   0x405A             EORS     R2,R3,R2
   \   00000066   0xF845 0x2020      STR      R2,[R5, R0, LSL #+2]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_6: (+1)
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD3F5             BCC.N    ??AES_ige_encrypt_7
   \   00000070   0x4632             MOV      R2,R6
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       AES_encrypt
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE7E1             B.N      ??AES_ige_encrypt_4
    113          				}
    114          			memcpy(ivec, ivp->data, AES_BLOCK_SIZE);
   \                     ??AES_ige_encrypt_5: (+1)
   \   0000007E   0x2210             MOVS     R2,#+16
   \   00000080   0x4638             MOV      R0,R7
   \   00000082   0x.... 0x....      BL       __aeabi_memcpy
    115          			memcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);
   \   00000086   0x2210             MOVS     R2,#+16
   \   00000088   0x4649             MOV      R1,R9
   \   0000008A   0xF107 0x0010      ADD      R0,R7,#+16
   \   0000008E   0x.... 0x....      BL       __aeabi_memcpy
    116          			}
   \   00000092   0xE0EE             B.N      ??AES_ige_encrypt_8
    117          		else
    118          			{
    119          			aes_block_t tmp, tmp2;
    120          			aes_block_t iv;
    121          			aes_block_t iv2;
    122          
    123          			load_block(iv, ivec);
   \                     ??AES_ige_encrypt_1: (+1)
   \   00000094   0x2210             MOVS     R2,#+16
   \   00000096   0x4639             MOV      R1,R7
   \   00000098   0xA808             ADD      R0,SP,#+32
   \   0000009A   0x.... 0x....      BL       __aeabi_memcpy
    124          			load_block(iv2, ivec + AES_BLOCK_SIZE);
   \   0000009E   0x2210             MOVS     R2,#+16
   \   000000A0   0xF107 0x0110      ADD      R1,R7,#+16
   \   000000A4   0x4668             MOV      R0,SP
   \   000000A6   0x.... 0x....      BL       __aeabi_memcpy
   \   000000AA   0xE01F             B.N      ??AES_ige_encrypt_9
    125          
    126          			while (len)
    127          				{
    128          				load_block(tmp, in);
    129          				for(n=0 ; n < N_WORDS; ++n)
    130          					tmp2.data[n] = tmp.data[n] ^ iv.data[n];
    131          				AES_encrypt((unsigned char *)tmp2.data, (unsigned char *)tmp2.data, key);
    132          				for(n=0 ; n < N_WORDS; ++n)
    133          					tmp2.data[n] ^= iv2.data[n];
   \                     ??AES_ige_encrypt_10: (+1)
   \   000000AC   0xA904             ADD      R1,SP,#+16
   \   000000AE   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   000000B2   0x466A             MOV      R2,SP
   \   000000B4   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   000000B8   0x4051             EORS     R1,R2,R1
   \   000000BA   0xAA04             ADD      R2,SP,#+16
   \   000000BC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_11: (+1)
   \   000000C2   0x2804             CMP      R0,#+4
   \   000000C4   0xD3F2             BCC.N    ??AES_ige_encrypt_10
    134          				store_block(out, tmp2);
   \   000000C6   0x2210             MOVS     R2,#+16
   \   000000C8   0xA904             ADD      R1,SP,#+16
   \   000000CA   0x4628             MOV      R0,R5
   \   000000CC   0x.... 0x....      BL       __aeabi_memcpy
    135          				iv = tmp2;
   \   000000D0   0xA808             ADD      R0,SP,#+32
   \   000000D2   0xA904             ADD      R1,SP,#+16
   \   000000D4   0x2210             MOVS     R2,#+16
   \   000000D6   0x.... 0x....      BL       __aeabi_memcpy4
    136          				iv2 = tmp;
   \   000000DA   0x4668             MOV      R0,SP
   \   000000DC   0xA90C             ADD      R1,SP,#+48
   \   000000DE   0x2210             MOVS     R2,#+16
   \   000000E0   0x.... 0x....      BL       __aeabi_memcpy4
    137          				--len;
   \   000000E4   0xF1A8 0x0801      SUB      R8,R8,#+1
    138          				in += AES_BLOCK_SIZE;
   \   000000E8   0x3410             ADDS     R4,R4,#+16
    139          				out += AES_BLOCK_SIZE;
   \   000000EA   0x3510             ADDS     R5,R5,#+16
   \                     ??AES_ige_encrypt_9: (+1)
   \   000000EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F0   0xD01A             BEQ.N    ??AES_ige_encrypt_12
   \   000000F2   0x2210             MOVS     R2,#+16
   \   000000F4   0x4621             MOV      R1,R4
   \   000000F6   0xA80C             ADD      R0,SP,#+48
   \   000000F8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xE00A             B.N      ??AES_ige_encrypt_13
   \                     ??AES_ige_encrypt_14: (+1)
   \   00000100   0xA90C             ADD      R1,SP,#+48
   \   00000102   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000106   0xAA08             ADD      R2,SP,#+32
   \   00000108   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   0000010C   0x4051             EORS     R1,R2,R1
   \   0000010E   0xAA04             ADD      R2,SP,#+16
   \   00000110   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000114   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_13: (+1)
   \   00000116   0x2804             CMP      R0,#+4
   \   00000118   0xD3F2             BCC.N    ??AES_ige_encrypt_14
   \   0000011A   0x4632             MOV      R2,R6
   \   0000011C   0xA904             ADD      R1,SP,#+16
   \   0000011E   0xA804             ADD      R0,SP,#+16
   \   00000120   0x.... 0x....      BL       AES_encrypt
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xE7CC             B.N      ??AES_ige_encrypt_11
    140          				}
    141          			memcpy(ivec, iv.data, AES_BLOCK_SIZE);
   \                     ??AES_ige_encrypt_12: (+1)
   \   00000128   0x2210             MOVS     R2,#+16
   \   0000012A   0xA908             ADD      R1,SP,#+32
   \   0000012C   0x4638             MOV      R0,R7
   \   0000012E   0x.... 0x....      BL       __aeabi_memcpy
    142          			memcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);
   \   00000132   0x2210             MOVS     R2,#+16
   \   00000134   0x4669             MOV      R1,SP
   \   00000136   0xF107 0x0010      ADD      R0,R7,#+16
   \   0000013A   0x.... 0x....      BL       __aeabi_memcpy
    143          			}
    144          		}
   \   0000013E   0xE098             B.N      ??AES_ige_encrypt_8
    145          	else
    146          		{
    147          		if (in != out &&
    148          		    (UNALIGNED_MEMOPS_ARE_FAST || ((size_t)in|(size_t)out|(size_t)ivec)%sizeof(long)==0))
   \                     ??AES_ige_encrypt_0: (+1)
   \   00000140   0x42AC             CMP      R4,R5
   \   00000142   0xD03C             BEQ.N    ??AES_ige_encrypt_15
   \   00000144   0xEA45 0x0004      ORR      R0,R5,R4
   \   00000148   0x4338             ORRS     R0,R7,R0
   \   0000014A   0xF010 0x0F03      TST      R0,#0x3
   \   0000014E   0xD136             BNE.N    ??AES_ige_encrypt_15
    149          			{
    150          			aes_block_t *ivp = (aes_block_t *)ivec;
   \   00000150   0x46B9             MOV      R9,R7
    151          			aes_block_t *iv2p = (aes_block_t *)(ivec + AES_BLOCK_SIZE);
   \   00000152   0xF107 0x0A10      ADD      R10,R7,#+16
   \   00000156   0xE00F             B.N      ??AES_ige_encrypt_16
    152          
    153          			while (len)
    154          				{
    155          				aes_block_t tmp;
    156          				aes_block_t *inp = (aes_block_t *)in;
    157          				aes_block_t *outp = (aes_block_t *)out;
    158          
    159          				for(n=0 ; n < N_WORDS; ++n)
    160          					tmp.data[n] = inp->data[n] ^ iv2p->data[n];
    161          				AES_decrypt((unsigned char *)tmp.data, (unsigned char *)outp->data, key);
    162          				for(n=0 ; n < N_WORDS; ++n)
    163          					outp->data[n] ^= ivp->data[n];
   \                     ??AES_ige_encrypt_17: (+1)
   \   00000158   0xF855 0x1020      LDR      R1,[R5, R0, LSL #+2]
   \   0000015C   0xF859 0x2020      LDR      R2,[R9, R0, LSL #+2]
   \   00000160   0x4051             EORS     R1,R2,R1
   \   00000162   0xF845 0x1020      STR      R1,[R5, R0, LSL #+2]
   \   00000166   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_18: (+1)
   \   00000168   0x2804             CMP      R0,#+4
   \   0000016A   0xD3F5             BCC.N    ??AES_ige_encrypt_17
    164          				ivp = inp;
   \   0000016C   0x46A1             MOV      R9,R4
    165          				iv2p = outp;
   \   0000016E   0x46AA             MOV      R10,R5
    166          				--len;
   \   00000170   0xF1A8 0x0801      SUB      R8,R8,#+1
    167          				in += AES_BLOCK_SIZE;
   \   00000174   0x3410             ADDS     R4,R4,#+16
    168          				out += AES_BLOCK_SIZE;
   \   00000176   0x3510             ADDS     R5,R5,#+16
   \                     ??AES_ige_encrypt_16: (+1)
   \   00000178   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000017C   0xD013             BEQ.N    ??AES_ige_encrypt_19
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0xE008             B.N      ??AES_ige_encrypt_20
   \                     ??AES_ige_encrypt_21: (+1)
   \   00000182   0xF854 0x1020      LDR      R1,[R4, R0, LSL #+2]
   \   00000186   0xF85A 0x2020      LDR      R2,[R10, R0, LSL #+2]
   \   0000018A   0x4051             EORS     R1,R2,R1
   \   0000018C   0xAA04             ADD      R2,SP,#+16
   \   0000018E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000192   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_20: (+1)
   \   00000194   0x2804             CMP      R0,#+4
   \   00000196   0xD3F4             BCC.N    ??AES_ige_encrypt_21
   \   00000198   0x4632             MOV      R2,R6
   \   0000019A   0x4629             MOV      R1,R5
   \   0000019C   0xA804             ADD      R0,SP,#+16
   \   0000019E   0x.... 0x....      BL       AES_decrypt
   \   000001A2   0x2000             MOVS     R0,#+0
   \   000001A4   0xE7E0             B.N      ??AES_ige_encrypt_18
    169          				}
    170          			memcpy(ivec, ivp->data, AES_BLOCK_SIZE);
   \                     ??AES_ige_encrypt_19: (+1)
   \   000001A6   0x2210             MOVS     R2,#+16
   \   000001A8   0x4649             MOV      R1,R9
   \   000001AA   0x4638             MOV      R0,R7
   \   000001AC   0x.... 0x....      BL       __aeabi_memcpy
    171          			memcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);
   \   000001B0   0x2210             MOVS     R2,#+16
   \   000001B2   0x4651             MOV      R1,R10
   \   000001B4   0xF107 0x0010      ADD      R0,R7,#+16
   \   000001B8   0x.... 0x....      BL       __aeabi_memcpy
    172          			}
   \   000001BC   0xE059             B.N      ??AES_ige_encrypt_8
    173          		else
    174          			{
    175          			aes_block_t tmp, tmp2;
    176          			aes_block_t iv;
    177          			aes_block_t iv2;
    178          
    179          			load_block(iv, ivec);
   \                     ??AES_ige_encrypt_15: (+1)
   \   000001BE   0x2210             MOVS     R2,#+16
   \   000001C0   0x4639             MOV      R1,R7
   \   000001C2   0xA808             ADD      R0,SP,#+32
   \   000001C4   0x.... 0x....      BL       __aeabi_memcpy
    180          			load_block(iv2, ivec + AES_BLOCK_SIZE);
   \   000001C8   0x2210             MOVS     R2,#+16
   \   000001CA   0xF107 0x0110      ADD      R1,R7,#+16
   \   000001CE   0xA80C             ADD      R0,SP,#+48
   \   000001D0   0x.... 0x....      BL       __aeabi_memcpy
   \   000001D4   0xE01F             B.N      ??AES_ige_encrypt_22
    181          
    182          			while (len)
    183          				{
    184          				load_block(tmp, in);
    185          				tmp2 = tmp;
    186          				for(n=0 ; n < N_WORDS; ++n)
    187          					tmp.data[n] ^= iv2.data[n];
    188          				AES_decrypt((unsigned char *)tmp.data, (unsigned char *)tmp.data, key);
    189          				for(n=0 ; n < N_WORDS; ++n)
    190          					tmp.data[n] ^= iv.data[n];
   \                     ??AES_ige_encrypt_23: (+1)
   \   000001D6   0x4669             MOV      R1,SP
   \   000001D8   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   000001DC   0xAA08             ADD      R2,SP,#+32
   \   000001DE   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   000001E2   0x4051             EORS     R1,R2,R1
   \   000001E4   0x466A             MOV      R2,SP
   \   000001E6   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   000001EA   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_24: (+1)
   \   000001EC   0x2804             CMP      R0,#+4
   \   000001EE   0xD3F2             BCC.N    ??AES_ige_encrypt_23
    191          				store_block(out, tmp);
   \   000001F0   0x2210             MOVS     R2,#+16
   \   000001F2   0x4669             MOV      R1,SP
   \   000001F4   0x4628             MOV      R0,R5
   \   000001F6   0x.... 0x....      BL       __aeabi_memcpy
    192          				iv = tmp2;
   \   000001FA   0xA808             ADD      R0,SP,#+32
   \   000001FC   0xA904             ADD      R1,SP,#+16
   \   000001FE   0x2210             MOVS     R2,#+16
   \   00000200   0x.... 0x....      BL       __aeabi_memcpy4
    193          				iv2 = tmp;
   \   00000204   0xA80C             ADD      R0,SP,#+48
   \   00000206   0x4669             MOV      R1,SP
   \   00000208   0x2210             MOVS     R2,#+16
   \   0000020A   0x.... 0x....      BL       __aeabi_memcpy4
    194          				--len;
   \   0000020E   0xF1A8 0x0801      SUB      R8,R8,#+1
    195          				in += AES_BLOCK_SIZE;
   \   00000212   0x3410             ADDS     R4,R4,#+16
    196          				out += AES_BLOCK_SIZE;
   \   00000214   0x3510             ADDS     R5,R5,#+16
   \                     ??AES_ige_encrypt_22: (+1)
   \   00000216   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000021A   0xD01F             BEQ.N    ??AES_ige_encrypt_25
   \   0000021C   0x2210             MOVS     R2,#+16
   \   0000021E   0x4621             MOV      R1,R4
   \   00000220   0x4668             MOV      R0,SP
   \   00000222   0x.... 0x....      BL       __aeabi_memcpy
   \   00000226   0xA804             ADD      R0,SP,#+16
   \   00000228   0x4669             MOV      R1,SP
   \   0000022A   0x2210             MOVS     R2,#+16
   \   0000022C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0xE00A             B.N      ??AES_ige_encrypt_26
   \                     ??AES_ige_encrypt_27: (+1)
   \   00000234   0x4669             MOV      R1,SP
   \   00000236   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000023A   0xAA0C             ADD      R2,SP,#+48
   \   0000023C   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000240   0x4051             EORS     R1,R2,R1
   \   00000242   0x466A             MOV      R2,SP
   \   00000244   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000248   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_ige_encrypt_26: (+1)
   \   0000024A   0x2804             CMP      R0,#+4
   \   0000024C   0xD3F2             BCC.N    ??AES_ige_encrypt_27
   \   0000024E   0x4632             MOV      R2,R6
   \   00000250   0x4669             MOV      R1,SP
   \   00000252   0x4668             MOV      R0,SP
   \   00000254   0x.... 0x....      BL       AES_decrypt
   \   00000258   0x2000             MOVS     R0,#+0
   \   0000025A   0xE7C7             B.N      ??AES_ige_encrypt_24
    197          				}
    198          			memcpy(ivec, iv.data, AES_BLOCK_SIZE);
   \                     ??AES_ige_encrypt_25: (+1)
   \   0000025C   0x2210             MOVS     R2,#+16
   \   0000025E   0xA908             ADD      R1,SP,#+32
   \   00000260   0x4638             MOV      R0,R7
   \   00000262   0x.... 0x....      BL       __aeabi_memcpy
    199          			memcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);
   \   00000266   0x2210             MOVS     R2,#+16
   \   00000268   0xA90C             ADD      R1,SP,#+48
   \   0000026A   0xF107 0x0010      ADD      R0,R7,#+16
   \   0000026E   0x.... 0x....      BL       __aeabi_memcpy
    200          			}
    201          		}
    202          	}
   \                     ??AES_ige_encrypt_8: (+1)
   \   00000272   0xB010             ADD      SP,SP,#+64
   \   00000274   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    203          
    204          /**
    205           * Note that its effectively impossible to do biIGE in anything other
    206           * than a single pass, so no provision is made for chaining.
    207           */
    208          
    209          /** N.B. The IV for this mode is _four times_ the block size */
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void AES_bi_ige_encrypt(const unsigned char *in, unsigned char *out,
    212          						const unsigned long length, const AES_KEY *key,
    213          						const AES_KEY *key2, const unsigned char *ivec,
    214          						const int enc)
    215          	{
   \                     AES_bi_ige_encrypt: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461D             MOV      R5,R3
    216          	unsigned long n;
    217          	unsigned long len = length;
   \   0000000E   0x46A1             MOV      R9,R4
   \   00000010   0xF8DD 0x806C      LDR      R8,[SP, #+108]
    218          	unsigned char tmp[AES_BLOCK_SIZE];
    219          	unsigned char tmp2[AES_BLOCK_SIZE];
    220          	unsigned char tmp3[AES_BLOCK_SIZE];
    221          	unsigned char prev[AES_BLOCK_SIZE];
    222          	const unsigned char *iv;
    223          	const unsigned char *iv2;
    224          
    225          	OPENSSL_assert(in && out && key && ivec);
    226          	OPENSSL_assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));
    227          	OPENSSL_assert((length%AES_BLOCK_SIZE) == 0);
    228          
    229          	if (AES_ENCRYPT == enc)
   \   00000014   0x981C             LDR      R0,[SP, #+112]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD15A             BNE.N    ??AES_bi_ige_encrypt_0
    230          		{
    231          		/** XXX: Do a separate case for when in != out (strictly should
    232          		   check for overlap, too) */
    233          
    234          		/** First the forward pass */ 
    235          		iv = ivec;
   \   0000001A   0x46C3             MOV      R11,R8
    236          		iv2 = ivec + AES_BLOCK_SIZE;
   \   0000001C   0xF108 0x0A10      ADD      R10,R8,#+16
   \   00000020   0xE013             B.N      ??AES_bi_ige_encrypt_1
    237          		while (len >= AES_BLOCK_SIZE)
    238          			{
    239          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    240          				out[n] = in[n] ^ iv[n];
    241          			AES_encrypt(out, out, key);
    242          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    243          				out[n] ^= iv2[n];
   \                     ??AES_bi_ige_encrypt_2: (+1)
   \   00000022   0x5D81             LDRB     R1,[R0, R6]
   \   00000024   0xF810 0x200A      LDRB     R2,[R0, R10]
   \   00000028   0x4051             EORS     R1,R2,R1
   \   0000002A   0x5581             STRB     R1,[R0, R6]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_bi_ige_encrypt_3: (+1)
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD3F7             BCC.N    ??AES_bi_ige_encrypt_2
    244          			iv = out;
   \   00000032   0x46B3             MOV      R11,R6
    245          			memcpy(prev, in, AES_BLOCK_SIZE);
   \   00000034   0x2210             MOVS     R2,#+16
   \   00000036   0x4639             MOV      R1,R7
   \   00000038   0xA804             ADD      R0,SP,#+16
   \   0000003A   0x.... 0x....      BL       __aeabi_memcpy
    246          			iv2 = prev;
   \   0000003E   0xF10D 0x0A10      ADD      R10,SP,#+16
    247          			len -= AES_BLOCK_SIZE;
   \   00000042   0xF1A9 0x0910      SUB      R9,R9,#+16
    248          			in += AES_BLOCK_SIZE;
   \   00000046   0x3710             ADDS     R7,R7,#+16
    249          			out += AES_BLOCK_SIZE;
   \   00000048   0x3610             ADDS     R6,R6,#+16
   \                     ??AES_bi_ige_encrypt_1: (+1)
   \   0000004A   0xF1B9 0x0F10      CMP      R9,#+16
   \   0000004E   0xD310             BCC.N    ??AES_bi_ige_encrypt_4
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE005             B.N      ??AES_bi_ige_encrypt_5
   \                     ??AES_bi_ige_encrypt_6: (+1)
   \   00000054   0x5DC1             LDRB     R1,[R0, R7]
   \   00000056   0xF810 0x200B      LDRB     R2,[R0, R11]
   \   0000005A   0x4051             EORS     R1,R2,R1
   \   0000005C   0x5581             STRB     R1,[R0, R6]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_bi_ige_encrypt_5: (+1)
   \   00000060   0x2810             CMP      R0,#+16
   \   00000062   0xD3F7             BCC.N    ??AES_bi_ige_encrypt_6
   \   00000064   0x462A             MOV      R2,R5
   \   00000066   0x4631             MOV      R1,R6
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0x.... 0x....      BL       AES_encrypt
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE7DD             B.N      ??AES_bi_ige_encrypt_3
    250          			}
    251          
    252          		/** And now backwards */
    253          		iv = ivec + AES_BLOCK_SIZE*2;
   \                     ??AES_bi_ige_encrypt_4: (+1)
   \   00000072   0xF108 0x0720      ADD      R7,R8,#+32
    254          		iv2 = ivec + AES_BLOCK_SIZE*3;
   \   00000076   0xF108 0x0830      ADD      R8,R8,#+48
    255          		len = length;
   \   0000007A   0xE010             B.N      ??AES_bi_ige_encrypt_7
    256          		while(len >= AES_BLOCK_SIZE)
    257          			{
    258          			out -= AES_BLOCK_SIZE;
    259          			/** XXX: reduce copies by alternating between buffers */
    260          			memcpy(tmp, out, AES_BLOCK_SIZE);
    261          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    262          				out[n] ^= iv[n];
    263          			/**			hexdump(stdout, "out ^ iv", out, AES_BLOCK_SIZE); */
    264          			AES_encrypt(out, out, key);
    265          			/**			hexdump(stdout,"enc", out, AES_BLOCK_SIZE); */
    266          			/**			hexdump(stdout,"iv2", iv2, AES_BLOCK_SIZE); */
    267          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    268          				out[n] ^= iv2[n];
   \                     ??AES_bi_ige_encrypt_8: (+1)
   \   0000007C   0x5D81             LDRB     R1,[R0, R6]
   \   0000007E   0xF810 0x2008      LDRB     R2,[R0, R8]
   \   00000082   0x4051             EORS     R1,R2,R1
   \   00000084   0x5581             STRB     R1,[R0, R6]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_bi_ige_encrypt_9: (+1)
   \   00000088   0x2810             CMP      R0,#+16
   \   0000008A   0xD3F7             BCC.N    ??AES_bi_ige_encrypt_8
    269          			/**			hexdump(stdout,"out", out, AES_BLOCK_SIZE); */
    270          			iv = out;
   \   0000008C   0x4637             MOV      R7,R6
    271          			memcpy(prev, tmp, AES_BLOCK_SIZE);
   \   0000008E   0x2210             MOVS     R2,#+16
   \   00000090   0x4669             MOV      R1,SP
   \   00000092   0xA804             ADD      R0,SP,#+16
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy4
    272          			iv2 = prev;
   \   00000098   0xF10D 0x0810      ADD      R8,SP,#+16
    273          			len -= AES_BLOCK_SIZE;
   \   0000009C   0x3C10             SUBS     R4,R4,#+16
   \                     ??AES_bi_ige_encrypt_7: (+1)
   \   0000009E   0x2C10             CMP      R4,#+16
   \   000000A0   0xF0C0 0x8080      BCC.W    ??AES_bi_ige_encrypt_10
   \   000000A4   0x3E10             SUBS     R6,R6,#+16
   \   000000A6   0x2210             MOVS     R2,#+16
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0x4668             MOV      R0,SP
   \   000000AC   0x.... 0x....      BL       __aeabi_memcpy
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xE004             B.N      ??AES_bi_ige_encrypt_11
   \                     ??AES_bi_ige_encrypt_12: (+1)
   \   000000B4   0x5D81             LDRB     R1,[R0, R6]
   \   000000B6   0x5DC2             LDRB     R2,[R0, R7]
   \   000000B8   0x4051             EORS     R1,R2,R1
   \   000000BA   0x5581             STRB     R1,[R0, R6]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_bi_ige_encrypt_11: (+1)
   \   000000BE   0x2810             CMP      R0,#+16
   \   000000C0   0xD3F8             BCC.N    ??AES_bi_ige_encrypt_12
   \   000000C2   0x462A             MOV      R2,R5
   \   000000C4   0x4631             MOV      R1,R6
   \   000000C6   0x4630             MOV      R0,R6
   \   000000C8   0x.... 0x....      BL       AES_encrypt
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE7DB             B.N      ??AES_bi_ige_encrypt_9
    274          			}
    275          		}
    276          	else
    277          		{
    278          		/** First backwards */
    279          		iv = ivec + AES_BLOCK_SIZE*2;
   \                     ??AES_bi_ige_encrypt_0: (+1)
   \   000000D0   0xF108 0x0A20      ADD      R10,R8,#+32
    280          		iv2 = ivec + AES_BLOCK_SIZE*3;
   \   000000D4   0xF108 0x0B30      ADD      R11,R8,#+48
    281          		in += length;
   \   000000D8   0x19E7             ADDS     R7,R4,R7
    282          		out += length;
   \   000000DA   0x19A6             ADDS     R6,R4,R6
   \   000000DC   0xE011             B.N      ??AES_bi_ige_encrypt_13
    283          		while (len >= AES_BLOCK_SIZE)
    284          			{
    285          			in -= AES_BLOCK_SIZE;
    286          			out -= AES_BLOCK_SIZE;
    287          			memcpy(tmp, in, AES_BLOCK_SIZE);
    288          			memcpy(tmp2, in, AES_BLOCK_SIZE);
    289          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    290          				tmp[n] ^= iv2[n];
    291          			AES_decrypt(tmp, out, key);
    292          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    293          				out[n] ^= iv[n];
   \                     ??AES_bi_ige_encrypt_14: (+1)
   \   000000DE   0x5D81             LDRB     R1,[R0, R6]
   \   000000E0   0xF810 0x200A      LDRB     R2,[R0, R10]
   \   000000E4   0x4051             EORS     R1,R2,R1
   \   000000E6   0x5581             STRB     R1,[R0, R6]
   \   000000E8   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_bi_ige_encrypt_15: (+1)
   \   000000EA   0x2810             CMP      R0,#+16
   \   000000EC   0xD3F7             BCC.N    ??AES_bi_ige_encrypt_14
    294          			memcpy(tmp3, tmp2, AES_BLOCK_SIZE);
   \   000000EE   0x2210             MOVS     R2,#+16
   \   000000F0   0xA90C             ADD      R1,SP,#+48
   \   000000F2   0xA808             ADD      R0,SP,#+32
   \   000000F4   0x.... 0x....      BL       __aeabi_memcpy4
    295          			iv = tmp3;
   \   000000F8   0xF10D 0x0A20      ADD      R10,SP,#+32
    296          			iv2 = out;
   \   000000FC   0x46B3             MOV      R11,R6
    297          			len -= AES_BLOCK_SIZE;
   \   000000FE   0xF1A9 0x0910      SUB      R9,R9,#+16
   \                     ??AES_bi_ige_encrypt_13: (+1)
   \   00000102   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000106   0xD31C             BCC.N    ??AES_bi_ige_encrypt_16
   \   00000108   0x3F10             SUBS     R7,R7,#+16
   \   0000010A   0x3E10             SUBS     R6,R6,#+16
   \   0000010C   0x2210             MOVS     R2,#+16
   \   0000010E   0x4639             MOV      R1,R7
   \   00000110   0x4668             MOV      R0,SP
   \   00000112   0x.... 0x....      BL       __aeabi_memcpy
   \   00000116   0x2210             MOVS     R2,#+16
   \   00000118   0x4639             MOV      R1,R7
   \   0000011A   0xA80C             ADD      R0,SP,#+48
   \   0000011C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x4668             MOV      R0,SP
   \   00000124   0xE005             B.N      ??AES_bi_ige_encrypt_17
   \                     ??AES_bi_ige_encrypt_18: (+1)
   \   00000126   0x5C0A             LDRB     R2,[R1, R0]
   \   00000128   0xF811 0x300B      LDRB     R3,[R1, R11]
   \   0000012C   0x405A             EORS     R2,R3,R2
   \   0000012E   0x540A             STRB     R2,[R1, R0]
   \   00000130   0x1C49             ADDS     R1,R1,#+1
   \                     ??AES_bi_ige_encrypt_17: (+1)
   \   00000132   0x2910             CMP      R1,#+16
   \   00000134   0xD3F7             BCC.N    ??AES_bi_ige_encrypt_18
   \   00000136   0x462A             MOV      R2,R5
   \   00000138   0x4631             MOV      R1,R6
   \   0000013A   0x.... 0x....      BL       AES_decrypt
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xE7D3             B.N      ??AES_bi_ige_encrypt_15
    298          			}
    299          
    300          		/** And now forwards */
    301          		iv = ivec;
   \                     ??AES_bi_ige_encrypt_16: (+1)
   \   00000142   0x4647             MOV      R7,R8
    302          		iv2 = ivec + AES_BLOCK_SIZE;
   \   00000144   0xF108 0x0810      ADD      R8,R8,#+16
    303          		len = length;
   \   00000148   0xE00F             B.N      ??AES_bi_ige_encrypt_19
    304          		while (len >= AES_BLOCK_SIZE)
    305          			{
    306          			memcpy(tmp, out, AES_BLOCK_SIZE);
    307          			memcpy(tmp2, out, AES_BLOCK_SIZE);
    308          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    309          				tmp[n] ^= iv2[n];
    310          			AES_decrypt(tmp, out, key);
    311          			for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
    312          				out[n] ^= iv[n];
   \                     ??AES_bi_ige_encrypt_20: (+1)
   \   0000014A   0x5D81             LDRB     R1,[R0, R6]
   \   0000014C   0x5DC2             LDRB     R2,[R0, R7]
   \   0000014E   0x4051             EORS     R1,R2,R1
   \   00000150   0x5581             STRB     R1,[R0, R6]
   \   00000152   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_bi_ige_encrypt_21: (+1)
   \   00000154   0x2810             CMP      R0,#+16
   \   00000156   0xD3F8             BCC.N    ??AES_bi_ige_encrypt_20
    313          			memcpy(tmp3, tmp2, AES_BLOCK_SIZE);
   \   00000158   0x2210             MOVS     R2,#+16
   \   0000015A   0xA90C             ADD      R1,SP,#+48
   \   0000015C   0xA808             ADD      R0,SP,#+32
   \   0000015E   0x.... 0x....      BL       __aeabi_memcpy4
    314          			iv = tmp3;
   \   00000162   0xAF08             ADD      R7,SP,#+32
    315          			iv2 = out;
   \   00000164   0x46B0             MOV      R8,R6
    316          			len -= AES_BLOCK_SIZE;
   \   00000166   0x3C10             SUBS     R4,R4,#+16
    317          			in += AES_BLOCK_SIZE;
    318          			out += AES_BLOCK_SIZE;
   \   00000168   0x3610             ADDS     R6,R6,#+16
   \                     ??AES_bi_ige_encrypt_19: (+1)
   \   0000016A   0x2C10             CMP      R4,#+16
   \   0000016C   0xD31A             BCC.N    ??AES_bi_ige_encrypt_10
   \   0000016E   0x2210             MOVS     R2,#+16
   \   00000170   0x4631             MOV      R1,R6
   \   00000172   0x4668             MOV      R0,SP
   \   00000174   0x.... 0x....      BL       __aeabi_memcpy
   \   00000178   0x2210             MOVS     R2,#+16
   \   0000017A   0x4631             MOV      R1,R6
   \   0000017C   0xA80C             ADD      R0,SP,#+48
   \   0000017E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000182   0x2100             MOVS     R1,#+0
   \   00000184   0x4668             MOV      R0,SP
   \   00000186   0xE005             B.N      ??AES_bi_ige_encrypt_22
   \                     ??AES_bi_ige_encrypt_23: (+1)
   \   00000188   0x5C0A             LDRB     R2,[R1, R0]
   \   0000018A   0xF811 0x3008      LDRB     R3,[R1, R8]
   \   0000018E   0x405A             EORS     R2,R3,R2
   \   00000190   0x540A             STRB     R2,[R1, R0]
   \   00000192   0x1C49             ADDS     R1,R1,#+1
   \                     ??AES_bi_ige_encrypt_22: (+1)
   \   00000194   0x2910             CMP      R1,#+16
   \   00000196   0xD3F7             BCC.N    ??AES_bi_ige_encrypt_23
   \   00000198   0x462A             MOV      R2,R5
   \   0000019A   0x4631             MOV      R1,R6
   \   0000019C   0x.... 0x....      BL       AES_decrypt
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xE7D7             B.N      ??AES_bi_ige_encrypt_21
    319          			}
    320          		}
    321          	}
   \                     ??AES_bi_ige_encrypt_10: (+1)
   \   000001A4   0xB011             ADD      SP,SP,#+68
   \   000001A6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    322          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   AES_bi_ige_encrypt
       104   -> AES_decrypt
       104   -> AES_encrypt
       104   -> __aeabi_memcpy
       104   -> __aeabi_memcpy4
      96   AES_ige_encrypt
        96   -> AES_decrypt
        96   -> AES_encrypt
        96   -> __aeabi_memcpy
        96   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     426  AES_bi_ige_encrypt
     632  AES_ige_encrypt

 
 1 058 bytes in section .text
 
 1 058 bytes of CODE memory

Errors: none
Warnings: none
