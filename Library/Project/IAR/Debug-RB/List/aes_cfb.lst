###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:47:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_cfb.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_cfb.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\aes_cfb.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\aes_cfb.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_cfb.c
      1          /** crypto/aes/aes_cfb.c -*- mode:C; c-file-style: "eay" -*- */
      2          /** ====================================================================
      3           * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          /** Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
     52           * All rights reserved.
     53           *
     54           * This package is an SSL implementation written
     55           * by Eric Young (eay@cryptsoft.com).
     56           * The implementation was written so as to conform with Netscapes SSL.
     57           * 
     58           * This library is free for commercial and non-commercial use as long as
     59           * the following conditions are aheared to.  The following conditions
     60           * apply to all code found in this distribution, be it the RC4, RSA,
     61           * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
     62           * included with this distribution is covered by the same copyright terms
     63           * except that the holder is Tim Hudson (tjh@cryptsoft.com).
     64           * 
     65           * Copyright remains Eric Young's, and as such any Copyright notices in
     66           * the code are not to be removed.
     67           * If this package is used in a product, Eric Young should be given attribution
     68           * as the author of the parts of the library used.
     69           * This can be in the form of a textual message at program startup or
     70           * in documentation (online or textual) provided with the package.
     71           * 
     72           * Redistribution and use in source and binary forms, with or without
     73           * modification, are permitted provided that the following conditions
     74           * are met:
     75           * 1. Redistributions of source code must retain the copyright
     76           *    notice, this list of conditions and the following disclaimer.
     77           * 2. Redistributions in binary form must reproduce the above copyright
     78           *    notice, this list of conditions and the following disclaimer in the
     79           *    documentation and/or other materials provided with the distribution.
     80           * 3. All advertising materials mentioning features or use of this software
     81           *    must display the following acknowledgement:
     82           *    "This product includes cryptographic software written by
     83           *     Eric Young (eay@cryptsoft.com)"
     84           *    The word 'cryptographic' can be left out if the rouines from the library
     85           *    being used are not cryptographic related :-).
     86           * 4. If you include any Windows specific code (or a derivative thereof) from 
     87           *    the apps directory (application code) you must include an acknowledgement:
     88           *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
     89           * 
     90           * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
     91           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     92           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     93           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
     94           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     95           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     96           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     97           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     98           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     99           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    100           * SUCH DAMAGE.
    101           * 
    102           * The licence and distribution terms for any publically available version or
    103           * derivative of this code cannot be changed.  i.e. this code cannot simply be
    104           * copied and put under another distribution licence
    105           * [including the GNU Public Licence.]
    106           */
    107          
    108          #ifndef AES_DEBUG
    109          # ifndef NDEBUG
    110          #  define NDEBUG
    111          # endif
    112          #endif
    113          #include <assert.h>
    114          
    115          #include <aes.h>
    116          
    117          /** The input and output encrypted as though 128bit cfb mode is being
    118           * used.  The extra state information to record how much of the
    119           * 128bit block we have used is contained in *num;
    120           */
    121          

   \                                 In section .text, align 2, keep-with-next
    122          void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,
    123          	const unsigned long length, const AES_KEY *key,
    124          	unsigned char *ivec, int *num, const int enc) {
   \                     AES_cfb128_encrypt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000D             MOVS     R5,R1
    125          
    126          	unsigned int n;
    127          	unsigned long l = length;
    128          	unsigned char c;
    129          
    130          	assert(in && out && key && ivec && num);
    131          
    132          	n = *num;
   \   00000006   0x9807             LDR      R0,[SP, #+28]
   \   00000008   0x6804             LDR      R4,[R0, #+0]
    133          
    134          	if (enc) {
   \   0000000A   0x9808             LDR      R0,[SP, #+32]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD11B             BNE      ??AES_cfb128_encrypt_0
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD016             BEQ      ??AES_cfb128_encrypt_1
   \   00000014   0x0017             MOVS     R7,R2
    135          		while (l--) {
    136          			if (n == 0) {
    137          				AES_encrypt(ivec, ivec, key);
    138          			}
    139          			ivec[n] = *(out++) = *(in++) ^ ivec[n];
    140          			n = (n+1) % AES_BLOCK_SIZE;
    141          		}
    142          	} else {
    143          		while (l--) {
    144          			if (n == 0) {
   \                     ??AES_cfb128_encrypt_2: (+1)
   \   00000016   0x1E7F             SUBS     R7,R7,#+1
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD104             BNE      ??AES_cfb128_encrypt_3
    145          				AES_encrypt(ivec, ivec, key);
   \   0000001C   0x9A00             LDR      R2,[SP, #+0]
   \   0000001E   0x9906             LDR      R1,[SP, #+24]
   \   00000020   0x0008             MOVS     R0,R1
   \   00000022   0x.... 0x....      BL       AES_encrypt
    146          			}
    147          			c = *(in);
   \                     ??AES_cfb128_encrypt_3: (+1)
   \   00000026   0x7830             LDRB     R0,[R6, #+0]
    148          			*(out++) = *(in++) ^ ivec[n];
   \   00000028   0x9906             LDR      R1,[SP, #+24]
   \   0000002A   0x1909             ADDS     R1,R1,R4
   \   0000002C   0x780A             LDRB     R2,[R1, #+0]
   \   0000002E   0x4042             EORS     R2,R2,R0
   \   00000030   0x702A             STRB     R2,[R5, #+0]
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    149          			ivec[n] = c;
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    150          			n = (n+1) % AES_BLOCK_SIZE;
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0x0724             LSLS     R4,R4,#+28
   \   0000003C   0x0F24             LSRS     R4,R4,#+28
    151          		}
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD1E9             BNE      ??AES_cfb128_encrypt_2
    152          	}
    153          
    154          	*num=n;
   \                     ??AES_cfb128_encrypt_1: (+1)
   \   00000042   0x9807             LDR      R0,[SP, #+28]
   \   00000044   0x6004             STR      R4,[R0, #+0]
    155          }
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??AES_cfb128_encrypt_0: (+1)
   \   00000048   0x2A00             CMP      R2,#+0
   \   0000004A   0xD0FA             BEQ      ??AES_cfb128_encrypt_1
   \   0000004C   0x0017             MOVS     R7,R2
   \                     ??AES_cfb128_encrypt_4: (+1)
   \   0000004E   0x1E7F             SUBS     R7,R7,#+1
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD104             BNE      ??AES_cfb128_encrypt_5
   \   00000054   0x9A00             LDR      R2,[SP, #+0]
   \   00000056   0x9906             LDR      R1,[SP, #+24]
   \   00000058   0x0008             MOVS     R0,R1
   \   0000005A   0x.... 0x....      BL       AES_encrypt
   \                     ??AES_cfb128_encrypt_5: (+1)
   \   0000005E   0x9806             LDR      R0,[SP, #+24]
   \   00000060   0x1900             ADDS     R0,R0,R4
   \   00000062   0x7832             LDRB     R2,[R6, #+0]
   \   00000064   0x7801             LDRB     R1,[R0, #+0]
   \   00000066   0x4051             EORS     R1,R1,R2
   \   00000068   0x1C76             ADDS     R6,R6,#+1
   \   0000006A   0x7029             STRB     R1,[R5, #+0]
   \   0000006C   0x1C6D             ADDS     R5,R5,#+1
   \   0000006E   0x7001             STRB     R1,[R0, #+0]
   \   00000070   0x1C64             ADDS     R4,R4,#+1
   \   00000072   0x0724             LSLS     R4,R4,#+28
   \   00000074   0x0F24             LSRS     R4,R4,#+28
   \   00000076   0x2F00             CMP      R7,#+0
   \   00000078   0xD0E3             BEQ      ??AES_cfb128_encrypt_1
   \   0000007A   0xE7E8             B        ??AES_cfb128_encrypt_4
    156          
    157          /** This expects a single block of size nbits for both in and out. Note that
    158             it corrupts any extra bits in the last byte of out */

   \                                 In section .text, align 2, keep-with-next
    159          void AES_cfbr_encrypt_block(const unsigned char *in,unsigned char *out,
    160          			    const int nbits,const AES_KEY *key,
    161          			    unsigned char *ivec,const int enc)
    162              {
   \                     AES_cfbr_encrypt_block: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001F             MOVS     R7,R3
    163              int n,rem,num;
    164              unsigned char ovec[AES_BLOCK_SIZE*2];
    165          
    166              if (nbits<=0 || nbits>128) return;
   \   0000000C   0x1E60             SUBS     R0,R4,#+1
   \   0000000E   0x2880             CMP      R0,#+128
   \   00000010   0xD254             BCS      ??AES_cfbr_encrypt_block_0
    167          
    168          	/** fill in the first half of the new IV with the current IV */
    169          	memcpy(ovec,ivec,AES_BLOCK_SIZE);
   \   00000012   0x2210             MOVS     R2,#+16
   \   00000014   0x990E             LDR      R1,[SP, #+56]
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy
    170          	/** construct the new IV */
    171          	AES_encrypt(ivec,ivec,key);
   \   0000001C   0x003A             MOVS     R2,R7
   \   0000001E   0x990E             LDR      R1,[SP, #+56]
   \   00000020   0x0008             MOVS     R0,R1
   \   00000022   0x.... 0x....      BL       AES_encrypt
    172          	num = (nbits+7)/8;
   \   00000026   0x1DE0             ADDS     R0,R4,#+7
   \   00000028   0x1081             ASRS     R1,R0,#+2
   \   0000002A   0x0F49             LSRS     R1,R1,#+29
   \   0000002C   0x1808             ADDS     R0,R1,R0
   \   0000002E   0x10C0             ASRS     R0,R0,#+3
    173          	if (enc)	/** encrypt the input */
   \   00000030   0x990F             LDR      R1,[SP, #+60]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD010             BEQ      ??AES_cfbr_encrypt_block_1
    174          	    for(n=0 ; n < num ; ++n)
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xDB1E             BLT      ??AES_cfbr_encrypt_block_2
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x3110             ADDS     R1,R1,#+16
   \   0000003E   0x9A0E             LDR      R2,[SP, #+56]
    175          		out[n] = (ovec[AES_BLOCK_SIZE+n] = in[n] ^ ivec[n]);
   \                     ??AES_cfbr_encrypt_block_3: (+1)
   \   00000040   0x7837             LDRB     R7,[R6, #+0]
   \   00000042   0x7813             LDRB     R3,[R2, #+0]
   \   00000044   0x407B             EORS     R3,R3,R7
   \   00000046   0x700B             STRB     R3,[R1, #+0]
   \   00000048   0x702B             STRB     R3,[R5, #+0]
   \   0000004A   0x1C6D             ADDS     R5,R5,#+1
   \   0000004C   0x1C52             ADDS     R2,R2,#+1
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0xD010             BEQ      ??AES_cfbr_encrypt_block_2
   \   00000056   0xE7F3             B        ??AES_cfbr_encrypt_block_3
    176          	else		/** decrypt the input */
    177          	    for(n=0 ; n < num ; ++n)
   \                     ??AES_cfbr_encrypt_block_1: (+1)
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xDB0D             BLT      ??AES_cfbr_encrypt_block_2
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x3110             ADDS     R1,R1,#+16
   \   00000060   0x9A0E             LDR      R2,[SP, #+56]
    178          		out[n] = (ovec[AES_BLOCK_SIZE+n] = in[n]) ^ ivec[n];
   \                     ??AES_cfbr_encrypt_block_4: (+1)
   \   00000062   0x7833             LDRB     R3,[R6, #+0]
   \   00000064   0x700B             STRB     R3,[R1, #+0]
   \   00000066   0x7817             LDRB     R7,[R2, #+0]
   \   00000068   0x405F             EORS     R7,R7,R3
   \   0000006A   0x702F             STRB     R7,[R5, #+0]
   \   0000006C   0x1C52             ADDS     R2,R2,#+1
   \   0000006E   0x1C6D             ADDS     R5,R5,#+1
   \   00000070   0x1C76             ADDS     R6,R6,#+1
   \   00000072   0x1C49             ADDS     R1,R1,#+1
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0xD1F4             BNE      ??AES_cfbr_encrypt_block_4
    179          	/** shift ovec left... */
    180          	rem = nbits%8;
   \                     ??AES_cfbr_encrypt_block_2: (+1)
   \   00000078   0x10A0             ASRS     R0,R4,#+2
   \   0000007A   0x0F40             LSRS     R0,R0,#+29
   \   0000007C   0x1900             ADDS     R0,R0,R4
   \   0000007E   0x10C1             ASRS     R1,R0,#+3
   \   00000080   0x00C8             LSLS     R0,R1,#+3
   \   00000082   0x1A20             SUBS     R0,R4,R0
    181          	num = nbits/8;
    182          	if(rem==0)
   \   00000084   0x466A             MOV      R2,SP
   \   00000086   0x1851             ADDS     R1,R2,R1
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD104             BNE      ??AES_cfbr_encrypt_block_5
    183          	    memcpy(ivec,ovec+num,AES_BLOCK_SIZE);
   \   0000008C   0x2210             MOVS     R2,#+16
   \   0000008E   0x980E             LDR      R0,[SP, #+56]
   \   00000090   0x.... 0x....      BL       __aeabi_memcpy
   \   00000094   0xE012             B        ??AES_cfbr_encrypt_block_0
    184          	else
    185          	    for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
   \                     ??AES_cfbr_encrypt_block_5: (+1)
   \   00000096   0x9A0E             LDR      R2,[SP, #+56]
   \   00000098   0x2308             MOVS     R3,#+8
   \   0000009A   0x1A1C             SUBS     R4,R3,R0
    186          		ivec[n] = ovec[n+num]<<rem | ovec[n+num+1]>>(8-rem);
   \                     ??AES_cfbr_encrypt_block_6: (+1)
   \   0000009C   0x780D             LDRB     R5,[R1, #+0]
   \   0000009E   0x4085             LSLS     R5,R5,R0
   \   000000A0   0x784E             LDRB     R6,[R1, #+1]
   \   000000A2   0x40E6             LSRS     R6,R6,R4
   \   000000A4   0x432E             ORRS     R6,R6,R5
   \   000000A6   0x7016             STRB     R6,[R2, #+0]
   \   000000A8   0x784D             LDRB     R5,[R1, #+1]
   \   000000AA   0x4085             LSLS     R5,R5,R0
   \   000000AC   0x788E             LDRB     R6,[R1, #+2]
   \   000000AE   0x40E6             LSRS     R6,R6,R4
   \   000000B0   0x432E             ORRS     R6,R6,R5
   \   000000B2   0x7056             STRB     R6,[R2, #+1]
   \   000000B4   0x1C89             ADDS     R1,R1,#+2
   \   000000B6   0x1C92             ADDS     R2,R2,#+2
   \   000000B8   0x1E5B             SUBS     R3,R3,#+1
   \   000000BA   0xD1EF             BNE      ??AES_cfbr_encrypt_block_6
    187          
    188              /** it is not necessary to cleanse ovec, since the IV is not secret */
    189              }
   \                     ??AES_cfbr_encrypt_block_0: (+1)
   \   000000BC   0xB009             ADD      SP,SP,#+36
   \   000000BE   0xBDF0             POP      {R4-R7,PC}       ;; return
    190          
    191          /** N.B. This expects the input to be packed, MS bit first */

   \                                 In section .text, align 2, keep-with-next
    192          void AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,
    193          		      const unsigned long length, const AES_KEY *key,
    194          		      unsigned char *ivec, int *num, const int enc)
    195              {
   \                     AES_cfb1_encrypt: (+1)
   \   00000000   0xB5FF             PUSH     {R0-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x0010             MOVS     R0,R2
   \   00000008   0xD02F             BEQ      ??AES_cfb1_encrypt_0
   \   0000000A   0x2580             MOVS     R5,#+128
    196              unsigned int n;
    197              unsigned char c[1],d[1];
    198          
    199              assert(in && out && key && ivec && num);
    200              assert(*num == 0);
    201          
    202              for(n=0 ; n < length ; ++n)
    203          	{
    204          	c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
   \                     ??AES_cfb1_encrypt_1: (+1)
   \   0000000C   0x0767             LSLS     R7,R4,#+29
   \   0000000E   0x0F7F             LSRS     R7,R7,#+29
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0x1BC9             SUBS     R1,R1,R7
   \   00000016   0x4088             LSLS     R0,R0,R1
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7208             STRB     R0,[R1, #+8]
   \   0000001C   0x08E6             LSRS     R6,R4,#+3
   \   0000001E   0x9803             LDR      R0,[SP, #+12]
   \   00000020   0x5D80             LDRB     R0,[R0, R6]
   \   00000022   0x7A09             LDRB     R1,[R1, #+8]
   \   00000024   0x4208             TST      R0,R1
   \   00000026   0xD001             BEQ      ??AES_cfb1_encrypt_2
   \   00000028   0x2080             MOVS     R0,#+128
   \   0000002A   0xE000             B        ??AES_cfb1_encrypt_3
   \                     ??AES_cfb1_encrypt_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??AES_cfb1_encrypt_3: (+1)
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x7288             STRB     R0,[R1, #+10]
    205          	AES_cfbr_encrypt_block(c,d,1,key,ivec,enc);
   \   00000032   0x980E             LDR      R0,[SP, #+56]
   \   00000034   0x9001             STR      R0,[SP, #+4]
   \   00000036   0x980C             LDR      R0,[SP, #+48]
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x9B06             LDR      R3,[SP, #+24]
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0xA902             ADD      R1,SP,#+8
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0xA802             ADD      R0,SP,#+8
   \   00000044   0x1C80             ADDS     R0,R0,#+2
   \   00000046   0x.... 0x....      BL       AES_cfbr_encrypt_block
    206          	out[n/8]=(out[n/8]&~(1 << (7-n%8)))|((d[0]&0x80) >> (n%8));
   \   0000004A   0x9804             LDR      R0,[SP, #+16]
   \   0000004C   0x1980             ADDS     R0,R0,R6
   \   0000004E   0x7801             LDRB     R1,[R0, #+0]
   \   00000050   0x466A             MOV      R2,SP
   \   00000052   0x7A12             LDRB     R2,[R2, #+8]
   \   00000054   0x4391             BICS     R1,R1,R2
   \   00000056   0x466A             MOV      R2,SP
   \   00000058   0x7A52             LDRB     R2,[R2, #+9]
   \   0000005A   0x402A             ANDS     R2,R2,R5
   \   0000005C   0x40FA             LSRS     R2,R2,R7
   \   0000005E   0x430A             ORRS     R2,R2,R1
   \   00000060   0x7002             STRB     R2,[R0, #+0]
    207          	}
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0x9805             LDR      R0,[SP, #+20]
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD3D0             BCC      ??AES_cfb1_encrypt_1
    208              }
   \                     ??AES_cfb1_encrypt_0: (+1)
   \   0000006A   0xB007             ADD      SP,SP,#+28
   \   0000006C   0xBDF0             POP      {R4-R7,PC}       ;; return
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,
    211          		      const unsigned long length, const AES_KEY *key,
    212          		      unsigned char *ivec, int *num, const int enc)
    213              {
    214              unsigned int n;
    215          
    216              assert(in && out && key && ivec && num);
    217              assert(*num == 0);
    218          
    219              for(n=0 ; n < length ; ++n)
   \                     AES_cfb8_encrypt: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xD100             BNE      ??AES_cfb8_encrypt_0
   \   00000004   0x4770             BX       LR
   \                     ??AES_cfb8_encrypt_0: (+1)
   \   00000006   0xB5FE             PUSH     {R1-R7,LR}
   \   00000008   0x000C             MOVS     R4,R1
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x0015             MOVS     R5,R2
   \   0000000E   0x9F0A             LDR      R7,[SP, #+40]
    220          	AES_cfbr_encrypt_block(&in[n],&out[n],8,key,ivec,enc);
   \                     ??AES_cfb8_encrypt_1: (+1)
   \   00000010   0x9701             STR      R7,[SP, #+4]
   \   00000012   0x9808             LDR      R0,[SP, #+32]
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x9B02             LDR      R3,[SP, #+8]
   \   00000018   0x2208             MOVS     R2,#+8
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       AES_cfbr_encrypt_block
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \   00000026   0x1E6D             SUBS     R5,R5,#+1
   \   00000028   0xD1F2             BNE      ??AES_cfb8_encrypt_1
    221              }
   \   0000002A   0xB003             ADD      SP,SP,#+12
   \   0000002C   0xBDF0             POP      {R4-R7,PC}       ;; return
    222          
    223          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   AES_cfb128_encrypt
        24   -> AES_encrypt
      48   AES_cfb1_encrypt
        48   -> AES_cfbr_encrypt_block
      32   AES_cfb8_encrypt
        32   -> AES_cfbr_encrypt_block
      56   AES_cfbr_encrypt_block
        56   -> AES_encrypt
        56   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     124  AES_cfb128_encrypt
     110  AES_cfb1_encrypt
      46  AES_cfb8_encrypt
     192  AES_cfbr_encrypt_block

 
 472 bytes in section .text
 
 472 bytes of CODE memory

Errors: none
Warnings: none
