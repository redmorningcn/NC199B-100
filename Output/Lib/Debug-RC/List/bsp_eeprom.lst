###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       16/Nov/2017  10:23:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_eeprom.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_eeprom.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\bsp_eeprom.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\bsp_eeprom.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_eeprom.c
      1          /*******************************************************************************
      2          *   Filename:       bsp_eeprom.c
      3          *   Revised:        All copyrights reserved to Roger.
      4          *   Date:           2015-08-18
      5          *   Revision:       v1.0
      6          *   Writer:	        wumingshen.
      7          *
      8          *   Description:    AT24Cxxx系列EEPROM驱动模块
      9          *
     10          *
     11          *   Notes:
     12          *
     13          *   All copyrights reserved to wumingshen
     14          *******************************************************************************/
     15          
     16          /*******************************************************************************
     17           * INCLUDES
     18           */
     19          #include <bsp_eeprom.h>
     20          
     21          
     22          #define  BSP_EEPROM_MODULE_EN   1
     23          #if  BSP_EEPROM_MODULE_EN > 0
     24          
     25          /*******************************************************************************
     26           * 描述： 该模块是否搭载uCOS系统使用
     27           */
     28          #define  UCOS_EN            DEF_ENABLED
     29          #define  GPIO_I2C1_PORT_EN  DEF_ENABLED
     30          #define  GPIO_I2C2_PORT_EN  DEF_DISABLED
     31          /***********************************************
     32          * 描述： AT24Cxx时间
     33          *
     34          Symbol  Parameter               |1.8-volt       |2.7-volt       |5.0-volt       Units
     35                                          |Min    Max     |Min    Max     |Min    Max
     36          fSCL    Clock Frequency, SCL    |       100     |       400     |       1000    kHz
     37          tLOW    Clock Pulse Width Low   |4.7            |1.3            |0.6            μs
     38          tHIGH   Clock Pulse Width High  |4.0            |1.0            |0.4            μs
     39          tAA     Clock Low to Data Out   |               |               |
     40                  Valid                   |0.1     4.5    |0.05    0.9    |0.05   0.55    μs
     41          tBUF    Time the bus must be    |               |               |
     42                  free before a new       |               |               |
     43                  transmission can start  |4.7            |1.3            |0.5            μs
     44          tHD.STA Start Hold Time         |4.0            |0.6            |0.25           μs
     45          tSU.STA Start Set-up Time       |4.7            |0.6            |0.25           μs
     46          tHD.DAT Data In Hold Time       |0              |0              |0              μs
     47          tSU.DAT Data In Set-up Time     |200            |100            |100            ns
     48          tR      Inputs Rise Time(1)     |        1.0    |        0.3    |       0.3     μs
     49          tF      Inputs Fall Time(1)     |        300    |        300    |       100     ns
     50          tSU.STO Stop Set-up Time        |4.7            |0.6            |0.25           μs
     51          tDH     Data Out Hold Time      |100            |50             |50             ns
     52          tWR     Write Cycle Time        |        20     |         10    |10             ms
     53          Endurance(1)                    |               |               |
     54                  5.0V, 25°C, Page Mode   |100K           |100K           |100K           Write Cycles
     55          按2.7V供电计算时间
     56          */
     57          /***********************************************
     58          * 描述： AT24Cxx时间（us）
     59          */
     60          #define DLY_CLK_SDA             10               // >=1.0us
     61          #define DLY_CLK_LOW             10               // >=1.3us
     62          #define DLY_CLK_HIGH            10               // >=1.0us
     63          #define DLY_SU_STA              10               // >=0.6us
     64          #define DLY_HD_STA              10               // >=0.6us
     65          #define DLY_SU_STO              10               // >=0.6us
     66          #define DLY_SDA_BUF             10               // >=1.3us
     67          
     68          /***********************************************
     69          * 描述： AT24Cxx时间（ms）
     70          */
     71          #define DLY_WR_STO              5               // >=10ms
     72          
     73          /***********************************************
     74          * 描述： AT24CXX应答定义
     75          */
     76          #ifndef I2C_ACK
     77          #define I2C_ACK                 0X01            // 应答
     78          #endif
     79          #ifndef I2C_NACK
     80          #define I2C_NACK                0X00            // 非应答
     81          #endif
     82          #ifndef HIGH
     83          #define LOW                     0X00            // 低电平
     84          #endif
     85          #ifndef HIGH
     86          #define HIGH                    0X01            // 高电平
     87          #endif
     88          /***********************************************
     89          * 描述： AT24CXX读写模式定义
     90          */
     91          #define MODE_PAGE_RW            0               // 页读写
     92          #define MODE_SINGLE_RW          1               // 单个读写
     93          #define BSP_EEP_READ_MODE       MODE_PAGE_RW    // 0分页读，1单字节读
     94          #define BSP_EEP_WRITE_MODE      MODE_PAGE_RW    // 0分页写，1单字节写
     95          

   \                                 In section .data, align 4
     96          INT32U  AT24CXX_SCL_PIN         = GPIO_Pin_6;
   \                     AT24CXX_SCL_PIN:
   \   00000000   0x00000040         DC32 64
     97          INT32U  AT24CXX_SDA_PIN         = GPIO_Pin_7;
   \                     AT24CXX_SDA_PIN:
   \   00000004   0x00000080         DC32 128
     98          
     99          /***********************************************
    100          * 描述： AT24CXX使用的IO，配置为开漏输出
    101          */
    102          #define I2C1_SCL_RCC            RCC_APB2Periph_GPIOE
    103          #define I2C1_SCL_PORT           GPIOE
    104          #define I2C1_SCL_PIN            GPIO_Pin_7
    105          
    106          #define I2C1_SDA_RCC            RCC_APB2Periph_GPIOE
    107          #define I2C1_SDA_PORT           GPIOE
    108          #define I2C1_SDA_PIN            GPIO_Pin_8
    109          
    110          #define I2C2_SCL_RCC            RCC_APB2Periph_GPIOB
    111          #define I2C2_SCL_PORT           GPIOB
    112          #define I2C2_SCL_PIN            GPIO_Pin_10
    113          
    114          #define I2C2_SDA_RCC            RCC_APB2Periph_GPIOB
    115          #define I2C2_SDA_PORT           GPIOB
    116          #define I2C2_SDA_PIN            GPIO_Pin_11
    117          
    118          
    119          #define AT24CXX_SCL_RCC         RCC_APB2Periph_GPIOB
    120          #define AT24CXX_SCL_PORT        GPIOB
    121          extern INT32U  AT24CXX_SCL_PIN;//         GPIO_Pin_6
    122          
    123          #define AT24CXX_SDA_RCC         RCC_APB2Periph_GPIOB
    124          #define AT24CXX_SDA_PORT        GPIOB
    125          extern INT32U  AT24CXX_SDA_PIN;//         GPIO_Pin_7
    126          /*******************************************************************************
    127          * 描述： AT24CXX使用的端口设置(直接操作寄存器)，直接修改该处端口
    128          */
    129          #define AT_SCL_1                GPIOB->BSRR = AT24CXX_SCL_PIN
    130          #define AT_SCL_0                GPIOB->BRR  = AT24CXX_SCL_PIN
    131          
    132          #define AT_SDA_1                GPIOB->BSRR = AT24CXX_SDA_PIN
    133          #define AT_SDA_0                GPIOB->BRR  = AT24CXX_SDA_PIN
    134          
    135          #define AT_SCL_S                ( GPIOB->IDR  & AT24CXX_SCL_PIN )
    136          #define AT_SDA_S                ( GPIOB->IDR  & AT24CXX_SDA_PIN )
    137          
    138          
    139          //============================================================================//
    140          
    141          /***********************************************
    142          * 描述： AT24CXX使用的端口设置，直接修改该处端口
    143          */
    144          #define AT24CXX_SET_SCL(sta)    { if(sta) {AT_SCL_1; Delay_Nus(DLY_CLK_HIGH);} else { AT_SCL_0; Delay_Nus(DLY_CLK_SDA); } }
    145          #define AT24CXX_SET_SDA(sta)    { if(sta) {AT_SDA_1; Delay_Nus(DLY_CLK_LOW); } else { AT_SDA_0; Delay_Nus(DLY_CLK_LOW); } }
    146          #define AT24CXX_GET_SCL(sta)    { if( AT_SCL_S ) sta |= 1; else sta &= ~1; }
    147          #define AT24CXX_GET_SDA(sta)    { if( AT_SDA_S ) sta |= 1; else sta &= ~1; }
    148          
    149          /***********************************************
    150          * 描述： AT24CXX引脚设置为开漏，可无须设置IO的方向
    151          */
    152          #define DIR_SEL         0
    153          
    154          #if DIR_SEL == 0
    155          #define SET_SDA_INPUT()
    156          #define SET_SDA_OUTPUT()
    157          #define SET_SCL_INPUT()
    158          #define SET_SCL_OUTPUT()
    159          #else
    160          #define SET_SDA_INPUT()   { GPIO_InitTypeDef  GPIO_InitStructure;\
    161                                      GPIO_InitStructure.GPIO_Pin =  AT24CXX_SDA_PIN;\
    162                                      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\
    163                                      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\
    164                                      GPIO_Init(AT24CXX_SDA_PORT, &GPIO_InitStructure);  }
    165          
    166          #define SET_SDA_OUTPUT()  { GPIO_InitTypeDef  GPIO_InitStructure;\
    167                                      GPIO_InitStructure.GPIO_Pin =  AT24CXX_SDA_PIN;\
    168                                      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\
    169                                      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\
    170                                      GPIO_Init(AT24CXX_SDA_PORT, &GPIO_InitStructure);  }
    171          
    172          #define SET_SCL_INPUT()   { GPIO_InitTypeDef  GPIO_InitStructure;\
    173                                      GPIO_InitStructure.GPIO_Pin =  AT24CXX_SCL_PIN;\
    174                                      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\
    175                                      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\
    176                                      GPIO_Init(AT24CXX_SCL_PORT, &GPIO_InitStructure);  }
    177          
    178          #define SET_SCL_OUTPUT()  { GPIO_InitTypeDef  GPIO_InitStructure;\
    179                                      GPIO_InitStructure.GPIO_Pin =  AT24CXX_SCL_PIN;\
    180                                      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\
    181                                      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\
    182                                      GPIO_Init(AT24CXX_SCL_PORT, &GPIO_InitStructure);  }
    183          #endif
    184          
    185          /***********************************************
    186          * 描述： OS接口
    187          */
    188          #if UCOS_EN     == DEF_ENABLED
    189              #if OS_VERSION > 30000U

   \                                 In section .bss, align 4
    190              static  OS_SEM                   Bsp_EepSem;    // 信号量
   \                     Bsp_EepSem:
   \   00000000                      DS8 28
    191              #else
    192              static  OS_EVENT                *Bsp_EepSem;    // 信号量
    193              #endif
    194          #endif
    195          
    196          /*******************************************************************************
    197           * GLOBAL FUNCTIONS
    198           */
    199          static void    I2C_Start      (void);
    200          static void    I2C_Stop       (void);
    201          
    202          static uint8_t I2C_SendByte   (uint8_t  byte);                //数据从高位到低位
    203          static uint8_t I2C_RecvByte   (uint8_t    ack, uint8_t *dat); //数据从高位到低位
    204          
    205          //============================================================================//
    206          
    207          /*******************************************************************************
    208          * 描述： AT24Cxx关键时序
    209          *
    210          *                ：开始/结束时序
    211          *                : SDA ˉˉˉˉ\_______/ˉˉˉˉˉˉ\_______/ˉˉˉˉˉ
    212          *                : SCL ˉˉˉˉˉˉ\______/ˉˉˉˉ\______/ˉˉˉˉˉˉˉ
    213          *                :       |   |                   |   |
    214          *                :       START                   STOP
    215          *                ：数据时序
    216          *                : SDA _____/ˉˉˉˉˉˉˉˉˉXˉˉˉˉˉˉˉˉˉˉˉ\
    217          *                :     ˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉ
    218          *                : SCL ______/ˉˉˉˉˉˉ\___/ˉˉˉˉˉˉˉˉ\______
    219          *                ：      |数据保持  |   |数据保持|
    220          *                ：                数据改变
    221          */
    222          
    223          
    224          /*******************************************************************************
    225          * 名    称： I2C_Start
    226          * 功    能： 启动I2C总线，即发送I2C初始条件
    227          * 入口参数： 无
    228          * 出口参数： 无
    229          * 作　 　者： 无名沈
    230          * 创建日期： 2015-08-18
    231          * 修    改：
    232          * 修改日期：
    233          * 备    注：  开始时序
    234          *             SDA ˉˉˉˉ\______
    235          *             SCL ˉˉˉˉˉˉ\____
    236          *                   |   |
    237          *                   START
    238          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    239          static void I2C_Start(void)
    240          {
   \                     I2C_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    241              SET_SDA_OUTPUT();				/*SDA设为输出                       */
    242              AT_SDA_1;						/*发送起始条件的数据信号            */
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable13  ;; 0x40010c10
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable13_1
   \   0000000A   0x6868             LDR      R0,[R5, #+4]
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    243              Delay_Nus(DLY_CLK_SDA);
   \   0000000E   0x200A             MOVS     R0,#+10
   \   00000010   0x.... 0x....      BL       Delay_Nus
    244              AT_SCL_1;
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x6020             STR      R0,[R4, #+0]
    245              Delay_Nus(DLY_SU_STA);		    /*起始条件建立时间大于4.7us,延时    */
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x.... 0x....      BL       Delay_Nus
    246              AT_SDA_0;						/*发送起始信号                      */
   \   0000001E   0x6868             LDR      R0,[R5, #+4]
   \   00000020   0x6060             STR      R0,[R4, #+4]
    247              Delay_Nus(DLY_HD_STA);			/*起始条件保持时间大于4μs           */
   \   00000022   0x200A             MOVS     R0,#+10
   \   00000024   0x.... 0x....      BL       Delay_Nus
    248              AT_SCL_0;						/*允许数据线改变，准备发送或接收数据*/
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6060             STR      R0,[R4, #+4]
    249              Delay_Nus(DLY_CLK_LOW);         /*CLK与SDA之间延时                  */
   \   0000002C   0x200A             MOVS     R0,#+10
   \   0000002E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000032   0x.... 0x....      B.W      Delay_Nus
    250          }
    251          
    252          /*******************************************************************************
    253          * 名    称： I2C_Stop
    254          * 功    能： 结束I2C总线，即发送I2C结束条件
    255          * 入口参数： 无
    256          * 出口参数： 无
    257          * 作　 　者： 无名沈
    258          * 创建日期： 2015-08-18
    259          * 修    改：
    260          * 修改日期：
    261          * 备    注： 停止时序
    262          *            SDA _______/ˉˉˉˉˉ
    263          *            SCL _____/ˉˉˉˉˉˉˉ
    264          *                      |   |
    265          *                      STOP
    266          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    267          static void I2C_Stop(void)
    268          {
   \                     I2C_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    269          	SET_SDA_OUTPUT();				/*SDA设为输出*/
    270              AT_SCL_0; 						/*钳住I2C总线，准备发送或接收数据 */
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable13  ;; 0x40010c10
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable13_1
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x6060             STR      R0,[R4, #+4]
    271          	Delay_Nus(DLY_CLK_SDA);
   \   0000000E   0x200A             MOVS     R0,#+10
   \   00000010   0x.... 0x....      BL       Delay_Nus
    272              AT_SDA_0; 						/*发送结束条件的数据信号*/
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x6060             STR      R0,[R4, #+4]
    273              Delay_Nus(DLY_CLK_SDA);
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x.... 0x....      BL       Delay_Nus
    274              AT_SCL_1; 						/*发送结束条件的时钟信号*/
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6020             STR      R0,[R4, #+0]
    275          	Delay_Nus(DLY_SU_STO);			/*结束条件建立时间大于4μs*/
   \   00000022   0x200A             MOVS     R0,#+10
   \   00000024   0x.... 0x....      BL       Delay_Nus
    276              AT_SDA_1; 						/*发送I2C总线结束信号*/
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    277              Delay_Nus(DLY_SDA_BUF); 		/*>4us*/
   \   0000002C   0x200A             MOVS     R0,#+10
   \   0000002E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000032   0x.... 0x....      B.W      Delay_Nus
    278          }
    279          
    280          /*******************************************************************************
    281          * 名    称： I2C_SendByte
    282          * 功    能： 字节数据传送函数，将数据 c 发送出去，可以是地址，也可以是数据，
    283                       发完后等待应答，并对此状态位进行操作
    284          * 入口参数： uint8_t 型数据
    285          * 出口参数： 无
    286          * 作　 　者： 无名沈
    287          * 创建日期： 2015-08-18
    288          * 修    改：
    289          * 修改日期：
    290          * 备    注： 数据时序
    291          *            SDA _____/ˉˉˉˉˉˉˉˉˉXˉˉˉˉˉˉˉˉˉˉˉ\
    292          *                ˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉ
    293          *            SCL ______/ˉˉˉˉˉˉ\___/ˉˉˉˉˉˉˉˉ\______
    294          *                  |数据保持  |   |数据保持|
    295          *                            数据改变
    296          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    297          static uint8_t I2C_SendByte(uint8_t byte) 					    //数据从高位到低位//
    298          {
   \                     I2C_SendByte: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
    299              INT08S  ctr     = 0;                            // 初始化数据位计数器
   \   00000006   0x2600             MOVS     R6,#+0
    300              uint8_t  ack     = 0;
   \   00000008   0x4634             MOV      R4,R6
    301          
    302              /***********************************************
    303              * 描述：发送数据
    304              */
    305              for ( ctr = 0 ; ctr < 8 ; ctr ++ ) {            // 检测是否已经发送完毕
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable13_2  ;; 0x40010c08
   \   0000000E   0x.... 0x....      LDR.W    R8,??DataTable13_1
   \   00000012   0xE00B             B.N      ??I2C_SendByte_0
    306                  AT24CXX_SET_SCL(LOW);                       // SCL = 0 允许数据线改变，准备发送数据
    307                  AT24CXX_SET_SDA((byte & 0x80) == 0x80);     // SDA = 0 发送数据：0;SDA = 1 发送数据：1
   \                     ??I2C_SendByte_1: (+1)
   \   00000014   0x60F8             STR      R0,[R7, #+12]
   \   00000016   0x200A             MOVS     R0,#+10
   \   00000018   0x.... 0x....      BL       Delay_Nus
    308                  AT24CXX_SET_SCL(HIGH);                      // SCL = 1 锁定数据，从机可以读取
   \                     ??I2C_SendByte_2: (+1)
   \   0000001C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000020   0x60B8             STR      R0,[R7, #+8]
   \   00000022   0x200A             MOVS     R0,#+10
   \   00000024   0x.... 0x....      BL       Delay_Nus
    309                  byte <<= 1;                                 // 当前值左移一位
   \   00000028   0x006D             LSLS     R5,R5,#+1
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \                     ??I2C_SendByte_0: (+1)
   \   0000002C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000030   0x2E08             CMP      R6,#+8
   \   00000032   0x60F8             STR      R0,[R7, #+12]
   \   00000034   0xDA0B             BGE.N    ??I2C_SendByte_3
   \   00000036   0x200A             MOVS     R0,#+10
   \   00000038   0x.... 0x....      BL       Delay_Nus
   \   0000003C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000040   0x0629             LSLS     R1,R5,#+24
   \   00000042   0xD5E7             BPL.N    ??I2C_SendByte_1
   \   00000044   0x60B8             STR      R0,[R7, #+8]
   \   00000046   0x200A             MOVS     R0,#+10
   \   00000048   0x.... 0x....      BL       Delay_Nus
   \   0000004C   0xE7E6             B.N      ??I2C_SendByte_2
    310              };
    311              /***********************************************
    312              * 描述：检查应答
    313              */
    314              AT24CXX_SET_SCL(LOW);                           // SCL = 0 允许数据线改变，准备接收应答位
   \                     ??I2C_SendByte_3: (+1)
   \   0000004E   0x200A             MOVS     R0,#+10
   \   00000050   0x.... 0x....      BL       Delay_Nus
    315              SET_SDA_INPUT();                                // SDA设为输入
    316              AT24CXX_SET_SDA(HIGH);                          // SDA = 1 主机释放总线
   \   00000054   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000058   0x60B8             STR      R0,[R7, #+8]
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0x.... 0x....      BL       Delay_Nus
    317          
    318              AT24CXX_SET_SCL(HIGH);                          // SCL = 1 锁定数据
   \   00000060   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000064   0x60B8             STR      R0,[R7, #+8]
   \   00000066   0x200A             MOVS     R0,#+10
   \   00000068   0x.... 0x....      BL       Delay_Nus
    319              AT24CXX_GET_SDA(ack);                           // 读取从机应答ACK
   \   0000006C   0x6838             LDR      R0,[R7, #+0]
   \   0000006E   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD000             BEQ.N    ??I2C_SendByte_4
   \   00000076   0x2401             MOVS     R4,#+1
    320              SET_SDA_OUTPUT();                               // SDA设为输出
    321              AT24CXX_SET_SCL(LOW);                           // SCL = 0 允许数据线改变，准备接收应答位
   \                     ??I2C_SendByte_4: (+1)
   \   00000078   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000007C   0x60F8             STR      R0,[R7, #+12]
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0x.... 0x....      BL       Delay_Nus
    322          
    323              if (ack)                                    	// 检测应答信号
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x4180             SBCS     R0,R0,R0
   \   0000008A   0x0FC0             LSRS     R0,R0,#+31
    324                  return (FALSE);                             // NACK返回
    325              else
    326                  return (TRUE);                              // ACK返回
   \   0000008C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    327          }
    328          
    329          /*******************************************************************************
    330          * 名    称： I2C_RecvByte
    331          * 功    能： 接收从器件传来的数据，并判断总线错误（不发应答信号），收完后
    332                       需要调用应答函数。
    333          * 入口参数： 无
    334          * 出口参数： uint8_t 型数据
    335          * 作　 　者： 无名沈
    336          * 创建日期： 2015-08-18
    337          * 修    改：
    338          * 修改日期：
    339          * 备    注： 数据时序
    340          *            SDA _____/ˉˉˉˉˉˉˉˉˉXˉˉˉˉˉˉˉˉˉˉˉ\
    341          *                ˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉˉ
    342          *            SCL ______/ˉˉˉˉˉˉ\___/ˉˉˉˉˉˉˉˉ\______
    343          *                  |数据保持  |   |数据保持|
    344          *                            数据改变
    345          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    346          static uint8_t I2C_RecvByte(uint8_t ack, uint8_t *dat)  	        //数据从高位到低位
    347          {
   \                     I2C_RecvByte: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    348              uint8_t  ctr     = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    349              INT08S  data    = 0;
   \   0000000A   0x46B9             MOV      R9,R7
    350          
    351              SET_SDA_INPUT();                                // SDA设为输入
    352              /***********************************************
    353              * 描述：接收数据
    354              */
    355              for ( ctr = 0 ; ctr < 8 ; ctr ++ ) {            // 数据左移一位，由于第一个数据是0所以左移还是0
   \   0000000C   0x.... 0x....      LDR.W    R6,??DataTable13_2  ;; 0x40010c08
   \   00000010   0x.... 0x....      LDR.W    R8,??DataTable13_1
   \   00000014   0xE008             B.N      ??I2C_RecvByte_0
    356                  data <<= 1;                                 // 准备下一位数据
    357                  AT24CXX_SET_SCL(HIGH);                      // SCL = 1 锁定数据，可以读取从机数据
    358                  AT24CXX_GET_SDA(data);                      // 如果为1则置1，否则不改变（默认为0）
   \                     ??I2C_RecvByte_1: (+1)
   \   00000016   0xF009 0x09FE      AND      R9,R9,#0xFE
    359                  AT24CXX_SET_SCL(LOW);                       // SCL = 0 允许数据线改变，准备读取从机数据
   \                     ??I2C_RecvByte_2: (+1)
   \   0000001A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000001E   0x60F0             STR      R0,[R6, #+12]
   \   00000020   0x200A             MOVS     R0,#+10
   \   00000022   0x.... 0x....      BL       Delay_Nus
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \                     ??I2C_RecvByte_0: (+1)
   \   00000028   0x2F08             CMP      R7,#+8
   \   0000002A   0xDA0F             BGE.N    ??I2C_RecvByte_3
   \   0000002C   0xEA4F 0x0949      LSL      R9,R9,#+1
   \   00000030   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000034   0x60B0             STR      R0,[R6, #+8]
   \   00000036   0x200A             MOVS     R0,#+10
   \   00000038   0x.... 0x....      BL       Delay_Nus
   \   0000003C   0x6830             LDR      R0,[R6, #+0]
   \   0000003E   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   00000042   0x4208             TST      R0,R1
   \   00000044   0xD0E7             BEQ.N    ??I2C_RecvByte_1
   \   00000046   0xF049 0x0901      ORR      R9,R9,#0x1
   \   0000004A   0xE7E6             B.N      ??I2C_RecvByte_2
    360              };
    361          
    362              SET_SDA_OUTPUT();                               // SDA设为输出
    363              /***********************************************
    364              * 描述：检查应答
    365              */
    366              AT24CXX_SET_SDA(!ack);                          // ACK,发送0
   \                     ??I2C_RecvByte_3: (+1)
   \   0000004C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD104             BNE.N    ??I2C_RecvByte_4
   \   00000054   0x60B0             STR      R0,[R6, #+8]
   \   00000056   0x200A             MOVS     R0,#+10
   \   00000058   0x.... 0x....      BL       Delay_Nus
   \   0000005C   0xE003             B.N      ??I2C_RecvByte_5
   \                     ??I2C_RecvByte_4: (+1)
   \   0000005E   0x60F0             STR      R0,[R6, #+12]
   \   00000060   0x200A             MOVS     R0,#+10
   \   00000062   0x.... 0x....      BL       Delay_Nus
    367          
    368              AT24CXX_SET_SCL(HIGH);
   \                     ??I2C_RecvByte_5: (+1)
   \   00000066   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000006A   0x60B0             STR      R0,[R6, #+8]
   \   0000006C   0x200A             MOVS     R0,#+10
   \   0000006E   0x.... 0x....      BL       Delay_Nus
    369              AT24CXX_SET_SCL(LOW);
   \   00000072   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000076   0x60F0             STR      R0,[R6, #+12]
   \   00000078   0x200A             MOVS     R0,#+10
   \   0000007A   0x.... 0x....      BL       Delay_Nus
    370              AT24CXX_SET_SDA(HIGH);
   \   0000007E   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000082   0x60B0             STR      R0,[R6, #+8]
   \   00000084   0x200A             MOVS     R0,#+10
   \   00000086   0x.... 0x....      BL       Delay_Nus
    371          
    372              *dat    = data;
   \   0000008A   0xF885 0x9000      STRB     R9,[R5, #+0]
    373          
    374              return (TRUE);                            	    // Return 8-bit data byte
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    375          }
    376          
    377          /*******************************************************************************
    378          * 名    称： AT24CXX_Enabled
    379          * 功    能： I2C使能
    380          * 入口参数： 无
    381          * 出口参数：
    382          * 作　 　者： 无名沈
    383          * 创建日期： 2015-08-18
    384          * 修    改：
    385          * 修改日期：
    386          * 备    注：
    387          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    388          uint8_t AT24CXX_Enabled( void )
    389          {
   \                     AT24CXX_Enabled: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    390              INT32S timeout  = 100;
   \   00000002   0x2464             MOVS     R4,#+100
    391              do {
    392                  I2C_Start();
   \                     ??AT24CXX_Enabled_0: (+1)
   \   00000004   0x.... 0x....      BL       I2C_Start
    393                  if ( I2C_SendByte( 0xA0 ) == TRUE )
   \   00000008   0x20A0             MOVS     R0,#+160
   \   0000000A   0x.... 0x....      BL       I2C_SendByte
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??AT24CXX_Enabled_1
    394                      return TRUE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xBD10             POP      {R4,PC}
    395              } while ( --timeout );
   \                     ??AT24CXX_Enabled_1: (+1)
   \   00000016   0x1E64             SUBS     R4,R4,#+1
   \   00000018   0xD1F4             BNE.N    ??AT24CXX_Enabled_0
    396              
    397              return FALSE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    398          }
    399          
    400          /*******************************************************************************
    401          * 名    称： AT24CXX_Init
    402          * 功    能： 初始化IIC
    403          * 入口参数： 无
    404          * 出口参数： 无
    405          * 作　 　者： 无名沈
    406          * 创建日期： 2015-08-18
    407          * 修    改：
    408          * 修改日期：
    409          * 备    注： 停止时序
    410          *            SDA _______/ˉˉˉˉˉ
    411          *            SCL _____/ˉˉˉˉˉˉˉ
    412          *                      |   |
    413          *                      STOP
    414          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    415          void AT24CXX_Init( void )
    416          {
   \                     AT24CXX_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    417              uint8_t size = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable13_2  ;; 0x40010c08
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable13_1
    418              do {
    419                  AT24CXX_SET_SCL(LOW);                       // SCL = 0 允许数据线改变，准备发送数据
   \                     ??AT24CXX_Init_0: (+1)
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x60E8             STR      R0,[R5, #+12]
   \   00000010   0x200A             MOVS     R0,#+10
   \   00000012   0x.... 0x....      BL       Delay_Nus
    420                  AT24CXX_SET_SDA(HIGH);                      // SDA = 1 主机释放总线
   \   00000016   0x6870             LDR      R0,[R6, #+4]
   \   00000018   0x60A8             STR      R0,[R5, #+8]
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0x.... 0x....      BL       Delay_Nus
    421                  AT24CXX_SET_SCL(HIGH);                      // SCL = 1 锁定数据，从机可以读取
   \   00000020   0x6830             LDR      R0,[R6, #+0]
   \   00000022   0x60A8             STR      R0,[R5, #+8]
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0x.... 0x....      BL       Delay_Nus
    422                  size        += 1;
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \   0000002C   0xB2E4             UXTB     R4,R4
    423              } while ( ( size < 10 ) && ( AT_SDA_S == 0 ) );
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xDA03             BGE.N    ??AT24CXX_Init_1
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6871             LDR      R1,[R6, #+4]
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD0E7             BEQ.N    ??AT24CXX_Init_0
    424          
    425              I2C_Start();
   \                     ??AT24CXX_Init_1: (+1)
   \   0000003C   0x.... 0x....      BL       I2C_Start
    426              I2C_Stop();
   \   00000040   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000044   0x....             B.N      I2C_Stop
    427          }
    428          
    429          /*******************************************************************************
    430          * 名    称： BSP_EEP_SetAddr
    431          * 功    能： 设置当前地址
    432          * 入口参数： suba - 地址； opt - 0:写； 1:读
    433          * 出口参数：
    434          * 作　 　者： 无名沈
    435          * 创建日期： 2015-08-18
    436          * 修    改：
    437          * 修改日期：
    438          * 备    注：
    439          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          uint8_t BSP_EEP_SetAddr( uint16_t suba, uint8_t opt)
    441          {
   \                     BSP_EEP_SetAddr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    442              uint8_t      ack;
    443          #if    AT_DEV_NO_SEL_PIN ==  DEF_ENABLED 
    444              //uint8_t    ctrl = BSP_EEP_I2C_ADDR | ((suba >> 7 ) & 0x0E);
    445              uint8_t    ctrl = BSP_EEP_I2C_ADDR | ((suba / 256) * 2 );
    446              ack = I2C_SendByte(ctrl);                   // 发送设备地址 + 存储块
    447          #else
    448              ack = I2C_SendByte(BSP_EEP_I2C_ADDR);       // 发送设备地址
   \   00000006   0x20A0             MOVS     R0,#+160
   \   00000008   0x.... 0x....      BL       I2C_SendByte
    449          #endif
    450              if(!ack)    goto exit;                      // 转至结束
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD013             BEQ.N    ??BSP_EEP_SetAddr_0
    451          
    452          #if    AT_DEV_NO_SEL_PIN ==  DEF_ENABLED 
    453              #if AT_MAX_BYTES > 32*1024u
    454              ack = I2C_SendByte(suba>>8);                // 发送内存高地址
    455              if(!ack)    goto exit;                      // 转至结束
    456              #endif
    457          #else
    458              #if AT_MAX_BYTES > 256u
    459              ack = I2C_SendByte(suba>>8);                // 发送内存高地址
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x0A00             LSRS     R0,R0,#+8
   \   00000014   0x.... 0x....      BL       I2C_SendByte
    460              if(!ack)    goto exit;                      // 转至结束
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00D             BEQ.N    ??BSP_EEP_SetAddr_0
    461              #endif
    462          #endif
    463              ack = I2C_SendByte(suba);                   // 发送内存低地址
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x.... 0x....      BL       I2C_SendByte
    464              if(!ack)    goto exit;                      // 转至结束
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD007             BEQ.N    ??BSP_EEP_SetAddr_0
    465              /***********************************************
    466              * 描述： 如果为读，则发送读地址
    467              */
    468              if ( opt ) {
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD005             BEQ.N    ??BSP_EEP_SetAddr_0
    469                I2C_Start();                              // 重新发送起始条件
   \   0000002C   0x.... 0x....      BL       I2C_Start
    470                ack = I2C_SendByte(BSP_EEP_I2C_ADDR+1);
   \   00000030   0x20A1             MOVS     R0,#+161
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x....             B.N      I2C_SendByte
    471                if(!ack)  goto exit;                      // 转至结束
    472              }
    473          exit:
    474              return ack;
   \                     ??BSP_EEP_SetAddr_0: (+1)
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    475          }
    476          
    477          #if (UCOS_EN     == DEF_ENABLED)
    478          /*******************************************************************************
    479          * 名    称： EEP_WaitEvent
    480          * 功    能： 等待信号量
    481          * 入口参数： 无
    482          * 出口参数：  0（操作有误），1（操作成功）
    483          * 作　 　者： 无名沈
    484          * 创建日期： 2015-08-18
    485          * 修    改：
    486          * 修改日期：
    487          * 备    注： 仅在使用UCOS操作系统时使用
    488          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    489          uint8_t EEP_WaitEvent(void)
    490          {
    491              /***********************************************
    492              * 描述： OS接口
    493              */
    494          
    495          #if OS_VERSION > 30000U
    496              return BSP_OS_SemWait(&Bsp_EepSem,0);           // 等待信号量
   \                     EEP_WaitEvent: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000006   0x.... 0x....      B.W      BSP_OS_SemWait
    497          #else
    498              uint8_t       err;
    499              OSSemPend(Bsp_EepSem,0,&err);                   // 等待信号量
    500              if ( err = OS_ERR_NONE )
    501                return TRUE;
    502              else
    503                return FALSE;
    504          #endif
    505          }
    506          
    507          /*******************************************************************************
    508          * 名    称： EEP_SendEvent
    509          * 功    能： 释放信号量
    510          * 入口参数： 无
    511          * 出口参数： 无
    512          * 作　 　者： 无名沈
    513          * 创建日期： 2015-08-18
    514          * 修    改：
    515          * 修改日期：
    516          * 备    注： 仅在使用UCOS操作系统时使用
    517          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    518          void EEP_SendEvent(void)
    519          {
    520              /***********************************************
    521              * 描述： OS接口
    522              */
    523          #if OS_VERSION > 30000U
    524              BSP_OS_SemPost(&Bsp_EepSem);                        // 发送信号量
   \                     EEP_SendEvent: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000004   0x.... 0x....      B.W      BSP_OS_SemPost
    525          #else
    526              uint8_t       err;
    527              OSSemPost(Bsp_EepSem);                              // 发送信号量
    528          #endif
    529          }
    530          #endif /* end of (UCOS_EN     == DEF_ENABLED)*/
    531          
    532          
    533          /*******************************************************************************
    534          * 名    称： BSP_EEP_WriteByte
    535          * 功    能： 从启动总线到发送地址、数据，结束总线的全过程，如果返回1，表示
    536                       操作成功，否则操作有误。
    537          * 入口参数： suba： EEPROM地址  byte写出的字节
    538          * 出口参数： 0（操作有误），1（操作成功）
    539          * 作　 　者： 无名沈
    540          * 创建日期： 2015-08-18
    541          * 修    改：
    542          * 修改日期：
    543          * 备    注：
    544          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    545          uint8_t BSP_EEP_WriteByte(uint16_t suba,uint8_t byte )
    546          {
   \                     BSP_EEP_WriteByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    547              uint8_t   ack;
    548          
    549          #if (UCOS_EN     == DEF_ENABLED)
    550              /***********************************************
    551              * 描述： OS接口
    552              */
    553              EEP_WaitEvent();                            // 等信号量
   \   00000006   0x.... 0x....      BL       EEP_WaitEvent
    554          #endif
    555          
    556              I2C_Start();                                // 发送起始条件
   \   0000000A   0x.... 0x....      BL       I2C_Start
    557          
    558              ack = BSP_EEP_SetAddr(suba,0);              // 设置读地址
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       BSP_EEP_SetAddr
   \   00000016   0x0004             MOVS     R4,R0
    559              if(!ack)    goto exit;                      // 转至结束
   \   00000018   0xD003             BEQ.N    ??BSP_EEP_WriteByte_0
    560          
    561              ack = I2C_SendByte(byte);                   // 发送要写入的内容
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       I2C_SendByte
   \   00000020   0x4604             MOV      R4,R0
    562              if(!ack)    goto exit;                      // 转至结束
    563          
    564          exit:
    565              I2C_Stop();                                 // 发送停止条件
   \                     ??BSP_EEP_WriteByte_0: (+1)
   \   00000022   0x.... 0x....      BL       I2C_Stop
    566          
    567          #if (UCOS_EN     == DEF_ENABLED)
    568              EEP_SendEvent();                            // 释放信号量
   \   00000026   0x.... 0x....      BL       EEP_SendEvent
    569          #endif
    570          
    571              return(ack);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    572          }
    573          
    574          /*******************************************************************************
    575          * 名    称： BSP_EEP_ReadByte
    576          * 功    能： 读1个字节。
    577          * 入口参数： suba： EEPROM地址  byte读出的字节
    578          * 出口参数： 0（操作有误），1（操作成功）
    579          * 作　 　者： 无名沈
    580          * 创建日期： 2015-08-18
    581          * 修    改：
    582          * 修改日期：
    583          * 备    注：
    584          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    585          uint8_t BSP_EEP_ReadByte( uint16_t suba, uint8_t *byte)
    586          {
   \                     BSP_EEP_ReadByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    587              uint8_t       ack;
    588          
    589          #if (UCOS_EN     == DEF_ENABLED)
    590              /***********************************************
    591              * 描述： OS接口
    592              */
    593              EEP_WaitEvent();                            // 等信号量
   \   00000006   0x.... 0x....      BL       EEP_WaitEvent
    594          #endif
    595          
    596              I2C_Start();                                // 发送起始条件
   \   0000000A   0x.... 0x....      BL       I2C_Start
    597          
    598              ack = BSP_EEP_SetAddr(suba,1);              // 设置读地址
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       BSP_EEP_SetAddr
   \   00000016   0x0004             MOVS     R4,R0
    599              if(!ack)    goto exit;                      // 转至结束
   \   00000018   0xD004             BEQ.N    ??BSP_EEP_ReadByte_0
    600          
    601              ack = I2C_RecvByte(I2C_NACK,byte);          // 接收内容并发关非应答
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       I2C_RecvByte
   \   00000022   0x4604             MOV      R4,R0
    602          exit:
    603              I2C_Stop();                                 // 发送停止条件
   \                     ??BSP_EEP_ReadByte_0: (+1)
   \   00000024   0x.... 0x....      BL       I2C_Stop
    604          
    605          #if (UCOS_EN     == DEF_ENABLED)
    606              EEP_SendEvent();                            // 释放信号量
   \   00000028   0x.... 0x....      BL       EEP_SendEvent
    607          #endif
    608          
    609              return ack;
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    610          }
    611          
    612          /*******************************************************************************
    613          * 名    称： BSP_EEP_WriteByteChk
    614          * 功    能： 写一个字节并且将写入的字节再都出来。
    615          * 入口参数： suba： EEPROM地址  byte写入的字节
    616          * 出口参数： 等于写入的字节byte
    617          * 作　 　者： 无名沈
    618          * 创建日期： 2015-08-18
    619          * 修    改：
    620          * 修改日期：
    621          * 备    注：
    622          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    623          uint8_t BSP_EEP_WriteByteChk(uint16_t suba,uint8_t byte )
    624          {
   \                     BSP_EEP_WriteByteChk: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    625              uint8_t   chk;
    626              uint8_t   retrys  = 10;
   \   00000008   0x260A             MOVS     R6,#+10
    627          
    628              do {
    629          #if (UCOS_EN     == DEF_ENABLED)
    630          #if OS_VERSION > 30000U
    631                  BSP_OS_TimeDly(DLY_WR_STO);
   \                     ??BSP_EEP_WriteByteChk_0: (+1)
   \   0000000A   0x2005             MOVS     R0,#+5
   \   0000000C   0x.... 0x....      BL       BSP_OS_TimeDly
    632          #else
    633                  OSTimeDly(DLY_WR_STO);
    634          #endif
    635          #else
    636                  Delay_Nms(DLY_WR_STO);
    637          #endif
    638                  if( BSP_EEP_WriteByte( suba, byte ) ) {
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       BSP_EEP_WriteByte
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00F             BEQ.N    ??BSP_EEP_WriteByteChk_1
    639                      chk     = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    640          #if (UCOS_EN     == DEF_ENABLED)
    641          #if OS_VERSION > 30000U
    642                      BSP_OS_TimeDly(DLY_WR_STO);
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0x.... 0x....      BL       BSP_OS_TimeDly
    643          #else
    644                      OSTimeDly(DLY_WR_STO);
    645          #endif
    646          #else
    647                      Delay_Nms(DLY_WR_STO);
    648          #endif
    649                      BSP_EEP_ReadByte( suba, &chk );
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       BSP_EEP_ReadByte
    650                      if ( chk == byte )
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD101             BNE.N    ??BSP_EEP_WriteByteChk_1
    651                          return TRUE;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBD76             POP      {R1,R2,R4-R6,PC}
    652                  }
    653              } while(--retrys);
   \                     ??BSP_EEP_WriteByteChk_1: (+1)
   \   0000003C   0x1E76             SUBS     R6,R6,#+1
   \   0000003E   0xB2F6             UXTB     R6,R6
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD1E2             BNE.N    ??BSP_EEP_WriteByteChk_0
    654          
    655              return(FALSE);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    656          }
    657          
    658          /*******************************************************************************
    659          * 名    称： BSP_EEP_WritePage
    660          * 功    能： 写一页数据
    661          * 入口参数： suba： EEPROM地址  pbuf ： 写入字节的数组 len : 数组的大小
    662          * 出口参数： 0（操作有误），1（操作成功）
    663          * 作　 　者： 无名沈
    664          * 创建日期： 2015-08-18
    665          * 修    改：
    666          * 修改日期：
    667          * 备    注：
    668          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    669          uint8_t BSP_EEP_WritePage( uint16_t suba , uint8_t * pbuf , uint8_t len )
    670          {
   \                     BSP_EEP_WritePage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    671              uint8_t    size   = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    672              uint8_t    ack;
    673          
    674              if ( len > AT_PAGE_SIZE )
   \   0000000A   0x2E21             CMP      R6,#+33
   \   0000000C   0xD203             BCS.N    ??BSP_EEP_WritePage_0
    675                return 0;
    676          
    677              if ( AT24CXX_Enabled() == FALSE )
   \   0000000E   0x.... 0x....      BL       AT24CXX_Enabled
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??BSP_EEP_WritePage_1
    678                  return 0;
   \                     ??BSP_EEP_WritePage_0: (+1)
   \   00000016   0x4638             MOV      R0,R7
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}
    679              
    680          #if (UCOS_EN     == DEF_ENABLED)
    681          #if OS_VERSION > 30000U
    682              BSP_OS_TimeDly(DLY_WR_STO);
   \                     ??BSP_EEP_WritePage_1: (+1)
   \   0000001A   0x2005             MOVS     R0,#+5
   \   0000001C   0x.... 0x....      BL       BSP_OS_TimeDly
    683          #else
    684              OSTimeDly(DLY_WR_STO);
    685          #endif
    686          #else
    687              Delay_Nms(DLY_WR_STO);                      // 上一个停止和下一个起始之间要最多延时10ms
    688          #endif
    689          
    690              I2C_Start();
   \   00000020   0x.... 0x....      BL       I2C_Start
    691          
    692              ack = BSP_EEP_SetAddr(suba,0);              // 设置读地址
    693              if(!ack)    goto exit;                      // 转至结束
   \   00000024   0x4639             MOV      R1,R7
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       BSP_EEP_SetAddr
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??BSP_EEP_WritePage_2
   \   00000030   0xE008             B.N      ??BSP_EEP_WritePage_3
    694          
    695              for ( ; size < len ; size ++ ) {
   \                     ??BSP_EEP_WritePage_4: (+1)
   \   00000032   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BSP_EEP_WritePage_2: (+1)
   \   00000034   0xB2FF             UXTB     R7,R7
   \   00000036   0x42B7             CMP      R7,R6
   \   00000038   0xD204             BCS.N    ??BSP_EEP_WritePage_3
    696                  ack = I2C_SendByte( pbuf[ size ] );
    697                  if(!ack)    goto exit;                      // 转至结束
   \   0000003A   0x5D78             LDRB     R0,[R7, R5]
   \   0000003C   0x.... 0x....      BL       I2C_SendByte
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD1F6             BNE.N    ??BSP_EEP_WritePage_4
    698              }
    699          exit:
    700              I2C_Stop();
   \                     ??BSP_EEP_WritePage_3: (+1)
   \   00000044   0x.... 0x....      BL       I2C_Stop
    701              return size;
   \   00000048   0x4638             MOV      R0,R7
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    702          }
    703          
    704          /*******************************************************************************
    705          * 名    称： BSP_EEP_ReadPage
    706          * 功    能： 读一页数据
    707          * 入口参数： suba： EEPROM地址  pbuf ： 写入字节的数组 len : 数组的大小
    708          * 出口参数： 0（操作有误），1（操作成功）
    709          * 作　 　者： 无名沈
    710          * 创建日期： 2015-08-18
    711          * 修    改：
    712          * 修改日期：
    713          * 备    注：
    714          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    715          uint16_t BSP_EEP_ReadPage(uint16_t suba,uint8_t *pbuf, uint16_t len)
    716          {
   \                     BSP_EEP_ReadPage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    717              uint8_t    size   = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    718              uint8_t    ack;
    719              /***********************************************
    720              * 描述： 检测是否超出存储容量
    721              */
    722              if ( (suba + len) > (AT_MAX_BYTES) )
   \   0000000C   0x46B0             MOV      R8,R6
   \   0000000E   0xEB08 0x0004      ADD      R0,R8,R4
   \   00000012   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000016   0xDC03             BGT.N    ??BSP_EEP_ReadPage_0
    723                  return 0;
    724          
    725              /***********************************************
    726              * 描述： 检测是否可操作
    727              */
    728              if ( AT24CXX_Enabled() == FALSE )
   \   00000018   0x.... 0x....      BL       AT24CXX_Enabled
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE.N    ??BSP_EEP_ReadPage_1
    729                  return 0;
   \                     ??BSP_EEP_ReadPage_0: (+1)
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0xE026             B.N      ??BSP_EEP_ReadPage_2
    730              
    731          #if (UCOS_EN     == DEF_ENABLED)
    732          #if OS_VERSION > 30000U
    733              BSP_OS_TimeDly(DLY_WR_STO);
   \                     ??BSP_EEP_ReadPage_1: (+1)
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0x.... 0x....      BL       BSP_OS_TimeDly
    734          #else
    735              OSTimeDly(DLY_WR_STO);
    736          #endif
    737          #else
    738              Delay_Nms(DLY_WR_STO);                          // 上一个停止和下一个起始之间要最多延时10ms
    739          #endif
    740              /***********************************************
    741              * 描述： 检测是否到最后一字节
    742              */
    743              I2C_Start();                                    // 发送起始条件
   \   0000002A   0x.... 0x....      BL       I2C_Start
    744              ack = BSP_EEP_SetAddr(suba,1);                  // 设置读地址
    745          
    746              if(!ack) {
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       BSP_EEP_SetAddr
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD104             BNE.N    ??BSP_EEP_ReadPage_3
    747                  I2C_Stop();                               // 发送停止条件
   \   0000003A   0x.... 0x....      BL       I2C_Stop
    748                  return 0;
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0xE017             B.N      ??BSP_EEP_ReadPage_2
    749              }
    750          
    751              /***********************************************
    752              * 描述： 检测是否到最后一字节
    753              */
    754              for( size = 0; size < len; size++ ) {
   \                     ??BSP_EEP_ReadPage_4: (+1)
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BSP_EEP_ReadPage_3: (+1)
   \   00000044   0xB2FF             UXTB     R7,R7
   \   00000046   0x463C             MOV      R4,R7
   \   00000048   0x42B4             CMP      R4,R6
   \   0000004A   0xD20F             BCS.N    ??BSP_EEP_ReadPage_5
    755                  /***********************************************
    756                  * 描述： 检测是否到最后一字节
    757                  */
    758                  if ( size == len - 1 ) {
   \   0000004C   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   00000050   0x4287             CMP      R7,R0
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0xD104             BNE.N    ??BSP_EEP_ReadPage_6
    759                      ack = I2C_RecvByte(I2C_NACK, pbuf++);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       I2C_RecvByte
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \   0000005E   0xE003             B.N      ??BSP_EEP_ReadPage_7
    760                  } else {
    761                      ack = I2C_RecvByte(I2C_ACK, pbuf++);
   \                     ??BSP_EEP_ReadPage_6: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x.... 0x....      BL       I2C_RecvByte
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
    762                  }
    763                  /***********************************************
    764                  * 描述： 检测应答信号是否正确
    765                  */
    766                  if(!ack) {
   \                     ??BSP_EEP_ReadPage_7: (+1)
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1EA             BNE.N    ??BSP_EEP_ReadPage_4
    767                      //I2C_Stop();                   // 发送停止条件
    768                      break;
    769                  }
    770              }
    771           
    772              I2C_Stop();                   // 发送停止条件
   \                     ??BSP_EEP_ReadPage_5: (+1)
   \   0000006C   0x.... 0x....      BL       I2C_Stop
    773          
    774              return size;
   \   00000070   0x4620             MOV      R0,R4
   \                     ??BSP_EEP_ReadPage_2: (+1)
   \   00000072   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    775          }
    776          

   \                                 In section .bss, align 4
    777          static uint8_t  buf[AT_PAGE_SIZE];
   \                     buf:
   \   00000000                      DS8 32
    778          /*******************************************************************************
    779          * 名    称： BSP_EEP_WriteBytes
    780          * 功    能： 写多个字节
    781          * 入口参数： suba： EEPROM地址  pbuf ：写入字节的数组 len : 数组的大小
    782          * 出口参数： 0（操作有误），1（操作成功）
    783          * 作　 　者： 无名沈
    784          * 创建日期： 2015-08-18
    785          * 修    改：
    786          * 修改日期：
    787          * 备    注：
    788          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    789          uint16_t BSP_EEP_WriteBytes( uint16_t suba, uint8_t *pbuf, uint16_t len )
    790          {
   \                     BSP_EEP_WriteBytes: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    791              uint16_t      bytes   = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    792              /***********************************************
    793              * 描述： 检测地址是否会溢出，如果溢出则直接返回
    794              */
    795              if ( (suba + len) > (AT_MAX_BYTES) )
   \   0000000C   0x46B0             MOV      R8,R6
   \   0000000E   0xEB08 0x0004      ADD      R0,R8,R4
   \   00000012   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000016   0xDD01             BLE.N    ??BSP_EEP_WriteBytes_0
    796                  return 0;
   \   00000018   0x4638             MOV      R0,R7
   \   0000001A   0xE051             B.N      ??BSP_EEP_WriteBytes_1
    797          
    798          #if (UCOS_EN     == DEF_ENABLED)
    799              /***********************************************
    800              * 描述： OS接口
    801              */
    802              EEP_WaitEvent();                            // 等信号量
   \                     ??BSP_EEP_WriteBytes_0: (+1)
   \   0000001C   0x.... 0x....      BL       EEP_WaitEvent
    803          #endif
    804          
    805              uint8_t    size    = 0;
    806          
    807              /***********************************************
    808              * 描述： 非页首开始，读取之前数据进行填充
    809              */
    810              if ( ( suba % AT_PAGE_SIZE ) != 0 ) {
   \   00000020   0x201F             MOVS     R0,#+31
   \   00000022   0x4204             TST      R4,R0
   \   00000024   0xD025             BEQ.N    ??BSP_EEP_WriteBytes_2
    811                  uint8_t  readLen;
    812                  uint16_t  pageAddr;
    813          
    814                  size        = AT_PAGE_SIZE - ( suba % AT_PAGE_SIZE );
   \   00000026   0xF004 0x001F      AND      R0,R4,#0x1F
   \   0000002A   0xF1C0 0x0720      RSB      R7,R0,#+32
   \   0000002E   0xB2FF             UXTB     R7,R7
    815                  readLen     = AT_PAGE_SIZE - size;
   \   00000030   0xF1C7 0x0920      RSB      R9,R7,#+32
   \   00000034   0xFA5F 0xF989      UXTB     R9,R9
    816                  pageAddr    = suba - readLen;
   \   00000038   0xEBA4 0x0A09      SUB      R10,R4,R9
    817                  BSP_EEP_ReadPage(pageAddr, buf, AT_PAGE_SIZE);
   \   0000003C   0x.... 0x....      LDR.W    R11,??DataTable13_4
   \   00000040   0x2220             MOVS     R2,#+32
   \   00000042   0x4659             MOV      R1,R11
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0xB280             UXTH     R0,R0
   \   00000048   0x.... 0x....      BL       BSP_EEP_ReadPage
    818          
    819                  if ( size > len )
   \   0000004C   0x45B8             CMP      R8,R7
   \   0000004E   0xDA01             BGE.N    ??BSP_EEP_WriteBytes_3
    820                      size = len;
   \   00000050   0x4637             MOV      R7,R6
   \   00000052   0xB2FF             UXTB     R7,R7
    821                  memcpy(&buf[readLen],pbuf,size);
   \                     ??BSP_EEP_WriteBytes_3: (+1)
   \   00000054   0x463A             MOV      R2,R7
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0xEB09 0x000B      ADD      R0,R9,R11
   \   0000005C   0x.... 0x....      BL       __aeabi_memcpy
    822          
    823                  BSP_EEP_WritePage( pageAddr , buf , AT_PAGE_SIZE );
   \   00000060   0x2220             MOVS     R2,#+32
   \   00000062   0x4659             MOV      R1,R11
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0xB280             UXTH     R0,R0
   \   00000068   0x.... 0x....      BL       BSP_EEP_WritePage
    824          
    825                  suba    += size;
   \   0000006C   0x193C             ADDS     R4,R7,R4
    826                  pbuf    += size;
   \   0000006E   0x197D             ADDS     R5,R7,R5
    827                  len     -= size;
   \   00000070   0x1BF6             SUBS     R6,R6,R7
    828                  bytes   += size;
    829              }
    830          
    831              /***********************************************
    832              * 描述： 页首开始，整页
    833              */
    834              size = len / AT_PAGE_SIZE;
   \                     ??BSP_EEP_WriteBytes_2: (+1)
   \   00000072   0xB2B6             UXTH     R6,R6
   \   00000074   0xEA4F 0x1856      LSR      R8,R6,#+5
   \   00000078   0xFA5F 0xF888      UXTB     R8,R8
   \   0000007C   0xE00D             B.N      ??BSP_EEP_WriteBytes_4
    835              while ( size > 0 ) {
    836                  BSP_EEP_WritePage( suba , pbuf, AT_PAGE_SIZE );
   \                     ??BSP_EEP_WriteBytes_5: (+1)
   \   0000007E   0x2220             MOVS     R2,#+32
   \   00000080   0x4629             MOV      R1,R5
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0xB280             UXTH     R0,R0
   \   00000086   0x.... 0x....      BL       BSP_EEP_WritePage
    837                  suba    += AT_PAGE_SIZE;
   \   0000008A   0x3420             ADDS     R4,R4,#+32
    838                  pbuf    += AT_PAGE_SIZE;
   \   0000008C   0x3520             ADDS     R5,R5,#+32
    839                  len     -= AT_PAGE_SIZE;
   \   0000008E   0x3E20             SUBS     R6,R6,#+32
    840                  bytes   += AT_PAGE_SIZE;
   \   00000090   0x3720             ADDS     R7,R7,#+32
    841                  size    -= 1;
   \   00000092   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8
    842              }
   \                     ??BSP_EEP_WriteBytes_4: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD1EE             BNE.N    ??BSP_EEP_WriteBytes_5
    843          
    844              /***********************************************
    845              * 描述： 页首开始，不足一页
    846              */
    847              if ( len > 0 ) {
   \   000000A0   0xB2B6             UXTH     R6,R6
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xD008             BEQ.N    ??BSP_EEP_WriteBytes_6
    848                  BSP_EEP_WritePage( suba , pbuf , len );
   \   000000A6   0x4632             MOV      R2,R6
   \   000000A8   0xB2D2             UXTB     R2,R2
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0xB280             UXTH     R0,R0
   \   000000B0   0x.... 0x....      BL       BSP_EEP_WritePage
    849                  bytes   += len;
   \   000000B4   0x19F7             ADDS     R7,R6,R7
   \   000000B6   0xB2BF             UXTH     R7,R7
    850              }
    851          
    852          #if (UCOS_EN     == DEF_ENABLED)
    853              /***********************************************
    854              * 描述： OS接口
    855              */
    856              EEP_SendEvent();                            // 释放信号量
   \                     ??BSP_EEP_WriteBytes_6: (+1)
   \   000000B8   0x.... 0x....      BL       EEP_SendEvent
    857          #endif
    858          
    859              return(bytes);
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0xB280             UXTH     R0,R0
   \                     ??BSP_EEP_WriteBytes_1: (+1)
   \   000000C0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    860          }
    861          
    862          
    863          /*******************************************************************************
    864          * 名    称： BSP_EEP_ReadBytes
    865          * 功    能： 读多个字节
    866          * 入口参数： suba： EEPROM地址  pbuf ：读出字节的数组 len : 数组的大小
    867          * 出口参数： 0（操作有误），1（操作成功）
    868          * 作　 　者： 无名沈
    869          * 创建日期： 2015-08-18
    870          * 修    改：
    871          * 修改日期：
    872          * 备    注：
    873          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    874          uint16_t BSP_EEP_ReadBytes(uint16_t suba,uint8_t *buf, uint16_t len)
    875          {
   \                     BSP_EEP_ReadBytes: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    876              uint16_t      bytes   = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    877              uint8_t      ack;
    878              /***********************************************
    879              * 描述： 检测是否超出存储容量
    880              */
    881              if ( (suba + len) > (AT_MAX_BYTES) )
   \   0000000C   0x46B0             MOV      R8,R6
   \   0000000E   0xEB08 0x0004      ADD      R0,R8,R4
   \   00000012   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000016   0xDD01             BLE.N    ??BSP_EEP_ReadBytes_0
    882                  return 0;
   \   00000018   0x4638             MOV      R0,R7
   \   0000001A   0xE02B             B.N      ??BSP_EEP_ReadBytes_1
    883          #if (UCOS_EN     == DEF_ENABLED)
    884              /***********************************************
    885              * 描述： OS接口
    886              */
    887              EEP_WaitEvent();                            // 等信号量
   \                     ??BSP_EEP_ReadBytes_0: (+1)
   \   0000001C   0x.... 0x....      BL       EEP_WaitEvent
    888          #endif
    889          
    890              /***********************************************
    891              * 描述： 检测是否可操作
    892              */
    893              if ( AT24CXX_Enabled() == FALSE )
   \   00000020   0x.... 0x....      BL       AT24CXX_Enabled
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD01F             BEQ.N    ??BSP_EEP_ReadBytes_2
    894                  goto exit;
    895              
    896          #if (UCOS_EN     == DEF_ENABLED)
    897          #if OS_VERSION > 30000U
    898              BSP_OS_TimeDly(DLY_WR_STO);
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0x.... 0x....      BL       BSP_OS_TimeDly
    899          #else
    900              OSTimeDly(DLY_WR_STO);
    901          #endif
    902          #else
    903              Delay_Nms(DLY_WR_STO);                          // 上一个停止和下一个起始之间要最多延时10ms
    904          #endif
    905              /***********************************************
    906              * 描述： 检测是否到最后一字节
    907              */
    908              I2C_Start();                                    // 发送起始条件
   \   0000002E   0x.... 0x....      BL       I2C_Start
    909              ack = BSP_EEP_SetAddr(suba,1);                  // 设置读地址
    910          
    911              if(!ack) {
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       BSP_EEP_SetAddr
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD101             BNE.N    ??BSP_EEP_ReadBytes_3
   \   0000003E   0xE013             B.N      ??BSP_EEP_ReadBytes_2
    912                  //I2C_Stop();                                 // 发送停止条件
    913                  bytes   = 0;
    914                  goto exit;
    915              }
    916          
    917              /***********************************************
    918              * 描述： 检测是否到最后一字节
    919              */
    920              for( bytes = 0; bytes < len; bytes++ ) {
   \                     ??BSP_EEP_ReadBytes_4: (+1)
   \   00000040   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BSP_EEP_ReadBytes_3: (+1)
   \   00000042   0xB2BF             UXTH     R7,R7
   \   00000044   0x42B7             CMP      R7,R6
   \   00000046   0xD20F             BCS.N    ??BSP_EEP_ReadBytes_2
    921                  /***********************************************
    922                  * 描述： 检测是否到最后一字节
    923                  */
    924                  if ( bytes == len - 1 ) {
   \   00000048   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   0000004C   0x4287             CMP      R7,R0
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0xD104             BNE.N    ??BSP_EEP_ReadBytes_5
    925                      ack = I2C_RecvByte(I2C_NACK, buf++);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       I2C_RecvByte
    926                      bytes++;
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
    927                      break;
   \   0000005A   0xE005             B.N      ??BSP_EEP_ReadBytes_2
    928                  } else {
    929                      ack = I2C_RecvByte(I2C_ACK, buf++);
   \                     ??BSP_EEP_ReadBytes_5: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       I2C_RecvByte
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
    930                  }
    931                  /***********************************************
    932                  * 描述： 检测应答信号是否正确
    933                  */
    934                  if(!ack) {
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1EB             BNE.N    ??BSP_EEP_ReadBytes_4
    935                      break;
    936                  }
    937              }
    938          exit:
    939              I2C_Stop();                   // 发送停止条件
   \                     ??BSP_EEP_ReadBytes_2: (+1)
   \   00000068   0x.... 0x....      BL       I2C_Stop
    940          #if (UCOS_EN     == DEF_ENABLED)
    941              /***********************************************
    942              * 描述： OS接口
    943              */
    944              EEP_SendEvent();                            // 释放信号量
   \   0000006C   0x.... 0x....      BL       EEP_SendEvent
    945          #endif
    946          
    947              return bytes;
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0xB280             UXTH     R0,R0
   \                     ??BSP_EEP_ReadBytes_1: (+1)
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    948          }
    949          
    950          
    951          /*******************************************************************************
    952          * 名    称： BSP_EEP_Writeuint16_t
    953          * 功    能： 写入一个16位的数（占两个字节）
    954          * 入口参数： suba： EEPROM地址   dat：16的数
    955          * 出口参数： 0（操作有误），1（操作成功）
    956          * 作　 　者： 无名沈
    957          * 创建日期： 2015-08-18
    958          * 修    改：
    959          * 修改日期：
    960          * 备    注：
    961          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    962          uint8_t BSP_EEP_WriteINT16U( uint16_t suba, uint16_t dat )
    963          {
   \                     BSP_EEP_WriteINT16U: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    964              uint8_t       bytes   = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    965              uint8_t      *pbuf   = (uint8_t *)&dat;
   \   00000006   0xAE01             ADD      R6,SP,#+4
    966          
    967              if ( suba > (AT_MAX_BYTES-1u-2u) )
   \   00000008   0xF641 0x70FE      MOVW     R0,#+8190
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD302             BCC.N    ??BSP_EEP_WriteINT16U_0
    968                  return 0;
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0xBD76             POP      {R1,R2,R4-R6,PC}
    969          
    970          
    971              /***********************************************
    972              * 描述：单字节写入，先写高字节
    973              */
    974              for( bytes = 0; bytes < 2; bytes++ ) {
   \                     ??BSP_EEP_WriteINT16U_1: (+1)
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
   \                     ??BSP_EEP_WriteINT16U_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5
   \   00000018   0x2D02             CMP      R5,#+2
   \   0000001A   0xDA08             BGE.N    ??BSP_EEP_WriteINT16U_2
    975                  if( !BSP_EEP_WriteByteChk( suba++, *pbuf++ ) ) {
   \   0000001C   0xF816 0x1B01      LDRB     R1,[R6], #+1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB280             UXTH     R0,R0
   \   00000024   0x.... 0x....      BL       BSP_EEP_WriteByteChk
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1F2             BNE.N    ??BSP_EEP_WriteINT16U_1
    976                      break;
    977                  }
    978              }
    979          
    980              return(bytes);
   \                     ??BSP_EEP_WriteINT16U_2: (+1)
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    981          }
    982          
    983          /*******************************************************************************
    984          * 名    称： BSP_EEP_Readuint16_t
    985          * 功    能： 读一个16位的数（占两个字节）
    986          * 入口参数： suba： EEPROM地址   dat：16的数
    987          * 出口参数： 0（操作有误），1（操作成功）
    988          * 作　 　者： 无名沈
    989          * 创建日期： 2015-08-18
    990          * 修    改：
    991          * 修改日期：
    992          * 备    注：
    993          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    994          uint8_t BSP_EEP_ReadINT16U( uint16_t suba,uint16_t *dat)
    995          {
   \                     BSP_EEP_ReadINT16U: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    996              uint8_t       bytes   = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    997              uint8_t      *pbuf   = (uint8_t *)dat;
    998          
    999              if ( suba > (AT_MAX_BYTES-1u-2u) )
   \   00000008   0xF641 0x70FE      MOVW     R0,#+8190
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD301             BCC.N    ??BSP_EEP_ReadINT16U_0
   1000                  return 0;
   \   00000010   0x4630             MOV      R0,R6
   \   00000012   0xBD70             POP      {R4-R6,PC}
   1001          
   1002              memset(buf,0x00,2);
   \                     ??BSP_EEP_ReadINT16U_0: (+1)
   \   00000014   0x4632             MOV      R2,R6
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x....             LDR.N    R0,??DataTable13_4
   \   0000001A   0x.... 0x....      BL       __aeabi_memset4
   1003          
   1004              /***********************************************
   1005              * 描述：单字节读取，先读高字节
   1006              */
   1007              for( bytes = 0; bytes < 2; bytes++ ) {
   \   0000001E   0xE000             B.N      ??BSP_EEP_ReadINT16U_1
   \                     ??BSP_EEP_ReadINT16U_2: (+1)
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??BSP_EEP_ReadINT16U_1: (+1)
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x2E02             CMP      R6,#+2
   \   00000026   0xDA08             BGE.N    ??BSP_EEP_ReadINT16U_3
   1008                  if( !BSP_EEP_ReadByte( suba++, pbuf++ ) ) {
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0x.... 0x....      BL       BSP_EEP_ReadByte
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F2             BNE.N    ??BSP_EEP_ReadINT16U_2
   1009                      break;
   1010                  }
   1011              }
   1012          
   1013              return bytes;
   \                     ??BSP_EEP_ReadINT16U_3: (+1)
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   1014          }
   1015          
   1016          /*******************************************************************************
   1017          * 名    称： BSP_EEP_Writeuint32_t
   1018          * 功    能： 写入一个32位的数（占四个字节）
   1019          * 入口参数： suba： EEPROM地址   dat：32位的数
   1020          * 出口参数： 0（操作有误），1（操作成功）
   1021          * 作　 　者： 无名沈
   1022          * 创建日期： 2015-08-18
   1023          * 修    改：
   1024          * 修改日期：
   1025          * 备    注：
   1026          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1027          uint8_t BSP_EEP_WriteINT32U( uint16_t suba, uint32_t dat )
   1028          {
   \                     BSP_EEP_WriteINT32U: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1029              uint8_t       bytes;
   1030              uint8_t      *pbuf   = (uint8_t *)&dat;
   \   00000004   0xAD01             ADD      R5,SP,#+4
   1031          
   1032              if ( suba > (AT_MAX_BYTES-1u-4u) )
   \   00000006   0xF641 0x70FC      MOVW     R0,#+8188
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD301             BCC.N    ??BSP_EEP_WriteINT32U_0
   1033                  return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD76             POP      {R1,R2,R4-R6,PC}
   1034          
   1035              /***********************************************
   1036              * 描述：单字节写入，先写高字节
   1037              */
   1038              for( bytes = 0; bytes < 4; bytes++ ) {
   \                     ??BSP_EEP_WriteINT32U_0: (+1)
   \   00000012   0x2600             MOVS     R6,#+0
   \   00000014   0xE000             B.N      ??BSP_EEP_WriteINT32U_1
   \                     ??BSP_EEP_WriteINT32U_2: (+1)
   \   00000016   0x1C76             ADDS     R6,R6,#+1
   \                     ??BSP_EEP_WriteINT32U_1: (+1)
   \   00000018   0xB2F6             UXTB     R6,R6
   \   0000001A   0x2E04             CMP      R6,#+4
   \   0000001C   0xDA08             BGE.N    ??BSP_EEP_WriteINT32U_3
   1039                  if( !BSP_EEP_WriteByteChk( suba++, *pbuf++ ) ) {
   \   0000001E   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0x.... 0x....      BL       BSP_EEP_WriteByteChk
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD1F2             BNE.N    ??BSP_EEP_WriteINT32U_2
   1040                      break;
   1041                  }
   1042              }
   1043          
   1044              return(bytes);
   \                     ??BSP_EEP_WriteINT32U_3: (+1)
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1045          }
   1046          
   1047          /*******************************************************************************
   1048          * 名    称： BSP_EEP_ReadINT32U
   1049          * 功    能： 读一个32位的数（占四个字节）
   1050          * 入口参数： suba： EEPROM地址   dat：32位的数
   1051          * 出口参数： 0（操作有误），1（操作成功）
   1052          * 作　 　者： 无名沈
   1053          * 创建日期： 2015-08-18
   1054          * 修    改：
   1055          * 修改日期：
   1056          * 备    注：
   1057          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1058          uint8_t BSP_EEP_ReadINT32U( uint16_t suba,uint32_t *dat)
   1059          {
   \                     BSP_EEP_ReadINT32U: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1060              uint8_t       bytes   = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1061              uint8_t      *pbuf   = (uint8_t *)dat;
   1062          
   1063              if ( suba > (AT_MAX_BYTES-1u-4u) )
   \   00000008   0xF641 0x70FC      MOVW     R0,#+8188
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD301             BCC.N    ??BSP_EEP_ReadINT32U_0
   1064                  return 0;
   \   00000010   0x4630             MOV      R0,R6
   \   00000012   0xBD70             POP      {R4-R6,PC}
   1065          
   1066              memset(buf,0x00,4);
   \                     ??BSP_EEP_ReadINT32U_0: (+1)
   \   00000014   0x4632             MOV      R2,R6
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0x....             LDR.N    R0,??DataTable13_4
   \   0000001A   0x.... 0x....      BL       __aeabi_memset4
   1067          
   1068              /***********************************************
   1069              * 描述：单字节写入，先写高字节
   1070              */
   1071              for( bytes = 0; bytes < 4; bytes++ ) {
   \   0000001E   0xE000             B.N      ??BSP_EEP_ReadINT32U_1
   \                     ??BSP_EEP_ReadINT32U_2: (+1)
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??BSP_EEP_ReadINT32U_1: (+1)
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x2E04             CMP      R6,#+4
   \   00000026   0xDA08             BGE.N    ??BSP_EEP_ReadINT32U_3
   1072                  if( !BSP_EEP_ReadByte( suba++, pbuf++ ) ) {
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0x.... 0x....      BL       BSP_EEP_ReadByte
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F2             BNE.N    ??BSP_EEP_ReadINT32U_2
   1073                      break;
   1074                  }
   1075              }
   1076          
   1077              return bytes;
   \                     ??BSP_EEP_ReadINT32U_3: (+1)
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   1078          }
   1079          /*******************************************************************************
   1080          * 名    称： BSP_I2CSetPort
   1081          * 功    能： 端口选择
   1082          * 入口参数： 无
   1083          * 出口参数： 无
   1084          * 作　 　者： 无名沈
   1085          * 创建日期： 2015-08-18
   1086          * 修    改：
   1087          * 修改日期：
   1088          * 备    注： 外部调用此函数初始化EEPROM
   1089          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1090          void BSP_I2CSetPort(INT08U port)
   1091          {
   1092              if ( port == 2 ) {        
   \                     BSP_I2CSetPort: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_1
   \   00000002   0x2802             CMP      R0,#+2
   \   00000004   0xD106             BNE.N    ??BSP_I2CSetPort_0
   1093                  AT24CXX_SCL_PIN         = GPIO_Pin_10;
   \   00000006   0xF44F 0x6080      MOV      R0,#+1024
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1094                  AT24CXX_SDA_PIN         = GPIO_Pin_11;
   \   0000000C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000010   0x6048             STR      R0,[R1, #+4]
   \   00000012   0x4770             BX       LR
   1095              }else {        
   1096                  AT24CXX_SCL_PIN         = GPIO_Pin_6;
   \                     ??BSP_I2CSetPort_0: (+1)
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1097                  AT24CXX_SDA_PIN         = GPIO_Pin_7;
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x6048             STR      R0,[R1, #+4]
   1098              }  
   1099          }
   \   0000001C   0x4770             BX       LR               ;; return
   1100          
   1101          /*******************************************************************************
   1102          * 名    称： BSP_EEP_Init
   1103          * 功    能： EEPROM初始化
   1104          * 入口参数： 无
   1105          * 出口参数： 无
   1106          * 作　 　者： 无名沈
   1107          * 创建日期： 2015-08-18
   1108          * 修    改：
   1109          * 修改日期：
   1110          * 备    注： 外部调用此函数初始化EEPROM
   1111          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1112          BOOL BSP_EEP_Init(void)
   1113          {
   \                     BSP_EEP_Init: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   1114              GPIO_InitTypeDef    gpio_init;
   1115              uint8_t              dat;
   1116          
   1117              /***********************************************
   1118              * 描述： I2C1
   1119              */
   1120          #if GPIO_I2C1_PORT_EN == DEF_ENABLED
   1121              RCC_APB2PeriphClockCmd(I2C1_SCL_RCC , ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2040             MOVS     R0,#+64
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   1122              gpio_init.GPIO_Pin   = I2C1_SCL_PIN;
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1123              gpio_init.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1124              gpio_init.GPIO_Mode  = GPIO_Mode_Out_OD;
   \   00000016   0x2014             MOVS     R0,#+20
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1125              
   1126              GPIO_Init(I2C1_SCL_PORT, &gpio_init);
   \   0000001C   0x....             LDR.N    R4,??DataTable13_5  ;; 0x40011800
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       GPIO_Init
   1127              RCC_APB2PeriphClockCmd(I2C1_SDA_RCC , ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   1128              gpio_init.GPIO_Pin   = I2C1_SDA_PIN;
   \   0000002E   0xF44F 0x7080      MOV      R0,#+256
   \   00000032   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1129              GPIO_Init(I2C1_SDA_PORT, &gpio_init);
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       GPIO_Init
   1130          #endif
   1131              /***********************************************
   1132              * 描述： I2C2
   1133              */
   1134          #if GPIO_I2C2_PORT_EN == DEF_ENABLED
   1135              RCC_APB2PeriphClockCmd(I2C2_SCL_RCC , ENABLE);
   1136              gpio_init.GPIO_Pin   = I2C2_SCL_PIN;
   1137              gpio_init.GPIO_Speed = GPIO_Speed_2MHz;
   1138              gpio_init.GPIO_Mode  = GPIO_Mode_Out_OD;
   1139              
   1140              GPIO_Init(I2C2_SCL_PORT, &gpio_init);
   1141              RCC_APB2PeriphClockCmd(I2C2_SDA_RCC , ENABLE);
   1142              gpio_init.GPIO_Pin   = I2C2_SDA_PIN;
   1143              GPIO_Init(I2C2_SDA_PORT, &gpio_init);
   1144          #endif
   1145              
   1146          #if GPIO_I2C1_PORT_EN == DEF_ENABLED
   1147              BSP_I2CSetPort(1);                              // 切换到I2C1
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       BSP_I2CSetPort
   1148              AT24CXX_Init();
   \   00000044   0x.... 0x....      BL       AT24CXX_Init
   1149          #endif
   1150          #if GPIO_I2C2_PORT_EN == DEF_ENABLED
   1151              BSP_I2CSetPort(2);                              // 切换到I2C1
   1152              AT24CXX_Init();
   1153          #endif
   1154              BOOL ack    = BSP_EEP_ReadByte( 0, &dat );
   \   00000048   0xA901             ADD      R1,SP,#+4
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       BSP_EEP_ReadByte
   \   00000050   0x4604             MOV      R4,R0
   1155              /***********************************************
   1156              * 描述： OS接口
   1157              */
   1158          #if (UCOS_EN     == DEF_ENABLED)
   1159          #if OS_VERSION > 30000U
   1160              BSP_OS_SemCreate(&Bsp_EepSem,1, "Bsp EepSem");      // 创建信号量
   \   00000052   0x.... 0x....      ADR.W    R2,?_0
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x....             LDR.N    R0,??DataTable13_3
   \   0000005A   0x.... 0x....      BL       BSP_OS_SemCreate
   1161          #else
   1162              Bsp_EepSem     = OSSemCreate(1);                    // 创建信号量
   1163          #endif
   1164          #endif
   1165              return ack;
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1166          }
   1167          
   1168          /*******************************************************************************
   1169          * Function Name  :
   1170          * Description    :
   1171          * Input          :
   1172          * Output         :
   1173          * Return         : None
   1174          ********************************************************************************/
   1175          #define     TEST_BUF_LEN    1024

   \                                 In section .bss, align 4
   1176          INT32U      idx;
   1177          CHAR        atBuf[TEST_BUF_LEN];
   \                     atBuf:
   \   00000000                      DS8 1024
   1178          CHAR        chkBuf[TEST_BUF_LEN];
   \                     chkBuf:
   \   00000400                      DS8 1024
   \                     idx:
   \   00000800                      DS8 4

   \                                 In section .text, align 2, keep-with-next
   1179          void BSP_EEP_Main(void)
   1180          {
   \                     BSP_EEP_Main: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1181          
   1182              uint16_t      baseAddr        = 100;
   1183              idx         = 0;
   \   00000002   0x....             LDR.N    R4,??DataTable13_6
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8C4 0x0800      STR      R0,[R4, #+2048]
   1184          
   1185              BSP_EEP_Init();                                 // 初始化存储器
   \   0000000A   0x.... 0x....      BL       BSP_EEP_Init
   1186          
   1187              memset(atBuf,0x00,TEST_BUF_LEN);
   \   0000000E   0xF44F 0x6580      MOV      R5,#+1024
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       __aeabi_memset4
   1188              memset(chkBuf,0x00,TEST_BUF_LEN);
   \   0000001C   0xF504 0x6680      ADD      R6,R4,#+1024
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       __aeabi_memset4
   1189          
   1190              for(idx = 0; idx < TEST_BUF_LEN; idx++ ) {
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8C4 0x0800      STR      R0,[R4, #+2048]
   \   00000030   0xE004             B.N      ??BSP_EEP_Main_0
   1191                if ( idx % 2 )
   1192                  atBuf[idx]  = 0xAA;
   1193                else
   1194                  atBuf[idx]  = idx / 2;
   \                     ??BSP_EEP_Main_1: (+1)
   \   00000032   0x0841             LSRS     R1,R0,#+1
   \   00000034   0x5501             STRB     R1,[R0, R4]
   \                     ??BSP_EEP_Main_2: (+1)
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0xF8C4 0x0800      STR      R0,[R4, #+2048]
   \                     ??BSP_EEP_Main_0: (+1)
   \   0000003C   0xF8D4 0x0800      LDR      R0,[R4, #+2048]
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD20B             BCS.N    ??BSP_EEP_Main_3
   \   00000046   0x07C1             LSLS     R1,R0,#+31
   \   00000048   0xD5F3             BPL.N    ??BSP_EEP_Main_1
   \   0000004A   0x21AA             MOVS     R1,#+170
   \   0000004C   0x5501             STRB     R1,[R0, R4]
   \   0000004E   0xE7F2             B.N      ??BSP_EEP_Main_2
   1195              }
   1196          
   1197              while (1) {
   1198                  memset(chkBuf,0x00,TEST_BUF_LEN);
   1199                  BSP_EEP_ReadBytes(baseAddr,(uint8_t*)&chkBuf[0],TEST_BUF_LEN);
   1200          
   1201                  for (  idx = 0; idx < TEST_BUF_LEN; idx++ ){
   1202                    if ( atBuf[idx] != chkBuf[idx] ) {
   1203                      BSP_EEP_WriteBytes  (baseAddr,(uint8_t*)&atBuf[0],TEST_BUF_LEN);
   1204                      break;
   1205                    }
   1206                  }
   1207                  if ( idx == TEST_BUF_LEN )
   1208                    break;
   1209                  Delay_Nms(1000);
   \                     ??BSP_EEP_Main_4: (+1)
   \   00000050   0xF44F 0x707A      MOV      R0,#+1000
   \   00000054   0x.... 0x....      BL       Delay_Nms
   1210                  BSP_LED_Toggle(2);
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x.... 0x....      BL       BSP_LED_Toggle
   \                     ??BSP_EEP_Main_3: (+1)
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       __aeabi_memset4
   \   00000068   0x462A             MOV      R2,R5
   \   0000006A   0x4631             MOV      R1,R6
   \   0000006C   0x2064             MOVS     R0,#+100
   \   0000006E   0x.... 0x....      BL       BSP_EEP_ReadBytes
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF8C4 0x0800      STR      R0,[R4, #+2048]
   \   00000078   0xE002             B.N      ??BSP_EEP_Main_5
   \                     ??BSP_EEP_Main_6: (+1)
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0xF8C4 0x0800      STR      R0,[R4, #+2048]
   \                     ??BSP_EEP_Main_5: (+1)
   \   00000080   0xF8D4 0x0800      LDR      R0,[R4, #+2048]
   \   00000084   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000088   0xD20A             BCS.N    ??BSP_EEP_Main_7
   \   0000008A   0x5D01             LDRB     R1,[R0, R4]
   \   0000008C   0x1902             ADDS     R2,R0,R4
   \   0000008E   0xF892 0x2400      LDRB     R2,[R2, #+1024]
   \   00000092   0x4291             CMP      R1,R2
   \   00000094   0xD0F1             BEQ.N    ??BSP_EEP_Main_6
   \   00000096   0x462A             MOV      R2,R5
   \   00000098   0x4621             MOV      R1,R4
   \   0000009A   0x2064             MOVS     R0,#+100
   \   0000009C   0x.... 0x....      BL       BSP_EEP_WriteBytes
   \                     ??BSP_EEP_Main_7: (+1)
   \   000000A0   0xF8D4 0x0800      LDR      R0,[R4, #+2048]
   \   000000A4   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000A8   0xD1D2             BNE.N    ??BSP_EEP_Main_4
   1211              }
   1212          }
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40010C10         DC32     0x40010c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     AT24CXX_SCL_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40010C08         DC32     0x40010c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     Bsp_EepSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     atBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x42 0x73          DC8 "Bsp EepSem"
   \              0x70 0x20    
   \              0x45 0x65    
   \              0x70 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   0000000B   0x00               DC8 0
   1213          /*******************************************************************************
   1214           *              end of file                                                    *
   1215           *******************************************************************************/
   1216          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AT24CXX_Enabled
         8   -> I2C_SendByte
         8   -> I2C_Start
      16   AT24CXX_Init
        16   -> Delay_Nus
        16   -> I2C_Start
         0   -> I2C_Stop
      16   BSP_EEP_Init
        16   -> AT24CXX_Init
        16   -> BSP_EEP_ReadByte
        16   -> BSP_I2CSetPort
        16   -> BSP_OS_SemCreate
        16   -> GPIO_Init
        16   -> RCC_APB2PeriphClockCmd
      16   BSP_EEP_Main
        16   -> BSP_EEP_Init
        16   -> BSP_EEP_ReadBytes
        16   -> BSP_EEP_WriteBytes
        16   -> BSP_LED_Toggle
        16   -> Delay_Nms
        16   -> __aeabi_memset4
      16   BSP_EEP_ReadByte
        16   -> BSP_EEP_SetAddr
        16   -> EEP_SendEvent
        16   -> EEP_WaitEvent
        16   -> I2C_RecvByte
        16   -> I2C_Start
        16   -> I2C_Stop
      24   BSP_EEP_ReadBytes
        24   -> AT24CXX_Enabled
        24   -> BSP_EEP_SetAddr
        24   -> BSP_OS_TimeDly
        24   -> EEP_SendEvent
        24   -> EEP_WaitEvent
        24   -> I2C_RecvByte
        24   -> I2C_Start
        24   -> I2C_Stop
      16   BSP_EEP_ReadINT16U
        16   -> BSP_EEP_ReadByte
        16   -> __aeabi_memset4
      16   BSP_EEP_ReadINT32U
        16   -> BSP_EEP_ReadByte
        16   -> __aeabi_memset4
      24   BSP_EEP_ReadPage
        24   -> AT24CXX_Enabled
        24   -> BSP_EEP_SetAddr
        24   -> BSP_OS_TimeDly
        24   -> I2C_RecvByte
        24   -> I2C_Start
        24   -> I2C_Stop
      16   BSP_EEP_SetAddr
         0   -> I2C_SendByte
        16   -> I2C_SendByte
        16   -> I2C_Start
      16   BSP_EEP_WriteByte
        16   -> BSP_EEP_SetAddr
        16   -> EEP_SendEvent
        16   -> EEP_WaitEvent
        16   -> I2C_SendByte
        16   -> I2C_Start
        16   -> I2C_Stop
      24   BSP_EEP_WriteByteChk
        24   -> BSP_EEP_ReadByte
        24   -> BSP_EEP_WriteByte
        24   -> BSP_OS_TimeDly
      40   BSP_EEP_WriteBytes
        40   -> BSP_EEP_ReadPage
        40   -> BSP_EEP_WritePage
        40   -> EEP_SendEvent
        40   -> EEP_WaitEvent
        40   -> __aeabi_memcpy
      24   BSP_EEP_WriteINT16U
        24   -> BSP_EEP_WriteByteChk
      24   BSP_EEP_WriteINT32U
        24   -> BSP_EEP_WriteByteChk
      24   BSP_EEP_WritePage
        24   -> AT24CXX_Enabled
        24   -> BSP_EEP_SetAddr
        24   -> BSP_OS_TimeDly
        24   -> I2C_SendByte
        24   -> I2C_Start
        24   -> I2C_Stop
       0   BSP_I2CSetPort
       0   EEP_SendEvent
         0   -> BSP_OS_SemPost
       0   EEP_WaitEvent
         0   -> BSP_OS_SemWait
      32   I2C_RecvByte
        32   -> Delay_Nus
      24   I2C_SendByte
        24   -> Delay_Nus
      16   I2C_Start
         0   -> Delay_Nus
        16   -> Delay_Nus
      16   I2C_Stop
         0   -> Delay_Nus
        16   -> Delay_Nus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
      12  ?_0
      30  AT24CXX_Enabled
      70  AT24CXX_Init
       8  AT24CXX_SCL_PIN
          AT24CXX_SDA_PIN
      98  BSP_EEP_Init
     172  BSP_EEP_Main
      48  BSP_EEP_ReadByte
     120  BSP_EEP_ReadBytes
      62  BSP_EEP_ReadINT16U
      62  BSP_EEP_ReadINT32U
     118  BSP_EEP_ReadPage
      58  BSP_EEP_SetAddr
      46  BSP_EEP_WriteByte
      72  BSP_EEP_WriteByteChk
     196  BSP_EEP_WriteBytes
      50  BSP_EEP_WriteINT16U
      52  BSP_EEP_WriteINT32U
      76  BSP_EEP_WritePage
      30  BSP_I2CSetPort
      28  Bsp_EepSem
       8  EEP_SendEvent
      10  EEP_WaitEvent
     148  I2C_RecvByte
     144  I2C_SendByte
      54  I2C_Start
      54  I2C_Stop
    2052  atBuf
          chkBuf
          idx
      32  buf

 
 2 112 bytes in section .bss
     8 bytes in section .data
 1 818 bytes in section .text
 
 1 818 bytes of CODE memory
 2 120 bytes of DATA memory

Errors: none
Warnings: none
