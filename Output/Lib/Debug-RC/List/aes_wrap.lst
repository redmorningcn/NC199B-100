###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:21:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\APP\AES\aes_wrap.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\AES\aes_wrap.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\aes_wrap.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\aes_wrap.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\AES\aes_wrap.c
      1          /** crypto/aes/aes_wrap.c */
      2          /** Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
      3           * project.
      4           */
      5          /** ====================================================================
      6           * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions
     10           * are met:
     11           *
     12           * 1. Redistributions of source code must retain the above copyright
     13           *    notice, this list of conditions and the following disclaimer. 
     14           *
     15           * 2. Redistributions in binary form must reproduce the above copyright
     16           *    notice, this list of conditions and the following disclaimer in
     17           *    the documentation and/or other materials provided with the
     18           *    distribution.
     19           *
     20           * 3. All advertising materials mentioning features or use of this
     21           *    software must display the following acknowledgment:
     22           *    "This product includes software developed by the OpenSSL Project
     23           *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
     24           *
     25           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     26           *    endorse or promote products derived from this software without
     27           *    prior written permission. For written permission, please contact
     28           *    licensing@OpenSSL.org.
     29           *
     30           * 5. Products derived from this software may not be called "OpenSSL"
     31           *    nor may "OpenSSL" appear in their names without prior written
     32           *    permission of the OpenSSL Project.
     33           *
     34           * 6. Redistributions of any form whatsoever must retain the following
     35           *    acknowledgment:
     36           *    "This product includes software developed by the OpenSSL Project
     37           *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
     38           *
     39           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     40           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     41           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     42           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     43           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     44           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     45           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     46           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     47           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     48           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     49           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     50           * OF THE POSSIBILITY OF SUCH DAMAGE.
     51           * ====================================================================
     52           */
     53          
     54          #include <aes.h>
     55          

   \                                 In section .text, align 4, keep-with-next
     56          static const unsigned char default_iv[] = {
   \                     default_iv:
   \   00000000   0xA6 0xA6          DC8 166, 166, 166, 166, 166, 166, 166, 166
   \              0xA6 0xA6    
   \              0xA6 0xA6    
   \              0xA6 0xA6    
     57            0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6,
     58          };
     59          

   \                                 In section .text, align 2, keep-with-next
     60          int AES_wrap_key(AES_KEY *key, 
     61                           const unsigned char *iv,
     62                           unsigned char *out,
     63                           const unsigned char *in, 
     64                           unsigned int inlen)
     65          {
   \                     AES_wrap_key: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x9E0C             LDR      R6,[SP, #+48]
     66          	unsigned char *A, B[16], *R;
     67          	unsigned int i, j, t;
     68          	if ((inlen & 0x7) || (inlen < 8))
   \   0000000E   0xF016 0x0F07      TST      R6,#0x7
   \   00000012   0xD101             BNE.N    ??AES_wrap_key_0
   \   00000014   0x2E08             CMP      R6,#+8
   \   00000016   0xD202             BCS.N    ??AES_wrap_key_1
     69          		return -1;
   \                     ??AES_wrap_key_0: (+1)
   \   00000018   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001C   0xE03D             B.N      ??AES_wrap_key_2
     70          	A = B;
     71          	t = 1;
   \                     ??AES_wrap_key_1: (+1)
   \   0000001E   0x2701             MOVS     R7,#+1
     72          	memcpy(out + 8, in, inlen);
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0xF105 0x0008      ADD      R0,R5,#+8
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy
     73          	if (!iv)
   \   0000002A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002E   0xD101             BNE.N    ??AES_wrap_key_3
     74          		iv = default_iv;
   \   00000030   0x.... 0x....      ADR.W    R8,default_iv
     75          
     76          	memcpy(A, iv, 8);
   \                     ??AES_wrap_key_3: (+1)
   \   00000034   0x2208             MOVS     R2,#+8
   \   00000036   0x4641             MOV      R1,R8
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x.... 0x....      BL       __aeabi_memcpy
     77          
     78          	for (j = 0; j < 6; j++)
   \   0000003E   0xF04F 0x0800      MOV      R8,#+0
   \   00000042   0xE01B             B.N      ??AES_wrap_key_4
     79          		{
     80          		R = out + 8;
     81          		for (i = 0; i < inlen; i += 8, t++, R += 8)
     82          			{
     83          			memcpy(B + 8, R, 8);
   \                     ??AES_wrap_key_5: (+1)
   \   00000044   0x2208             MOVS     R2,#+8
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0xA802             ADD      R0,SP,#+8
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy
     84          			AES_encrypt(B, B, key);
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       AES_encrypt
     85          			A[7] ^= (unsigned char)(t & 0xff);
   \   00000058   0x4668             MOV      R0,SP
   \   0000005A   0x79C1             LDRB     R1,[R0, #+7]
   \   0000005C   0x4079             EORS     R1,R7,R1
   \   0000005E   0x71C1             STRB     R1,[R0, #+7]
     86          			if (t > 0xff)	
     87          				{
     88          				A[6] ^= (unsigned char)((t & 0xff) >> 8);
     89          				A[5] ^= (unsigned char)((t & 0xff) >> 16);
     90          				A[4] ^= (unsigned char)((t & 0xff) >> 24);
     91          				}
     92          			memcpy(R, B + 8, 8);
   \   00000060   0x2208             MOVS     R2,#+8
   \   00000062   0xA902             ADD      R1,SP,#+8
   \   00000064   0x4648             MOV      R0,R9
   \   00000066   0x.... 0x....      BL       __aeabi_memcpy
     93          			}
   \   0000006A   0xF10A 0x0A08      ADD      R10,R10,#+8
   \   0000006E   0x1C7F             ADDS     R7,R7,#+1
   \   00000070   0xF109 0x0908      ADD      R9,R9,#+8
   \                     ??AES_wrap_key_6: (+1)
   \   00000074   0x45B2             CMP      R10,R6
   \   00000076   0xD3E5             BCC.N    ??AES_wrap_key_5
   \   00000078   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??AES_wrap_key_4: (+1)
   \   0000007C   0xF1B8 0x0F06      CMP      R8,#+6
   \   00000080   0xD204             BCS.N    ??AES_wrap_key_7
   \   00000082   0xF105 0x0908      ADD      R9,R5,#+8
   \   00000086   0xF04F 0x0A00      MOV      R10,#+0
   \   0000008A   0xE7F3             B.N      ??AES_wrap_key_6
     94          		}
     95          	memcpy(out, A, 8);
   \                     ??AES_wrap_key_7: (+1)
   \   0000008C   0x2208             MOVS     R2,#+8
   \   0000008E   0x4669             MOV      R1,SP
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0x.... 0x....      BL       __aeabi_memcpy
     96          	return inlen + 8;
   \   00000096   0xF106 0x0008      ADD      R0,R6,#+8
   \                     ??AES_wrap_key_2: (+1)
   \   0000009A   0xB004             ADD      SP,SP,#+16
   \   0000009C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
     97          	}
     98          

   \                                 In section .text, align 2, keep-with-next
     99          int AES_unwrap_key(AES_KEY *key, 
    100                             const unsigned char *iv,
    101                             unsigned char *out,
    102                             const unsigned char *in, 
    103                             unsigned int inlen)
    104          {
   \                     AES_unwrap_key: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x4699             MOV      R9,R3
    105          	unsigned char *A, B[16], *R;
    106          	unsigned int i, j, t;
    107          	inlen -= 8;
   \   0000000E   0x980E             LDR      R0,[SP, #+56]
   \   00000010   0xF1A0 0x0708      SUB      R7,R0,#+8
    108          	if (inlen & 0x7)
   \   00000014   0xF017 0x0F07      TST      R7,#0x7
   \   00000018   0xD101             BNE.N    ??AES_unwrap_key_0
    109          		return -1;
    110          	if (inlen < 8)
   \   0000001A   0x2F08             CMP      R7,#+8
   \   0000001C   0xD202             BCS.N    ??AES_unwrap_key_1
    111          		return -1;
   \                     ??AES_unwrap_key_0: (+1)
   \   0000001E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000022   0xE047             B.N      ??AES_unwrap_key_2
    112          	A = B;
    113          	t =  6 * (inlen >> 3);
   \                     ??AES_unwrap_key_1: (+1)
   \   00000024   0x08F8             LSRS     R0,R7,#+3
   \   00000026   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000002A   0xEA4F 0x0841      LSL      R8,R1,#+1
    114          	memcpy(A, in, 8);
   \   0000002E   0x2208             MOVS     R2,#+8
   \   00000030   0x4649             MOV      R1,R9
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy
    115          	memcpy(out, in + 8, inlen);
   \   00000038   0x463A             MOV      R2,R7
   \   0000003A   0xF109 0x0108      ADD      R1,R9,#+8
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy
    116          	for (j = 0; j < 6; j++)
   \   00000044   0xF04F 0x0900      MOV      R9,#+0
   \   00000048   0xE01D             B.N      ??AES_unwrap_key_3
    117          		{
    118          		R = out + inlen - 8;
    119          		for (i = 0; i < inlen; i += 8, t--, R -= 8)
    120          			{
    121          			A[7] ^= (unsigned char)(t & 0xff);
   \                     ??AES_unwrap_key_4: (+1)
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x79C1             LDRB     R1,[R0, #+7]
   \   0000004E   0xEA88 0x0101      EOR      R1,R8,R1
   \   00000052   0x71C1             STRB     R1,[R0, #+7]
    122          			if (t > 0xff)	
    123          				{
    124          				A[6] ^= (unsigned char)((t & 0xff) >> 8);
    125          				A[5] ^= (unsigned char)((t & 0xff) >> 16);
    126          				A[4] ^= (unsigned char)((t & 0xff) >> 24);
    127          				}
    128          			memcpy(B + 8, R, 8);
   \   00000054   0x2208             MOVS     R2,#+8
   \   00000056   0x4651             MOV      R1,R10
   \   00000058   0xA802             ADD      R0,SP,#+8
   \   0000005A   0x.... 0x....      BL       __aeabi_memcpy
    129          			AES_decrypt(B, B, key);
   \   0000005E   0x4622             MOV      R2,R4
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x.... 0x....      BL       AES_decrypt
    130          			memcpy(R, B + 8, 8);
   \   00000068   0x2208             MOVS     R2,#+8
   \   0000006A   0xA902             ADD      R1,SP,#+8
   \   0000006C   0x4650             MOV      R0,R10
   \   0000006E   0x.... 0x....      BL       __aeabi_memcpy
    131          			}
   \   00000072   0xF10B 0x0B08      ADD      R11,R11,#+8
   \   00000076   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   0000007A   0xF1AA 0x0A08      SUB      R10,R10,#+8
   \                     ??AES_unwrap_key_5: (+1)
   \   0000007E   0x45BB             CMP      R11,R7
   \   00000080   0xD3E3             BCC.N    ??AES_unwrap_key_4
   \   00000082   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??AES_unwrap_key_3: (+1)
   \   00000086   0xF1B9 0x0F06      CMP      R9,#+6
   \   0000008A   0xD205             BCS.N    ??AES_unwrap_key_6
   \   0000008C   0x19B8             ADDS     R0,R7,R6
   \   0000008E   0xF1A0 0x0A08      SUB      R10,R0,#+8
   \   00000092   0xF04F 0x0B00      MOV      R11,#+0
   \   00000096   0xE7F2             B.N      ??AES_unwrap_key_5
    132          		}
    133          	if (!iv)
   \                     ??AES_unwrap_key_6: (+1)
   \   00000098   0x2D00             CMP      R5,#+0
   \   0000009A   0xD101             BNE.N    ??AES_unwrap_key_7
    134          		iv = default_iv;
   \   0000009C   0x.... 0x....      ADR.W    R5,default_iv
    135          	if (memcmp(A, iv, 8))
   \                     ??AES_unwrap_key_7: (+1)
   \   000000A0   0x2208             MOVS     R2,#+8
   \   000000A2   0x4629             MOV      R1,R5
   \   000000A4   0x4668             MOV      R0,SP
   \   000000A6   0x.... 0x....      BL       memcmp
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??AES_unwrap_key_8
    136          		{
    137          		OPENSSL_cleanse(out, inlen);
    138          		return 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xE000             B.N      ??AES_unwrap_key_2
    139          		}
    140          	return inlen;
   \                     ??AES_unwrap_key_8: (+1)
   \   000000B2   0x4638             MOV      R0,R7
   \                     ??AES_unwrap_key_2: (+1)
   \   000000B4   0xB005             ADD      SP,SP,#+20
   \   000000B6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    141          	}
    142          
    143          #ifdef AES_WRAP_TEST
    144          
    145          int AES_wrap_unwrap_test(const unsigned char *kek, 
    146                                   int keybits,
    147                                   const unsigned char *iv,
    148                                   const unsigned char *eout,
    149                                   const unsigned char *key, 
    150                                   int keylen)
    151          {
    152          	unsigned char *otmp = NULL, *ptmp = NULL;
    153          	int r, ret = 0;
    154          	AES_KEY wctx;
    155          	otmp = OPENSSL_malloc(keylen + 8);
    156          	ptmp = OPENSSL_malloc(keylen);
    157          	if (!otmp || !ptmp)
    158          		return 0;
    159          	if (AES_set_encrypt_key(kek, keybits, &wctx))
    160          		goto err;
    161          	r = AES_wrap_key(&wctx, iv, otmp, key, keylen);
    162          	if (r <= 0)
    163          		goto err;
    164          
    165          	if (eout && memcmp(eout, otmp, keylen))
    166          		goto err;
    167          		
    168          	if (AES_set_decrypt_key(kek, keybits, &wctx))
    169          		goto err;
    170          	r = AES_unwrap_key(&wctx, iv, ptmp, otmp, r);
    171          
    172          	if (memcmp(key, ptmp, keylen))
    173          		goto err;
    174          
    175          	ret = 1;
    176          
    177          	err:
    178          	if (otmp)
    179          		OPENSSL_free(otmp);
    180          	if (ptmp)
    181          		OPENSSL_free(ptmp);
    182          
    183          	return ret;
    184          
    185          	}
    186          
    187          
    188          
    189          int main(int argc, char **argv)
    190          {
    191          
    192          static const unsigned char kek[] = {
    193            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    194            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    195            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    196            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    197          };
    198          
    199          static const unsigned char key[] = {
    200            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    201            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    202            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    203            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    204          };
    205          
    206          static const unsigned char e1[] = {
    207            0x1f, 0xa6, 0x8b, 0x0a, 0x81, 0x12, 0xb4, 0x47,
    208            0xae, 0xf3, 0x4b, 0xd8, 0xfb, 0x5a, 0x7b, 0x82,
    209            0x9d, 0x3e, 0x86, 0x23, 0x71, 0xd2, 0xcf, 0xe5
    210          };
    211          
    212          static const unsigned char e2[] = {
    213            0x96, 0x77, 0x8b, 0x25, 0xae, 0x6c, 0xa4, 0x35,
    214            0xf9, 0x2b, 0x5b, 0x97, 0xc0, 0x50, 0xae, 0xd2,
    215            0x46, 0x8a, 0xb8, 0xa1, 0x7a, 0xd8, 0x4e, 0x5d
    216          };
    217          
    218          static const unsigned char e3[] = {
    219            0x64, 0xe8, 0xc3, 0xf9, 0xce, 0x0f, 0x5b, 0xa2,
    220            0x63, 0xe9, 0x77, 0x79, 0x05, 0x81, 0x8a, 0x2a,
    221            0x93, 0xc8, 0x19, 0x1e, 0x7d, 0x6e, 0x8a, 0xe7
    222          };
    223          
    224          static const unsigned char e4[] = {
    225            0x03, 0x1d, 0x33, 0x26, 0x4e, 0x15, 0xd3, 0x32,
    226            0x68, 0xf2, 0x4e, 0xc2, 0x60, 0x74, 0x3e, 0xdc,
    227            0xe1, 0xc6, 0xc7, 0xdd, 0xee, 0x72, 0x5a, 0x93,
    228            0x6b, 0xa8, 0x14, 0x91, 0x5c, 0x67, 0x62, 0xd2
    229          };
    230          
    231          static const unsigned char e5[] = {
    232            0xa8, 0xf9, 0xbc, 0x16, 0x12, 0xc6, 0x8b, 0x3f,
    233            0xf6, 0xe6, 0xf4, 0xfb, 0xe3, 0x0e, 0x71, 0xe4,
    234            0x76, 0x9c, 0x8b, 0x80, 0xa3, 0x2c, 0xb8, 0x95,
    235            0x8c, 0xd5, 0xd1, 0x7d, 0x6b, 0x25, 0x4d, 0xa1
    236          };
    237          
    238          static const unsigned char e6[] = {
    239            0x28, 0xc9, 0xf4, 0x04, 0xc4, 0xb8, 0x10, 0xf4,
    240            0xcb, 0xcc, 0xb3, 0x5c, 0xfb, 0x87, 0xf8, 0x26,
    241            0x3f, 0x57, 0x86, 0xe2, 0xd8, 0x0e, 0xd3, 0x26,
    242            0xcb, 0xc7, 0xf0, 0xe7, 0x1a, 0x99, 0xf4, 0x3b,
    243            0xfb, 0x98, 0x8b, 0x9b, 0x7a, 0x02, 0xdd, 0x21
    244          };
    245          
    246          	AES_KEY wctx, xctx;
    247          	int ret;
    248          	ret = AES_wrap_unwrap_test(kek, 128, NULL, e1, key, 16);
    249          	fprintf(stderr, "Key test result %d\n", ret);
    250          	ret = AES_wrap_unwrap_test(kek, 192, NULL, e2, key, 16);
    251          	fprintf(stderr, "Key test result %d\n", ret);
    252          	ret = AES_wrap_unwrap_test(kek, 256, NULL, e3, key, 16);
    253          	fprintf(stderr, "Key test result %d\n", ret);
    254          	ret = AES_wrap_unwrap_test(kek, 192, NULL, e4, key, 24);
    255          	fprintf(stderr, "Key test result %d\n", ret);
    256          	ret = AES_wrap_unwrap_test(kek, 256, NULL, e5, key, 24);
    257          	fprintf(stderr, "Key test result %d\n", ret);
    258          	ret = AES_wrap_unwrap_test(kek, 256, NULL, e6, key, 32);
    259          	fprintf(stderr, "Key test result %d\n", ret);
    260          }
    261          	
    262          	
    263          #endif
    264          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   AES_unwrap_key
        56   -> AES_decrypt
        56   -> __aeabi_memcpy
        56   -> memcmp
      48   AES_wrap_key
        48   -> AES_encrypt
        48   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     186  AES_unwrap_key
     160  AES_wrap_key
       8  default_iv

 
 354 bytes in section .text
 
 354 bytes of CODE memory

Errors: none
Warnings: none
