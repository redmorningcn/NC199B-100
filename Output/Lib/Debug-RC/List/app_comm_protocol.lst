###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Nov/2017  10:06:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\APP\Protocol\app_comm_protocol.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\Protocol\app_comm_protocol.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\app_comm_protocol.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\app_comm_protocol.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\Protocol\app_comm_protocol.c
      1          /*******************************************************************************
      2           *   Filename:       app_lib.c
      3           *   Revised:        All copyrights reserved to Wuming Shen.
      4           *   Date:           2014-07-05
      5           *   Revision:       v1.0
      6           *   Writer:	     Wuming Shen.
      7           *
      8           *   Description:    双击选中 wdt 按 Ctrl + H, 钩选 Match the case, Replace with
      9           *                   输入您要的名字，点击 Replace All
     10           *                   双击选中 Wdt 按 Ctrl + H, 钩选 Match the case, Replace with
     11           *                   输入您要的名字，点击 Replace All
     12           *                   双击选中 WDT 按 Ctrl + H, 钩选 Match the case, Replace with
     13           *                   输入您要的名字，点击 Replace All
     14           *                   在 app_cfg.h 中指定任务的优先级 和 任务堆栈大小
     15           *
     16           *   Notes:
     17           *					QQ:276193028
     18           *     				E-mail:shenchangwei945@163.com
     19           *
     20           *******************************************************************************/
     21          
     22          /*******************************************************************************
     23           * INCLUDES
     24           */
     25          #define  SNL_APP_SOURCE
     26          #include <app.h>
     27          #include <app_chk.h>
     28          #include <bsp_usart.h>
     29          
     30          #define BSP_COMM_PROTOCOL_MODULE_EN 1
     31          #if BSP_COMM_PROTOCOL_MODULE_EN > 0
     32          
     33          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     34          const  CPU_CHAR  *app_comm_protocol__c = "$Id: $";
     35          #endif
     36          
     37          /*******************************************************************************
     38           * CONSTANTS
     39           */
     40          
     41          /*******************************************************************************
     42           * MACROS
     43           */
     44          
     45          /*******************************************************************************
     46           * TYPEDEFS
     47           */
     48               
     49          /*******************************************************************************
     50           * LOCAL VARIABLES
     51           */
     52          
     53          /*******************************************************************************
     54           * GLOBAL VARIABLES
     55           */
     56          
     57          /*******************************************************************************
     58           * LOCAL FUNCTIONS
     59           */
     60          
     61          /*******************************************************************************
     62           * GLOBAL FUNCTIONS
     63           */
     64          
     65          /*******************************************************************************
     66           * EXTERN VARIABLES
     67           */
     68          
     69          /*******************************************************************************
     70           * EXTERN FUNCTIONS
     71           */
     72           

   \                                 In section .bss, align 1
     73          unsigned char   l_recslaveaddr = 0;
   \                     l_recslaveaddr:
   \   00000000                      DS8 1
     74          
     75          /***********************************************
     76          * 描述： 
     77          */

   \                                 In section .text, align 2, keep-with-next
     78          unsigned char GetRecSlaveAddr(void)
     79          {
     80          	return	l_recslaveaddr;
   \                     GetRecSlaveAddr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     81          }
     82          

   \                                 In section .bss, align 1
     83          static INT08U	RecvFrameNbr = 0;
   \                     RecvFrameNbr:
   \   00000000                      DS8 1
     84          /***********************************************
     85          * 描述： 
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          INT08U	GetRecvFrameNbr(void)
     88          {
     89          	return 	RecvFrameNbr;
   \                     GetRecvFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     90          }
     91          
     92          
     93          /***********************************************
     94          * 描述： 
     95          */

   \                                 In section .text, align 2, keep-with-next
     96          void	SetRecvFrameNbr(void)
     97          {
     98          	RecvFrameNbr++;		
   \                     SetRecvFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_1
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
     99          }
   \   00000008   0x4770             BX       LR               ;; return
    100          
    101          /*******************************************************************************
    102          * 名    称： CSNC_GetData
    103          * 功    能： 
    104          * 入口参数： 无
    105          * 出口参数： 无
    106          * 作　 　者： wumingshen.
    107          * 创建日期： 2015-12-07
    108          * 修    改：
    109          * 修改日期：
    110          * 备    注：
    111          *******************************************************************************/
    112          //unsigned char  CSNC_GetData(	INT08U *RecvBuf,
    113          //								INT16U	RecLen,
    114          //								INT08U *DataBuf,
    115          //								INT16U *InfoLen)

   \                                 In section .text, align 2, keep-with-next
    116          unsigned char  CSNC_GetData(	INT08U *RecvBuf,
    117          								INT16U	RecvLen,
    118                                          StrNcProtocol   *pack)
    119          {
   \                     CSNC_GetData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
    120              unsigned short		j,k;
    121              unsigned char		SumCheck8;
    122              unsigned char		Tmp;
    123              unsigned short		RecCRC16,Check16;
    124          		
    125          	unsigned short		DataLen          = pack->Len;
    126              unsigned char     *pDat             = RecvBuf;    
    127              unsigned short    MaxDataLen        = RecvLen - 2;
   \   00000008   0x1E88             SUBS     R0,R1,#+2
    128              
    129              //pack->Len            = 0;
    130              /***********************************************
    131              * 描述： 识别帧头
    132              */
    133          //    for(i = 0; i < MaxDataLen; i++)	{		        //循环遍历
    134          //		if(	( (pack->Data[i + 0] ) == FRAM_HERD0 ) && 
    135          //            ( (pack->Data[i + 1] ) == FRAM_HERD1 ) ) {
    136          //            pDat    = &pack->Data[i];
    137          //            goto next;
    138          //        }
    139          //    }
    140          //    return 0;
    141              /***********************************************
    142              * 描述： 接收数据去掉帧头识别字0X10的重复部分
    143              */
    144          	for(j = 0;j < RecvLen ;j++ )	{				    //去重复通讯首字节
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xE007             B.N      ??CSNC_GetData_0
    145                  if( ( pDat[j]   == FRAM_HERD0 ) &&
    146                      ( pDat[j+1] == FRAM_HERD0 ) ) {
    147                      for(k = j; k < RecvLen; k++) {
    148                         Tmp	        = pDat[k+1];
    149                         pDat[k]      = Tmp;
   \                     ??CSNC_GetData_1: (+1)
   \   0000000E   0x191F             ADDS     R7,R3,R4
   \   00000010   0x787F             LDRB     R7,[R7, #+1]
   \   00000012   0x551F             STRB     R7,[R3, R4]
    150                      }
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0xB29B             UXTH     R3,R3
   \                     ??CSNC_GetData_2: (+1)
   \   00000018   0x428B             CMP      R3,R1
   \   0000001A   0xDBF8             BLT.N    ??CSNC_GetData_1
   \                     ??CSNC_GetData_3: (+1)
   \   0000001C   0x1C52             ADDS     R2,R2,#+1
   \                     ??CSNC_GetData_0: (+1)
   \   0000001E   0xB292             UXTH     R2,R2
   \   00000020   0x428A             CMP      R2,R1
   \   00000022   0xD209             BCS.N    ??CSNC_GetData_4
   \   00000024   0x4613             MOV      R3,R2
   \   00000026   0x5D1F             LDRB     R7,[R3, R4]
   \   00000028   0x2F10             CMP      R7,#+16
   \   0000002A   0xD1F7             BNE.N    ??CSNC_GetData_3
   \   0000002C   0x191B             ADDS     R3,R3,R4
   \   0000002E   0x785B             LDRB     R3,[R3, #+1]
   \   00000030   0x2B10             CMP      R3,#+16
   \   00000032   0xD1F3             BNE.N    ??CSNC_GetData_3
   \   00000034   0x4613             MOV      R3,R2
   \   00000036   0xE7EF             B.N      ??CSNC_GetData_2
    151                  }
    152          	}
    153              pDat    += 6;
    154              DataLen  = *pDat;
   \                     ??CSNC_GetData_4: (+1)
   \   00000038   0x79A7             LDRB     R7,[R4, #+6]
    155              // 长度超范围
    156              if ( DataLen > MaxDataLen )
   \   0000003A   0xB280             UXTH     R0,R0
   \   0000003C   0x42B8             CMP      R0,R7
   \   0000003E   0xDB2C             BLT.N    ??CSNC_GetData_5
    157                  return 0;
    158              
    159              pDat    += DataLen + 4;
    160              /***********************************************
    161              * 描述： 检查帧尾
    162              */
    163          //    if( ( pDat[0] 	!= FRAM_END0)	||
    164          //        ( pDat[1] 	!= FRAM_END1) ) {
    165          //        return 0;
    166          //    }
    167              pDat            = RecvBuf;
    168              SumCheck8 		= GetCheckSumNR((unsigned char *)&pDat[2],5);	//索引区校验
   \   00000040   0x2105             MOVS     R1,#+5
   \   00000042   0x1CA0             ADDS     R0,R4,#+2
   \   00000044   0x.... 0x....      BL       GetCheckSumNR
   \   00000048   0x4680             MOV      R8,R0
    169              RecCRC16 		= ((unsigned short)pDat[8+DataLen])
    170                              * 256 + pDat[9+DataLen];	        //校验	
   \   0000004A   0x1938             ADDS     R0,R7,R4
   \   0000004C   0x7A01             LDRB     R1,[R0, #+8]
   \   0000004E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000050   0xEB00 0x2901      ADD      R9,R0,R1, LSL #+8
    171                         
    172              switch((pDat[5]>>4) & 0x03) {							    //校验和算法判断
   \   00000054   0x7960             LDRB     R0,[R4, #+5]
   \   00000056   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD105             BNE.N    ??CSNC_GetData_6
    173              case	RS485_CHK_SUM:
    174                  break;
    175              case	RS485_CHK_CRC:
    176                 Check16 = GetCrc16Chk1(&pDat[2],6+DataLen);
   \   0000005E   0x1DB9             ADDS     R1,R7,#+6
   \   00000060   0xB289             UXTH     R1,R1
   \   00000062   0x1CA0             ADDS     R0,R4,#+2
   \   00000064   0x.... 0x....      BL       GetCrc16Chk1
   \   00000068   0x4606             MOV      R6,R0
    177                  break;
    178              case	RS485_CHK_RESUM:
    179                  break;
    180              }
    181              
    182              if(	(SumCheck8 == 	pDat[7] ) && 
    183                  (RecCRC16  ==	Check16 ) ) {
   \                     ??CSNC_GetData_6: (+1)
   \   0000006A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000006C   0x4580             CMP      R8,R0
   \   0000006E   0xD114             BNE.N    ??CSNC_GetData_5
   \   00000070   0xFA1F 0xF989      UXTH     R9,R9
   \   00000074   0xB2B6             UXTH     R6,R6
   \   00000076   0x45B1             CMP      R9,R6
   \   00000078   0xD10F             BNE.N    ??CSNC_GetData_5
    184                  /***********************************************
    185                  * 描述： 获取帧头
    186                  */
    187                  pack->SrcAddr 	= pDat[2];
   \   0000007A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000007C   0x7028             STRB     R0,[R5, #+0]
    188                  pack->DstAddr   = pDat[3];
   \   0000007E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000080   0x7068             STRB     R0,[R5, #+1]
    189                  pack->RecvSn   	= pDat[4];
   \   00000082   0x7920             LDRB     R0,[R4, #+4]
   \   00000084   0x70E8             STRB     R0,[R5, #+3]
    190                  pack->Pack.Dat 	= pDat[5];
   \   00000086   0x7960             LDRB     R0,[R4, #+5]
   \   00000088   0x7128             STRB     R0,[R5, #+4]
    191                  pack->Len 		= pDat[6]; 
   \   0000008A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000008C   0x7168             STRB     R0,[R5, #+5]
    192                  pack->Data      =&pDat[8];
   \   0000008E   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000092   0xF8C5 0x0006      STR      R0,[R5, #+6]
    193                  return		pack->DstAddr;
   \   00000096   0x7868             LDRB     R0,[R5, #+1]
   \   00000098   0xE000             B.N      ??CSNC_GetData_7
    194              }
    195                         
    196              return	0;
   \                     ??CSNC_GetData_5: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \                     ??CSNC_GetData_7: (+1)
   \   0000009C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    197          }
    198          

   \                                 In section .bss, align 1
    199          static INT08U	SendFrameNbr = 0;
   \                     SendFrameNbr:
   \   00000000                      DS8 1
    200          
    201          /***********************************************
    202          * 描述： 
    203          */

   \                                 In section .text, align 2, keep-with-next
    204          INT08U	GetSendFrameNbr(void)
    205          {
    206          	return SendFrameNbr;		
   \                     GetSendFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    207          }
    208          
    209          /***********************************************
    210          * 描述： 
    211          */

   \                                 In section .text, align 2, keep-with-next
    212          void	SetSendFrameNbr(void)
    213          {
    214          	SendFrameNbr++;		
   \                     SetSendFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_2
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    215          }
   \   00000008   0x4770             BX       LR               ;; return
    216          
    217          /*******************************************************************************
    218          * 名    称： CSNC_SendData
    219          * 功    能： 
    220          * 入口参数： 无
    221          * 出口参数： 无
    222          * 作  　者： wumingshen.
    223          * 创建日期： 2015-12-07
    224          * 修    改：
    225          * 修改日期：
    226          * 备    注：
    227          *******************************************************************************/
    228          //void	CSNC_SendData(	MODBUS_CH *pch,
    229          //                        INT08U  SourceAddr,
    230          //						INT08U  DistAddr,
    231          //						INT08U *DataBuf,
    232          //						INT16U  DataLen)
    233          //void	CSNC_SendData(	MODBUS_CH       *pch,
    234          //                        StrNcProtocol   *pack)
    235          //{
    236          //	unsigned char	SndBuf[250] = {0};
    237          //	unsigned char	SndBufTmp[250] = {0};
    238          //	unsigned char	SumCheck8;
    239          //	unsigned short	Crc16;
    240          //	unsigned short	AddHeadNum;
    241          //	unsigned short	i;
    242          //	unsigned char	ByteStation;
    243          //    
    244          //	ByteStation = 0;
    245          //	SndBuf[ByteStation++] = FRAM_HERD0;
    246          //	SndBuf[ByteStation++] = FRAM_HERD1;
    247          //	SndBuf[ByteStation++] = pack->SrcAddr;  //SourceAddr;	 
    248          //	SndBuf[ByteStation++] = pack->DstAddr;  //DistAddr;				    // 地址
    249          //	SndBuf[ByteStation++] = pack->SendSn;       //SendFrameNbr;               // SendFrameNbr++;
    250          //	SndBuf[ByteStation++] = pack->Pack.Dat;//(RS485_CHK_CRC<<4) | (PROTOCOL_VER_HIG << 6) | (PROTOCOL_VER_LOW << 0);
    251          //	SndBuf[ByteStation++] = pack->Len;      //DataLen;
    252          //	
    253          //	SumCheck8 = GetCheckSumNR(&SndBuf[2],5);		   	// 索引区校验
    254          //
    255          //	SndBuf[ByteStation++] = SumCheck8;
    256          //
    257          //	//memcpy(&SndBuf[8],DataBuf,DataLen);
    258          //	memcpy(&SndBuf[8],pack->Data,pack->Len);
    259          //
    260          //	Crc16 = GetCrc16Chk1(&SndBuf[2],6+ pack->Len);
    261          //
    262          //	SndBuf[2+6+pack->Len+1] = Crc16;
    263          //	SndBuf[2+6+pack->Len]   = Crc16>>8;
    264          //
    265          //	SndBufTmp[0] = SndBuf[0];						    // 准备数据发送
    266          //	SndBufTmp[1] = SndBuf[1];
    267          //	
    268          //	AddHeadNum = 0;
    269          //	for(i = 2; i< 2+6+pack->Len + 2;i++ )	{				// 数据，补移位 FRAM_HERD0
    270          //		SndBufTmp[i+AddHeadNum] = SndBuf[i];
    271          //		
    272          //		if(SndBuf[i] == FRAM_HERD0) {
    273          //			SndBufTmp[i+AddHeadNum+1] = FRAM_HERD0;
    274          //			AddHeadNum++;
    275          //		}
    276          //	}
    277          //
    278          //	SndBufTmp[2+6+pack->Len + 2 +AddHeadNum] = FRAM_END0;
    279          //	SndBufTmp[2+6+pack->Len + 2 +AddHeadNum+1] = FRAM_END1;      
    280          //    
    281          //    CPU_INT16U nbr_bytes= (2+6+pack->Len + 2 +AddHeadNum +2);
    282          //    if ( nbr_bytes < MB_DATA_NBR_REGS * 2 ) {  
    283          //        NMB_Tx(pch,
    284          //               (CPU_INT08U  *)SndBufTmp,
    285          //               (CPU_INT16U   )nbr_bytes);
    286          //    }
    287          //}
    288          
    289          

   \                                 In section .bss, align 4
    290          static  unsigned char	SndBuf[250] = {0};
    291          static  unsigned char	SndBufTmp[250] = {0};
   \                     SndBufTmp:
   \   00000000                      DS8 252
   \   000000FC                      DS8 252
    292          /*******************************************************************************
    293          * 名    称： CSNC_SendData
    294          * 功    能： 
    295          * 入口参数： 无
    296          * 出口参数： 无
    297          * 作  　者： wumingshen.
    298          * 创建日期： 2015-12-07
    299          * 修    改：
    300          * 修改日期：
    301          * 备    注：
    302          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          void	CSNC_SendData(	MODBUS_CH *pch,
    304                                  INT08U  SourceAddr,
    305          						INT08U  DistAddr,
    306                                  INT08U  SendFrameNum,
    307          						INT08U  SendCode,                       
    308          						INT08U *DataBuf,
    309          						INT16U  DataLen)
    310          {
   \                     CSNC_SendData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
    311          	unsigned char	    SumCheck8;
    312          	unsigned short	Crc16;
    313          	unsigned short	AddHeadNum;
    314          	unsigned short	i;
    315          	unsigned char	    ByteStation;	
    316              
    317          	ByteStation = 0;
    318          	SndBuf[ByteStation++] = FRAM_HERD0;
   \   00000006   0x....             LDR.N    R6,??DataTable5_3
   \   00000008   0xF106 0x07FC      ADD      R7,R6,#+252
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x7038             STRB     R0,[R7, #+0]
    319          	SndBuf[ByteStation++] = FRAM_HERD1;
   \   00000010   0x2028             MOVS     R0,#+40
   \   00000012   0x7078             STRB     R0,[R7, #+1]
    320          	SndBuf[ByteStation++] = SourceAddr;	 
   \   00000014   0x70B9             STRB     R1,[R7, #+2]
    321          	SndBuf[ByteStation++] = DistAddr;				    // 地址
   \   00000016   0x70FA             STRB     R2,[R7, #+3]
    322          	SndBuf[ByteStation++] = SendFrameNum;               // 发送帧序号
   \   00000018   0x713B             STRB     R3,[R7, #+4]
    323          
    324          	SndBuf[ByteStation++] =  ( RS485_CHK_CRC<<4 )+ SendCode;// 发送控制字	
   \   0000001A   0x9806             LDR      R0,[SP, #+24]
   \   0000001C   0x3010             ADDS     R0,R0,#+16
   \   0000001E   0x7178             STRB     R0,[R7, #+5]
   \   00000020   0x9C08             LDR      R4,[SP, #+32]
    325          	SndBuf[ByteStation++] = DataLen;
   \   00000022   0x71BC             STRB     R4,[R7, #+6]
    326          	
    327          	SumCheck8 = GetCheckSumNR(&SndBuf[2],5);		   	// 索引区校验
    328          
    329          	SndBuf[ByteStation++] = SumCheck8;
   \   00000024   0xF106 0x08FE      ADD      R8,R6,#+254
   \   00000028   0x2105             MOVS     R1,#+5
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0x.... 0x....      BL       GetCheckSumNR
   \   00000030   0x71F8             STRB     R0,[R7, #+7]
    330          
    331          	memcpy(&SndBuf[8],DataBuf,DataLen);
   \   00000032   0x4622             MOV      R2,R4
   \   00000034   0x9907             LDR      R1,[SP, #+28]
   \   00000036   0xF506 0x7082      ADD      R0,R6,#+260
   \   0000003A   0x.... 0x....      BL       __aeabi_memcpy
    332          
    333          	Crc16 = GetCrc16Check(&SndBuf[2],6+DataLen);
   \   0000003E   0x1DA1             ADDS     R1,R4,#+6
   \   00000040   0xB289             UXTH     R1,R1
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x.... 0x....      BL       GetCrc16Check
    334          
    335          	SndBuf[2+6+DataLen+1] = Crc16;
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0x198A             ADDS     R2,R1,R6
   \   0000004C   0xF502 0x7282      ADD      R2,R2,#+260
   \   00000050   0x7050             STRB     R0,[R2, #+1]
    336          	SndBuf[2+6+DataLen]   = Crc16>>8;
   \   00000052   0x1200             ASRS     R0,R0,#+8
   \   00000054   0x7010             STRB     R0,[R2, #+0]
    337          
    338          	SndBufTmp[0] = SndBuf[0];						    // 准备数据发送
   \   00000056   0x7838             LDRB     R0,[R7, #+0]
   \   00000058   0x7030             STRB     R0,[R6, #+0]
    339          	SndBufTmp[1] = SndBuf[1];
   \   0000005A   0x7878             LDRB     R0,[R7, #+1]
   \   0000005C   0x7070             STRB     R0,[R6, #+1]
    340          	
    341          	AddHeadNum = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
    342          	for(i = 2; i< 2+6+DataLen + 2 + AddHeadNum;i++ )	{				// 数据，补移位 FRAM_HERD0
   \   00000060   0x2202             MOVS     R2,#+2
   \   00000062   0xE00D             B.N      ??CSNC_SendData_0
   \                     ??CSNC_SendData_1: (+1)
   \   00000064   0x1993             ADDS     R3,R2,R6
   \   00000066   0xF893 0x30FC      LDRB     R3,[R3, #+252]
   \   0000006A   0x1887             ADDS     R7,R0,R2
   \   0000006C   0x55BB             STRB     R3,[R7, R6]
    343          	
    344          		SndBufTmp[i+AddHeadNum] = SndBuf[i];
    345          		
    346          		if(SndBuf[i] == FRAM_HERD0) {
   \   0000006E   0x2B10             CMP      R3,#+16
   \   00000070   0xD104             BNE.N    ??CSNC_SendData_2
    347          			SndBufTmp[i+AddHeadNum+1] = FRAM_HERD0;
   \   00000072   0x2310             MOVS     R3,#+16
   \   00000074   0x19BF             ADDS     R7,R7,R6
   \   00000076   0x707B             STRB     R3,[R7, #+1]
    348          			AddHeadNum++;
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0xB280             UXTH     R0,R0
    349          		}
    350          	}
   \                     ??CSNC_SendData_2: (+1)
   \   0000007C   0x1C52             ADDS     R2,R2,#+1
   \   0000007E   0xB292             UXTH     R2,R2
   \                     ??CSNC_SendData_0: (+1)
   \   00000080   0x1843             ADDS     R3,R0,R1
   \   00000082   0xF103 0x070A      ADD      R7,R3,#+10
   \   00000086   0x42BA             CMP      R2,R7
   \   00000088   0xDBEC             BLT.N    ??CSNC_SendData_1
    351          
    352          	SndBufTmp[2+6+DataLen + 2 +AddHeadNum] = FRAM_END0;
   \   0000008A   0x1999             ADDS     R1,R3,R6
   \   0000008C   0x2210             MOVS     R2,#+16
   \   0000008E   0x728A             STRB     R2,[R1, #+10]
    353          	SndBufTmp[2+6+DataLen + 2 +AddHeadNum+1] = FRAM_END1;      
   \   00000090   0x222C             MOVS     R2,#+44
   \   00000092   0x72CA             STRB     R2,[R1, #+11]
    354              
    355              CPU_INT16U nbr_bytes= (2+6+DataLen + 2 +AddHeadNum +2);
   \   00000094   0x1900             ADDS     R0,R0,R4
   \   00000096   0xF100 0x020C      ADD      R2,R0,#+12
    356              if ( nbr_bytes < MB_DATA_NBR_REGS * 2 ) {  
   \   0000009A   0xB292             UXTH     R2,R2
   \   0000009C   0x2AFA             CMP      R2,#+250
   \   0000009E   0xDA08             BGE.N    ??CSNC_SendData_3
    357                  //串口在非接收状态，发送数据。
    358                  if (pch->RxBufByteCtr == 0) 
   \   000000A0   0x8E28             LDRH     R0,[R5, #+48]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD105             BNE.N    ??CSNC_SendData_3
    359                  {                
    360                      NMB_Tx(pch,
    361                             (CPU_INT08U  *)SndBufTmp,
    362                             (CPU_INT16U   )nbr_bytes);
   \   000000A6   0x4631             MOV      R1,R6
   \   000000A8   0x4628             MOV      R0,R5
   \   000000AA   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000AE   0x.... 0x....      B.W      NMB_Tx
    363                  }
    364                  else
    365                  {
    366                      return;
    367                  }
    368              }
    369          }
   \                     ??CSNC_SendData_3: (+1)
   \   000000B2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     l_recslaveaddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     RecvFrameNbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     SendFrameNbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     SndBufTmp
    370          
    371          
    372          /*******************************************************************************
    373           * 				                    end of file                                *
    374           *******************************************************************************/
    375          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   CSNC_GetData
        32   -> GetCheckSumNR
        32   -> GetCrc16Chk1
      24   CSNC_SendData
        24   -> GetCheckSumNR
        24   -> GetCrc16Check
         0   -> NMB_Tx
        24   -> __aeabi_memcpy
       0   GetRecSlaveAddr
       0   GetRecvFrameNbr
       0   GetSendFrameNbr
       0   SetRecvFrameNbr
       0   SetSendFrameNbr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
     160  CSNC_GetData
     182  CSNC_SendData
       6  GetRecSlaveAddr
       6  GetRecvFrameNbr
       6  GetSendFrameNbr
       1  RecvFrameNbr
       1  SendFrameNbr
      10  SetRecvFrameNbr
      10  SetSendFrameNbr
     504  SndBufTmp
          SndBuf
       1  l_recslaveaddr

 
 507 bytes in section .bss
 396 bytes in section .text
 
 396 bytes of CODE memory
 507 bytes of DATA memory

Errors: none
Warnings: none
