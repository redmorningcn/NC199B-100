###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       20/Nov/2017  11:24:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\APP\AES\aes_cfb.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\AES\aes_cfb.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\aes_cfb.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\aes_cfb.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\AES\aes_cfb.c
      1          /** crypto/aes/aes_cfb.c -*- mode:C; c-file-style: "eay" -*- */
      2          /** ====================================================================
      3           * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          /** Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
     52           * All rights reserved.
     53           *
     54           * This package is an SSL implementation written
     55           * by Eric Young (eay@cryptsoft.com).
     56           * The implementation was written so as to conform with Netscapes SSL.
     57           * 
     58           * This library is free for commercial and non-commercial use as long as
     59           * the following conditions are aheared to.  The following conditions
     60           * apply to all code found in this distribution, be it the RC4, RSA,
     61           * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
     62           * included with this distribution is covered by the same copyright terms
     63           * except that the holder is Tim Hudson (tjh@cryptsoft.com).
     64           * 
     65           * Copyright remains Eric Young's, and as such any Copyright notices in
     66           * the code are not to be removed.
     67           * If this package is used in a product, Eric Young should be given attribution
     68           * as the author of the parts of the library used.
     69           * This can be in the form of a textual message at program startup or
     70           * in documentation (online or textual) provided with the package.
     71           * 
     72           * Redistribution and use in source and binary forms, with or without
     73           * modification, are permitted provided that the following conditions
     74           * are met:
     75           * 1. Redistributions of source code must retain the copyright
     76           *    notice, this list of conditions and the following disclaimer.
     77           * 2. Redistributions in binary form must reproduce the above copyright
     78           *    notice, this list of conditions and the following disclaimer in the
     79           *    documentation and/or other materials provided with the distribution.
     80           * 3. All advertising materials mentioning features or use of this software
     81           *    must display the following acknowledgement:
     82           *    "This product includes cryptographic software written by
     83           *     Eric Young (eay@cryptsoft.com)"
     84           *    The word 'cryptographic' can be left out if the rouines from the library
     85           *    being used are not cryptographic related :-).
     86           * 4. If you include any Windows specific code (or a derivative thereof) from 
     87           *    the apps directory (application code) you must include an acknowledgement:
     88           *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
     89           * 
     90           * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
     91           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     92           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     93           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
     94           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     95           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     96           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     97           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     98           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     99           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    100           * SUCH DAMAGE.
    101           * 
    102           * The licence and distribution terms for any publically available version or
    103           * derivative of this code cannot be changed.  i.e. this code cannot simply be
    104           * copied and put under another distribution licence
    105           * [including the GNU Public Licence.]
    106           */
    107          
    108          #ifndef AES_DEBUG
    109          # ifndef NDEBUG
    110          #  define NDEBUG
    111          # endif
    112          #endif
    113          #include <assert.h>
    114          
    115          #include <aes.h>
    116          
    117          /** The input and output encrypted as though 128bit cfb mode is being
    118           * used.  The extra state information to record how much of the
    119           * 128bit block we have used is contained in *num;
    120           */
    121          

   \                                 In section .text, align 2, keep-with-next
    122          void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,
    123          	const unsigned long length, const AES_KEY *key,
    124          	unsigned char *ivec, int *num, const int enc) {
   \                     AES_cfb128_encrypt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
    125          
    126          	unsigned int n;
    127          	unsigned long l = length;
   \   0000000C   0x9F09             LDR      R7,[SP, #+36]
    128          	unsigned char c;
    129          
    130          	assert(in && out && key && ivec && num);
    131          
    132          	n = *num;
   \   0000000E   0xF8D7 0x8000      LDR      R8,[R7, #+0]
   \   00000012   0xF8DD 0x9020      LDR      R9,[SP, #+32]
    133          
    134          	if (enc) {
   \   00000016   0x980A             LDR      R0,[SP, #+40]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD02F             BEQ.N    ??AES_cfb128_encrypt_0
    135          		while (l--) {
   \                     ??AES_cfb128_encrypt_1: (+1)
   \   0000001C   0x4650             MOV      R0,R10
   \   0000001E   0xF1A0 0x0A01      SUB      R10,R0,#+1
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD02F             BEQ.N    ??AES_cfb128_encrypt_2
    136          			if (n == 0) {
   \   00000026   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002A   0xD104             BNE.N    ??AES_cfb128_encrypt_3
    137          				AES_encrypt(ivec, ivec, key);
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4649             MOV      R1,R9
   \   00000030   0x4648             MOV      R0,R9
   \   00000032   0x.... 0x....      BL       AES_encrypt
    138          			}
    139          			ivec[n] = *(out++) = *(in++) ^ ivec[n];
   \                     ??AES_cfb128_encrypt_3: (+1)
   \   00000036   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000003A   0xF818 0x1009      LDRB     R1,[R8, R9]
   \   0000003E   0x4048             EORS     R0,R1,R0
   \   00000040   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000044   0xF808 0x0009      STRB     R0,[R8, R9]
    140          			n = (n+1) % AES_BLOCK_SIZE;
   \   00000048   0xF108 0x0001      ADD      R0,R8,#+1
   \   0000004C   0xF000 0x080F      AND      R8,R0,#0xF
   \   00000050   0xE7E4             B.N      ??AES_cfb128_encrypt_1
    141          		}
    142          	} else {
    143          		while (l--) {
    144          			if (n == 0) {
   \                     ??AES_cfb128_encrypt_4: (+1)
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD104             BNE.N    ??AES_cfb128_encrypt_5
    145          				AES_encrypt(ivec, ivec, key);
   \   00000058   0x4632             MOV      R2,R6
   \   0000005A   0x4649             MOV      R1,R9
   \   0000005C   0x4648             MOV      R0,R9
   \   0000005E   0x.... 0x....      BL       AES_encrypt
    146          			}
    147          			c = *(in);
   \                     ??AES_cfb128_encrypt_5: (+1)
   \   00000062   0x7820             LDRB     R0,[R4, #+0]
    148          			*(out++) = *(in++) ^ ivec[n];
   \   00000064   0xF818 0x1009      LDRB     R1,[R8, R9]
   \   00000068   0x4041             EORS     R1,R1,R0
   \   0000006A   0xF805 0x1B01      STRB     R1,[R5], #+1
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
    149          			ivec[n] = c;
   \   00000070   0xF808 0x0009      STRB     R0,[R8, R9]
    150          			n = (n+1) % AES_BLOCK_SIZE;
   \   00000074   0xF108 0x0001      ADD      R0,R8,#+1
   \   00000078   0xF000 0x080F      AND      R8,R0,#0xF
    151          		}
   \                     ??AES_cfb128_encrypt_0: (+1)
   \   0000007C   0x4650             MOV      R0,R10
   \   0000007E   0xF1A0 0x0A01      SUB      R10,R0,#+1
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD1E5             BNE.N    ??AES_cfb128_encrypt_4
    152          	}
    153          
    154          	*num=n;
   \                     ??AES_cfb128_encrypt_2: (+1)
   \   00000086   0xF8C7 0x8000      STR      R8,[R7, #+0]
    155          }
   \   0000008A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    156          
    157          /** This expects a single block of size nbits for both in and out. Note that
    158             it corrupts any extra bits in the last byte of out */

   \                                 In section .text, align 2, keep-with-next
    159          void AES_cfbr_encrypt_block(const unsigned char *in,unsigned char *out,
    160          			    const int nbits,const AES_KEY *key,
    161          			    unsigned char *ivec,const int enc)
    162              {
   \                     AES_cfbr_encrypt_block: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x4698             MOV      R8,R3
    163              int n,rem,num;
    164              unsigned char ovec[AES_BLOCK_SIZE*2];
    165          
    166              if (nbits<=0 || nbits>128) return;
   \   0000000E   0x1E60             SUBS     R0,R4,#+1
   \   00000010   0x2880             CMP      R0,#+128
   \   00000012   0xD249             BCS.N    ??AES_cfbr_encrypt_block_0
   \   00000014   0x9D0E             LDR      R5,[SP, #+56]
    167          
    168          	/** fill in the first half of the new IV with the current IV */
    169          	memcpy(ovec,ivec,AES_BLOCK_SIZE);
   \   00000016   0x2210             MOVS     R2,#+16
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    170          	/** construct the new IV */
    171          	AES_encrypt(ivec,ivec,key);
   \   00000020   0x4642             MOV      R2,R8
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       AES_encrypt
    172          	num = (nbits+7)/8;
   \   0000002A   0x1DE0             ADDS     R0,R4,#+7
   \   0000002C   0x1081             ASRS     R1,R0,#+2
   \   0000002E   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   00000032   0x10C1             ASRS     R1,R0,#+3
    173          	if (enc)	/** encrypt the input */
   \   00000034   0x980F             LDR      R0,[SP, #+60]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD00B             BEQ.N    ??AES_cfbr_encrypt_block_1
    174          	    for(n=0 ; n < num ; ++n)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??AES_cfbr_encrypt_block_2: (+1)
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xDA14             BGE.N    ??AES_cfbr_encrypt_block_3
    175          		out[n] = (ovec[AES_BLOCK_SIZE+n] = in[n] ^ ivec[n]);
   \   00000040   0x5D82             LDRB     R2,[R0, R6]
   \   00000042   0x5D43             LDRB     R3,[R0, R5]
   \   00000044   0x405A             EORS     R2,R3,R2
   \   00000046   0x466B             MOV      R3,SP
   \   00000048   0x18C3             ADDS     R3,R0,R3
   \   0000004A   0x741A             STRB     R2,[R3, #+16]
   \   0000004C   0x55C2             STRB     R2,[R0, R7]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0xE7F4             B.N      ??AES_cfbr_encrypt_block_2
    176          	else		/** decrypt the input */
    177          	    for(n=0 ; n < num ; ++n)
   \                     ??AES_cfbr_encrypt_block_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE007             B.N      ??AES_cfbr_encrypt_block_4
    178          		out[n] = (ovec[AES_BLOCK_SIZE+n] = in[n]) ^ ivec[n];
   \                     ??AES_cfbr_encrypt_block_5: (+1)
   \   00000056   0x5D82             LDRB     R2,[R0, R6]
   \   00000058   0x466B             MOV      R3,SP
   \   0000005A   0x18C3             ADDS     R3,R0,R3
   \   0000005C   0x741A             STRB     R2,[R3, #+16]
   \   0000005E   0x5D43             LDRB     R3,[R0, R5]
   \   00000060   0x405A             EORS     R2,R3,R2
   \   00000062   0x55C2             STRB     R2,[R0, R7]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_cfbr_encrypt_block_4: (+1)
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xDBF5             BLT.N    ??AES_cfbr_encrypt_block_5
    179          	/** shift ovec left... */
    180          	rem = nbits%8;
   \                     ??AES_cfbr_encrypt_block_3: (+1)
   \   0000006A   0x10A0             ASRS     R0,R4,#+2
   \   0000006C   0xEB04 0x7050      ADD      R0,R4,R0, LSR #+29
   \   00000070   0x10C1             ASRS     R1,R0,#+3
   \   00000072   0xEBB4 0x02C1      SUBS     R2,R4,R1, LSL #+3
    181          	num = nbits/8;
    182          	if(rem==0)
   \   00000076   0xD106             BNE.N    ??AES_cfbr_encrypt_block_6
    183          	    memcpy(ivec,ovec+num,AES_BLOCK_SIZE);
   \   00000078   0x2210             MOVS     R2,#+16
   \   0000007A   0x4668             MOV      R0,SP
   \   0000007C   0x1809             ADDS     R1,R1,R0
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       __aeabi_memcpy
   \   00000084   0xE010             B.N      ??AES_cfbr_encrypt_block_0
    184          	else
    185          	    for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
   \                     ??AES_cfbr_encrypt_block_6: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE00C             B.N      ??AES_cfbr_encrypt_block_7
    186          		ivec[n] = ovec[n+num]<<rem | ovec[n+num+1]>>(8-rem);
   \                     ??AES_cfbr_encrypt_block_8: (+1)
   \   0000008A   0x180B             ADDS     R3,R1,R0
   \   0000008C   0x466C             MOV      R4,SP
   \   0000008E   0x5D1C             LDRB     R4,[R3, R4]
   \   00000090   0x4094             LSLS     R4,R4,R2
   \   00000092   0x466E             MOV      R6,SP
   \   00000094   0x199B             ADDS     R3,R3,R6
   \   00000096   0x785B             LDRB     R3,[R3, #+1]
   \   00000098   0xF1C2 0x0608      RSB      R6,R2,#+8
   \   0000009C   0x4133             ASRS     R3,R3,R6
   \   0000009E   0x4323             ORRS     R3,R3,R4
   \   000000A0   0x5543             STRB     R3,[R0, R5]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \                     ??AES_cfbr_encrypt_block_7: (+1)
   \   000000A4   0x2810             CMP      R0,#+16
   \   000000A6   0xDBF0             BLT.N    ??AES_cfbr_encrypt_block_8
    187          
    188              /** it is not necessary to cleanse ovec, since the IV is not secret */
    189              }
   \                     ??AES_cfbr_encrypt_block_0: (+1)
   \   000000A8   0xB008             ADD      SP,SP,#+32
   \   000000AA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    190          
    191          /** N.B. This expects the input to be packed, MS bit first */

   \                                 In section .text, align 2, keep-with-next
    192          void AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,
    193          		      const unsigned long length, const AES_KEY *key,
    194          		      unsigned char *ivec, int *num, const int enc)
    195              {
   \                     AES_cfb1_encrypt: (+1)
   \   00000000   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x469B             MOV      R11,R3
    196              unsigned int n;
    197              unsigned char c[1],d[1];
    198          
    199              assert(in && out && key && ivec && num);
    200              assert(*num == 0);
    201          
    202              for(n=0 ; n < length ; ++n)
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x9E0E             LDR      R6,[SP, #+56]
   \   0000000E   0x9F10             LDR      R7,[SP, #+64]
   \   00000010   0xE019             B.N      ??AES_cfb1_encrypt_0
    203          	{
    204          	c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
   \                     ??AES_cfb1_encrypt_1: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0008      STRB     R0,[SP, #+8]
    205          	AES_cfbr_encrypt_block(c,d,1,key,ivec,enc);
   \                     ??AES_cfb1_encrypt_2: (+1)
   \   00000018   0x9701             STR      R7,[SP, #+4]
   \   0000001A   0x9600             STR      R6,[SP, #+0]
   \   0000001C   0x465B             MOV      R3,R11
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xF10D 0x0109      ADD      R1,SP,#+9
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0x.... 0x....      BL       AES_cfbr_encrypt_block
    206          	out[n/8]=(out[n/8]&~(1 << (7-n%8)))|((d[0]&0x80) >> (n%8));
   \   0000002A   0xF818 0x0004      LDRB     R0,[R8, R4]
   \   0000002E   0xEA20 0x0009      BIC      R0,R0,R9
   \   00000032   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   00000036   0xF001 0x0180      AND      R1,R1,#0x80
   \   0000003A   0xFA21 0xF10A      LSR      R1,R1,R10
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0xF808 0x0004      STRB     R0,[R8, R4]
   \   00000044   0x1C6D             ADDS     R5,R5,#+1
   \                     ??AES_cfb1_encrypt_0: (+1)
   \   00000046   0x9804             LDR      R0,[SP, #+16]
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xD212             BCS.N    ??AES_cfb1_encrypt_3
   \   0000004C   0xF005 0x0A07      AND      R10,R5,#0x7
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF1CA 0x0107      RSB      R1,R10,#+7
   \   00000056   0xFA00 0xF901      LSL      R9,R0,R1
   \   0000005A   0xEA4F 0x08D5      LSR      R8,R5,#+3
   \   0000005E   0x9803             LDR      R0,[SP, #+12]
   \   00000060   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000064   0xEA10 0x0F09      TST      R0,R9
   \   00000068   0xD0D3             BEQ.N    ??AES_cfb1_encrypt_1
   \   0000006A   0x2080             MOVS     R0,#+128
   \   0000006C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000070   0xE7D2             B.N      ??AES_cfb1_encrypt_2
    207          	}
    208              }
   \                     ??AES_cfb1_encrypt_3: (+1)
   \   00000072   0xB005             ADD      SP,SP,#+20
   \   00000074   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,
    211          		      const unsigned long length, const AES_KEY *key,
    212          		      unsigned char *ivec, int *num, const int enc)
    213              {
   \                     AES_cfb8_encrypt: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    214              unsigned int n;
    215          
    216              assert(in && out && key && ivec && num);
    217              assert(*num == 0);
    218          
    219              for(n=0 ; n < length ; ++n)
   \   0000000C   0xF04F 0x0A00      MOV      R10,#+0
   \   00000010   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000014   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   00000018   0xE00D             B.N      ??AES_cfb8_encrypt_0
    220          	AES_cfbr_encrypt_block(&in[n],&out[n],8,key,ivec,enc);
   \                     ??AES_cfb8_encrypt_1: (+1)
   \   0000001A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000001E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000022   0x463B             MOV      R3,R7
   \   00000024   0x2208             MOVS     R2,#+8
   \   00000026   0xEB0A 0x0105      ADD      R1,R10,R5
   \   0000002A   0xEB0A 0x0004      ADD      R0,R10,R4
   \   0000002E   0x.... 0x....      BL       AES_cfbr_encrypt_block
   \   00000032   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??AES_cfb8_encrypt_0: (+1)
   \   00000036   0x45B2             CMP      R10,R6
   \   00000038   0xD3EF             BCC.N    ??AES_cfb8_encrypt_1
    221              }
   \   0000003A   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    222          
    223          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AES_cfb128_encrypt
        32   -> AES_encrypt
      56   AES_cfb1_encrypt
        56   -> AES_cfbr_encrypt_block
      40   AES_cfb8_encrypt
        40   -> AES_cfbr_encrypt_block
      56   AES_cfbr_encrypt_block
        56   -> AES_encrypt
        56   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     142  AES_cfb128_encrypt
     120  AES_cfb1_encrypt
      62  AES_cfb8_encrypt
     174  AES_cfbr_encrypt_block

 
 498 bytes in section .text
 
 498 bytes of CODE memory

Errors: none
Warnings: none
