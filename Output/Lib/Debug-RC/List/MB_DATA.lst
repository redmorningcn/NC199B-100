###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Nov/2017  10:06:13
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Cfg\Template\MB_DATA.C
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Cfg\Template\MB_DATA.C
#        -D USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\MB_DATA.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\MB_DATA.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Cfg\Template\MB_DATA.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                         uC/MODBUS TARGET SPECIFIC DATA ACCESS FUNCTIONS (Template)
     19          *
     20          * Filename      : mb_data.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          
     29          #include <mb.h>
     30          #include <os.h>
     31          #include <app.h>
     32          #include <bsp_time.h>
     33          #include <bsp_eeprom.h>
     34          #include <includes.h>
     35          #include <global.h>
     36          
     37          /*******************************************************************************
     38          * 名    称： exchangeBytes
     39          * 功    能： 模拟的htons 或者 ntohs，如果系统支字节序更改可直接替换成系统函数
     40          * 入口参数： value
     41          * 出口参数： 更改过字节序的short数值
     42          * 作　 　者： 无名沈.
     43          * 创建日期： 2015-06-25
     44          * 修    改：
     45          * 修改日期：
     46          * 备    注：
     47          *******************************************************************************/
     48          //int16_t	exchangeBytes(int16_t	value)
     49          //{
     50          //	int16_t		tmp_value;
     51          //	uint8_t		*index_1, *index_2;
     52          //
     53          //	index_1 = (uint8_t *)&tmp_value;
     54          //	index_2 = (uint8_t *)&value;
     55          //
     56          //	*index_1 = *(index_2+1);
     57          //	*(index_1+1) = *index_2;
     58          //
     59          //	return tmp_value;
     60          //}
     61          
     62          #if MODBUS_CFG_SLAVE_EN == DEF_ENABLED

   \                                 In section .data, align 4
     63          StrMbData   mbData  = {MB_DATA_NBR_REGS, MB_DATA_NBR_COILS, 0,0,0};
   \                     mbData:
   \   00000000   0x007D 0x0020      DC16 125, 32
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000088   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000098   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000C8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000D8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000E8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000F8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     64          #endif
     65          /*$PAGE*/
     66          /*
     67          *********************************************************************************************************
     68          *                                     GET THE VALUE OF A SINGLE COIL
     69          *
     70          * Description: This function returns the value of a single coil.
     71          *              It is called by 'MBS_FC01_CoilRd()'.
     72          *              You must 'map' the 'coil' to the actual application's coil.
     73          *
     74          * Arguments  : coil     is the coil number that is being requested.
     75          *
     76          *              perr     is a pointer to an error code variable.  You must either return:
     77          *
     78          *                       MODBUS_ERR_NONE     the specified coil is valid and you are returning its value.
     79          *                       MODBUS_ERR_RANGE    the specified coil is an invalid coil number in your
     80          *                                           application (i.e. product).  YOUR product defines what the
     81          *                                           valid range of values is for the 'coil' argument.
     82          *
     83          * Note(s)    : 1) You can perform the mapping of coil number to application coils directly in this
     84          *                 function or via a table lookup.  A table lookup would make sense if you had a lot of
     85          *                 coils in your product.
     86          *********************************************************************************************************
     87          */
     88          
     89          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
     90          CPU_BOOLEAN  MB_CoilRd (CPU_INT16U   coil,
     91                                  CPU_INT16U  *perr)
     92          {
   \                     MB_CoilRd: (+1)
   \   00000000   0xB410             PUSH     {R4}
     93              /***********************************************
     94              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
     95              */
     96              if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
   \   00000002   0x....             LDR.N    R3,??DataTable3
   \   00000004   0x881A             LDRH     R2,[R3, #+0]
   \   00000006   0xF641 0x045D      MOVW     R4,#+6237
   \   0000000A   0x42A2             CMP      R2,R4
   \   0000000C   0xD003             BEQ.N    ??MB_CoilRd_0
     97                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x8008             STRH     R0,[R1, #+0]
     98                  return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE013             B.N      ??MB_CoilRd_1
     99              }
    100              
    101              CPU_BOOLEAN     coil_val;
    102              CPU_INT16U      reg         = coil / 16;        // 获取当前寄存器
   \                     ??MB_CoilRd_0: (+1)
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x0912             LSRS     R2,R2,#+4
    103              CPU_INT08U      bit         = coil % 16;        // 获取当前寄存器的位
   \   0000001A   0xF000 0x000F      AND      R0,R0,#0xF
    104              CPU_INT16U      reg_val;
    105              //CPU_INT16U      *preg       = (CPU_INT16U *) Ctrl.Para.buf2;
    106              CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    107              /***********************************************
    108              * 描述： 获取值
    109              */
    110              if ( reg < sizeof(Ctrl) / 2 ) {
   \   0000001E   0xF5B2 0x7F18      CMP      R2,#+608
   \   00000022   0xD804             BHI.N    ??MB_CoilRd_2
    111                  reg_val = preg[reg];
   \   00000024   0xF833 0x2012      LDRH     R2,[R3, R2, LSL #+1]
    112                  *perr = MODBUS_ERR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x800B             STRH     R3,[R1, #+0]
   \   0000002C   0xE002             B.N      ??MB_CoilRd_3
    113              } else {
    114                  reg_val = 0;
   \                     ??MB_CoilRd_2: (+1)
   \   0000002E   0x2200             MOVS     R2,#+0
    115                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000030   0x2302             MOVS     R3,#+2
   \   00000032   0x800B             STRH     R3,[R1, #+0]
    116              }
    117                  
    118              /***********************************************
    119              * 描述： 获取当前位的值
    120              */
    121              coil_val    = (CPU_BOOLEAN)(reg_val & ( 1 << bit ) );
    122          
    123              return (coil_val);
   \                     ??MB_CoilRd_3: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xFA01 0xF000      LSL      R0,R1,R0
   \   0000003A   0x4010             ANDS     R0,R0,R2
   \   0000003C   0xB2C0             UXTB     R0,R0
   \                     ??MB_CoilRd_1: (+1)
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
    124          }
    125          #endif
    126          
    127          /*
    128          *********************************************************************************************************
    129          *                                     SET THE VALUE OF A SINGLE COIL
    130          *
    131          * Description: This function changes the value of a single coil.
    132          *              It is called by 'MBS_FC05_CoilWr()' and 'MBS_FC15_CoilWrMultiple()'.
    133          *              You must 'map' the 'coil' to the actual application's coil.
    134          *
    135          * Arguments  : coil      is the coil number that needs to be changed.
    136          *
    137          *              coil_val  is the desired value of the coil.  This value can be either DEF_TRUE or DEF_FALSE with
    138          *                        DEF_TRUE indicating an energized coil.
    139          *
    140          *              perr      is a pointer to an error code variable.  You must either return:
    141          *
    142          *                        MODBUS_ERR_NONE     the specified coil is valid and your code changed the value
    143          *                                            of the coil.
    144          *                        MODBUS_ERR_RANGE    the specified coil is an invalid coil number in your
    145          *                                            application (i.e. product).  YOUR product defines what the
    146          *                                            valid range of values is for the 'coil' argument.
    147          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    148          *
    149          * Note(s)    : 1) You can perform the mapping of coil number to application coils directly in this
    150          *                 function or via a table lookup.  A table lookup would make sense if you had a lot of
    151          *                 coils in your product.
    152          *********************************************************************************************************
    153          */
    154          
    155          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED) || \
    156              (MODBUS_CFG_FC15_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    157          void  MB_CoilWr (CPU_INT16U    coil,
    158                           CPU_BOOLEAN   coil_val,
    159                           CPU_INT16U   *perr)
    160          {
   \                     MB_CoilWr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4614             MOV      R4,R2
    161              /***********************************************
    162              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    163              */
    164              if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
   \   00000006   0x....             LDR.N    R5,??DataTable3
   \   00000008   0x882A             LDRH     R2,[R5, #+0]
   \   0000000A   0xF641 0x035D      MOVW     R3,#+6237
   \   0000000E   0x429A             CMP      R2,R3
   \   00000010   0xD002             BEQ.N    ??MB_CoilWr_0
    165                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    166                  return;
   \   00000016   0xE024             B.N      ??MB_CoilWr_1
    167              }
    168              
    169              (void)coil;
    170              (void)coil_val;
    171              CPU_SR          cpu_sr;
    172              CPU_INT16U      reg         = coil / 16;
   \                     ??MB_CoilWr_0: (+1)
   \   00000018   0x4602             MOV      R2,R0
   \   0000001A   0x0916             LSRS     R6,R2,#+4
    173              CPU_INT08U      bit         = coil % 16;
    174              CPU_INT16U      reg_val     = 0;
    175              CPU_INT16U      temp;
    176          
    177              /***********************************************
    178              * 描述： 获取当前位
    179              */
    180              reg_val         |= coil_val << bit;
   \   0000001C   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000020   0xFA01 0xF700      LSL      R7,R1,R0
   \   00000024   0xB2BF             UXTH     R7,R7
    181              
    182              //CPU_INT16U      *preg       = (CPU_INT16U *) Ctrl.Para.buf2;
    183              CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    184              /***********************************************
    185              * 描述： 获取值
    186              */
    187              if ( reg < sizeof(Ctrl) / 2 ) {
   \   00000026   0xF5B6 0x7F18      CMP      R6,#+608
   \   0000002A   0xD818             BHI.N    ??MB_CoilWr_2
    188                  /***********************************************
    189                  * 描述：
    190                  */
    191                  if ( reg < 127 ) {
   \   0000002C   0x2E7F             CMP      R6,#+127
   \   0000002E   0xDA13             BGE.N    ??MB_CoilWr_3
    192                      int idx = reg - 0;
    193                      
    194                      CPU_CRITICAL_ENTER();
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x4680             MOV      R8,R0
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStart
    195                      temp          = preg[idx];
   \   0000003A   0xF835 0x0016      LDRH     R0,[R5, R6, LSL #+1]
    196                      ( reg_val )   ? ( reg_val = reg_val | temp )
    197                          : ( reg_val =~reg_val & temp );
   \   0000003E   0x0039             MOVS     R1,R7
   \   00000040   0xD001             BEQ.N    ??MB_CoilWr_4
   \   00000042   0x4307             ORRS     R7,R0,R7
   \   00000044   0xE001             B.N      ??MB_CoilWr_5
   \                     ??MB_CoilWr_4: (+1)
   \   00000046   0xEA20 0x0707      BIC      R7,R0,R7
    198                          preg[idx]       = reg_val;
   \                     ??MB_CoilWr_5: (+1)
   \   0000004A   0xF825 0x7016      STRH     R7,[R5, R6, LSL #+1]
    199                          CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
    200                  }
    201                  *perr = MODBUS_ERR_NONE;
   \                     ??MB_CoilWr_3: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
   \   0000005C   0xE001             B.N      ??MB_CoilWr_1
    202              } else {
    203                  reg_val = 0;
    204                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \                     ??MB_CoilWr_2: (+1)
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x8020             STRH     R0,[R4, #+0]
    205              }
    206          }
   \                     ??MB_CoilWr_1: (+1)
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    207          #endif
    208          
    209          /*$PAGE*/
    210          /*
    211          *********************************************************************************************************
    212          *                                GET THE VALUE OF A SINGLE DISCRETE INPUT
    213          *
    214          * Description: This function reads the value of a single DI (DI means Discrete Input).
    215          *              It is called by 'MBS_FC02_DIRd()'.
    216          *              You must 'map' the 'di'  to the actual application's DI.
    217          *
    218          * Arguments  : di        is the Discrete Input number that needs to be read.
    219          *
    220          *              perr      is a pointer to an error code variable.  You must either return:
    221          *
    222          *                        MODBUS_ERR_NONE     the specified DI is valid and your code is returning its
    223          *                                            current value.
    224          *                        MODBUS_ERR_RANGE    the specified DI is an invalid Discrete Input number in your
    225          *                                            application (i.e. product).  YOUR product defines what the
    226          *                                            valid range of values is for the 'di' argument.
    227          *
    228          * Note(s)    : 1) You can perform the mapping of DI number to the application DIs directly in this function
    229          *                 or via a table lookup.  A table lookup would make sense if you had a lot of Discrete
    230          *                 Inputs in your product.
    231          *********************************************************************************************************
    232          */
    233          
    234          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    235          CPU_BOOLEAN  MB_DIRd (CPU_INT16U   di,
    236                                CPU_INT16U  *perr)
    237          {
    238              (void)di;
    239              *perr = MODBUS_ERR_NONE;
    240              return (DEF_FALSE);
    241          }
    242          #endif
    243          
    244          /*$PAGE*/
    245          /*
    246          *********************************************************************************************************
    247          *                               GET THE VALUE OF A SINGLE INPUT REGISTER
    248          *
    249          * Description: This function reads the value of a single Input Register.
    250          *              It is called by 'MBS_FC04_InRegRd()' when the argument 'reg' is BELOW the value set by
    251          *              the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    252          *              You must 'map' the Input Register to the actual application's corresponding integer register.
    253          *
    254          * Arguments  : reg       is the Input Register number that needs to be read.
    255          *
    256          *              perr      is a pointer to an error code variable.  You must either return:
    257          *
    258          *                        MODBUS_ERR_NONE     the specified input register is valid and your code is
    259          *                                            returning its current value.
    260          *                        MODBUS_ERR_RANGE    the specified input register is an invalid number in your
    261          *                                            application (i.e. product).  YOUR product defines what the
    262          *                                            valid range of values is for the 'reg' argument.
    263          *
    264          * Note(s)    : 1) You can perform the mapping of input register number to the application's input registers
    265          *                 directly in this function or via a table lookup.  A table lookup would make sense if you
    266          *                 had a lot of Input Registers in your product.
    267          *              2) If your product doesn't have input registers, you could simply set '*err' to
    268          *                 MODBUS_ERR_NONE and return 0.
    269          *********************************************************************************************************
    270          */
    271          
    272          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    273          CPU_INT16U  MB_InRegRd (CPU_INT16U   reg,
    274                                  CPU_INT16U  *perr)
    275          {
    276              CPU_INT16U  val;
    277              CPU_SR      cpu_sr;
    278          
    279          
    280              switch (reg) {
    281                  case 10:
    282                       CPU_CRITICAL_ENTER();
    283                       val = (CPU_INT16U)OSCPUUsage;
    284                       CPU_CRITICAL_EXIT();
    285                       break;
    286          
    287                  case 11:
    288                       CPU_CRITICAL_ENTER();
    289                       val = (CPU_INT16U)OSCtxSwCtr;
    290                       CPU_CRITICAL_EXIT();
    291                       break;
    292          
    293                  case 12:
    294                       CPU_CRITICAL_ENTER();
    295                       val = (CPU_INT16U)(OSTime >> 16);
    296                       CPU_CRITICAL_EXIT();
    297                       break;
    298          
    299                  case 13:
    300                       CPU_CRITICAL_ENTER();
    301                       val = (CPU_INT16U)(OSTime & 0x0000FFFF);
    302                       CPU_CRITICAL_EXIT();
    303                       break;
    304          
    305                  case 14:
    306                       CPU_CRITICAL_ENTER();
    307                       val = (CPU_INT16U)MB_ChSize;
    308                       CPU_CRITICAL_EXIT();
    309                       break;
    310          
    311                  case 15:
    312                       CPU_CRITICAL_ENTER();
    313                       val = (CPU_INT16U)(MB_TotalRAMSize & 0x0000FFFF);
    314                       CPU_CRITICAL_EXIT();
    315                       break;
    316          
    317                  default:
    318                       val = 0;
    319                       break;
    320              }
    321              *perr = MODBUS_ERR_NONE;
    322              return (val);
    323          }
    324          #endif
    325          
    326          /*
    327          *********************************************************************************************************
    328          *                     GET THE VALUE OF A SINGLE 'FLOATING-POINT' INPUT REGISTER
    329          *
    330          * Description: This function reads the value of a single Input Register.
    331          *              It is called by 'MBS_FC04_InRegRd()' when the argument 'reg' is ABOVE or equal to the
    332          *              value set the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    333          *              You must 'map' the Input Register to the actual application's corresponding floating-point
    334          *              register.
    335          *
    336          * Arguments  : reg       is the Input Register number that needs to be read.
    337          *
    338          *              perr      is a pointer to an error code variable.  You must either return:
    339          *
    340          *                        MODBUS_ERR_NONE     the specified input register is valid and your code is
    341          *                                            returning its current value.
    342          *                        MODBUS_ERR_RANGE    the specified input register is an invalid number in your
    343          *                                            application (i.e. product).  YOUR product defines what the
    344          *                                            valid range of values is for the 'reg' argument.
    345          *
    346          * Note(s)    : 1) You can perform the mapping of input register number to the application's input registers
    347          *                 directly in this function or via a table lookup.  A table lookup would make sense if you
    348          *                 had a lot of Input Registers in your product.
    349          *              2) If your product doesn't have input registers, you could simply set '*err' to
    350          *                 MODBUS_ERR_NONE and return (CPU_FP32)0.
    351          *********************************************************************************************************
    352          */
    353          
    354          #if (MODBUS_CFG_FP_EN   == DEF_ENABLED)
    355          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    356          CPU_FP32  MB_InRegRdFP (CPU_INT16U   reg,
    357                                  CPU_INT16U  *perr)
    358          {
    359              (void)reg;
    360              *perr = MODBUS_ERR_NONE;
    361              return ((CPU_FP32)0);
    362          }
    363          #endif
    364          #endif
    365          
    366          /*$PAGE*/
    367          /*
    368          *********************************************************************************************************
    369          *                             GET THE VALUE OF A SINGLE HOLDING REGISTER
    370          *
    371          * Description: This function reads the value of a single Holding Register.
    372          *              It is called by 'MBS_FC03_HoldingRegRd()' when the argument 'reg' is BELOW the value set
    373          *              by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    374          *              You must 'map' the Holding Register to the actual application's corresponding integer register.
    375          *
    376          * Arguments  : reg       is the Holding Register number that needs to be read.
    377          *
    378          *              perr      is a pointer to an error code variable.  You must either return:
    379          *
    380          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    381          *                                            returning its current value.
    382          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    383          *                                            application (i.e. product).  YOUR product defines what the
    384          *                                            valid range of values is for the 'reg' argument.
    385          *
    386          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    387          *                 registers directly in this function or via a table lookup.  A table lookup would make
    388          *                 sense if you had a lot of Holding Registers in your product.
    389          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    390          *                 MODBUS_ERR_NONE and return 0.
    391          *********************************************************************************************************
    392          */
    393          
    394          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    395          CPU_INT16U  MB_HoldingRegRd (CPU_INT16U   reg,
    396                                       CPU_INT16U  *perr)
    397          {
   \                     MB_HoldingRegRd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    398              CPU_INT16U  reg_val;
    399              CPU_SR      cpu_sr;
    400          
    401              /***********************************************
    402              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    403              */
    404              if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
   \   00000006   0x....             LDR.N    R6,??DataTable3
   \   00000008   0x8830             LDRH     R0,[R6, #+0]
   \   0000000A   0xF641 0x015D      MOVW     R1,#+6237
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD003             BEQ.N    ??MB_HoldingRegRd_0
    405                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    406                  return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}
    407              }
    408                  
    409              //CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Sen.H.AdcValue;//Para.buf2;
    410              CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    411              /***********************************************
    412              * 描述： 获取值
    413              */
    414              if ( reg < sizeof(Ctrl) / 2 ) {
   \                     ??MB_HoldingRegRd_0: (+1)
   \   0000001A   0xF5B5 0x7F18      CMP      R5,#+608
   \   0000001E   0xD80E             BHI.N    ??MB_HoldingRegRd_1
    415                  CPU_CRITICAL_ENTER();
   \   00000020   0x.... 0x....      BL       CPU_SR_Save
   \   00000024   0x4607             MOV      R7,R0
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStart
    416                  reg_val = preg[reg];
   \   0000002A   0xF836 0x5015      LDRH     R5,[R6, R5, LSL #+1]
    417                  CPU_CRITICAL_EXIT();
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
    418                  *perr = MODBUS_ERR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x8020             STRH     R0,[R4, #+0]
   \   0000003C   0xE002             B.N      ??MB_HoldingRegRd_2
    419              } else {
    420                  reg_val = 0;
   \                     ??MB_HoldingRegRd_1: (+1)
   \   0000003E   0x2500             MOVS     R5,#+0
    421                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x8020             STRH     R0,[R4, #+0]
    422              }
    423              
    424              return (reg_val);
   \                     ??MB_HoldingRegRd_2: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    425          }
    426          #endif
    427          
    428          /*$PAGE*/
    429          /*
    430          *********************************************************************************************************
    431          *                     GET THE VALUE OF A SINGLE 'FLOATING-POINT' HOLDING REGISTER
    432          *
    433          * Description: This function reads the value of a single Floating-Point Holding Register.
    434          *              It is called by 'MBS_FC03_HoldingRegRd()' when the argument 'reg' is ABOVE or equal to the
    435          *              value set by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    436          *              You must 'map' the Holding Register to the actual application's corresponding floating-point
    437          *              register.
    438          *
    439          * Arguments  : reg       is the Holding Register number that needs to be read.
    440          *
    441          *              perr      is a pointer to an error code variable.  You must either return:
    442          *
    443          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    444          *                                            returning its current value.
    445          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    446          *                                            application (i.e. product).  YOUR product defines what the
    447          *                                            valid range of values is for the 'reg' argument.
    448          *
    449          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    450          *                 registers directly in this function or via a table lookup.  A table lookup would make
    451          *                 sense if you had a lot of Holding Registers in your product.
    452          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    453          *                 MODBUS_ERR_NONE and return 0.
    454          *********************************************************************************************************
    455          */
    456          
    457          #if (MODBUS_CFG_FP_EN   == DEF_ENABLED)
    458          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    459          CPU_FP32  MB_HoldingRegRdFP (CPU_INT16U   reg,
    460                                       CPU_INT16U  *perr)
    461          {
    462              (void)reg;    
    463              
    464              /***********************************************
    465              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    466              */
    467              if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
    468                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
    469                  return 0;
    470              }
    471              /***********************************************
    472              * 描述： 浮点寄存器
    473              */
    474              CPU_FP32   *preg        = (CPU_FP32 *)&Ctrl.Sen.Para.buf3[0];
    475              reg        = reg - MODBUS_CFG_FP_START_IX;
    476              CPU_FP32   reg_val      = 0;
    477              
    478              /***********************************************
    479              * 描述： 获取值
    480              */
    481              if ( reg < sizeof(UnionSenPara) / 4 ) {
    482                  preg    += reg;
    483                  CPU_SR_ALLOC();
    484                  CPU_CRITICAL_ENTER();
    485                  reg_val     = *preg;
    486                  CPU_CRITICAL_EXIT();
    487                  *perr = MODBUS_ERR_NONE;
    488              } else {
    489                  *perr = MODBUS_ERR_RANGE;
    490              }
    491              
    492              return ((CPU_FP32)reg_val);
    493          }
    494          #endif
    495          #endif
    496          
    497          /*$PAGE*/
    498          /*
    499          *********************************************************************************************************
    500          *                            SET THE VALUE OF A SINGLE HOLDING REGISTER
    501          *
    502          * Description: This function is called to change the value of a single Integer Holding Register.
    503          *              It is called by 'MBS_FC06_HoldingRegWr()' and 'MBS_FC16_HoldingRegWrMultiple()' when the argument
    504          *              'reg' is BELOW to the value set by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    505          *              You must 'map' the Holding Register to the actual application's corresponding integer register.
    506          *
    507          * Arguments  : reg       is the Holding Register number that needs to be read.
    508          *
    509          *              reg_val   is the desired value of the holding register.
    510          *                        The value is specified as an unsigned integer even though it could actually be
    511          *                        represented by a signed integer.
    512          *
    513          *              perr      is a pointer to an error code variable.  You must either return:
    514          *
    515          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    516          *                                            returning its current value.
    517          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    518          *                                            application (i.e. product).  YOUR product defines what the
    519          *                                            valid range of values is for the 'reg' argument.
    520          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    521          *
    522          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    523          *                 registers directly in this function or via a table lookup.  A table lookup would make
    524          *                 sense if you had a lot of Holding Registers in your product.
    525          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    526          *                 MODBUS_ERR_NONE and return 0.
    527          *********************************************************************************************************
    528          */
    529          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED) || \
    530              (MODBUS_CFG_FC16_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    531          void  MB_HoldingRegWr (CPU_INT16U   reg,
    532                                 CPU_INT16U   reg_val,
    533                                 CPU_INT16U  *perr)
    534          {
   \                     MB_HoldingRegWr: (+1)
   \   00000000   0xB410             PUSH     {R4}
    535              /* Access to your variable here! */
    536              (void)reg;
    537              (void)reg_val;
    538              
    539              /***********************************************
    540              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    541              */
    542              if ( ( Ctrl.Para.dat.Password == MB_DATA_ACC_PASSWORD ) ||
    543                   ( ( reg == 0 ) && ( reg_val == MB_DATA_ACC_PASSWORD ) ) ) {
   \   00000002   0xF641 0x035D      MOVW     R3,#+6237
   \   00000006   0x....             LDR.N    R4,??DataTable3
   \   00000008   0x8824             LDRH     R4,[R4, #+0]
   \   0000000A   0x429C             CMP      R4,R3
   \   0000000C   0xD005             BEQ.N    ??MB_HoldingRegWr_0
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??MB_HoldingRegWr_1
   \   00000012   0x4299             CMP      R1,R3
   \   00000014   0xD001             BEQ.N    ??MB_HoldingRegWr_0
    544              } else {
    545                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \                     ??MB_HoldingRegWr_1: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x8010             STRH     R0,[R2, #+0]
    546                  return;
    547              }
    548              
    549              CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    550               
    551              /***********************************************
    552              * 描述： 获取值
    553              */
    554              if ( reg < sizeof(Ctrl) / 2 ) {
    555                  preg    += reg;
    556                  /***********************************************
    557                  * 描述： 写入测量模块校准参数
    558                  */    
    559          //        extern BOOL App_SetParaToSensor(INT08U dev, INT32U addr, INT08U *dat, INT16U len);
    560          //        if ( preg == &Ctrl.Para.buf2[58] ) {
    561          //            if ( ( reg_val & 0x0001 ) == 0x0001 ) {
    562          //                NVIC_SystemReset();                        // 重启（core_cm3.h文件提供该函数）
    563          //            }
    564          //        } else if ( ( preg > &Ctrl.Para.buf2[0] ) &&
    565          //             ( preg <= &Ctrl.Para.buf2[127] ) ) {
    566          //            //BSP_I2CSetPort(2);
    567          //            
    568          //            INT16U addr = (preg - &Ctrl.Para.buf2[0])*2;
    569                      //INT08U *pb  = (INT08U *)preg;
    570                      
    571          //            if ( !BSP_EEP_WriteINT16U (addr, reg_val ) ) {
    572          //            //if ( !App_SetParaToSensor(2, addr, NULL, 2) ) {
    573          //                *perr = MODBUS_ERR_ILLEGAL_DATA_VAL;
    574          //                return;
    575          //            }
    576          //        /***********************************************
    577          //        * 描述： 写入传感器模块校准参数
    578          //        */
    579          //        } else if ( ( preg >= &Ctrl.Sen.Para.buf2[0] ) &&
    580          //                    ( preg <= &Ctrl.Sen.Para.buf2[128] ) ) {
    581          //            BSP_I2CSetPort(1);
    582          //            INT16U addr = (preg - Ctrl.Sen.Para.buf2)*2;
    583          //            //INT08U *pb  = (INT08U *)preg;
    584          //            
    585          //            //if ( App_SetParaToEep(addr, NULL, 2 ) ) {
    586          //            if ( !BSP_EEP_WriteINT16U (addr, reg_val ) ) {
    587          //                *perr = MODBUS_ERR_ILLEGAL_DATA_VAL;
    588          //                BSP_I2CSetPort(2);
    589          //                return;
    590          //            }
    591          //            BSP_I2CSetPort(2);
    592          ////        } else if ( ( preg > (INT16U *)&Ctrl.Tab ) &&
    593          ////             ( preg <= (INT16U *)&Ctrl.Tab.buf2[127] ) ) {
    594          ////            BSP_I2CSetPort(2);
    595          ////            
    596          ////            INT16U addr = (preg - (INT16U *)&Ctrl.Tab.buf2)*2+256;
    597          ////            INT08U *pb  = (INT08U *)preg;
    598          ////            
    599          ////            if ( !BSP_EEP_WriteINT16U (addr, reg_val ) ) {
    600          ////            //if ( App_SetParaToEep(addr, NULL, 2 ) ) { 
    601          ////                *perr = MODBUS_ERR_ILLEGAL_DATA_VAL;
    602          ////                return;
    603          ////            }
    604          //        /***********************************************
    605          //        * 描述： 写入测量模块校准参数
    606          //        */
    607                  }
    608          //        
    609          //        CPU_SR_ALLOC();
    610          //        CPU_CRITICAL_ENTER();
    611          //        *preg       = reg_val;
    612          //        CPU_CRITICAL_EXIT();
    613          //        
    614          //        *perr = MODBUS_ERR_NONE;
    615          //    } else {
    616          //        *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
    617          //    }    
    618          }
   \                     ??MB_HoldingRegWr_0: (+1)
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    619          #endif
    620          
    621          /*$PAGE*/
    622          /*
    623          *********************************************************************************************************
    624          *                     SET THE VALUE OF A SINGLE 'FLOATING-POINT' HOLDING REGISTER
    625          *
    626          * Description: This function is called to change the value of a single Floating-Point Holding Register.
    627          *              It is called by 'MBS_FC06_HoldingRegWr()' and 'MBS_FC16_HoldingRegWrMultiple()' when the argument
    628          *              'reg' is ABOVE or equal to the value set by the configuration constant MODBUS_CFG_FP_START_IX
    629          *              (see MB_CFG.H).
    630          *              You must 'map' the Holding Register to the actual application's corresponding floating-point
    631          *              register.
    632          *
    633          * Arguments  : reg       is the Holding Register number that needs to be read.
    634          *
    635          *              reg_val   is the desired value of the holding register.
    636          *                        The value is specified as an unsigned integer even though it could actually be
    637          *                        represented by a signed integer.
    638          *
    639          *              perr      is a pointer to an error code variable.  You must either return:
    640          *
    641          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    642          *                                            returning its current value.
    643          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    644          *                                            application (i.e. product).  YOUR product defines what the
    645          *                                            valid range of values is for the 'reg' argument.
    646          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    647          *
    648          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    649          *                 registers directly in this function or via a table lookup.  A table lookup would make
    650          *                 sense if you had a lot of Holding Registers in your product.
    651          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    652          *                 MODBUS_ERR_NONE and return 0.
    653          *********************************************************************************************************
    654          */
    655          
    656          #if (MODBUS_CFG_FP_EN    == DEF_ENABLED)
    657          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED) || \
    658              (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    659          void  MB_HoldingRegWrFP (CPU_INT16U   reg,
    660                                   CPU_FP32     reg_val_fp,
    661                                   CPU_INT16U  *perr)
    662          {
    663              (void)reg;
    664              (void)reg_val_fp;
    665                  
    666              /***********************************************
    667              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    668              */
    669              if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
    670                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
    671                  return;
    672              }
    673              
    674              /***********************************************
    675              * 描述： 浮点寄存器
    676              */
    677              CPU_FP32   *preg      = (CPU_FP32 *)&Ctrl.Sen.Para.buf3[0];
    678              reg        = reg - MODBUS_CFG_FP_START_IX;
    679              /***********************************************
    680              * 描述： 获取值
    681              */
    682              if ( reg < sizeof(UnionSenPara) / 4 ) {
    683                  preg    += reg;
    684                  CPU_SR_ALLOC();
    685                  CPU_CRITICAL_ENTER();
    686                  *preg    = reg_val_fp;
    687                  CPU_CRITICAL_EXIT();
    688                  *perr = MODBUS_ERR_NONE;
    689              } else {
    690                  *perr = MODBUS_ERR_RANGE;
    691              }
    692          }
    693          #endif
    694          #endif
    695          
    696          /*$PAGE*/
    697          /*
    698          *********************************************************************************************************
    699          *                              GET A SINGLE ENTRY FROM A RECORD IN A FILE
    700          *
    701          * Description: This function is called to read a single integer from a file.
    702          *              As mentionned in the Modbus specifications, a file is an organization of records.
    703          *              Each file can contain up to 10,000 records (addressed from 0 to 9999).
    704          *              You must 'map' the File/Record/Ix to the actual application's corresponding data.
    705          *
    706          * Arguments  : file_nbr    is the number of the desired file.
    707          *
    708          *              record_nbr  is the desired record within the file
    709          *
    710          *              ix          is the desired entry in the specified record.
    711          *
    712          *              record_len  is the desired length of the record.  Note that this parameter is passed to
    713          *                          this function to provide the 'requested' requested length from the MODBUS command.
    714          *
    715          *              perr        is a pointer to an error code variable.  You must either return:
    716          *
    717          *                          MODBUS_ERR_NONE     the specified file/record/entry is valid and your code is
    718          *                                              returning its current value.
    719          *                          MODBUS_ERR_FILE     if the specified 'file_nbr' is not a valid file number in
    720          *                                              your product.
    721          *                          MODBUS_ERR_RECORD   if the specified 'record_nbr' is not a valid record in the
    722          *                                              specified file.
    723          *                          MODBUS_ERR_IX       if the specified 'ix' is not a valid index into the specified
    724          *                                              record.
    725          *
    726          * Note(s)    : 1) You can perform the mapping of file/record/ix to the application's data directly in
    727          *                 this function or via a table lookup.  A table lookup would make sense if you had a lot
    728          *                 data in your files.
    729          *********************************************************************************************************
    730          */
    731          
    732          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    733          CPU_INT16U  MB_FileRd (CPU_INT16U   file_nbr,
    734                                 CPU_INT16U   record_nbr,
    735                                 CPU_INT16U   ix,
    736                                 CPU_INT08U   record_len,
    737                                 CPU_INT16U  *perr)
    738          {
    739              (void)file_nbr;
    740              (void)record_nbr;
    741              (void)ix;
    742              (void)record_len;
    743              *perr  = MODBUS_ERR_NONE;
   \                     MB_FileRd: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9900             LDR      R1,[SP, #+0]
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    744              return (0);
   \   00000006   0x4770             BX       LR               ;; return
    745          }
    746          #endif
    747          
    748          /*$PAGE*/
    749          /*
    750          *********************************************************************************************************
    751          *                               SET A SINGLE ENTRY OF A RECORD IN A FILE
    752          *
    753          * Description: This function is called to change a single integer value in a file.
    754          *              As mentionned in the Modbus specifications, a file is an organization of records.
    755          *              Each file can contain up to 10,000 records (addressed from 0 to 9999).
    756          *              You must 'map' the File/Record/Ix to the actual application's corresponding data.
    757          *
    758          * Arguments  : file_nbr    is the number of the desired file.
    759          *
    760          *              record_nbr  is the desired record within the file
    761          *
    762          *              ix          is the desired entry in the specified record.
    763          *
    764          *              record_len  is the desired length of the record.  Note that this parameter is passed to
    765          *                          this function to provide the 'requested' requested length from the MODBUS command.
    766          *
    767          *              val         is the new value to place in the file.
    768          *
    769          *              perr        is a pointer to an error code variable.  You must either return:
    770          *
    771          *                          MODBUS_ERR_NONE     the specified file/record/entry is valid and your code is
    772          *                                              returning its current value.
    773          *                          MODBUS_ERR_FILE     if the specified 'file_nbr' is not a valid file number in
    774          *                                              your product.
    775          *                          MODBUS_ERR_RECORD   if the specified 'record_nbr' is not a valid record in the
    776          *                                              specified file.
    777          *                          MODBUS_ERR_IX       if the specified 'ix' is not a valid index into the specified
    778          *                                              record.
    779          *
    780          * Note(s)    : 1) You can perform the mapping of file/record/ix to the application's data directly in
    781          *                 this function or via a table lookup.  A table lookup would make sense if you had a lot
    782          *                 data in your files.
    783          *********************************************************************************************************
    784          */
    785          
    786          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    787          void  MB_FileWr (CPU_INT16U   file_nbr,
    788                           CPU_INT16U   record_nbr,
    789                           CPU_INT16U   ix,
    790                           CPU_INT08U   record_len,
    791                           CPU_INT16U   val,
    792                           CPU_INT16U  *perr)
    793          {
    794              (void)file_nbr;
    795              (void)record_nbr;
    796              (void)ix;
    797              (void)record_len;
    798              (void)val;
    799              *perr = MODBUS_ERR_NONE;
   \                     MB_FileWr: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9901             LDR      R1,[SP, #+4]
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    800          }
   \   00000006   0x4770             BX       LR               ;; return
    801          #endif
    802          
    803          /***********************************************
    804          * 描述： 2015/12/07增加，用于非MODBBUS通信
    805          *        非MODBUS通信，带帧头帧尾的通信数据处理
    806          */
    807          #if MB_NONMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    808          CPU_BOOLEAN NON_MBS_FCxx_Handler (MODBUS_CH  *pch)
    809          {    
    810              /***********************************************
    811              * 描述： 调用串口数据处理回调函数
    812              */
    813              extern INT08U APP_CommRxDataDealCB(MODBUS_CH  *pch);
    814              
    815              return APP_CommRxDataDealCB(pch);
   \                     NON_MBS_FCxx_Handler: (+1)
   \   00000000   0x.... 0x....      B.W      APP_CommRxDataDealCB
    816          }
    817          #endif
    818          
    819          
    820          /***********************************************
    821          * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    822          */
    823          #if MB_IAPMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    824          CPU_BOOLEAN IAP_MBS_FCxx_Handler (MODBUS_CH  *pch)
    825          {    
    826              /***********************************************
    827              * 描述： 调用串口数据处理回调函数
    828              */
    829              extern INT08U IAP_CommRxDataDealCB(MODBUS_CH  *pch);
    830              
    831              return IAP_CommRxDataDealCB(pch);
   \                     IAP_MBS_FCxx_Handler: (+1)
   \   00000000   0x.... 0x....      B.W      IAP_CommRxDataDealCB
    832          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     Ctrl
    833          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IAP_MBS_FCxx_Handler
         0   -> IAP_CommRxDataDealCB
       4   MB_CoilRd
      24   MB_CoilWr
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   MB_FileRd
       0   MB_FileWr
      24   MB_HoldingRegRd
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       4   MB_HoldingRegWr
       0   NON_MBS_FCxx_Handler
         0   -> APP_CommRxDataDealCB


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  IAP_MBS_FCxx_Handler
      66  MB_CoilRd
     102  MB_CoilWr
       8  MB_FileRd
       8  MB_FileWr
      72  MB_HoldingRegRd
      30  MB_HoldingRegWr
       4  NON_MBS_FCxx_Handler
     268  mbData

 
 268 bytes in section .data
 298 bytes in section .text
 
 298 bytes of CODE memory
 268 bytes of DATA memory

Errors: none
Warnings: none
