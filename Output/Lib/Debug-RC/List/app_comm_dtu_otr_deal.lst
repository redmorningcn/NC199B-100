###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:21:27
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-200 主板\Software\APP\comm\app_comm_dtu_otr_deal.c
#    Command line =  
#        "F:\iar\NC199B-200 主板\Software\APP\comm\app_comm_dtu_otr_deal.c" -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\app_comm_dtu_otr_deal.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\app_comm_dtu_otr_deal.o
#
###############################################################################

F:\iar\NC199B-200 主板\Software\APP\comm\app_comm_dtu_otr_deal.c
      1          /*******************************************************************************
      2          *   Filename:       app_comm_dtu_otr_deal.c
      3          *   Revised:        All copyrights reserved to redmorningcn.
      4          *   Revision:       v1.0
      5          *   Writer:	        redmorningcn.
      6          *
      7          *   Description:    双击选中 dtu 按 Ctrl + H, 钩选 Match the case, Replace with
      8          *                   输入您要的名字，点击 Replace All
      9          *                   双击选中 Dtu 按 Ctrl + H, 钩选 Match the case, Replace with
     10          *                   输入您要的名字，点击 Replace All
     11          *                   双击选中 DTU 按 Ctrl + H, 钩选 Match the case, Replace with
     12          *                   输入您要的名字，点击 Replace All
     13          *                   在 app_cfg.h 中指定本任务的 优先级  （ APP_TASK_COMM_PRIO     ）
     14          *                                            和 任务堆栈（ APP_TASK_COMM_STK_SIZE ）大小
     15          *
     16          *   Notes:
     17          *     				E-mail: redmorningcn@qq.com
     18          *
     19          *******************************************************************************/
     20          
     21          /*******************************************************************************
     22          * INCLUDES
     23          */
     24          #define  SNL_APP_SOURCE
     25          #include <includes.h>
     26          #include <app_comm_protocol.h>
     27          #include <app_ctrl.h>
     28          #include <app.h>
     29          #include <os_cfg_app.h>
     30          #include <bsp_FRAM.h>
     31          #include <bsp_DS3231.h>
     32          #include  <global.h>
     33          
     34          
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *app_comm_dtu_otr__c = "$Id: $";
     38          #endif
     39          
     40          #define APP_TASK_COMM_EN     DEF_ENABLED
     41          #if APP_TASK_COMM_EN == DEF_ENABLED
     42          /*******************************************************************************
     43          * CONSTANTS
     44          */
     45          
     46          /*******************************************************************************
     47          * MACROS
     48          */
     49          #define CYCLE_TIME_TICKS            (OS_TICKS_PER_SEC * 1)
     50          
     51          /*******************************************************************************
     52          * TYPEDEFS
     53          */
     54          
     55          #define		DATA_CARD           0x0001			//数据卡-----暂时未用
     56          //#define		DENSITY_CARD		0x0020		//密度卡
     57          #define		AIR_PARA_SET        0x00000020      //空气运算参数设置
     58          
     59          #define		RUN_PARA_SET        0x0040	        //设备运行参数
     60          #define		TIME_CARD           0x00000100			//时间卡-----
     61          #define		COM_MODEL_CARD	    0x0100		    //串口模型卡-暂时未用
     62          //#define		HIGHT_CARD			0x0200			//高度卡-----
     63          #define		MEASURE_ONCE        0x00000200      //启动一次测试
     64          
     65          #define		COPY_CARD           0x0400			//复制卡-----暂时未用
     66          #define		MODEL_SELECT_CARD	0x1000			//模型选择卡-
     67          #define		FIX_CARD            0x00002000		//装车卡-----
     68          #define		COPY_FRAM_CARD	    0x4000			//铁电复制卡-暂时未用
     69          #define		SET_DATA_CARD		0x0080			//置数卡-----按时未用
     70          #define		DEBUG_CARD			0x0800			//调试卡-----暂时未用
     71          
     72          #define		EXPAND_CARD         0x8000			//扩展卡-----暂时未用
     73          #define		DATA_CARD_DIS       0x10000			//数据卡指示
     74          #define		DATA_CARD_FIN       0x20000			//数据卡结束
     75          #define		SYS_RUN_PARA        0x40000			//系统参数卡--暂未使用
     76          #define		CLEAR_ALL           0x00080000		//清零卡，数据记录清零
     77          
     78          #define		RST_SYS             0x00100000		//复位指令
     79          #define		CALC_PARA           0x200000		//计算斜率
     80          #define		RUN_MODEL_PARA      0x400000		//运算模型卡
     81          
     82          #define     OIL_BOX_MODEL_ADDR  2000    //油箱模型存储地址
     83          
     84          
     85          /*******************************************************************************
     86          * LOCAL VARIABLES
     87          */
     88          
     89          /*******************************************************************************
     90          * GLOBAL VARIABLES
     91          */
     92          
     93          /***********************************************
     94          * 描述： 软定时器声明
     95          */
     96          
     97          /***********************************************
     98          * 描述： 软定时器回调函数
     99          */
    100          
    101          
    102          /*******************************************************************************
    103          * LOCAL FUNCTIONS
    104          */
    105          uint8   comm_record_send_one(StrDevDtu * sDtu,uint8 addrnum);
    106          void    comm_record_send(StrDevDtu * sDtu,uint8 addrnum);
    107          void    comm_para_flow(StrDevDtu * sDtu,uint8 addrnum);
    108          uint8	ReadFlshRec(stcFlshRec * sFlshRec,uint32	FlshRecNum);
    109          
    110          //void    Restart(void);
    111          
    112          
    113          
    114          /*******************************************************************************
    115          * GLOBAL FUNCTIONS
    116          */
    117          
    118          /*******************************************************************************
    119          * EXTERN VARIABLES
    120          */
    121          
    122          /*******************************************************************************
    123          * EXTERN FUNCTIONS
    124          */
    125          
    126          void    BSP_DispClrAll(void);       
    127          void    GetOilPara(void);
    128          void    SetDispNow(void);
    129          void    StartAirMeasure(void);
    130          
    131          //uint8   comm_tinyrec_send(StcDevOtr * sOtr,uint8    addrnum);
    132          
    133          /*******************************************************************************/
    134          extern  OS_SEM			Bsp_MeasureSem;    	//信号量
    135          
    136          
    137          /*******************************************************************************
    138          * 名    称： comm_para_flow
    139          * 功    能： 参数流。根据具体参数进行操作
    140          *            
    141          * 入口参数： 无线设备数据结构
    142          * 出口参数： 无
    143          * 作　 　者： redmorningcn.
    144          * 创建日期： 2017-05-19
    145          * 修    改：
    146          * 修改日期：
    147          * 备    注： 任务创建函数需要在app.h文件中声明
    148          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    149          void    comm_para_flow(StrDevDtu * sDtu,uint8 addrnum)
    150          {
   \                     comm_para_flow: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    151              uint32       i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    152              uint32      tmp32;
    153              uint16      crc16;
    154              uint8       bittmp; 
    155              uint8       success = 0;
   \   00000008   0x4635             MOV      R5,R6
    156              
    157              BSP_DispClrAll();                               //清原显示值，立即显示设定值                 
   \   0000000A   0x.... 0x....      BL       BSP_DispClrAll
    158              
    159              switch (sDtu->RxCtrl.DataCode)  
   \   0000000E   0xF8D4 0x0148      LDR      R0,[R4, #+328]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF000 0x8132      BEQ.W    ??comm_para_flow_0
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xD027             BEQ.N    ??comm_para_flow_1
   \   0000001C   0x2840             CMP      R0,#+64
   \   0000001E   0xF000 0x8089      BEQ.W    ??comm_para_flow_2
   \   00000022   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000026   0xF000 0x80B5      BEQ.W    ??comm_para_flow_3
   \   0000002A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000002E   0xF000 0x80C5      BEQ.W    ??comm_para_flow_4
   \   00000032   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000036   0xF000 0x80C6      BEQ.W    ??comm_para_flow_5
   \   0000003A   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000003E   0xF000 0x80D2      BEQ.W    ??comm_para_flow_6
   \   00000042   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000046   0xF000 0x80D6      BEQ.W    ??comm_para_flow_7
   \   0000004A   0xF5B0 0x2F80      CMP      R0,#+262144
   \   0000004E   0xF000 0x8100      BEQ.W    ??comm_para_flow_8
   \   00000052   0xF5B0 0x2F00      CMP      R0,#+524288
   \   00000056   0xF000 0x80DA      BEQ.W    ??comm_para_flow_9
   \   0000005A   0xF5B0 0x1F80      CMP      R0,#+1048576
   \   0000005E   0xF000 0x80E5      BEQ.W    ??comm_para_flow_10
   \   00000062   0xF5B0 0x0F80      CMP      R0,#+4194304
   \   00000066   0xF000 0x810F      BEQ.W    ??comm_para_flow_11
   \   0000006A   0xE118             B.N      ??comm_para_flow_12
    160              {
    161                  //
    162              case    AIR_PARA_SET:                           //空气质量指标参数
    163                  uprintf("test");
   \                     ??comm_para_flow_1: (+1)
   \   0000006C   0x.... 0x....      ADR.W    R6,?_0
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x.... 0x....      BL       uprintf
    164                  uprintf("test");
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       uprintf
    165                  
    166                  if(sDtu->Rd.sAirPara.SetFlg.SetVocStand)    //voc-s
   \   0000007C   0x....             LDR.N    R6,??DataTable11_2
   \   0000007E   0x8C60             LDRH     R0,[R4, #+34]
   \   00000080   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD006             BEQ.N    ??comm_para_flow_13
    167                  {
    168                      memcpy((uint8 *)&Ctrl.Para.dat.sAirPara.sStandard_VOC,
    169                             (uint8 *)&sDtu->Rd.sAirPara.sStandard_VOC,
    170                             sizeof(sDtu->Rd.sAirPara.sStandard_VOC)
    171                                 );
   \   00000088   0x2204             MOVS     R2,#+4
   \   0000008A   0x1D21             ADDS     R1,R4,#+4
   \   0000008C   0xF106 0x0024      ADD      R0,R6,#+36
   \   00000090   0x.... 0x....      BL       __aeabi_memcpy
    172                      success = 1;
   \   00000094   0x2501             MOVS     R5,#+1
    173                  }
    174                  
    175                  if(sDtu->Rd.sAirPara.SetFlg.SetHumStand)    //hum-s
   \                     ??comm_para_flow_13: (+1)
   \   00000096   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   0000009A   0x07C0             LSLS     R0,R0,#+31
   \   0000009C   0xD506             BPL.N    ??comm_para_flow_14
    176                  {
    177                      memcpy((uint8 *)&Ctrl.Para.dat.sAirPara.sStandard_Hum,
    178                             (uint8 *)&sDtu->Rd.sAirPara.sStandard_Hum,
    179                             sizeof(sDtu->Rd.sAirPara.sStandard_Hum)
    180                                 );
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0x4621             MOV      R1,R4
   \   000000A2   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000A6   0x.... 0x....      BL       __aeabi_memcpy
    181                      success = 1;
   \   000000AA   0x2501             MOVS     R5,#+1
    182                  }
    183                  
    184                  if(sDtu->Rd.sAirPara.SetFlg.SetDustStand)   //dust-s
   \                     ??comm_para_flow_14: (+1)
   \   000000AC   0x8C60             LDRH     R0,[R4, #+34]
   \   000000AE   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD007             BEQ.N    ??comm_para_flow_15
    185                  {
    186                      memcpy((uint8 *)&Ctrl.Para.dat.sAirPara.sStandard_Dust,
    187                             (uint8 *)&sDtu->Rd.sAirPara.sStandard_Dust,
    188                             sizeof(sDtu->Rd.sAirPara.sStandard_Dust)
    189                                 );
   \   000000B6   0x2204             MOVS     R2,#+4
   \   000000B8   0xF104 0x0108      ADD      R1,R4,#+8
   \   000000BC   0xF106 0x0028      ADD      R0,R6,#+40
   \   000000C0   0x.... 0x....      BL       __aeabi_memcpy
    190                      success = 1;
   \   000000C4   0x2501             MOVS     R5,#+1
    191                  }
    192                  
    193                  if(sDtu->Rd.sAirPara.SetFlg.SetVocModefy)   //voc-m
   \                     ??comm_para_flow_15: (+1)
   \   000000C6   0x8C60             LDRH     R0,[R4, #+34]
   \   000000C8   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD007             BEQ.N    ??comm_para_flow_16
    194                  {
    195                      memcpy((uint8 *)&Ctrl.Para.dat.sAirPara.Voc_modefy,
    196                             (uint8 *)&sDtu->Rd.sAirPara.Voc_modefy,
    197                             sizeof(sDtu->Rd.sAirPara.Voc_modefy)
    198                                 );
   \   000000D0   0x2202             MOVS     R2,#+2
   \   000000D2   0xF104 0x0112      ADD      R1,R4,#+18
   \   000000D6   0xF106 0x0032      ADD      R0,R6,#+50
   \   000000DA   0x.... 0x....      BL       __aeabi_memcpy
    199                      success = 1;            
   \   000000DE   0x2501             MOVS     R5,#+1
    200                  }
    201                  
    202                  if(sDtu->Rd.sAirPara.SetFlg.SetHumModefy)   //hum-m
   \                     ??comm_para_flow_16: (+1)
   \   000000E0   0x8C60             LDRH     R0,[R4, #+34]
   \   000000E2   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD007             BEQ.N    ??comm_para_flow_17
    203                  {
    204                      memcpy((uint8 *)&Ctrl.Para.dat.sAirPara.Hum_modefy,
    205                             (uint8 *)&sDtu->Rd.sAirPara.Hum_modefy,
    206                             sizeof(sDtu->Rd.sAirPara.Hum_modefy)
    207                                 );
   \   000000EA   0x2202             MOVS     R2,#+2
   \   000000EC   0xF104 0x010E      ADD      R1,R4,#+14
   \   000000F0   0xF106 0x002E      ADD      R0,R6,#+46
   \   000000F4   0x.... 0x....      BL       __aeabi_memcpy
    208                      success = 1;            
   \   000000F8   0x2501             MOVS     R5,#+1
    209                  }
    210                  
    211                  if(sDtu->Rd.sAirPara.SetFlg.SetDustModefy)  //dust-m
   \                     ??comm_para_flow_17: (+1)
   \   000000FA   0x8C60             LDRH     R0,[R4, #+34]
   \   000000FC   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD007             BEQ.N    ??comm_para_flow_18
    212                  {
    213                      memcpy((uint8 *)&Ctrl.Para.dat.sAirPara.Dust_modefy,
    214                             (uint8 *)&sDtu->Rd.sAirPara.Dust_modefy,
    215                             sizeof(sDtu->Rd.sAirPara.Dust_modefy)
    216                                 );
   \   00000104   0x2202             MOVS     R2,#+2
   \   00000106   0xF104 0x0110      ADD      R1,R4,#+16
   \   0000010A   0xF106 0x0030      ADD      R0,R6,#+48
   \   0000010E   0x.... 0x....      BL       __aeabi_memcpy
    217                      success = 1;            
   \   00000112   0x2501             MOVS     R5,#+1
    218                  }
    219                  
    220                  
    221                  crc16 = GetCrc16Check((uint8 *)&Ctrl.Para.dat.sAirPara,sizeof(stcAirPara) - 2); 
    222                  Ctrl.Para.dat.sAirPara.crc16 = crc16;
   \                     ??comm_para_flow_18: (+1)
   \   00000114   0x2126             MOVS     R1,#+38
   \   00000116   0xF106 0x0020      ADD      R0,R6,#+32
   \   0000011A   0x.... 0x....      BL       GetCrc16Check
   \   0000011E   0xF8A6 0x0046      STRH     R0,[R6, #+70]
    223                  
    224                  FRAM_StoreAirPara(&Ctrl.Para.dat.sAirPara);
   \   00000122   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000126   0x.... 0x....      BL       FRAM_StoreAirPara
    225                  FRAM_ReadAirPara (&Ctrl.Para.dat.sAirPara);
   \   0000012A   0xF106 0x0020      ADD      R0,R6,#+32
   \   0000012E   0x.... 0x....      BL       FRAM_ReadAirPara
    226          
    227                  //        Ctrl.SOilPara.Density = sDtu->Rd.Density;          
    228                  //        
    229                  //        FRAM_StoreOilPara((StrOilPara *)&Ctrl.SOilPara);   //存数据。关键数据存储时保护
    230                  //        
    231                  //        uprintf("%8d",Ctrl.SOilPara.Density);   //立即显示设定值 
    232                  
    233                  break;
   \   00000132   0xE0B4             B.N      ??comm_para_flow_12
    234                  
    235                  
    236              case    RUN_PARA_SET:                               //运行参数设定
    237                  
    238                  
    239                  if(sDtu->Rd.sRunPara.setflg.MeasureSecond == 1)   //测量L期时间
   \                     ??comm_para_flow_2: (+1)
   \   00000134   0x6A60             LDR      R0,[R4, #+36]
   \   00000136   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD007             BEQ.N    ??comm_para_flow_19
    240                  {
    241                      if(sDtu->Rd.sRunPara.MeasureSecond < 30 && sDtu->Rd.sRunPara.MeasureSecond > 0)
   \   0000013E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000140   0x281E             CMP      R0,#+30
   \   00000142   0xDA04             BGE.N    ??comm_para_flow_19
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD002             BEQ.N    ??comm_para_flow_19
    242                      {
    243                          Ctrl.Para.dat.sRunPara.MeasureSecond = sDtu->Rd.sRunPara.MeasureSecond;
   \   00000148   0x....             LDR.N    R1,??DataTable11_3
   \   0000014A   0x7288             STRB     R0,[R1, #+10]
    244                          success = 1;
   \   0000014C   0x2501             MOVS     R5,#+1
    245                      }
    246                  }
    247                  
    248                  if(sDtu->Rd.sRunPara.setflg.MeasureMin == 1)   //测量^程时间
   \                     ??comm_para_flow_19: (+1)
   \   0000014E   0x6A60             LDR      R0,[R4, #+36]
   \   00000150   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD007             BEQ.N    ??comm_para_flow_20
    249                  {
    250                      if(sDtu->Rd.sRunPara.MeasureMin < 15 && sDtu->Rd.sRunPara.MeasureMin > 0)
   \   00000158   0x7A60             LDRB     R0,[R4, #+9]
   \   0000015A   0x280F             CMP      R0,#+15
   \   0000015C   0xDA04             BGE.N    ??comm_para_flow_20
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD002             BEQ.N    ??comm_para_flow_20
    251                      {
    252                          Ctrl.Para.dat.sRunPara.MeasureMin = sDtu->Rd.sRunPara.MeasureMin;
   \   00000162   0x....             LDR.N    R1,??DataTable11_3
   \   00000164   0x72C8             STRB     R0,[R1, #+11]
    253                          success = 1;
   \   00000166   0x2501             MOVS     R5,#+1
    254                      }
    255          
    256                  }
    257          
    258                  if(sDtu->Rd.sRunPara.setflg.StoreCycle == 1)   //存
   \                     ??comm_para_flow_20: (+1)
   \   00000168   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000016C   0x07C0             LSLS     R0,R0,#+31
   \   0000016E   0xD507             BPL.N    ??comm_para_flow_21
    259                  {
    260                      if(sDtu->Rd.sRunPara.StoreCycle < 60 && sDtu->Rd.sRunPara.StoreCycle > 0)
   \   00000170   0x7820             LDRB     R0,[R4, #+0]
   \   00000172   0x283C             CMP      R0,#+60
   \   00000174   0xDA04             BGE.N    ??comm_para_flow_21
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD002             BEQ.N    ??comm_para_flow_21
    261                      {
    262                          Ctrl.Para.dat.sRunPara.StoreCycle = sDtu->Rd.sRunPara.StoreCycle;
   \   0000017A   0x....             LDR.N    R1,??DataTable11_3
   \   0000017C   0x7088             STRB     R0,[R1, #+2]
    263                          success = 1;
   \   0000017E   0x2501             MOVS     R5,#+1
    264                      }
    265                  }    
    266                  
    267                  FRAM_StoreRunPara(&Ctrl.Para.dat.sRunPara);     //存运算参数。
   \                     ??comm_para_flow_21: (+1)
   \   00000180   0x....             LDR.N    R6,??DataTable11_2
   \   00000182   0xF106 0x0048      ADD      R0,R6,#+72
   \   00000186   0x.... 0x....      BL       FRAM_StoreRunPara
    268                  FRAM_ReadRunPara(&Ctrl.Para.dat.sRunPara);
   \   0000018A   0xF106 0x0048      ADD      R0,R6,#+72
   \   0000018E   0x.... 0x....      BL       FRAM_ReadRunPara
    269                  
    270                  break;
   \   00000192   0xE084             B.N      ??comm_para_flow_12
   \                     ??comm_para_flow_3: (+1)
   \   00000194   0x4668             MOV      R0,SP
   \   00000196   0x4621             MOV      R1,R4
   \   00000198   0x2206             MOVS     R2,#+6
   \   0000019A   0x.... 0x....      BL       __aeabi_memcpy
    271          
    272                  //设置时间
    273              case    TIME_CARD:                
    274                  
    275                  WriteTime(sDtu->Rd.sTime);          
   \   0000019E   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000001A2   0x.... 0x....      BL       WriteTime
    276                  ReadTime((stcTime *)&sDtu->Rd.sTime);
   \   000001A6   0x4620             MOV      R0,R4
   \   000001A8   0x.... 0x....      BL       ReadTime
    277                  
    278                  
    279                  //        uprintf("%02d-%02d-%02d",sTime.Year
    280                  //                ,sTime.Month
    281                  //                    ,sTime.Date
    282                  //                        );     
    283                  //        uprintf("%02d-%02d-%02d",sTime.Hour
    284                  //                ,sTime.Min
    285                  //                    ,sTime.Sec
    286                  //                        );          
    287                  uprintf("%02d.%02d" ,sDtu->Rd.sTime.Hour
    288                          ,sDtu->Rd.sTime.Min
    289                              );   
   \   000001AC   0x7862             LDRB     R2,[R4, #+1]
   \   000001AE   0x78A1             LDRB     R1,[R4, #+2]
   \   000001B0   0x.... 0x....      ADR.W    R0,?_1
   \   000001B4   0x.... 0x....      BL       uprintf
    290          
    291                  success = 1;
   \   000001B8   0x2501             MOVS     R5,#+1
    292          
    293                  break;
   \   000001BA   0xE070             B.N      ??comm_para_flow_12
    294                  
    295                  //高度卡
    296              case    MEASURE_ONCE: 
    297          
    298                  BSP_OS_SemPost(&Bsp_MeasureSem);   
   \                     ??comm_para_flow_4: (+1)
   \   000001BC   0x....             LDR.N    R0,??DataTable11_4
   \   000001BE   0x.... 0x....      BL       BSP_OS_SemPost
    299                  success = 1;
   \   000001C2   0x2501             MOVS     R5,#+1
    300                  break;
   \   000001C4   0xE06B             B.N      ??comm_para_flow_12
    301                  
    302                  //模型选择卡
    303              case    MODEL_SELECT_CARD:   
    304                  //        Ctrl.SOilPara.ModelNum = sDtu->Rd.ModelNum;//选择的模型编号
    305                  //        
    306                  //        FRAM_StoreOilPara((StrOilPara *)&Ctrl.SOilPara);   //存数据。关键数据存储时保护
    307                  //        
    308                  //        uprintf("%8d",Ctrl.SOilPara.ModelNum);      //立即显示设定值 
    309                  break;
    310                  
    311                  //车型车号
    312              case    FIX_CARD: 
    313                  Ctrl.Para.dat.sProductInfo.sLocoId.Num = sDtu->Rd.sLocoId.Num;
   \                     ??comm_para_flow_5: (+1)
   \   000001C6   0x....             LDR.N    R6,??DataTable11_2
   \   000001C8   0x1D35             ADDS     R5,R6,#+4
   \   000001CA   0x8860             LDRH     R0,[R4, #+2]
   \   000001CC   0x8368             STRH     R0,[R5, #+26]
    314                  Ctrl.Para.dat.sProductInfo.sLocoId.Type = sDtu->Rd.sLocoId.Type;
   \   000001CE   0x8820             LDRH     R0,[R4, #+0]
   \   000001D0   0x8328             STRH     R0,[R5, #+24]
    315                  
    316                  FRAM_StoreProductInfo((stcProductInfo *)&Ctrl.Para.dat.sProductInfo);
   \   000001D2   0xF106 0x0014      ADD      R0,R6,#+20
   \   000001D6   0x.... 0x....      BL       FRAM_StoreProductInfo
    317                  
    318                  uprintf("%4d",Ctrl.Para.dat.sProductInfo.sLocoId.Num
    319                              );
   \   000001DA   0x8B69             LDRH     R1,[R5, #+26]
   \   000001DC   0x....             ADR.N    R0,??DataTable11  ;; "%4d"
   \   000001DE   0x.... 0x....      BL       uprintf
    320                  
    321                  success = 1;
   \   000001E2   0x2501             MOVS     R5,#+1
    322          
    323                  break;
   \   000001E4   0xE05B             B.N      ??comm_para_flow_12
    324                  
    325                  //读数据指示
    326              case    DATA_CARD_DIS: 
    327                  i=0;
    328                  while(i < 4)
   \                     ??comm_para_flow_6: (+1)
   \   000001E6   0x2E04             CMP      R6,#+4
   \   000001E8   0xD259             BCS.N    ??comm_para_flow_12
    329                  {
    330                      uprintf("%8d",i); 
   \   000001EA   0x4631             MOV      R1,R6
   \   000001EC   0x....             ADR.N    R0,??DataTable11_1  ;; "%8d"
   \   000001EE   0x.... 0x....      BL       uprintf
    331                      i++;
   \   000001F2   0x1C76             ADDS     R6,R6,#+1
   \   000001F4   0xE7F7             B.N      ??comm_para_flow_6
    332                  }
    333                  break;
    334                  
    335                  //读数据指示结束
    336              case    DATA_CARD_FIN: 
    337                  i=0;
    338                  while(i < 4)
   \                     ??comm_para_flow_7: (+1)
   \   000001F6   0x2E04             CMP      R6,#+4
   \   000001F8   0xD251             BCS.N    ??comm_para_flow_12
    339                  {
    340                      uprintf("    good");  
   \   000001FA   0x.... 0x....      ADR.W    R0,?_4
   \   000001FE   0x.... 0x....      BL       uprintf
    341                      uprintf("         ");  
   \   00000202   0x.... 0x....      ADR.W    R0,?_5
   \   00000206   0x.... 0x....      BL       uprintf
    342                      i++;
   \   0000020A   0x1C76             ADDS     R6,R6,#+1
   \   0000020C   0xE7F3             B.N      ??comm_para_flow_7
    343                  }
    344                  break;
    345                  
    346                  //数据清零
    347              case    CLEAR_ALL: 
    348                  Ctrl.Para.dat.sRecNumMgr.Current = 0;
   \                     ??comm_para_flow_9: (+1)
   \   0000020E   0x....             LDR.N    R6,??DataTable11_2
   \   00000210   0x1D35             ADDS     R5,R6,#+4
   \   00000212   0x2000             MOVS     R0,#+0
   \   00000214   0x6028             STR      R0,[R5, #+0]
    349                  Ctrl.Para.dat.sRecNumMgr.GrsRead = 0;
   \   00000216   0x60A8             STR      R0,[R5, #+8]
    350                  Ctrl.Para.dat.sRecNumMgr.IcRead  = 0;
   \   00000218   0x6068             STR      R0,[R5, #+4]
    351                  
    352                  FRAM_StoreRecNumMgr((stcRecNumMgr *)&Ctrl.Para.dat.sRecNumMgr);
   \   0000021A   0x4628             MOV      R0,R5
   \   0000021C   0x.... 0x....      BL       FRAM_StoreRecNumMgr
    353                  
    354                  uprintf("CALL");  
   \   00000220   0x.... 0x....      ADR.W    R0,?_6
   \   00000224   0x.... 0x....      BL       uprintf
    355                  success = 1;
   \   00000228   0x2501             MOVS     R5,#+1
    356          
    357                  break;
   \   0000022A   0xE038             B.N      ??comm_para_flow_12
    358                  
    359                  //装置复位，先应答消息，再
    360              case    RST_SYS:
    361                  
    362                  //参数设置，数据原路返回
    363                  CSNC_SendData(  Ctrl.Dtu.pch,                      //DTU 的PCH：串口号，收发控制等底层信息
    364                                Ctrl.Dtu.RxCtrl.DestAddr,          //源地址，
    365                                Ctrl.Dtu.RxCtrl.SourceAddr,        //目标地址
    366                                Ctrl.Dtu.RxCtrl.FramNum,           //帧序号 
    367                                Ctrl.Dtu.RxCtrl.FrameCode,         //命令字
    368                                Ctrl.Dtu.Rd.Buf,                   //数据区
    369                                Ctrl.Dtu.RxCtrl.Len                //发送长度
    370                                    );
   \                     ??comm_para_flow_10: (+1)
   \   0000022C   0x....             LDR.N    R6,??DataTable11_2
   \   0000022E   0xF206 0x4021      ADDW     R0,R6,#+1057
   \   00000232   0x78C1             LDRB     R1,[R0, #+3]
   \   00000234   0x9102             STR      R1,[SP, #+8]
   \   00000236   0xF206 0x21E1      ADDW     R1,R6,#+737
   \   0000023A   0x9101             STR      R1,[SP, #+4]
   \   0000023C   0x7901             LDRB     R1,[R0, #+4]
   \   0000023E   0x9100             STR      R1,[SP, #+0]
   \   00000240   0x7883             LDRB     R3,[R0, #+2]
   \   00000242   0x7842             LDRB     R2,[R0, #+1]
   \   00000244   0x7801             LDRB     R1,[R0, #+0]
   \   00000246   0x69C0             LDR      R0,[R0, #+28]
   \   00000248   0x.... 0x....      BL       CSNC_SendData
    371                  
    372                  //重启复位
    373                  void Boot( void );
    374                  Boot();
   \   0000024C   0x.... 0x....      BL       Boot
    375                  //        void JMP_Boot(u32 appAddr);
    376                  //        JMP_Boot(STM32_FLASH_BASE);
    377                  //Restart();                                          //重启系统
    378                  break;
   \   00000250   0xE025             B.N      ??comm_para_flow_12
    379                  
    380                  //设置斜率
    381              case    CALC_PARA: 
    382                  //斜率具有镭计的效果
    383                  //        Ctrl.SOilPara.Slope = (Ctrl.SOilPara.Slope  * sDtu->Rd.Slope)/10000;
    384                  //        
    385                  //        //0.1~2
    386                  //        if(Ctrl.SOilPara.Slope >20000 || Ctrl.SOilPara.Slope < 1000)
    387                  //            Ctrl.SOilPara.Slope = 10000;
    388                  //        
    389                  //        FRAM_StoreOilPara((StrOilPara *)&Ctrl.SOilPara);   //存数据。关键数据存储时保护
    390                  //        
    391                  //        uprintf("%d",Ctrl.SOilPara.Slope);         //立即显示设定值 
    392                  break;
    393                  
    394                  /***********************************************
    395                  * 描述： 设置油箱模型。
    396                  *   IC 卡模块插入IC卡后，IC卡主动应答模型。  
    397                  *   后续每200ms发送数据，序号从0开始累加。
    398                  数据发送完成后，序号为0xffffffff。
    399                  */    
    400                  //设置斜率
    401              case    SYS_RUN_PARA: 
    402                  //存运行参数，存储时间，数据格式等信息
    403                  //FRAM_StoreRunPara((stcRunPara *)&Ctrl.sRunPara);   //存数据。关键数据存储时保护
    404                  bittmp =  (uint8)(0x01 << ( ( (uint8 *)&Ctrl.Para.dat.sRunPara.StoreType ) - (uint8 *)&Ctrl.Para.dat.sRunPara));    //数据格式更改
    405                  
    406                  if((sDtu->Rd.sRunPara.SetBitFlg & bittmp) == bittmp )
   \                     ??comm_para_flow_8: (+1)
   \   00000252   0x....             LDR.N    R6,??DataTable11_2
   \   00000254   0xF106 0x0746      ADD      R7,R6,#+70
   \   00000258   0x79E0             LDRB     R0,[R4, #+7]
   \   0000025A   0x0680             LSLS     R0,R0,#+26
   \   0000025C   0xD504             BPL.N    ??comm_para_flow_22
    407                  {
    408                      Ctrl.Para.dat.sRunPara.StoreType    = sDtu->Rd.sRunPara.StoreType;
   \   0000025E   0x7960             LDRB     R0,[R4, #+5]
   \   00000260   0x71F8             STRB     R0,[R7, #+7]
    409                      Ctrl.Para.dat.sRunPara.StoreTypeBak = sDtu->Rd.sRunPara.StoreTypeBak;
   \   00000262   0x79A0             LDRB     R0,[R4, #+6]
   \   00000264   0x7238             STRB     R0,[R7, #+8]
    410                      success = 1;
   \   00000266   0x2501             MOVS     R5,#+1
    411          
    412                  }
    413                  
    414                  FRAM_StoreRunPara((stcRunPara *)&Ctrl.Para.dat.sRunPara);   //存数据。关键数据存储时保护
   \                     ??comm_para_flow_22: (+1)
   \   00000268   0xF106 0x0048      ADD      R0,R6,#+72
   \   0000026C   0x.... 0x....      BL       FRAM_StoreRunPara
    415                  uprintf("rt-%d",    Ctrl.Para.dat.sRunPara.StoreType);      //立即显示设定值 （0x02 ）数据新版
   \   00000270   0x79F9             LDRB     R1,[R7, #+7]
   \   00000272   0x.... 0x....      ADR.W    R0,?_7
   \   00000276   0x.... 0x....      BL       uprintf
    416                  
    417                  break;
   \   0000027A   0xE010             B.N      ??comm_para_flow_12
    418                  
    419                  
    420                  //数据
    421              case    DATA_CARD: 
    422                  
    423                   osal_start_timerEx(  OS_TASK_ID_TMR,     //计数器重新开始
    424                                        OS_EVT_TMR_DTU,
    425                                        100); 
   \                     ??comm_para_flow_0: (+1)
   \   0000027C   0x2264             MOVS     R2,#+100
   \   0000027E   0x2102             MOVS     R1,#+2
   \   00000280   0x2001             MOVS     R0,#+1
   \   00000282   0x.... 0x....      BL       osal_start_timerEx
    426                  //        
    427                  //        memcpy((uint8 *)&tmp32,sDtu->Rd.Buf,sizeof(tmp32));     //请求流水号
    428                  //        if(sDtu->RxCtrl.SourceAddr == SLAVE_ADDR_DTU)           //无线通道请求的
    429                  //        {
    430                  //            if(Ctrl.Para.dat.sRecNumMgr.GrsRead  > tmp32){
    431                  //                Ctrl.Para.dat.sRecNumMgr.GrsRead = tmp32;               //指定位置取数据
    432                  //            }
    433                  //            
    434                  //            comm_record_send_one(sDtu,addrnum);                 
    435                  //            
    436                  //            FRAM_StoreRecNumMgr((stcRecNumMgr *)&Ctrl.Para.dat.sRecNumMgr);         //保存记录号
    437                  //            
    438                  //            Ctrl.Para.dat.sRecNumMgr.GrsRead++;
    439                  //            
    440                  //        }else if(sDtu->RxCtrl.SourceAddr == SLAVE_ADDR_OTR)     //IC卡
    441                  //        {
    442                  //            if(Ctrl.Para.dat.sRecNumMgr.IcRead  > tmp32){
    443                  //                Ctrl.Para.dat.sRecNumMgr.IcRead = tmp32;                //指定位置取数据
    444                  //            }
    445                  //            
    446                  //            comm_record_send_one(sDtu,addrnum);                 //指定位置取数据   
    447                  //            
    448                  //            FRAM_StoreRecNumMgr((stcRecNumMgr *)&Ctrl.Para.dat.sRecNumMgr); //保存记录号
    449                  //            
    450                  //            Ctrl.Para.dat.sRecNumMgr.IcRead++;           
    451                  //            
    452                  //            //快速启动定时器
    453                  //            if(Ctrl.Para.dat.sRecNumMgr.IcRead < Ctrl.Para.dat.sRecNumMgr.Current ){
    454                  //                osal_start_timerRl( OS_TASK_ID_TMR, 
    455                  //                                   OS_EVT_TMR_OTR, 
    456                  //                                   OS_TICKS_PER_SEC/2 );          //统计装置和无线发送模块定时器  10s
    457                  //            }
    458                  //            
    459                  //        }
    460                  break;
   \   00000286   0xE00A             B.N      ??comm_para_flow_12
    461                  
    462              case    RUN_MODEL_PARA:
    463                  
    464                  uprintf("SET--");         //立即显示设定值 
   \                     ??comm_para_flow_11: (+1)
   \   00000288   0x.... 0x....      ADR.W    R0,?_8
   \   0000028C   0x.... 0x....      BL       uprintf
    465                  SetDispNow();
   \   00000290   0x.... 0x....      BL       SetDispNow
    466                  
    467                  memcpy((uint8 *)&tmp32, &sDtu->Rd.Buf[0],sizeof(tmp32));        //取帧序号
   \   00000294   0x2204             MOVS     R2,#+4
   \   00000296   0x4621             MOV      R1,R4
   \   00000298   0xA803             ADD      R0,SP,#+12
   \   0000029A   0x.... 0x....      BL       __aeabi_memcpy
    468                  //        if(tmp32 < (1 + sizeof(l_sCalcModel)/128 ))                     //序号有效
    469                  //        {
    470                  //            p = (uint8 *)&l_sCalcModel;
    471                  //            memcpy((uint8 *)(  p + 128*tmp32),
    472                  //                               (uint8 *)&sDtu->Rd.Buf[4],
    473                  //                               sDtu->RxCtrl.Len-4);
    474                  //            
    475                  //            if(tmp32 == sizeof(l_sCalcModel)/128)               //接收完成
    476                  //            {
    477                  //                crc16 = GetCrc16Check((uint8 *)&l_sCalcModel,sizeof(l_sCalcModel)-2);   //计算校验
    478                  //                if(crc16 == l_sCalcModel.CrcCheck)              //模型校验通过，赋值给计算使用
    479                  //                {
    480                  //                    l_sCalcModel.valid = 1;                     //置模型有效位
    481                  //                    
    482                  //                    l_sCalcModel.CrcCheck = GetCrc16Check((uint8 *)&l_sCalcModel,sizeof(l_sCalcModel)-2); 
    483                  //                    
    484                  //                    memcpy((uint8 *)&Ctrl.sCalcModel,(uint8 *)&l_sCalcModel,sizeof(l_sCalcModel)); //赋值给正在使用的模型。
    485                  //                    
    486                  //                    FRAM_StoreCalcModel(&Ctrl.sCalcModel);
    487                  //                }
    488                  //                
    489                  //                //设置成功后，指示
    490                  //                uprintf("SET-%d",l_sCalcModel.ModelNum);         //立即显示设定值 
    491                  //                SetDispNow();
    492                  //                tmp32 = 1000000;
    493                  //                while(tmp32--);
    494                  //                uprintf("SET-%d",l_sCalcModel.ModelNum);         //立即显示设定值 
    495                  //                SetDispNow();
    496                  //            }
    497                  //        }
    498                  
    499                  break;
    500                  
    501              default:
    502                  break;
    503                  
    504              }
    505              
    506              if( success == 1)   //
   \                     ??comm_para_flow_12: (+1)
   \   0000029E   0x2D01             CMP      R5,#+1
   \   000002A0   0xD101             BNE.N    ??comm_para_flow_23
    507              
    508              SetDispNow();
   \   000002A2   0x.... 0x....      BL       SetDispNow
    509          
    510          }
   \                     ??comm_para_flow_23: (+1)
   \   000002A6   0xB005             ADD      SP,SP,#+20
   \   000002A8   0xBDF0             POP      {R4-R7,PC}       ;; return
    511          
    512          /*******************************************************************************
    513          * 名    称： comm_record_send_one
    514          * 功    能： 发送one条数据记录
    515          * 入口参数： 无线设备数据结构
    516          * 出口参数： 无
    517          * 作　 　者： redmorningcn.
    518          * 创建日期： 2017-05-19
    519          * 修    改：
    520          * 修改日期：
    521          * 备    注： 任务创建函数需要在app.h文件中声明
    522          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    523          uint8    comm_record_send_one(StrDevDtu * sDtu,uint8    addrnum)
    524          {
   \                     comm_record_send_one: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
    525              //记录号为0，还未发送数据。不做通讯状态判断
    526              if( Ctrl.Para.dat.sRecNumMgr.Current == 0 )                                   
   \   00000006   0x....             LDR.N    R5,??DataTable11_2
   \   00000008   0x6868             LDR      R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??comm_record_send_one_0
    527              {
    528                  return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE02C             B.N      ??comm_record_send_one_1
    529              }
   \                     ??comm_record_send_one_0: (+1)
   \   00000012   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \   00000016   0xF501 0x76A8      ADD      R6,R1,#+336
   \   0000001A   0x7831             LDRB     R1,[R6, #+0]
   \   0000001C   0x29CA             CMP      R1,#+202
   \   0000001E   0xD116             BNE.N    ??comm_record_send_one_2
    530              /***********************************************
    531              * 描述： 记录号合理性判断。已发数据<当前数据 发送数据
    532              * 
    533              */ 
    534              if(sDtu->ConnCtrl[addrnum].SlaveAddr == SLAVE_ADDR_DTU)
    535              {
    536                  if(Ctrl.Para.dat.sRecNumMgr.Current <= Ctrl.Para.dat.sRecNumMgr.GrsRead )               //已发送记录号比当前记录号大，进行异常处理
   \   00000020   0x68E9             LDR      R1,[R5, #+12]
   \   00000022   0x4281             CMP      R1,R0
   \   00000024   0xD308             BCC.N    ??comm_record_send_one_3
    537                  {
    538                      Ctrl.Para.dat.sRecNumMgr.GrsRead = 0;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x60E9             STR      R1,[R5, #+12]
    539                      if(Ctrl.Para.dat.sRecNumMgr.Current)
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??comm_record_send_one_4
    540                          Ctrl.Para.dat.sRecNumMgr.GrsRead = Ctrl.Para.dat.sRecNumMgr.Current - 1;        //最后有效记录赋值     
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x60E8             STR      R0,[R5, #+12]
    541                      
    542                      FRAM_StoreRecNumMgr((stcRecNumMgr *)&Ctrl.Para.dat.sRecNumMgr);             //保存记录号
   \                     ??comm_record_send_one_4: (+1)
   \   00000032   0x1D28             ADDS     R0,R5,#+4
   \   00000034   0x.... 0x....      BL       FRAM_StoreRecNumMgr
    543                  }
    544                  
    545                  //sDtu->ConnCtrl[addrnum].SendFramNum++;                                //发送序号由接收控制
    546                  
    547                  /***********************************************
    548                  * 描述： 数据记录准备,根据记录号取数据记录。
    549                  * 
    550                  */ 
    551                  ReadFlshRec((stcFlshRec *)&sDtu->Wr.sRec,
    552                              Ctrl.Para.dat.sRecNumMgr.GrsRead);
   \                     ??comm_record_send_one_3: (+1)
   \   00000038   0x68E9             LDR      R1,[R5, #+12]
   \   0000003A   0xF104 0x00A0      ADD      R0,R4,#+160
   \   0000003E   0x.... 0x....      BL       ReadFlshRec
    553                  
    554                  //重新给定时器给初值。osal_start_timerRl可以自动赋值，
    555                  osal_start_timerRl( OS_TASK_ID_TMR, 
    556                                     OS_EVT_TMR_DTU, 
    557                                     OS_TICKS_PER_SEC*10 );  //统计装置和无线发送模块定时器  10s
   \   00000042   0xF242 0x7210      MOVW     R2,#+10000
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       osal_start_timerRl
    558              }
    559              
    560              //    if(sDtu->ConnCtrl[addrnum].SlaveAddr == SLAVE_ADDR_OTR)
    561              //    {
    562              //        if(Ctrl.Para.dat.sRecNumMgr.Current <= Ctrl.Para.dat.sRecNumMgr.IcRead )                //已发送记录号比当前记录号大，进行异常处理
    563              //        {
    564              //            Ctrl.Para.dat.sRecNumMgr.IcRead = 0;
    565              //            if(Ctrl.Para.dat.sRecNumMgr.Current)
    566              //                Ctrl.Para.dat.sRecNumMgr.IcRead = Ctrl.Para.dat.sRecNumMgr.Current - 1;         //最后有效记录赋值     
    567              //            
    568              //            Ctrl.Otr.ConnCtrl[addrnum].SendFramNum++;
    569              //            FRAM_StoreRecNumMgr((stcRecNumMgr *)&Ctrl.Para.dat.sRecNumMgr);             //保存记录号
    570              //        }
    571              //        
    572              //        /***********************************************
    573              //        * 描述： 数据记录准备,根据记录号取数据记录。
    574              //        * 
    575              //        */ 
    576              //        ReadFlshRec((stcFlshRec *)&sDtu->Wr.sRec,
    577              //                    Ctrl.Para.dat.sRecNumMgr.IcRead);
    578              //        
    579              //        osal_start_timerRl( OS_TASK_ID_TMR, 
    580              //                           OS_EVT_TMR_OTR, 
    581              //                           OS_TICKS_PER_SEC*10 );               //统计装置和无线发送模块定时器  10s
    582              //    }
    583              
    584              uint8   framecode = 0x02;
    585              
    586              //    //超时值发送SLAVE_ADDR_DTU 的数据
    587              //    CSNC_SendData(sDtu->pch,                                    //DTU 的PCH：串口号，收发控制等底层信息
    588              //                  sDtu->ConnCtrl[addrnum].MasterAddr,           //源地址，
    589              //                  sDtu->ConnCtrl[addrnum].SlaveAddr,            //目标地址
    590              //                  sDtu->ConnCtrl[addrnum].SendFramNum,          //帧序号 ，，在接收中累加
    591              //                  framecode,                                    //命令字
    592              //                  (uint8 *)&sDtu->Wr.sRec,                      //数据区
    593              //                  sizeof(sDtu->Wr.sRec)                        //发送长度
    594              //                      );
    595              
    596              CSNC_SendData(sDtu->pch,                                    //DTU 的PCH：串口号，收发控制等底层信息
    597                            sDtu->ConnCtrl[addrnum].MasterAddr,           //源地址，
    598                            sDtu->ConnCtrl[addrnum].SlaveAddr,            //目标地址
    599                            sDtu->ConnCtrl[addrnum].SendFramNum,          //帧序号 ，，在接收中累加
    600                            framecode,                                    //命令字
    601                            (uint8 *)&sDtu->Wr.sRec,                      //数据区
    602                            sizeof(sDtu->Wr.sRec)                        //发送长度
    603                                );
   \                     ??comm_record_send_one_2: (+1)
   \   0000004E   0x2080             MOVS     R0,#+128
   \   00000050   0x9002             STR      R0,[SP, #+8]
   \   00000052   0xF104 0x00A0      ADD      R0,R4,#+160
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x78B3             LDRB     R3,[R6, #+2]
   \   0000005E   0x7832             LDRB     R2,[R6, #+0]
   \   00000060   0x7871             LDRB     R1,[R6, #+1]
   \   00000062   0xF8D4 0x015C      LDR      R0,[R4, #+348]
   \   00000066   0x.... 0x....      BL       CSNC_SendData
    604              
    605              
    606              return 1;
   \   0000006A   0x2001             MOVS     R0,#+1
   \                     ??comm_record_send_one_1: (+1)
   \   0000006C   0xB004             ADD      SP,SP,#+16
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    607          }
    608          
    609          
    610          /*******************************************************************************
    611          * 名    称： comm_record_send
    612          * 功    能： 通讯数据传输
    613          *            先查询已发送记录，然后发送该记录。记录号加1，帧号加1。起始记录号
    614          从1开始。  
    615          *              （通过帧号判断通讯是否结束正确）
    616          * 入口参数： 无线设备数据结构
    617          * 出口参数： 无
    618          * 作　 　者： redmorningcn.
    619          * 创建日期： 2017-05-19
    620          * 修    改：
    621          * 修改日期：
    622          * 备    注： 任务创建函数需要在app.h文件中声明
    623          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          void    comm_record_send(StrDevDtu * sDtu,uint8 addrnum)
    625          {
   \                     comm_record_send: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xEB04 0x00C5      ADD      R0,R4,R5, LSL #+3
   \   0000000A   0xF890 0x1152      LDRB     R1,[R0, #+338]
   \   0000000E   0xF894 0x2142      LDRB     R2,[R4, #+322]
   \   00000012   0x428A             CMP      R2,R1
   \   00000014   0xD123             BNE.N    ??comm_record_send_0
    626              /***********************************************
    627              * 描述： 发送和接收的记录号相符，发送流水号加1
    628              *       再根据数据量，发送数据。
    629              * 
    630              */      
    631              
    632              if(sDtu->RxCtrl.FramNum == sDtu->ConnCtrl[addrnum].SendFramNum){
    633                  sDtu->ConnCtrl[addrnum].SendFramNum++;                  //数据正确，序号加1
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xF880 0x1152      STRB     R1,[R0, #+338]
    634                  Ctrl.Para.dat.sRecNumMgr.GrsRead++;
   \   0000001C   0x....             LDR.N    R6,??DataTable11_2
   \   0000001E   0x68F0             LDR      R0,[R6, #+12]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x60F0             STR      R0,[R6, #+12]
    635                  
    636                  CPU_SR  cpu_sr;
    637                  CPU_CRITICAL_ENTER() ;
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x4607             MOV      R7,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
    638                  FRAM_StoreRecNumMgr((stcRecNumMgr *)&Ctrl.Para.dat.sRecNumMgr); //保存记录号
   \   0000002E   0x1D30             ADDS     R0,R6,#+4
   \   00000030   0x.... 0x....      BL       FRAM_StoreRecNumMgr
    639                  CPU_CRITICAL_EXIT() ;
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000038   0x4638             MOV      R0,R7
   \   0000003A   0x.... 0x....      BL       CPU_SR_Restore
    640                  
    641                  if(Ctrl.Para.dat.sRecNumMgr.GrsRead < Ctrl.Para.dat.sRecNumMgr.Current) //数据还未发送完成。收到数据及发送。
   \   0000003E   0x68F0             LDR      R0,[R6, #+12]
   \   00000040   0x6871             LDR      R1,[R6, #+4]
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD20B             BCS.N    ??comm_record_send_0
    642                  {
    643                      comm_record_send_one(sDtu,addrnum);                 //发送数据记录。
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       comm_record_send_one
    644                      //重新启动超时定时器
    645                      osal_start_timerRl( OS_TASK_ID_TMR, 
    646                                         OS_EVT_TMR_DTU, 
    647                                         OS_TICKS_PER_SEC*10 );          //统计装置和无线发送模块定时器  10s
   \   0000004E   0xF242 0x7210      MOVW     R2,#+10000
   \   00000052   0x2102             MOVS     R1,#+2
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   0000005A   0x.... 0x....      B.W      osal_start_timerRl
    648                  }
    649                  
    650              }
    651          }
   \                     ??comm_record_send_0: (+1)
   \   0000005E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x25 0x34          DC8      "%4d"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x25 0x38          DC8      "%8d"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     Ctrl+0x46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     Bsp_MeasureSem

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x34          DC8 "%4d"
   \              0x64 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x25 0x38          DC8 "%8d"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x74 0x65          DC8 "test"
   \              0x73 0x74    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x25 0x30          DC8 "%02d.%02d"
   \              0x32 0x64    
   \              0x2E 0x25    
   \              0x30 0x32    
   \              0x64 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x20 0x20          DC8 "    good"
   \              0x20 0x20    
   \              0x67 0x6F    
   \              0x6F 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x20 0x20          DC8 "         "
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x43 0x41          DC8 "CALL"
   \              0x4C 0x4C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x72 0x74          DC8 "rt-%d"
   \              0x2D 0x25    
   \              0x64 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x53 0x45          DC8 "SET--"
   \              0x54 0x2D    
   \              0x2D 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
    652          
    653          
    654          /*******************************************************************************
    655          * 				end of file
    656          *******************************************************************************/
    657          #endif
    658          
    659          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   comm_para_flow
        40   -> BSP_DispClrAll
        40   -> BSP_OS_SemPost
        40   -> Boot
        40   -> CSNC_SendData
        40   -> FRAM_ReadAirPara
        40   -> FRAM_ReadRunPara
        40   -> FRAM_StoreAirPara
        40   -> FRAM_StoreProductInfo
        40   -> FRAM_StoreRecNumMgr
        40   -> FRAM_StoreRunPara
        40   -> GetCrc16Check
        40   -> ReadTime
        40   -> SetDispNow
        40   -> WriteTime
        40   -> __aeabi_memcpy
        40   -> osal_start_timerEx
        40   -> uprintf
      24   comm_record_send
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> FRAM_StoreRecNumMgr
        24   -> comm_record_send_one
         0   -> osal_start_timerRl
      32   comm_record_send_one
        32   -> CSNC_SendData
        32   -> FRAM_StoreRecNumMgr
        32   -> ReadFlshRec
        32   -> osal_start_timerRl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       8  ?_0
      12  ?_1
       4  ?_2
       4  ?_3
      12  ?_4
      12  ?_5
       8  ?_6
       8  ?_7
       8  ?_8
     682  comm_para_flow
      96  comm_record_send
     112  comm_record_send_one

 
   8 bytes in section .rodata
 978 bytes in section .text
 
 978 bytes of CODE  memory
   8 bytes of CONST memory

Errors: none
Warnings: 1
