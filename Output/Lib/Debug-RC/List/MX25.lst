###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       20/Nov/2017  13:49:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\MX25.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\MX25.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\MX25.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\MX25.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\MX25.c
      1          #include "stm32f10x.h"
      2          #include <stdio.h>
      3          #include <stdint.h>
      4          #include <string.h>
      5          #include "SZ_STM32F107VC_LIB.h"
      6          #include "DS3231.h"
      7          #include "I2C_CLK.h"
      8          #include "Display.h"
      9          #include "DATA_STORAGE.h"
     10          #include "DELAY.h"
     11          #include "MX25.h"
     12          #include "FM24CL64.h"
     13          #include "POWER_MACRO.h"
     14          #include "crccheck.h"
     15          #include "WatchDog.h"
     16          
     17          
     18          #include  <global.h>
     19          #include  <includes.h>
     20          
     21          /****************************************Copyright (c)**************************************************
     22          **                               Guangzou ZLG-MCU Development Co.,LTD.
     23          **                                      graduate school
     24          **                                 http://www.zlgmcu.com
     25          **
     26          **--------------File Info-------------------------------------------------------------------------------
     27          ** File name:            MX25L1602.c
     28          ** Descriptions:        SPI下的SST25VF016B操作函数库 
     29          **
     30          **------------------------------------------------------------------------------------------------------
     31          ** Created by:            Litiantian
     32          ** Created date:        2007-04-16
     33          ** Version:                1.0
     34          ** Descriptions:        The original version
     35          **
     36          **------------------------------------------------------------------------------------------------------
     37          ** Modified by:            
     38          ** Modified date:    
     39          ** Version:
     40          ** Descriptions:        
     41          ********************************************************************************************************/
     42          #define SPI_FLASH_SPI                   SPI2
     43          #define SPI_FLASH_SPI_CLK               RCC_APB1Periph_SPI2
     44          
     45          #define SPI_FLASH_SPI_SCK_PIN           GPIO_Pin_13              /* PB.13 */
     46          #define SPI_FLASH_SPI_SCK_GPIO_PORT     GPIOB
     47          #define SPI_FLASH_SPI_SCK_GPIO_CLK      RCC_APB2Periph_GPIOB
     48          
     49          #define SPI_FLASH_SPI_MISO_PIN          GPIO_Pin_14              /* PB.14 */
     50          #define SPI_FLASH_SPI_MISO_GPIO_PORT    GPIOB
     51          #define SPI_FLASH_SPI_MISO_GPIO_CLK     RCC_APB2Periph_GPIOB
     52          
     53          #define SPI_FLASH_SPI_MOSI_PIN          GPIO_Pin_15              /* PB.15 */
     54          #define SPI_FLASH_SPI_MOSI_GPIO_PORT    GPIOB
     55          #define SPI_FLASH_SPI_MOSI_GPIO_CLK     RCC_APB2Periph_GPIOB
     56          
     57          #define SPI_FLASH_CS_PIN_NUM            12                       /* PB.12 */
     58          #define SPI_FLASH_CS_PIN                GPIO_Pin_12  
     59          #define SPI_FLASH_CS_GPIO_PORT          GPIOB
     60          #define SPI_FLASH_CS_GPIO_CLK           RCC_APB2Periph_GPIOB
     61          
     62          /* Private typedef -----------------------------------------------------------*/
     63          #define SPI_FLASH_PageSize              256
     64          #define SPI_FLASH_PerWritePageSize      256
     65          
     66          
     67          /* Private define ------------------------------------------------------------*/
     68          #define W25X_WriteEnable                0x06 
     69          #define W25X_WriteDisable               0x04 
     70          #define W25X_ReadStatusReg              0x05 
     71          #define W25X_WriteStatusReg             0x01 
     72          #define W25X_ReadData                   0x03 
     73          #define W25X_FastReadData               0x0B 
     74          #define W25X_FastReadDual               0x3B 
     75          #define W25X_PageProgram                0x02 
     76          #define W25X_BlockErase                 0xD8 
     77          #define W25X_SectorErase                0x20 
     78          #define W25X_ChipErase                  0xC7 
     79          #define W25X_PowerDown                  0xB9 
     80          #define W25X_ReleasePowerDown           0xAB 
     81          #define W25X_DeviceID                   0xAB 
     82          #define W25X_ManufactDeviceID           0x90 
     83          #define W25X_JedecDeviceID              0x9F 
     84          
     85          #define WIP_FlagMask                    0x01  /* Write In Progress (WIP) flag */
     86          
     87          #define Dummy_Byte1                     0xA5
     88          
     89          
     90          /* Private macro -------------------------------------------------------------*/
     91          /* Select SPI FLASH: Chip Select pin low  */
     92          #define CE_Low()       (Periph_BB((uint32_t)&SPI_FLASH_CS_GPIO_PORT->ODR, SPI_FLASH_CS_PIN_NUM) = 0)
     93          
     94          /* Deselect SPI FLASH: Chip Select pin high */
     95          #define CE_High()      (Periph_BB((uint32_t)&SPI_FLASH_CS_GPIO_PORT->ODR, SPI_FLASH_CS_PIN_NUM) = 1)
     96          
     97          #define  UCOS_EN            DEF_ENABLED
     98          
     99          /***********************************************
    100          * 描述： OS接口
    101          */
    102          #if UCOS_EN     == DEF_ENABLED
    103              #if OS_VERSION > 30000U

   \                                 In section .bss, align 4
    104              static  OS_SEM                   Bsp_EepSem;    // 信号量
   \                     Bsp_EepSem:
   \   00000000                      DS8 28
    105              #else
    106              static  OS_EVENT                *Bsp_EepSem;    // 信号量
    107              #endif
    108          #endif
    109            
    110              
    111          /*******************************************************************************
    112          * 名    称： EEP_WaitEvent
    113          * 功    能： 等待信号量
    114          * 入口参数： 无
    115          * 出口参数：  0（操作有误），1（操作成功）
    116          * 作　 　者： 无名沈
    117          * 创建日期： 2015-08-18
    118          * 修    改：
    119          * 修改日期：
    120          * 备    注： 仅在使用UCOS操作系统时使用
    121          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    122          static uint8_t EEP_WaitEvent(void)
    123          {
    124              /***********************************************
    125              * 描述： OS接口
    126              */
    127          #if OS_VERSION > 30000U
    128              return BSP_OS_SemWait(&Bsp_EepSem,0);           // 等待信号量
   \                     EEP_WaitEvent: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000006   0x.... 0x....      B.W      BSP_OS_SemWait
    129          #else
    130              uint8_t       err;
    131              OSSemPend(Bsp_EepSem,0,&err);                   // 等待信号量
    132              if ( err = OS_ERR_NONE )
    133                return TRUE;
    134              else
    135                return FALSE;
    136          #endif
    137          }
    138          
    139          
    140          /*******************************************************************************
    141          * 名    称： EEP_SendEvent
    142          * 功    能： 释放信号量
    143          * 入口参数： 无
    144          * 出口参数： 无
    145          * 作　 　者： 无名沈
    146          * 创建日期： 2015-08-18
    147          * 修    改：
    148          * 修改日期：
    149          * 备    注： 仅在使用UCOS操作系统时使用
    150          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    151          static void EEP_SendEvent(void)
    152          {
    153              /***********************************************
    154              * 描述： OS接口
    155              */
    156          #if OS_VERSION > 30000U
    157              BSP_OS_SemPost(&Bsp_EepSem);                        // 发送信号量
   \                     EEP_SendEvent: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000004   0x.... 0x....      B.W      BSP_OS_SemPost
    158          #else
    159              uint8_t       err;
    160              OSSemPost(Bsp_EepSem);                              // 发送信号量
    161          #endif
    162          }
    163          
    164          /**-----------------------------------------------------------------
    165            * @函数名 SPI_FLASH_Init
    166            * @功能   初始化与外部SPI FLASH接口的驱动函数
    167            *         Initializes the peripherals used by the SPI FLASH driver.
    168            * @参数   无
    169            * @返回值 无
    170          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    171          void SPI_FLASH_Init(void)
    172          {
   \                     SPI_FLASH_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    173              SPI_InitTypeDef  SPI_InitStructure;
    174              GPIO_InitTypeDef GPIO_InitStructure;
    175          
    176              /* Enable SPI2 and GPIO clocks */
    177              /*!< SPI_FLASH_SPI_CS_GPIO, SPI_FLASH_SPI_MOSI_GPIO, 
    178                 SPI_FLASH_SPI_MISO_GPIO, SPI_FLASH_SPI_DETECT_GPIO 
    179                 and SPI_FLASH_SPI_SCK_GPIO Periph clock enable */
    180              RCC_APB2PeriphClockCmd(SPI_FLASH_CS_GPIO_CLK | SPI_FLASH_SPI_MOSI_GPIO_CLK |
    181                                   SPI_FLASH_SPI_MISO_GPIO_CLK | SPI_FLASH_SPI_SCK_GPIO_CLK, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2008             MOVS     R0,#+8
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    182          
    183              /*!< SPI_FLASH_SPI Periph clock enable */
    184              RCC_APB1PeriphClockCmd(SPI_FLASH_SPI_CLK, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    185              
    186              /*!< AFIO Periph clock enable */
    187              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x4608             MOV      R0,R1
   \   0000001A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    188          
    189              /*!< Configure SPI_FLASH_SPI pins: SCK */
    190              GPIO_InitStructure.GPIO_Pin = SPI_FLASH_SPI_SCK_PIN;
   \   0000001E   0xF44F 0x5000      MOV      R0,#+8192
   \   00000022   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    191              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xF88D 0x0002      STRB     R0,[SP, #+2]
    192              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000002C   0x2018             MOVS     R0,#+24
   \   0000002E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    193          	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;			   //不能设置为推挽输出，？？
    194              GPIO_Init(SPI_FLASH_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
   \   00000032   0x.... 0x....      LDR.W    R4,??DataTable20_1  ;; 0x40010c00
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       GPIO_Init
    195          
    196              /*!< Configure SPI_FLASH_SPI pins: MOSI */
    197              GPIO_InitStructure.GPIO_Pin = SPI_FLASH_SPI_MOSI_PIN;
   \   0000003E   0xF44F 0x4000      MOV      R0,#+32768
   \   00000042   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    198              GPIO_Init(SPI_FLASH_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       GPIO_Init
    199          
    200              /*!< Configure SPI_FLASH_SPI pins: MISO */
    201              GPIO_InitStructure.GPIO_Pin = SPI_FLASH_SPI_MISO_PIN;
   \   0000004E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000052   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    202              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;                //GPIO_Mode_IN_FLOATING;
   \   00000056   0x2048             MOVS     R0,#+72
   \   00000058   0xF88D 0x0003      STRB     R0,[SP, #+3]
    203          	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;				   //设置为复用PP或OD均可
    204              GPIO_Init(SPI_FLASH_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       GPIO_Init
    205          
    206              /*!< Configure SPI_FLASH_SPI_CS_PIN pin: SPI_FLASH Card CS pin */
    207              GPIO_InitStructure.GPIO_Pin = SPI_FLASH_CS_PIN;
   \   00000064   0xF44F 0x5080      MOV      R0,#+4096
   \   00000068   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    208              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000006C   0x2010             MOVS     R0,#+16
   \   0000006E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    209              GPIO_Init(SPI_FLASH_CS_GPIO_PORT, &GPIO_InitStructure);
   \   00000072   0x4669             MOV      R1,SP
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       GPIO_Init
    210          
    211              /* Deselect the FLASH: Chip Select high */
    212              CE_High();
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x422181b0
   \   00000080   0x6008             STR      R0,[R1, #+0]
    213          
    214              /* SPI2 configuration */
    215              // W25X16: data input on the DIO pin is sampled on the rising edge of the CLK. 
    216              // Data on the DO and DIO pins are clocked out on the falling edge of CLK.
    217              SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    218              SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   \   00000088   0xF44F 0x7082      MOV      R0,#+260
   \   0000008C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    219              SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    220              SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
   \   00000096   0x2002             MOVS     R0,#+2
   \   00000098   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    221              SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    222              SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
   \   000000A2   0xF44F 0x7000      MOV      R0,#+512
   \   000000A6   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    223              SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
   \   000000AA   0x2008             MOVS     R0,#+8
   \   000000AC   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    224              SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    225              SPI_InitStructure.SPI_CRCPolynomial = 7;
   \   000000B6   0x2007             MOVS     R0,#+7
   \   000000B8   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    226              SPI_Init(SPI2, &SPI_InitStructure);
   \   000000BC   0x.... 0x....      LDR.W    R4,??DataTable20_3  ;; 0x40003800
   \   000000C0   0xA901             ADD      R1,SP,#+4
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       SPI_Init
    227          
    228              /* Enable SPI2  */
    229              SPI_Cmd(SPI2, ENABLE);
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       SPI_Cmd
    230          
    231              SPI_Flash_WAKEUP();
   \   000000D0   0x.... 0x....      BL       SPI_Flash_WAKEUP
    232              
    233              /***********************************************
    234              * 描述： OS接口
    235              */
    236          #if (UCOS_EN     == DEF_ENABLED)
    237          #if OS_VERSION > 30000U
    238              BSP_OS_SemCreate(&Bsp_EepSem,1, "Bsp EepSem");      // 创建信号量
   \   000000D4   0x.... 0x....      ADR.W    R2,?_0
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000DE   0x.... 0x....      BL       BSP_OS_SemCreate
    239          #else
    240              Bsp_EepSem     = OSSemCreate(1);                    // 创建信号量
    241          #endif
    242          #endif
    243          }
   \   000000E2   0xB006             ADD      SP,SP,#+24
   \   000000E4   0xBD10             POP      {R4,PC}          ;; return
    244          
    245          /**-----------------------------------------------------------------
    246            * @函数名 Send_Byte
    247            * @功能   通过SPI总线发送一个字节数据(顺便接收一个字节数据)
    248            *         Sends a byte through the SPI interface and return the byte
    249            *         received from the SPI bus.
    250            * @参数   要写入的一个字节数据
    251            * @返回值 在发数据时，MISO信号线上接收的一个字节
    252          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    253          uint8_t Send_Byte(uint8_t byte)
    254          {
   \                     Send_Byte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable20_3  ;; 0x40003800
    255              /* Loop while DR register in not empty */
    256              while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??Send_Byte_0: (+1)
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD0F9             BEQ.N    ??Send_Byte_0
    257          
    258              /* Send byte through the SPI2 peripheral */
    259              SPI_I2S_SendData(SPI2, byte);
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       SPI_I2S_SendData
    260          
    261              /* Wait to receive a byte */
    262              while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??Send_Byte_1: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD0F9             BEQ.N    ??Send_Byte_1
    263          
    264              /* Return the byte read from the SPI bus */
    265              return SPI_I2S_ReceiveData(SPI2);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       SPI_I2S_ReceiveData
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    266          }
    267          
    268          /**-----------------------------------------------------------------
    269            * @函数名 Get_Byte
    270            * @功能   读取SPI FLASH的一个字节，未包含发送读命令和起始地址
    271            * @参数   无
    272            * @返回值 从SPI_FLASH读取的一个字节
    273          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    274          uint8_t Get_Byte(void)
    275          {
    276              return (Send_Byte(Dummy_Byte1));
   \                     Get_Byte: (+1)
   \   00000000   0x20A5             MOVS     R0,#+165
   \   00000002   0x....             B.N      Send_Byte
    277          }
    278          
    279          /**-----------------------------------------------------------------
    280            * @函数名 SPI_Flash_WAKEUP
    281            * @功能   唤醒SPI FLASH
    282            * @参数   无
    283            * @返回值 无
    284          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    285          void SPI_Flash_WAKEUP(void)   
    286          {
   \                     SPI_Flash_WAKEUP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    287            /* Select the FLASH: Chip Select low */
    288            CE_Low();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable20_2  ;; 0x422181b0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
    289          
    290            /* Send "Power Down" instruction */
    291            Send_Byte(W25X_ReleasePowerDown);
   \   0000000A   0x20AB             MOVS     R0,#+171
   \   0000000C   0x.... 0x....      BL       Send_Byte
    292          
    293            /* Deselect the FLASH: Chip Select high */
    294            CE_High();
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x6020             STR      R0,[R4, #+0]
    295          }   
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    296           
    297          /* 以下函数在移植时无需修改 */
    298          /************************************************************************
    299          ** 函数名称:MX25L1602_RD                                                                                                        
    300          ** 函数功能:MX25L1602的读函数,可选择读ID和读数据操作                
    301          ** 入口参数:
    302          **            uint32_t Dst：目标地址,范围 0x0 - MAX_ADDR（MAX_ADDR = 0x1FFFFF）                
    303          **          uint32_t NByte:    要读取的数据字节数
    304          **            uint8_t* RcvBufPt:接收缓存的指针            
    305          ** 出口参数:操作成功则返回OK,失败则返回ERROR        
    306          ** 注     意:若某功能下,某一入口参数无效,可在该入口参数处填Invalid，该参数将被忽略
    307          ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    308          uint8_t MX25L3206_RD(uint32_t Dst, uint32_t NByte,uint8_t* RcvBufPt)
    309          {
   \                     MX25L3206_RD: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    310              uint32_t i = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    311          	uint32_t adr;
    312              
    313              EEP_WaitEvent();
   \   0000000C   0x.... 0x....      BL       EEP_WaitEvent
    314              
    315          	adr=Dst&MAX_ADDR ;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0xffff80
   \   00000014   0x4004             ANDS     R4,R0,R4
    316              CE_Low();            
   \   00000016   0x.... 0x....      LDR.W    R8,??DataTable20_2  ;; 0x422181b0
   \   0000001A   0x4638             MOV      R0,R7
   \   0000001C   0xF8C8 0x0000      STR      R0,[R8, #+0]
    317              Send_Byte(0x0B);                                // 发送读命令
   \   00000020   0x200B             MOVS     R0,#+11
   \   00000022   0x.... 0x....      BL       Send_Byte
    318              Send_Byte(((adr & 0xFFFFFF) >> 16));            // 发送地址信息:该地址由3个字节组成
   \   00000026   0x0C20             LSRS     R0,R4,#+16
   \   00000028   0x.... 0x....      BL       Send_Byte
    319              Send_Byte(((adr & 0xFFFF) >> 8));
   \   0000002C   0x0A20             LSRS     R0,R4,#+8
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x.... 0x....      BL       Send_Byte
    320              Send_Byte(adr & 0xFF);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x.... 0x....      BL       Send_Byte
    321              Send_Byte(0xFF);                                // 发送一个哑字节以读取数据
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x.... 0x....      BL       Send_Byte
    322              for (i = 0; i < NByte; i++)        
   \   00000042   0xE003             B.N      ??MX25L3206_RD_0
    323              {
    324                  RcvBufPt[i] = Get_Byte();        
   \                     ??MX25L3206_RD_1: (+1)
   \   00000044   0x.... 0x....      BL       Get_Byte
   \   00000048   0x55B8             STRB     R0,[R7, R6]
    325              }
   \   0000004A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??MX25L3206_RD_0: (+1)
   \   0000004C   0x42AF             CMP      R7,R5
   \   0000004E   0xD3F9             BCC.N    ??MX25L3206_RD_1
    326              CE_High();   
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF8C8 0x0000      STR      R0,[R8, #+0]
    327              EEP_SendEvent();
   \   00000056   0x.... 0x....      BL       EEP_SendEvent
    328              return (1);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    329          }
    330          
    331          /************************************************************************
    332          ** 函数名称:MX25L1602_RdID                                                                                                        
    333          ** 函数功能:MX25L1602的读ID函数,可选择读ID和读数据操作                
    334          ** 入口参数:
    335          **            idtype IDType:ID类型。用户可在Jedec_ID,Dev_ID,Manu_ID三者里选择
    336          **            uint32_t* RcvbufPt:存储ID变量的指针
    337          ** 出口参数:操作成功则返回OK,失败则返回ERROR        
    338          ** 注     意:若填入的参数不符合要求，则返回ERROR
    339          ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    340          uint32_t MX25L3206_RdID(void)
    341          {
   \                     MX25L3206_RdID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    342              uint32_t temp = 0;
    343              CE_Low();            
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable20_2  ;; 0x422181b0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
    344              Send_Byte(0x9F);                            // 发送读JEDEC ID命令(9Fh)
   \   0000000A   0x209F             MOVS     R0,#+159
   \   0000000C   0x.... 0x....      BL       Send_Byte
    345              temp = (temp | Get_Byte()) << 8;            // 接收数据 
   \   00000010   0x.... 0x....      BL       Get_Byte
   \   00000014   0x0205             LSLS     R5,R0,#+8
    346              temp = (temp | Get_Byte()) << 8;    
   \   00000016   0x.... 0x....      BL       Get_Byte
   \   0000001A   0x4328             ORRS     R0,R0,R5
   \   0000001C   0x0205             LSLS     R5,R0,#+8
    347              temp = (temp | Get_Byte());                 // 在本例中,temp的值应为0xBF2541
   \   0000001E   0x.... 0x....      BL       Get_Byte
   \   00000022   0x4328             ORRS     R0,R0,R5
    348              CE_High();            
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x6021             STR      R1,[R4, #+0]
    349          	return temp;
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    350          }
    351          
    352          /************************************************************************
    353          ** 函数名称:MX25L1602_WR                                            
    354          ** 函数功能:MX25L1602的写函数，可写1个和多个数据到指定地址                                    
    355          ** 入口参数:
    356          **            uint32_t Dst：目标地址,范围 0x0 - MAX_ADDR（MAX_ADDR = 0x1FFFFF）                
    357          **            uint8_t* SndbufPt:发送缓存区指针
    358          **          uint32_t NByte:要写的数据字节数
    359          ** 出口参数:操作成功则返回OK,失败则返回ERROR        
    360          ** 注     意:若某功能下,某一入口参数无效,可在该入口参数处填Invalid，该参数将被忽略
    361          ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    362          uint8_t MX25L3206_WR(uint32_t Dst, uint8_t* SndbufPt, uint32_t NByte)
    363          {
   \                     MX25L3206_WR: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
    364              uint8_t StatRgVal = 0;
    365              uint32_t i = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
    366          	uint32_t adr;
    367              
    368              EEP_WaitEvent();
   \   0000000C   0x.... 0x....      BL       EEP_WaitEvent
    369              
    370          	adr=Dst&MAX_ADDR ;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0xffff80
   \   00000014   0xEA00 0x0807      AND      R8,R0,R7
    371              
    372              CE_Low();            
   \   00000018   0x.... 0x....      LDR.W    R7,??DataTable20_2  ;; 0x422181b0
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x6038             STR      R0,[R7, #+0]
    373              Send_Byte(0x06);                                                    /* 发送写使能命令               */
   \   00000020   0x2006             MOVS     R0,#+6
   \   00000022   0x.... 0x....      BL       Send_Byte
    374              CE_High();        
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x6038             STR      R0,[R7, #+0]
    375              //写数据 
    376              CE_Low();            
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x6038             STR      R0,[R7, #+0]
    377              Send_Byte(0x02);                                                    /* 发送字节数据烧写命令         */
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       Send_Byte
    378              Send_Byte((((adr+i) & 0xFFFFFF) >> 16));                            /* 发送3个字节的地址信息        */
   \   00000034   0xEA4F 0x4018      LSR      R0,R8,#+16
   \   00000038   0x.... 0x....      BL       Send_Byte
    379              Send_Byte((((adr+i) & 0xFFFF) >> 8));
   \   0000003C   0xEA4F 0x2018      LSR      R0,R8,#+8
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x.... 0x....      BL       Send_Byte
    380              Send_Byte((adr+i) & 0xFF);
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       Send_Byte
    381              for(i = 0; i < NByte; i++)
   \   0000004E   0xE003             B.N      ??MX25L3206_WR_0
    382              {
    383                  Send_Byte(SndbufPt[i]);                                     /* 发送被烧写的数据             */
   \                     ??MX25L3206_WR_1: (+1)
   \   00000050   0x5D30             LDRB     R0,[R6, R4]
   \   00000052   0x.... 0x....      BL       Send_Byte
    384              }
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \                     ??MX25L3206_WR_0: (+1)
   \   00000058   0x42AE             CMP      R6,R5
   \   0000005A   0xD3F9             BCC.N    ??MX25L3206_WR_1
    385              CE_High();    
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x6038             STR      R0,[R7, #+0]
    386              
    387              do
    388              {
    389                  CE_Low();             
   \                     ??MX25L3206_WR_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6038             STR      R0,[R7, #+0]
    390                  Send_Byte(0x05);                                                /* 发送读状态寄存器命令         */
   \   00000064   0x2005             MOVS     R0,#+5
   \   00000066   0x.... 0x....      BL       Send_Byte
    391                  StatRgVal = Get_Byte();                                         /* 保存读得的状态寄存器值       */
   \   0000006A   0x.... 0x....      BL       Get_Byte
    392                  CE_High();                                
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x6039             STR      R1,[R7, #+0]
    393              }
    394              while (StatRgVal == 0x03);                                          /* 一直等待，直到芯片空闲       */
   \   00000072   0x2803             CMP      R0,#+3
   \   00000074   0xD0F4             BEQ.N    ??MX25L3206_WR_2
    395              EEP_SendEvent();
   \   00000076   0x.... 0x....      BL       EEP_SendEvent
    396              return (1);        
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    397          }
    398          
    399          /************************************************************************
    400          ** 函数名称:MX25L1602_Erase                                                
    401          ** 函数功能:根据指定的扇区号选取最高效的算法擦除                                
    402          ** 入口参数:
    403          **            uint32_t sec1：起始扇区号,范围(0~499)
    404          **            uint32_t sec2：终止扇区号,范围(0~499)
    405          ** 出口参数:操作成功则返回OK,失败则返回ERROR        
    406          ************************************************************************/
    407          

   \                                 In section .text, align 2, keep-with-next
    408          uint8_t MX25L3206_Erase(uint32_t sec1, uint32_t sec2)
    409          {
   \                     MX25L3206_Erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    410              uint8_t  temp2 = 0,StatRgVal = 0;
    411              uint32_t SecnHdAddr = 0;                  
    412              uint32_t no_SecsToEr = 0;                       // 要擦除的扇区数目
    413              uint32_t CurSecToEr = 0;                        // 当前要擦除的扇区号
    414              
    415              /*  检查入口参数 */
    416              if ((sec1 > SEC_MAX)||(sec2 > SEC_MAX))    
   \   00000006   0xF241 0x0001      MOVW     R0,#+4097
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD201             BCS.N    ??MX25L3206_Erase_0
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD301             BCC.N    ??MX25L3206_Erase_1
    417              {
    418                  return (0);    
   \                     ??MX25L3206_Erase_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    419              }       
    420              
    421              CE_Low();            
   \                     ??MX25L3206_Erase_1: (+1)
   \   00000016   0x....             LDR.N    R5,??DataTable20_2  ;; 0x422181b0
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    422              Send_Byte(0x06);                                // 发送写使能命令
   \   0000001C   0x2006             MOVS     R0,#+6
   \   0000001E   0x.... 0x....      BL       Send_Byte
    423              CE_High();            
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x6028             STR      R0,[R5, #+0]
    424          
    425              /* 如果用户输入的起始扇区号大于终止扇区号，则在内部作出调整 */
    426              if (sec1 > sec2)
   \   00000026   0x42A6             CMP      R6,R4
   \   00000028   0xD203             BCS.N    ??MX25L3206_Erase_2
    427              {
    428                 temp2 = sec1;
   \   0000002A   0x4620             MOV      R0,R4
    429                 sec1  = sec2;
   \   0000002C   0x4634             MOV      R4,R6
    430                 sec2  = temp2;
   \   0000002E   0x4606             MOV      R6,R0
   \   00000030   0xB2F6             UXTB     R6,R6
    431              } 
    432              /* 若起止扇区号相等则擦除单个扇区 */
    433              if (sec1 == sec2)    
   \                     ??MX25L3206_Erase_2: (+1)
   \   00000032   0x42B4             CMP      R4,R6
   \   00000034   0xD121             BNE.N    ??MX25L3206_Erase_3
    434              {
    435                  SecnHdAddr = SEC_SIZE * sec1;               // 计算扇区的起始地址
   \   00000036   0x0327             LSLS     R7,R4,#+12
    436                  CE_Low();    
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6028             STR      R0,[R5, #+0]
    437                  Send_Byte(0x20);                            // 发送扇区擦除指令
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       Send_Byte
    438                  Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16)); // 发送3个字节的地址信息
   \   00000042   0x0C38             LSRS     R0,R7,#+16
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x.... 0x....      BL       Send_Byte
    439                     Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   0000004A   0x0A38             LSRS     R0,R7,#+8
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       Send_Byte
    440                     Send_Byte(SecnHdAddr & 0xFF);
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       Send_Byte
    441                    CE_High();            
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x6028             STR      R0,[R5, #+0]
    442                  do
    443                  {
    444                        CE_Low();             
   \                     ??MX25L3206_Erase_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6028             STR      R0,[R5, #+0]
    445                      Send_Byte(0x05);                        // 发送读状态寄存器命令
   \   00000062   0x2005             MOVS     R0,#+5
   \   00000064   0x.... 0x....      BL       Send_Byte
    446                      StatRgVal = Get_Byte();                 // 保存读得的状态寄存器值
   \   00000068   0x.... 0x....      BL       Get_Byte
   \   0000006C   0x4607             MOV      R7,R0
    447                      CE_High();                                
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x6028             STR      R0,[R5, #+0]
    448                    }
    449                  while (StatRgVal == 0x03);                  // 一直等待，直到芯片空闲
   \   00000072   0x2F03             CMP      R7,#+3
   \   00000074   0xF040 0x808B      BNE.W    ??MX25L3206_Erase_5
   \   00000078   0xE7F1             B.N      ??MX25L3206_Erase_4
    450                  return (1);            
    451              }
    452              
    453                               /*         根据起始扇区和终止扇区间距调用最快速的擦除功能                             */    
    454              
    455              if (sec2 - sec1 == SEC_MAX)    
   \                     ??MX25L3206_Erase_3: (+1)
   \   0000007A   0x1B30             SUBS     R0,R6,R4
   \   0000007C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000080   0xD116             BNE.N    ??MX25L3206_Erase_6
    456              {
    457                  CE_Low();            
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x6028             STR      R0,[R5, #+0]
    458                  Send_Byte(0x60);                            // 发送芯片擦除指令(60h or C7h)
   \   00000086   0x2060             MOVS     R0,#+96
   \   00000088   0x.... 0x....      BL       Send_Byte
    459                  CE_High();            
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x6028             STR      R0,[R5, #+0]
    460                  do
    461                  {
    462                      CE_Low();             
   \                     ??MX25L3206_Erase_7: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x6028             STR      R0,[R5, #+0]
    463                      Send_Byte(0x05);                        // 发送读状态寄存器命令
   \   00000094   0x2005             MOVS     R0,#+5
   \   00000096   0x.... 0x....      BL       Send_Byte
    464                      StatRgVal = Get_Byte();                 // 保存读得的状态寄存器值
   \   0000009A   0x.... 0x....      BL       Get_Byte
   \   0000009E   0x4607             MOV      R7,R0
    465                      CE_High(); 
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x6028             STR      R0,[R5, #+0]
    466          			Delay(10);								//此处延时是否考虑更改
   \   000000A4   0x200A             MOVS     R0,#+10
   \   000000A6   0x.... 0x....      BL       Delay
    467                  }
    468                  while (StatRgVal == 0x03);                  // 一直等待，直到芯片空闲
   \   000000AA   0x2F03             CMP      R7,#+3
   \   000000AC   0xD16F             BNE.N    ??MX25L3206_Erase_5
   \   000000AE   0xE7EF             B.N      ??MX25L3206_Erase_7
    469                  return (1);
    470              }
    471              
    472              no_SecsToEr = sec2 - sec1 +1;                   // 获取要擦除的扇区数目
   \                     ??MX25L3206_Erase_6: (+1)
   \   000000B0   0x1C46             ADDS     R6,R0,#+1
    473              CurSecToEr  = sec1;                             // 从起始扇区开始擦除
   \   000000B2   0xE021             B.N      ??MX25L3206_Erase_8
    474              
    475              /* 若两个扇区之间的间隔够大，则采取16扇区擦除算法 */
    476              while (no_SecsToEr >= 16)
    477              {
    478                  SecnHdAddr = SEC_SIZE * CurSecToEr;         // 计算扇区的起始地址
   \                     ??MX25L3206_Erase_9: (+1)
   \   000000B4   0x0327             LSLS     R7,R4,#+12
    479                  CE_Low();    
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x6028             STR      R0,[R5, #+0]
    480                  Send_Byte(0xD8);                            // 发送64KB块擦除指令
   \   000000BA   0x20D8             MOVS     R0,#+216
   \   000000BC   0x.... 0x....      BL       Send_Byte
    481                  Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16)); // 发送3个字节的地址信息
   \   000000C0   0x0C38             LSRS     R0,R7,#+16
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0x.... 0x....      BL       Send_Byte
    482                  Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   000000C8   0x0A38             LSRS     R0,R7,#+8
   \   000000CA   0xB2C0             UXTB     R0,R0
   \   000000CC   0x.... 0x....      BL       Send_Byte
    483                  Send_Byte(SecnHdAddr & 0xFF);
   \   000000D0   0x4638             MOV      R0,R7
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x.... 0x....      BL       Send_Byte
    484                  CE_High();            
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0x6028             STR      R0,[R5, #+0]
    485                  do
    486                  {
    487                      CE_Low();             
   \                     ??MX25L3206_Erase_10: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x6028             STR      R0,[R5, #+0]
    488                      Send_Byte(0x05);                        // 发送读状态寄存器命令
   \   000000E0   0x2005             MOVS     R0,#+5
   \   000000E2   0x.... 0x....      BL       Send_Byte
    489                      StatRgVal = Get_Byte();                 // 保存读得的状态寄存器值
   \   000000E6   0x.... 0x....      BL       Get_Byte
   \   000000EA   0x4607             MOV      R7,R0
    490                      CE_High();                                
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x6028             STR      R0,[R5, #+0]
    491                    }
    492                  while (StatRgVal == 0x03);                  // 一直等待，直到芯片空闲
   \   000000F0   0x2F03             CMP      R7,#+3
   \   000000F2   0xD0F3             BEQ.N    ??MX25L3206_Erase_10
    493                  CurSecToEr  += 16;                          // 计算擦除了16个扇区后,和擦除区域相邻的待擦除扇区号
   \   000000F4   0x3410             ADDS     R4,R4,#+16
    494                  no_SecsToEr -=  16;                         // 对需擦除的扇区总数作出调整
   \   000000F6   0x3E10             SUBS     R6,R6,#+16
    495              }
   \                     ??MX25L3206_Erase_8: (+1)
   \   000000F8   0x2E10             CMP      R6,#+16
   \   000000FA   0xD2DB             BCS.N    ??MX25L3206_Erase_9
    496              /* 若两个扇区之间的间隔够大，则采取8扇区擦除算法 */
    497              while (no_SecsToEr >= 8)
   \                     ??MX25L3206_Erase_11: (+1)
   \   000000FC   0x2E08             CMP      R6,#+8
   \   000000FE   0xD344             BCC.N    ??MX25L3206_Erase_12
    498              {
    499                  SecnHdAddr = SEC_SIZE * CurSecToEr;         // 计算扇区的起始地址
   \   00000100   0x0327             LSLS     R7,R4,#+12
    500                  CE_Low();    
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x6028             STR      R0,[R5, #+0]
    501                  Send_Byte(0x52);                            // 发送32KB擦除指令
   \   00000106   0x2052             MOVS     R0,#+82
   \   00000108   0x.... 0x....      BL       Send_Byte
    502                  Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16)); // 发送3个字节的地址信息
   \   0000010C   0x0C38             LSRS     R0,R7,#+16
   \   0000010E   0xB2C0             UXTB     R0,R0
   \   00000110   0x.... 0x....      BL       Send_Byte
    503                  Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   00000114   0x0A38             LSRS     R0,R7,#+8
   \   00000116   0xB2C0             UXTB     R0,R0
   \   00000118   0x.... 0x....      BL       Send_Byte
    504                  Send_Byte(SecnHdAddr & 0xFF);
   \   0000011C   0x4638             MOV      R0,R7
   \   0000011E   0xB2C0             UXTB     R0,R0
   \   00000120   0x.... 0x....      BL       Send_Byte
    505                  CE_High();            
   \   00000124   0x2001             MOVS     R0,#+1
   \   00000126   0x6028             STR      R0,[R5, #+0]
    506                  do
    507                  {
    508                      CE_Low();             
   \                     ??MX25L3206_Erase_13: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x6028             STR      R0,[R5, #+0]
    509                      Send_Byte(0x05);                        // 发送读状态寄存器命令
   \   0000012C   0x2005             MOVS     R0,#+5
   \   0000012E   0x.... 0x....      BL       Send_Byte
    510                      StatRgVal = Get_Byte();                 // 保存读得的状态寄存器值
   \   00000132   0x.... 0x....      BL       Get_Byte
   \   00000136   0x4607             MOV      R7,R0
    511                      CE_High();                                
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0x6028             STR      R0,[R5, #+0]
    512                    }
    513                  while (StatRgVal == 0x03);                  // 一直等待，直到芯片空闲    
   \   0000013C   0x2F03             CMP      R7,#+3
   \   0000013E   0xD0F3             BEQ.N    ??MX25L3206_Erase_13
    514                  CurSecToEr  += 8;
   \   00000140   0x3408             ADDS     R4,R4,#+8
    515                  no_SecsToEr -=  8;
   \   00000142   0x3E08             SUBS     R6,R6,#+8
   \   00000144   0xE7DA             B.N      ??MX25L3206_Erase_11
    516              }
    517              /* 采用扇区擦除算法擦除剩余的扇区 */
    518              while (no_SecsToEr >= 1)
    519              {
    520                  SecnHdAddr = SEC_SIZE * CurSecToEr;         // 计算扇区的起始地址
   \                     ??MX25L3206_Erase_14: (+1)
   \   00000146   0x0327             LSLS     R7,R4,#+12
    521                  CE_Low();    
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0x6028             STR      R0,[R5, #+0]
    522                  Send_Byte(0x20);                            // 发送扇区擦除指令
   \   0000014C   0x2020             MOVS     R0,#+32
   \   0000014E   0x.... 0x....      BL       Send_Byte
    523                  Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16)); // 发送3个字节的地址信息
   \   00000152   0x0C38             LSRS     R0,R7,#+16
   \   00000154   0xB2C0             UXTB     R0,R0
   \   00000156   0x.... 0x....      BL       Send_Byte
    524                     Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   0000015A   0x0A38             LSRS     R0,R7,#+8
   \   0000015C   0xB2C0             UXTB     R0,R0
   \   0000015E   0x.... 0x....      BL       Send_Byte
    525                     Send_Byte(SecnHdAddr & 0xFF);
   \   00000162   0x4638             MOV      R0,R7
   \   00000164   0xB2C0             UXTB     R0,R0
   \   00000166   0x.... 0x....      BL       Send_Byte
    526                    CE_High();            
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0x6028             STR      R0,[R5, #+0]
    527                  do
    528                  {
    529                        CE_Low();             
   \                     ??MX25L3206_Erase_15: (+1)
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x6028             STR      R0,[R5, #+0]
    530                      Send_Byte(0x05);                        // 发送读状态寄存器命令
   \   00000172   0x2005             MOVS     R0,#+5
   \   00000174   0x.... 0x....      BL       Send_Byte
    531                      StatRgVal = Get_Byte();                 // 保存读得的状态寄存器值
   \   00000178   0x.... 0x....      BL       Get_Byte
   \   0000017C   0x4607             MOV      R7,R0
    532                      CE_High();                                
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0x6028             STR      R0,[R5, #+0]
    533                    }
    534                  while (StatRgVal == 0x03);                  // 一直等待，直到芯片空闲
   \   00000182   0x2F03             CMP      R7,#+3
   \   00000184   0xD0F3             BEQ.N    ??MX25L3206_Erase_15
    535                  CurSecToEr  += 1;
   \   00000186   0x1C64             ADDS     R4,R4,#+1
    536                  no_SecsToEr -=  1;
   \   00000188   0x1E76             SUBS     R6,R6,#+1
    537              }
   \                     ??MX25L3206_Erase_12: (+1)
   \   0000018A   0x2E00             CMP      R6,#+0
   \   0000018C   0xD1DB             BNE.N    ??MX25L3206_Erase_14
    538              return (1);
   \                     ??MX25L3206_Erase_5: (+1)
   \   0000018E   0x2001             MOVS     R0,#+1
   \   00000190   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    539          }
    540          
    541          

   \                                 In section .text, align 2, keep-with-next
    542          uint8_t SaveOneREcord(uint32_t adr,uint8_t *buf,uint32_t len)
    543          {
   \                     SaveOneREcord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    544          	if((adr&0x0FFF)==0)							//在块边界，需要擦除块
   \   00000008   0x0520             LSLS     R0,R4,#+20
   \   0000000A   0xD108             BNE.N    ??SaveOneREcord_0
    545          	{
    546                  EEP_WaitEvent();
   \   0000000C   0x.... 0x....      BL       EEP_WaitEvent
    547          		MX25L3206_Erase((adr>>12)&0x3FF,(adr>>12)&0x3FF);
   \   00000010   0xF3C4 0x3009      UBFX     R0,R4,#+12,#+10
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x.... 0x....      BL       MX25L3206_Erase
    548                  EEP_SendEvent();
   \   0000001A   0x.... 0x....      BL       EEP_SendEvent
    549          	}
    550          	return MX25L3206_WR(adr, buf, len);
   \                     ??SaveOneREcord_0: (+1)
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000028   0x....             B.N      MX25L3206_WR
    551          }

   \                                 In section .text, align 2, keep-with-next
    552          void FASTREAD(uint32_t adr,uint8_t *buf,uint32_t len)
    553          {
   \                     FASTREAD: (+1)
   \   00000000   0x4613             MOV      R3,R2
    554          	MX25L3206_RD(adr, len,buf);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4619             MOV      R1,R3
   \   00000006   0x....             B.N      MX25L3206_RD
    555          	
    556          }

   \                                 In section .text, align 2, keep-with-next
    557          uint8_t RDSR(void)
    558          {
   \                     RDSR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    559          	uint8_t dat;
    560              CE_Low();             
   \   00000002   0x....             LDR.N    R4,??DataTable20_2  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    561              Send_Byte(0x05);                                // 发送读状态寄存器命令
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      BL       Send_Byte
    562              dat = Get_Byte();                             // 保存读得的状态寄存器值
   \   0000000E   0x.... 0x....      BL       Get_Byte
    563              CE_High();                                
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x6021             STR      R1,[R4, #+0]
    564          	return dat;
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    565          }

   \                                 In section .text, align 2, keep-with-next
    566          void WRSR(uint8_t dat)
    567          {
   \                     WRSR: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    568              CE_Low();             
   \   00000004   0x....             LDR.N    R5,??DataTable20_2  ;; 0x422181b0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6028             STR      R0,[R5, #+0]
    569              Send_Byte(0x06);                                // 发送读状态寄存器命令
   \   0000000A   0x2006             MOVS     R0,#+6
   \   0000000C   0x.... 0x....      BL       Send_Byte
    570              CE_High();                                
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x6028             STR      R0,[R5, #+0]
    571              CE_Low();             
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6028             STR      R0,[R5, #+0]
    572              Send_Byte(0x01);                                // 发送读状态寄存器命令
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      BL       Send_Byte
    573              Send_Byte(dat);                                // 发送读状态寄存器命令
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       Send_Byte
    574              CE_High();                                
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6028             STR      R0,[R5, #+0]
    575          }
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    576          

   \                                 In section .text, align 2, keep-with-next
    577          void SaveRecord(void)
    578          {
   \                     SaveRecord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    579          	uint8_t   AddressBuf[4] = {0};
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
    580          	uint32_t  Address = 0;
    581          	
    582          	GetTime((TIME *)&recordsfr.Time[0]);
   \   00000008   0x....             LDR.N    R4,??DataTable20_5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       GetTime
    583              
    584          	recordsfr.Crc16 = GetCrc16Chk1((uint8_t *)&recordsfr.Time[0],sizeof(SDAT)-2);
   \   00000010   0x211E             MOVS     R1,#+30
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       GetCrc16Chk1
   \   00000018   0x83E0             STRH     R0,[R4, #+30]
    585             	SaveOneREcord(g_Flash_Adr,(uint8_t *)&recordsfr.Time[0],sizeof(SDAT));
   \   0000001A   0x....             LDR.N    R5,??DataTable20_6
   \   0000001C   0x2220             MOVS     R2,#+32
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x.... 0x....      BL       SaveOneREcord
    586              // 	printf("g_Flash_Adr = %d",g_Flash_Adr);
    587          	g_Flash_Adr += sizeof(SDAT);
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x3020             ADDS     R0,R0,#+32
   \   0000002A   0x6028             STR      R0,[R5, #+0]
    588              //	printf("g_Flash_Adr = %d",g_Flash_Adr);
    589          	Address = (MAX_ADDR & g_Flash_Adr)|0xAA000000;	 //FLASH大小，128Mbit
    590          	TO_Arayy(AddressBuf , Address);
   \   0000002C   0x....             LDR.N    R1,??DataTable20_4  ;; 0xffff80
   \   0000002E   0x4008             ANDS     R0,R1,R0
   \   00000030   0xF040 0x412A      ORR      R1,R0,#0xAA000000
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x.... 0x....      BL       TO_Arayy
    591          	WriteFM24CL64(60, AddressBuf, 4);
   \   0000003A   0x2204             MOVS     R2,#+4
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x203C             MOVS     R0,#+60
   \   00000040   0x.... 0x....      BL       WriteFM24CL64
    592          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    593          
    594          
    595          /*  数据转储                    */
    596          /*  数据低字节在前，高字节在后  */

   \                                 In section .text, align 2, keep-with-next
    597          void DOWNLOAD(uint32_t NRecord)
    598          {	
   \                     DOWNLOAD: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    599          	uint32_t i;
    600          	static uint8_t  DATA_OUT[32] = {0};
    601              
    602          	uint32_t PP_Power = 0;
    603          	uint32_t NP_Power = 0;
    604          	uint32_t PQ_Power = 0;
    605          	uint32_t NQ_Power = 0;
    606          	uint16_t CRC_sum1 = 0;
    607          	uint16_t CRC_sum2 = 0;
    608              
    609          	for(i=0;i<NRecord;i++) {
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0xE003             B.N      ??DOWNLOAD_0
    610          		FeedDog_HIGH();
    611          		MX25L3206_RD(i*32, 32 ,DATA_OUT);				  //每次读取32字节，即一条记录
    612          		FeedDog_LOW();
    613          		
    614          		CRC_sum1 = GetCrc16Chk1((uint8_t *)&DATA_OUT[0],sizeof(SDAT)-2);		
    615          		CRC_sum2 = DATA_OUT[30] + (DATA_OUT[31] << 8);
    616          		
    617                  if(CRC_sum1 == CRC_sum2) {						   //进行累加和计算
    618          			printf("\r\n第%05d条记录：20%02d-%02d-%02d %02d:%02d:%02d  ", (i+1),
    619                             DATA_OUT[0],DATA_OUT[1],DATA_OUT[2],
    620                             DATA_OUT[3],DATA_OUT[4],DATA_OUT[5]);
    621          			FeedDog_HIGH();
    622          			PP_Power =  DATA_OUT[11]<<24 |  DATA_OUT[10]<<16 | DATA_OUT[9]<<8  | DATA_OUT[8];
    623          			FeedDog_LOW();
    624          			printf("正有功电量：%10dkW.h  ", PP_Power);
    625          			FeedDog_HIGH();
    626          			NP_Power =  DATA_OUT[15]<<24 |  DATA_OUT[14]<<16 | DATA_OUT[13]<<8 | DATA_OUT[12];
    627          			FeedDog_LOW();
    628          			printf("负有功电量：%10dkW.h  ", NP_Power);
    629          			PQ_Power =  DATA_OUT[19]<<24 |  DATA_OUT[18]<<16 | DATA_OUT[17]<<8 | DATA_OUT[16];
    630          			FeedDog_HIGH();
    631          			printf("正无功电量：%10dkvar.h  ", PQ_Power);
    632          			FeedDog_LOW();
    633          			NQ_Power =  DATA_OUT[23]<<24 |  DATA_OUT[22]<<16 | DATA_OUT[21]<<8 | DATA_OUT[20];
    634          			FeedDog_HIGH();
    635          			printf("负无功电量：%10dkvar.h  ", NQ_Power);
    636          			FeedDog_LOW();
    637          		}
    638          		else 
    639          			printf("累加和错误！");
   \                     ??DOWNLOAD_1: (+1)
   \   0000000A   0x.... 0x....      ADR.W    R0,?_7
   \   0000000E   0x.... 0x....      BL       printf
   \                     ??DOWNLOAD_0: (+1)
   \   00000012   0x42A5             CMP      R5,R4
   \   00000014   0xD275             BCS.N    ??DOWNLOAD_2
   \   00000016   0x.... 0x....      BL       FeedDog_HIGH
   \   0000001A   0x....             LDR.N    R6,??DataTable20_7
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x0168             LSLS     R0,R5,#+5
   \   00000022   0x.... 0x....      BL       MX25L3206_RD
   \   00000026   0x.... 0x....      BL       FeedDog_LOW
   \   0000002A   0x211E             MOVS     R1,#+30
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       GetCrc16Chk1
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0x7FB1             LDRB     R1,[R6, #+30]
   \   00000036   0x7FF2             LDRB     R2,[R6, #+31]
   \   00000038   0xEB01 0x2102      ADD      R1,R1,R2, LSL #+8
   \   0000003C   0xB289             UXTH     R1,R1
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD1E3             BNE.N    ??DOWNLOAD_1
   \   00000042   0x7970             LDRB     R0,[R6, #+5]
   \   00000044   0x9003             STR      R0,[SP, #+12]
   \   00000046   0x7930             LDRB     R0,[R6, #+4]
   \   00000048   0x9002             STR      R0,[SP, #+8]
   \   0000004A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x78B0             LDRB     R0,[R6, #+2]
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x7873             LDRB     R3,[R6, #+1]
   \   00000054   0x7832             LDRB     R2,[R6, #+0]
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x.... 0x....      ADR.W    R0,?_2
   \   0000005C   0x.... 0x....      BL       printf
   \   00000060   0x.... 0x....      BL       FeedDog_HIGH
   \   00000064   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000066   0x7AB1             LDRB     R1,[R6, #+10]
   \   00000068   0x0409             LSLS     R1,R1,#+16
   \   0000006A   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   0000006E   0x7A71             LDRB     R1,[R6, #+9]
   \   00000070   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000074   0x7A31             LDRB     R1,[R6, #+8]
   \   00000076   0xEA41 0x0700      ORR      R7,R1,R0
   \   0000007A   0x.... 0x....      BL       FeedDog_LOW
   \   0000007E   0x4639             MOV      R1,R7
   \   00000080   0x.... 0x....      ADR.W    R0,?_3
   \   00000084   0x.... 0x....      BL       printf
   \   00000088   0x.... 0x....      BL       FeedDog_HIGH
   \   0000008C   0x7BF0             LDRB     R0,[R6, #+15]
   \   0000008E   0x7BB1             LDRB     R1,[R6, #+14]
   \   00000090   0x0409             LSLS     R1,R1,#+16
   \   00000092   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000096   0x7B71             LDRB     R1,[R6, #+13]
   \   00000098   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000009C   0x7B31             LDRB     R1,[R6, #+12]
   \   0000009E   0xEA41 0x0700      ORR      R7,R1,R0
   \   000000A2   0x.... 0x....      BL       FeedDog_LOW
   \   000000A6   0x4639             MOV      R1,R7
   \   000000A8   0x.... 0x....      ADR.W    R0,?_4
   \   000000AC   0x.... 0x....      BL       printf
   \   000000B0   0x7CF0             LDRB     R0,[R6, #+19]
   \   000000B2   0x7CB1             LDRB     R1,[R6, #+18]
   \   000000B4   0x0409             LSLS     R1,R1,#+16
   \   000000B6   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000BA   0x7C71             LDRB     R1,[R6, #+17]
   \   000000BC   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000C0   0x7C31             LDRB     R1,[R6, #+16]
   \   000000C2   0xEA41 0x0700      ORR      R7,R1,R0
   \   000000C6   0x.... 0x....      BL       FeedDog_HIGH
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      ADR.W    R0,?_5
   \   000000D0   0x.... 0x....      BL       printf
   \   000000D4   0x.... 0x....      BL       FeedDog_LOW
   \   000000D8   0x7DF0             LDRB     R0,[R6, #+23]
   \   000000DA   0x7DB1             LDRB     R1,[R6, #+22]
   \   000000DC   0x0409             LSLS     R1,R1,#+16
   \   000000DE   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000E2   0x7D71             LDRB     R1,[R6, #+21]
   \   000000E4   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000E8   0x7D31             LDRB     R1,[R6, #+20]
   \   000000EA   0xEA41 0x0600      ORR      R6,R1,R0
   \   000000EE   0x.... 0x....      BL       FeedDog_HIGH
   \   000000F2   0x4631             MOV      R1,R6
   \   000000F4   0x.... 0x....      ADR.W    R0,?_6
   \   000000F8   0x.... 0x....      BL       printf
   \   000000FC   0x.... 0x....      BL       FeedDog_LOW
   \   00000100   0xE787             B.N      ??DOWNLOAD_0
    640          	}
    641          }
   \                     ??DOWNLOAD_2: (+1)
   \   00000102   0xB005             ADD      SP,SP,#+20
   \   00000104   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??DATA_OUT:
   \   00000000                      DS8 32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     Bsp_EepSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x422181B0         DC32     0x422181b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x00FFFF80         DC32     0xffff80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     recordsfr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     g_Flash_Adr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     ??DATA_OUT

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x42 0x73          DC8 "Bsp EepSem"
   \              0x70 0x20    
   \              0x45 0x65    
   \              0x70 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0D 0x0A          DC8 "\015\012\265\332%05d\314\365\274\307\302\274\243\27220%02d-%02d-%02d %02d:%02d:%02d  "
   \              0xB5 0xDA    
   \              0x25 0x30    
   \              0x35 0x64    
   \              0xCC 0xF5    
   \              0xBC 0xC7    
   \              0xC2 0xBC    
   \              0xA3 0xBA    
   \              0x32 0x30    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x2D 0x25    
   \              0x30 0x32    
   \              0x64 0x2D    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x64 0x3A    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x64 0x20    
   \              0x20 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0xD5 0xFD          DC8 "\325\375\323\320\271\246\265\347\301\277\243\272%10dkW.h  "
   \              0xD3 0xD0    
   \              0xB9 0xA6    
   \              0xB5 0xE7    
   \              0xC1 0xBF    
   \              0xA3 0xBA    
   \              0x25 0x31    
   \              0x30 0x64    
   \              0x6B 0x57    
   \              0x2E 0x68    
   \              0x20 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0xB8 0xBA          DC8 "\270\272\323\320\271\246\265\347\301\277\243\272%10dkW.h  "
   \              0xD3 0xD0    
   \              0xB9 0xA6    
   \              0xB5 0xE7    
   \              0xC1 0xBF    
   \              0xA3 0xBA    
   \              0x25 0x31    
   \              0x30 0x64    
   \              0x6B 0x57    
   \              0x2E 0x68    
   \              0x20 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0xD5 0xFD          DC8 "\325\375\316\336\271\246\265\347\301\277\243\272%10dkvar.h  "
   \              0xCE 0xDE    
   \              0xB9 0xA6    
   \              0xB5 0xE7    
   \              0xC1 0xBF    
   \              0xA3 0xBA    
   \              0x25 0x31    
   \              0x30 0x64    
   \              0x6B 0x76    
   \              0x61 0x72    
   \              0x2E 0x68    
   \              0x20 0x20    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0xB8 0xBA          DC8 "\270\272\316\336\271\246\265\347\301\277\243\272%10dkvar.h  "
   \              0xCE 0xDE    
   \              0xB9 0xA6    
   \              0xB5 0xE7    
   \              0xC1 0xBF    
   \              0xA3 0xBA    
   \              0x25 0x31    
   \              0x30 0x64    
   \              0x6B 0x76    
   \              0x61 0x72    
   \              0x2E 0x68    
   \              0x20 0x20    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0xC0 0xDB          DC8 "\300\333\274\323\272\315\264\355\316\363\243\241"
   \              0xBC 0xD3    
   \              0xBA 0xCD    
   \              0xB4 0xED    
   \              0xCE 0xF3    
   \              0xA3 0xA1    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    642          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   DOWNLOAD
        40   -> FeedDog_HIGH
        40   -> FeedDog_LOW
        40   -> GetCrc16Chk1
        40   -> MX25L3206_RD
        40   -> printf
       0   EEP_SendEvent
         0   -> BSP_OS_SemPost
       0   EEP_WaitEvent
         0   -> BSP_OS_SemWait
       0   FASTREAD
         0   -> MX25L3206_RD
       0   Get_Byte
         0   -> Send_Byte
      24   MX25L3206_Erase
        24   -> Delay
        24   -> Get_Byte
        24   -> Send_Byte
      24   MX25L3206_RD
        24   -> EEP_SendEvent
        24   -> EEP_WaitEvent
        24   -> Get_Byte
        24   -> Send_Byte
      16   MX25L3206_RdID
        16   -> Get_Byte
        16   -> Send_Byte
      24   MX25L3206_WR
        24   -> EEP_SendEvent
        24   -> EEP_WaitEvent
        24   -> Get_Byte
        24   -> Send_Byte
       8   RDSR
         8   -> Get_Byte
         8   -> Send_Byte
      32   SPI_FLASH_Init
        32   -> BSP_OS_SemCreate
        32   -> GPIO_Init
        32   -> RCC_APB1PeriphClockCmd
        32   -> RCC_APB2PeriphClockCmd
        32   -> SPI_Cmd
        32   -> SPI_Flash_WAKEUP
        32   -> SPI_Init
       8   SPI_Flash_WAKEUP
         8   -> Send_Byte
      16   SaveOneREcord
        16   -> EEP_SendEvent
        16   -> EEP_WaitEvent
        16   -> MX25L3206_Erase
         0   -> MX25L3206_WR
      16   SaveRecord
        16   -> GetCrc16Chk1
        16   -> GetTime
        16   -> SaveOneREcord
        16   -> TO_Arayy
        16   -> WriteFM24CL64
      16   Send_Byte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   WRSR
        16   -> Send_Byte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
      12  ?_0
       4  ?_1
      52  ?_2
      24  ?_3
      24  ?_4
      28  ?_5
      28  ?_6
      16  ?_7
      28  Bsp_EepSem
      32  DATA_OUT
     262  DOWNLOAD
       8  EEP_SendEvent
      10  EEP_WaitEvent
       8  FASTREAD
       4  Get_Byte
     402  MX25L3206_Erase
      96  MX25L3206_RD
      42  MX25L3206_RdID
     128  MX25L3206_WR
      24  RDSR
     230  SPI_FLASH_Init
      22  SPI_Flash_WAKEUP
      42  SaveOneREcord
      70  SaveRecord
      50  Send_Byte
      42  WRSR

 
    60 bytes in section .bss
     4 bytes in section .rodata
 1 656 bytes in section .text
 
 1 656 bytes of CODE  memory
     4 bytes of CONST memory
    60 bytes of DATA  memory

Errors: none
Warnings: none
