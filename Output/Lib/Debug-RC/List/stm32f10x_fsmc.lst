###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       22/Nov/2017  18:23:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\BSP\ST\FWLib\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\ST\FWLib\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
#        -D USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\stm32f10x_fsmc.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\stm32f10x_fsmc.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\ST\FWLib\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the FSMC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_fsmc.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup FSMC 
     31            * @brief FSMC driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup FSMC_Private_TypesDefinitions
     36            * @{
     37            */ 
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup FSMC_Private_Defines
     43            * @{
     44            */
     45          
     46          /* --------------------- FSMC registers bit mask ---------------------------- */
     47          
     48          /* FSMC BCRx Mask */
     49          #define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
     50          #define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
     51          #define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
     52          
     53          /* FSMC PCRx Mask */
     54          #define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
     55          #define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
     56          #define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
     57          #define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
     58          #define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
     59          /**
     60            * @}
     61            */
     62          
     63          /** @defgroup FSMC_Private_Macros
     64            * @{
     65            */
     66          
     67          /**
     68            * @}
     69            */
     70          
     71          /** @defgroup FSMC_Private_Variables
     72            * @{
     73            */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @defgroup FSMC_Private_FunctionPrototypes
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup FSMC_Private_Functions
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
     93            *         reset values.
     94            * @param  FSMC_Bank: specifies the FSMC Bank to be used
     95            *   This parameter can be one of the following values:
     96            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
     97            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
     98            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
     99            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    100            * @retval None
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    103          {
    104            /* Check the parameter */
    105            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    106            
    107            /* FSMC_Bank1_NORSRAM1 */
    108            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \                     FSMC_NORSRAMDeInit: (+1)
   \   00000000   0xF04F 0x4120      MOV      R1,#-1610612736
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD103             BNE.N    ??FSMC_NORSRAMDeInit_0
    109            {
    110              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
   \   00000008   0xF243 0x02DB      MOVW     R2,#+12507
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   \   0000000E   0xE003             B.N      ??FSMC_NORSRAMDeInit_1
    111            }
    112            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    113            else
    114            {   
    115              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
   \                     ??FSMC_NORSRAMDeInit_0: (+1)
   \   00000010   0xF243 0x02D2      MOVW     R2,#+12498
   \   00000014   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    116            }
    117            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMDeInit_1: (+1)
   \   00000018   0xF06F 0x4170      MVN      R1,#-268435456
   \   0000001C   0x0082             LSLS     R2,R0,#+2
   \   0000001E   0xF1A2 0x42C0      SUB      R2,R2,#+1610612736
   \   00000022   0x6051             STR      R1,[R2, #+4]
    118            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   00000028   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    119          }
   \   0000002C   0x4770             BX       LR               ;; return
    120          
    121          /**
    122            * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
    123            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    124            *   This parameter can be one of the following values:
    125            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    126            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    127            * @retval None
    128            */

   \                                 In section .text, align 2, keep-with-next
    129          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    130          {
    131            /* Check the parameter */
    132            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    133            
    134            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_NANDDeInit: (+1)
   \   00000000   0xF04F 0x31FC      MOV      R1,#-50529028
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0xa0000060
   \   00000008   0x2810             CMP      R0,#+16
   \   0000000A   0xD106             BNE.N    ??FSMC_NANDDeInit_0
    135            {
    136              /* Set the FSMC_Bank2 registers to their reset values */
    137              FSMC_Bank2->PCR2 = 0x00000018;
   \   0000000C   0x2018             MOVS     R0,#+24
   \   0000000E   0x6010             STR      R0,[R2, #+0]
    138              FSMC_Bank2->SR2 = 0x00000040;
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0x6050             STR      R0,[R2, #+4]
    139              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \   00000014   0x6091             STR      R1,[R2, #+8]
    140              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \   00000016   0x60D1             STR      R1,[R2, #+12]
   \   00000018   0x4770             BX       LR
    141            }
    142            /* FSMC_Bank3_NAND */  
    143            else
    144            {
    145              /* Set the FSMC_Bank3 registers to their reset values */
    146              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_0: (+1)
   \   0000001A   0x2018             MOVS     R0,#+24
   \   0000001C   0x6210             STR      R0,[R2, #+32]
    147              FSMC_Bank3->SR3 = 0x00000040;
   \   0000001E   0x2040             MOVS     R0,#+64
   \   00000020   0x6250             STR      R0,[R2, #+36]
    148              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \   00000022   0x6291             STR      R1,[R2, #+40]
    149              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \   00000024   0x62D1             STR      R1,[R2, #+44]
    150            }  
    151          }
   \   00000026   0x4770             BX       LR               ;; return
    152          
    153          /**
    154            * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
    155            * @param  None                       
    156            * @retval None
    157            */

   \                                 In section .text, align 2, keep-with-next
    158          void FSMC_PCCARDDeInit(void)
    159          {
    160            /* Set the FSMC_Bank4 registers to their reset values */
    161            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0xa00000a0
   \   00000004   0x2118             MOVS     R1,#+24
   \   00000006   0x6001             STR      R1,[R0, #+0]
    162            FSMC_Bank4->SR4 = 0x00000000;	
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    163            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \   0000000C   0xF04F 0x31FC      MOV      R1,#-50529028
   \   00000010   0x6081             STR      R1,[R0, #+8]
    164            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    165            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \   00000014   0x6101             STR      R1,[R0, #+16]
    166          }
   \   00000016   0x4770             BX       LR               ;; return
    167          
    168          /**
    169            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    170            *         parameters in the FSMC_NORSRAMInitStruct.
    171            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
    172            *         structure that contains the configuration information for 
    173            *        the FSMC NOR/SRAM specified Banks.                       
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    177          { 
   \                     FSMC_NORSRAMInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    178            /* Check the parameters */
    179            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    180            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    181            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    182            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    183            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    184            assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
    185            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    186            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    187            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    188            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    189            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    190            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    191            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
    192            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    193            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    194            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    195            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    196            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    197            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    198            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
    199            
    200            /* Bank1 NOR/SRAM control register configuration */ 
    201            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    202                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    203                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    204                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    205                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    206                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    207                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    208                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    209                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    210                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    211                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    212                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    213                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \   00000002   0xF04F 0x4120      MOV      R1,#-1610612736
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0x6883             LDR      R3,[R0, #+8]
   \   0000000A   0x431A             ORRS     R2,R3,R2
   \   0000000C   0x68C3             LDR      R3,[R0, #+12]
   \   0000000E   0x431A             ORRS     R2,R3,R2
   \   00000010   0x6903             LDR      R3,[R0, #+16]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x6943             LDR      R3,[R0, #+20]
   \   00000016   0x431A             ORRS     R2,R3,R2
   \   00000018   0x6983             LDR      R3,[R0, #+24]
   \   0000001A   0x431A             ORRS     R2,R3,R2
   \   0000001C   0x69C3             LDR      R3,[R0, #+28]
   \   0000001E   0x431A             ORRS     R2,R3,R2
   \   00000020   0x6A03             LDR      R3,[R0, #+32]
   \   00000022   0x431A             ORRS     R2,R3,R2
   \   00000024   0x6A43             LDR      R3,[R0, #+36]
   \   00000026   0x431A             ORRS     R2,R3,R2
   \   00000028   0x6A83             LDR      R3,[R0, #+40]
   \   0000002A   0x431A             ORRS     R2,R3,R2
   \   0000002C   0x6AC3             LDR      R3,[R0, #+44]
   \   0000002E   0x431A             ORRS     R2,R3,R2
   \   00000030   0x6B03             LDR      R3,[R0, #+48]
   \   00000032   0x431A             ORRS     R2,R3,R2
   \   00000034   0x6803             LDR      R3,[R0, #+0]
   \   00000036   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
    214          
    215            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \   0000003A   0x6882             LDR      R2,[R0, #+8]
   \   0000003C   0x2A08             CMP      R2,#+8
   \   0000003E   0xD106             BNE.N    ??FSMC_NORSRAMInit_0
    216            {
    217              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0xF851 0x3022      LDR      R3,[R1, R2, LSL #+2]
   \   00000046   0xF043 0x0340      ORR      R3,R3,#0x40
   \   0000004A   0xF841 0x3022      STR      R3,[R1, R2, LSL #+2]
    218            }
    219            
    220            /* Bank1 NOR/SRAM timing register configuration */
    221            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    222                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    223                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    224                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    225                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    226                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    227                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    228                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_0: (+1)
   \   0000004E   0x6B41             LDR      R1,[R0, #+52]
   \   00000050   0x680A             LDR      R2,[R1, #+0]
   \   00000052   0x684B             LDR      R3,[R1, #+4]
   \   00000054   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   00000058   0x688B             LDR      R3,[R1, #+8]
   \   0000005A   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000005E   0x68CB             LDR      R3,[R1, #+12]
   \   00000060   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000064   0x690B             LDR      R3,[R1, #+16]
   \   00000066   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   0000006A   0x694B             LDR      R3,[R1, #+20]
   \   0000006C   0xEA42 0x6203      ORR      R2,R2,R3, LSL #+24
   \   00000070   0x6989             LDR      R1,[R1, #+24]
   \   00000072   0x4311             ORRS     R1,R1,R2
   \   00000074   0x6802             LDR      R2,[R0, #+0]
   \   00000076   0x0092             LSLS     R2,R2,#+2
   \   00000078   0xF1A2 0x42C0      SUB      R2,R2,#+1610612736
   \   0000007C   0x6051             STR      R1,[R2, #+4]
    229                      
    230              
    231            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    232            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   00000084   0x6AC3             LDR      R3,[R0, #+44]
   \   00000086   0xF5B3 0x4F80      CMP      R3,#+16384
   \   0000008A   0xD112             BNE.N    ??FSMC_NORSRAMInit_1
    233            {
    234              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    235              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    236              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    237              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    238              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    239              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    240              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    241                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    242                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    243                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    244                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    245                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    246                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \   0000008C   0x6B80             LDR      R0,[R0, #+56]
   \   0000008E   0x6803             LDR      R3,[R0, #+0]
   \   00000090   0x6844             LDR      R4,[R0, #+4]
   \   00000092   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   00000096   0x6884             LDR      R4,[R0, #+8]
   \   00000098   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000009C   0x6904             LDR      R4,[R0, #+16]
   \   0000009E   0xEA43 0x5304      ORR      R3,R3,R4, LSL #+20
   \   000000A2   0x6944             LDR      R4,[R0, #+20]
   \   000000A4   0xEA43 0x6304      ORR      R3,R3,R4, LSL #+24
   \   000000A8   0x6980             LDR      R0,[R0, #+24]
   \   000000AA   0x4318             ORRS     R0,R0,R3
   \   000000AC   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   000000B0   0xE003             B.N      ??FSMC_NORSRAMInit_2
    247            }
    248            else
    249            {
    250              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_1: (+1)
   \   000000B2   0xF06F 0x4070      MVN      R0,#-268435456
   \   000000B6   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    251            }
    252          }
   \                     ??FSMC_NORSRAMInit_2: (+1)
   \   000000BA   0xBC10             POP      {R4}
   \   000000BC   0x4770             BX       LR               ;; return
    253          
    254          /**
    255            * @brief  Initializes the FSMC NAND Banks according to the specified 
    256            *         parameters in the FSMC_NANDInitStruct.
    257            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
    258            *         structure that contains the configuration information for the FSMC 
    259            *         NAND specified Banks.                       
    260            * @retval None
    261            */

   \                                 In section .text, align 2, keep-with-next
    262          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    263          {
   \                     FSMC_NANDInit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    264            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
    265              
    266            /* Check the parameters */
    267            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    268            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    269            assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    270            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    271            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    272            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    273            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    274            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    275            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    276            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    277            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    278            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    279            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    280            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    281            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    282            
    283            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    284            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    285                      PCR_MemoryType_NAND |
    286                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    287                      FSMC_NANDInitStruct->FSMC_ECC |
    288                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    289                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    290                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x6882             LDR      R2,[R0, #+8]
   \   00000006   0x4311             ORRS     R1,R2,R1
   \   00000008   0x68C2             LDR      R2,[R0, #+12]
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0x6902             LDR      R2,[R0, #+16]
   \   0000000E   0x4311             ORRS     R1,R2,R1
   \   00000010   0x6942             LDR      R2,[R0, #+20]
   \   00000012   0xEA41 0x2142      ORR      R1,R1,R2, LSL #+9
   \   00000016   0x6982             LDR      R2,[R0, #+24]
   \   00000018   0xEA41 0x3142      ORR      R1,R1,R2, LSL #+13
   \   0000001C   0xF041 0x0108      ORR      R1,R1,#0x8
    291                      
    292            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    293            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    294                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    295                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    296                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   00000020   0x69C2             LDR      R2,[R0, #+28]
   \   00000022   0x6813             LDR      R3,[R2, #+0]
   \   00000024   0x6854             LDR      R4,[R2, #+4]
   \   00000026   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000002A   0x6894             LDR      R4,[R2, #+8]
   \   0000002C   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000030   0x68D2             LDR      R2,[R2, #+12]
   \   00000032   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
    297                      
    298            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    299            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    300                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    301                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    302                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \   00000036   0x6A03             LDR      R3,[R0, #+32]
   \   00000038   0x681C             LDR      R4,[R3, #+0]
   \   0000003A   0x685D             LDR      R5,[R3, #+4]
   \   0000003C   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   00000040   0x689D             LDR      R5,[R3, #+8]
   \   00000042   0xEA44 0x4405      ORR      R4,R4,R5, LSL #+16
   \   00000046   0x68DB             LDR      R3,[R3, #+12]
   \   00000048   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
    303            
    304            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \   0000004C   0x....             LDR.N    R4,??DataTable15_1  ;; 0xa0000060
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x2810             CMP      R0,#+16
   \   00000052   0xD103             BNE.N    ??FSMC_NANDInit_0
    305            {
    306              /* FSMC_Bank2_NAND registers configuration */
    307              FSMC_Bank2->PCR2 = tmppcr;
   \   00000054   0x6021             STR      R1,[R4, #+0]
    308              FSMC_Bank2->PMEM2 = tmppmem;
   \   00000056   0x60A2             STR      R2,[R4, #+8]
    309              FSMC_Bank2->PATT2 = tmppatt;
   \   00000058   0x60E3             STR      R3,[R4, #+12]
   \   0000005A   0xE002             B.N      ??FSMC_NANDInit_1
    310            }
    311            else
    312            {
    313              /* FSMC_Bank3_NAND registers configuration */
    314              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_0: (+1)
   \   0000005C   0x6221             STR      R1,[R4, #+32]
    315              FSMC_Bank3->PMEM3 = tmppmem;
   \   0000005E   0x62A2             STR      R2,[R4, #+40]
    316              FSMC_Bank3->PATT3 = tmppatt;
   \   00000060   0x62E3             STR      R3,[R4, #+44]
    317            }
    318          }
   \                     ??FSMC_NANDInit_1: (+1)
   \   00000062   0xBC30             POP      {R4,R5}
   \   00000064   0x4770             BX       LR               ;; return
    319          
    320          /**
    321            * @brief  Initializes the FSMC PCCARD Bank according to the specified 
    322            *         parameters in the FSMC_PCCARDInitStruct.
    323            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
    324            *         structure that contains the configuration information for the FSMC 
    325            *         PCCARD Bank.                       
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    329          {
   \                     FSMC_PCCARDInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    330            /* Check the parameters */
    331            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    332            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    333            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    334           
    335            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    336            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    337            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    338            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    339            
    340            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    341            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    342            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    343            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    344            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    345            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    346            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    347            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    348            
    349            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    350            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    351                               FSMC_MemoryDataWidth_16b |  
    352                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    353                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \   00000002   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa00000a0
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x6843             LDR      R3,[R0, #+4]
   \   00000008   0xEA42 0x2243      ORR      R2,R2,R3, LSL #+9
   \   0000000C   0x6883             LDR      R3,[R0, #+8]
   \   0000000E   0xEA42 0x3243      ORR      R2,R2,R3, LSL #+13
   \   00000012   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000016   0x600A             STR      R2,[R1, #+0]
    354                      
    355            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    356            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    357                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    358                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    359                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0x6813             LDR      R3,[R2, #+0]
   \   0000001C   0x6854             LDR      R4,[R2, #+4]
   \   0000001E   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000022   0x6894             LDR      R4,[R2, #+8]
   \   00000024   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000028   0x68D2             LDR      R2,[R2, #+12]
   \   0000002A   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   0000002E   0x608A             STR      R2,[R1, #+8]
    360                      
    361            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    362            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    363                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    364                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    365                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \   00000030   0x6902             LDR      R2,[R0, #+16]
   \   00000032   0x6813             LDR      R3,[R2, #+0]
   \   00000034   0x6854             LDR      R4,[R2, #+4]
   \   00000036   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000003A   0x6894             LDR      R4,[R2, #+8]
   \   0000003C   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000040   0x68D2             LDR      R2,[R2, #+12]
   \   00000042   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   00000046   0x60CA             STR      R2,[R1, #+12]
    366                      
    367            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    368            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    369                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    370                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    371                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0x6802             LDR      R2,[R0, #+0]
   \   0000004C   0x6843             LDR      R3,[R0, #+4]
   \   0000004E   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000052   0x6883             LDR      R3,[R0, #+8]
   \   00000054   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xEA42 0x6000      ORR      R0,R2,R0, LSL #+24
   \   0000005E   0x6108             STR      R0,[R1, #+16]
    372          }
   \   00000060   0xBC10             POP      {R4}
   \   00000062   0x4770             BX       LR               ;; return
    373          
    374          /**
    375            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    376            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
    377            *         structure which will be initialized.
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    381          {  
    382            /* Reset NOR/SRAM Init structure parameters values */
    383            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \                     FSMC_NORSRAMStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    384            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x6041             STR      R1,[R0, #+4]
    385            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    386            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    387            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    388            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   \   00000010   0x6141             STR      R1,[R0, #+20]
    389            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \   00000012   0x6181             STR      R1,[R0, #+24]
    390            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \   00000014   0x61C1             STR      R1,[R0, #+28]
    391            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \   00000016   0x6201             STR      R1,[R0, #+32]
    392            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \   00000018   0xF44F 0x5180      MOV      R1,#+4096
   \   0000001C   0x6241             STR      R1,[R0, #+36]
    393            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \   0000001E   0xF44F 0x5100      MOV      R1,#+8192
   \   00000022   0x6281             STR      R1,[R0, #+40]
    394            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x62C1             STR      R1,[R0, #+44]
    395            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   \   00000028   0x6301             STR      R1,[R0, #+48]
    396            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   0000002A   0x210F             MOVS     R1,#+15
   \   0000002C   0x6B42             LDR      R2,[R0, #+52]
   \   0000002E   0x6011             STR      R1,[R2, #+0]
    397            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   00000030   0x6B42             LDR      R2,[R0, #+52]
   \   00000032   0x6051             STR      R1,[R2, #+4]
    398            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   00000034   0x21FF             MOVS     R1,#+255
   \   00000036   0x6B42             LDR      R2,[R0, #+52]
   \   00000038   0x6091             STR      R1,[R2, #+8]
    399            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   0000003A   0x220F             MOVS     R2,#+15
   \   0000003C   0x6B43             LDR      R3,[R0, #+52]
   \   0000003E   0x60DA             STR      R2,[R3, #+12]
    400            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   00000040   0x6B43             LDR      R3,[R0, #+52]
   \   00000042   0x611A             STR      R2,[R3, #+16]
    401            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000044   0x6B43             LDR      R3,[R0, #+52]
   \   00000046   0x615A             STR      R2,[R3, #+20]
    402            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x6B43             LDR      R3,[R0, #+52]
   \   0000004C   0x619A             STR      R2,[R3, #+24]
    403            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   0000004E   0x220F             MOVS     R2,#+15
   \   00000050   0x6B83             LDR      R3,[R0, #+56]
   \   00000052   0x601A             STR      R2,[R3, #+0]
    404            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   00000054   0x6B83             LDR      R3,[R0, #+56]
   \   00000056   0x605A             STR      R2,[R3, #+4]
    405            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   00000058   0x6B82             LDR      R2,[R0, #+56]
   \   0000005A   0x6091             STR      R1,[R2, #+8]
    406            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   0000005C   0x210F             MOVS     R1,#+15
   \   0000005E   0x6B82             LDR      R2,[R0, #+56]
   \   00000060   0x60D1             STR      R1,[R2, #+12]
    407            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   00000062   0x6B82             LDR      R2,[R0, #+56]
   \   00000064   0x6111             STR      R1,[R2, #+16]
    408            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000066   0x6B82             LDR      R2,[R0, #+56]
   \   00000068   0x6151             STR      R1,[R2, #+20]
    409            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6B80             LDR      R0,[R0, #+56]
   \   0000006E   0x6181             STR      R1,[R0, #+24]
    410          }
   \   00000070   0x4770             BX       LR               ;; return
    411          
    412          /**
    413            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    414            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
    415            *         structure which will be initialized.
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    419          { 
    420            /* Reset NAND Init structure parameters values */
    421            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit: (+1)
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0x6001             STR      R1,[R0, #+0]
    422            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    423            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   00000008   0x6081             STR      R1,[R0, #+8]
    424            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
    425            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \   0000000C   0x6101             STR      R1,[R0, #+16]
    426            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   0000000E   0x6141             STR      R1,[R0, #+20]
    427            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000010   0x6181             STR      R1,[R0, #+24]
    428            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000012   0x21FC             MOVS     R1,#+252
   \   00000014   0x69C2             LDR      R2,[R0, #+28]
   \   00000016   0x6011             STR      R1,[R2, #+0]
    429            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000018   0x69C2             LDR      R2,[R0, #+28]
   \   0000001A   0x6051             STR      R1,[R2, #+4]
    430            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   0000001C   0x69C2             LDR      R2,[R0, #+28]
   \   0000001E   0x6091             STR      R1,[R2, #+8]
    431            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   00000020   0x69C2             LDR      R2,[R0, #+28]
   \   00000022   0x60D1             STR      R1,[R2, #+12]
    432            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000024   0x6A02             LDR      R2,[R0, #+32]
   \   00000026   0x6011             STR      R1,[R2, #+0]
    433            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000028   0x6A02             LDR      R2,[R0, #+32]
   \   0000002A   0x6051             STR      R1,[R2, #+4]
    434            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x6091             STR      R1,[R2, #+8]
    435            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
   \   00000030   0x6A00             LDR      R0,[R0, #+32]
   \   00000032   0x60C1             STR      R1,[R0, #+12]
    436          }
   \   00000034   0x4770             BX       LR               ;; return
    437          
    438          /**
    439            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    440            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
    441            *         structure which will be initialized.
    442            * @retval None
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    445          {
    446            /* Reset PCCARD Init structure parameters values */
    447            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    448            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    449            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    450            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000008   0x21FC             MOVS     R1,#+252
   \   0000000A   0x68C2             LDR      R2,[R0, #+12]
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    451            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000000E   0x68C2             LDR      R2,[R0, #+12]
   \   00000010   0x6051             STR      R1,[R2, #+4]
    452            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000012   0x68C2             LDR      R2,[R0, #+12]
   \   00000014   0x6091             STR      R1,[R2, #+8]
    453            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   00000016   0x68C2             LDR      R2,[R0, #+12]
   \   00000018   0x60D1             STR      R1,[R2, #+12]
    454            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000001A   0x6902             LDR      R2,[R0, #+16]
   \   0000001C   0x6011             STR      R1,[R2, #+0]
    455            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000001E   0x6902             LDR      R2,[R0, #+16]
   \   00000020   0x6051             STR      R1,[R2, #+4]
    456            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000022   0x6902             LDR      R2,[R0, #+16]
   \   00000024   0x6091             STR      R1,[R2, #+8]
    457            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \   00000026   0x6902             LDR      R2,[R0, #+16]
   \   00000028   0x60D1             STR      R1,[R2, #+12]
    458            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000002A   0x6942             LDR      R2,[R0, #+20]
   \   0000002C   0x6011             STR      R1,[R2, #+0]
    459            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000002E   0x6942             LDR      R2,[R0, #+20]
   \   00000030   0x6051             STR      R1,[R2, #+4]
    460            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000032   0x6942             LDR      R2,[R0, #+20]
   \   00000034   0x6091             STR      R1,[R2, #+8]
    461            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   00000036   0x6940             LDR      R0,[R0, #+20]
   \   00000038   0x60C1             STR      R1,[R0, #+12]
    462          }
   \   0000003A   0x4770             BX       LR               ;; return
    463          
    464          /**
    465            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    466            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    467            *   This parameter can be one of the following values:
    468            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    469            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    470            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    471            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    472            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    473            * @retval None
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    476          {
    477            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
    479            
    480            if (NewState != DISABLE)
   \                     FSMC_NORSRAMCmd: (+1)
   \   00000000   0xF04F 0x4220      MOV      R2,#-1610612736
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xF852 0x1020      LDR      R1,[R2, R0, LSL #+2]
   \   0000000A   0xD004             BEQ.N    ??FSMC_NORSRAMCmd_0
    481            {
    482              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    483              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR
    484            }
    485            else
    486            {
    487              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    488              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
   \                     ??FSMC_NORSRAMCmd_0: (+1)
   \   00000016   0x....             LDR.N    R3,??DataTable15_3  ;; 0xffffe
   \   00000018   0x4019             ANDS     R1,R3,R1
   \   0000001A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    489            }
    490          }
   \   0000001E   0x4770             BX       LR               ;; return
    491          
    492          /**
    493            * @brief  Enables or disables the specified NAND Memory Bank.
    494            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    495            *   This parameter can be one of the following values:
    496            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    497            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    498            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    499            * @retval None
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    502          {
    503            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    504            assert_param(IS_FUNCTIONAL_STATE(NewState));
    505            
    506            if (NewState != DISABLE)
   \                     FSMC_NANDCmd: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable15_1  ;; 0xa0000060
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00B             BEQ.N    ??FSMC_NANDCmd_0
    507            {
    508              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    509              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD104             BNE.N    ??FSMC_NANDCmd_1
    510              {
    511                FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000010   0x6010             STR      R0,[R2, #+0]
   \   00000012   0x4770             BX       LR
    512              }
    513              else
    514              {
    515                FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
   \                     ??FSMC_NANDCmd_1: (+1)
   \   00000014   0x6A10             LDR      R0,[R2, #+32]
   \   00000016   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000001A   0x6210             STR      R0,[R2, #+32]
   \   0000001C   0x4770             BX       LR
    516              }
    517            }
    518            else
    519            {
    520              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    521              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_0: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable15_4  ;; 0xffffb
   \   00000020   0x2810             CMP      R0,#+16
   \   00000022   0xD103             BNE.N    ??FSMC_NANDCmd_2
    522              {
    523                FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
   \   00000024   0x6810             LDR      R0,[R2, #+0]
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x6010             STR      R0,[R2, #+0]
   \   0000002A   0x4770             BX       LR
    524              }
    525              else
    526              {
    527                FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
   \                     ??FSMC_NANDCmd_2: (+1)
   \   0000002C   0x6A10             LDR      R0,[R2, #+32]
   \   0000002E   0x4008             ANDS     R0,R1,R0
   \   00000030   0x6210             STR      R0,[R2, #+32]
    528              }
    529            }
    530          }
   \   00000032   0x4770             BX       LR               ;; return
    531          
    532          /**
    533            * @brief  Enables or disables the PCCARD Memory Bank.
    534            * @param  NewState: new state of the PCCARD Memory Bank.  
    535            *   This parameter can be: ENABLE or DISABLE.
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void FSMC_PCCARDCmd(FunctionalState NewState)
    539          {
    540            assert_param(IS_FUNCTIONAL_STATE(NewState));
    541            
    542            if (NewState != DISABLE)
   \                     FSMC_PCCARDCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa00000a0
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??FSMC_PCCARDCmd_0
    543            {
    544              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    545              FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
   \   00000008   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    546            }
    547            else
    548            {
    549              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    550              FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
   \                     ??FSMC_PCCARDCmd_0: (+1)
   \   00000010   0x....             LDR.N    R2,??DataTable15_4  ;; 0xffffb
   \   00000012   0x4010             ANDS     R0,R2,R0
   \   00000014   0x6008             STR      R0,[R1, #+0]
    551            }
    552          }
   \   00000016   0x4770             BX       LR               ;; return
    553          
    554          /**
    555            * @brief  Enables or disables the FSMC NAND ECC feature.
    556            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    557            *   This parameter can be one of the following values:
    558            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    559            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    560            * @param  NewState: new state of the FSMC NAND ECC feature.  
    561            *   This parameter can be: ENABLE or DISABLE.
    562            * @retval None
    563            */

   \                                 In section .text, align 2, keep-with-next
    564          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    565          {
    566            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    567            assert_param(IS_FUNCTIONAL_STATE(NewState));
    568            
    569            if (NewState != DISABLE)
   \                     FSMC_NANDECCCmd: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable15_1  ;; 0xa0000060
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00B             BEQ.N    ??FSMC_NANDECCCmd_0
    570            {
    571              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    572              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD104             BNE.N    ??FSMC_NANDECCCmd_1
    573              {
    574                FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000010   0x6010             STR      R0,[R2, #+0]
   \   00000012   0x4770             BX       LR
    575              }
    576              else
    577              {
    578                FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
   \                     ??FSMC_NANDECCCmd_1: (+1)
   \   00000014   0x6A10             LDR      R0,[R2, #+32]
   \   00000016   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000001A   0x6210             STR      R0,[R2, #+32]
   \   0000001C   0x4770             BX       LR
    579              }
    580            }
    581            else
    582            {
    583              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    584              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_0: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable15_5  ;; 0xfffbf
   \   00000020   0x2810             CMP      R0,#+16
   \   00000022   0xD103             BNE.N    ??FSMC_NANDECCCmd_2
    585              {
    586                FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
   \   00000024   0x6810             LDR      R0,[R2, #+0]
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x6010             STR      R0,[R2, #+0]
   \   0000002A   0x4770             BX       LR
    587              }
    588              else
    589              {
    590                FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
   \                     ??FSMC_NANDECCCmd_2: (+1)
   \   0000002C   0x6A10             LDR      R0,[R2, #+32]
   \   0000002E   0x4008             ANDS     R0,R1,R0
   \   00000030   0x6210             STR      R0,[R2, #+32]
    591              }
    592            }
    593          }
   \   00000032   0x4770             BX       LR               ;; return
    594          
    595          /**
    596            * @brief  Returns the error correction code register value.
    597            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    598            *   This parameter can be one of the following values:
    599            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    600            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    601            * @retval The Error Correction Code (ECC) value.
    602            */

   \                                 In section .text, align 2, keep-with-next
    603          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    604          {
    605            uint32_t eccval = 0x00000000;
    606            
    607            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_GetECC: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000074
   \   00000002   0x2810             CMP      R0,#+16
   \   00000004   0xD101             BNE.N    ??FSMC_GetECC_0
    608            {
    609              /* Get the ECCR2 register value */
    610              eccval = FSMC_Bank2->ECCR2;
   \   00000006   0x6808             LDR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR
    611            }
    612            else
    613            {
    614              /* Get the ECCR3 register value */
    615              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0: (+1)
   \   0000000A   0x6A08             LDR      R0,[R1, #+32]
    616            }
    617            /* Return the error correction code value */
    618            return(eccval);
   \   0000000C   0x4770             BX       LR               ;; return
    619          }
    620          
    621          /**
    622            * @brief  Enables or disables the specified FSMC interrupts.
    623            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    624            *   This parameter can be one of the following values:
    625            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    626            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    627            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    628            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    629            *   This parameter can be any combination of the following values:
    630            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    631            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    632            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    633            * @param  NewState: new state of the specified FSMC interrupts.
    634            *   This parameter can be: ENABLE or DISABLE.
    635            * @retval None
    636            */

   \                                 In section .text, align 2, keep-with-next
    637          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    638          {
    639            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    640            assert_param(IS_FSMC_IT(FSMC_IT));	
    641            assert_param(IS_FUNCTIONAL_STATE(NewState));
    642            
    643            if (NewState != DISABLE)
   \                     FSMC_ITConfig: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable15_7  ;; 0xa0000064
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD010             BEQ.N    ??FSMC_ITConfig_0
    644            {
    645              /* Enable the selected FSMC_Bank2 interrupts */
    646              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD103             BNE.N    ??FSMC_ITConfig_1
    647              {
    648                FSMC_Bank2->SR2 |= FSMC_IT;
   \   0000000A   0x6818             LDR      R0,[R3, #+0]
   \   0000000C   0x4308             ORRS     R0,R1,R0
   \   0000000E   0x6018             STR      R0,[R3, #+0]
   \   00000010   0x4770             BX       LR
    649              }
    650              /* Enable the selected FSMC_Bank3 interrupts */
    651              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_1: (+1)
   \   00000012   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000016   0xD103             BNE.N    ??FSMC_ITConfig_2
    652              {
    653                FSMC_Bank3->SR3 |= FSMC_IT;
   \   00000018   0x6A18             LDR      R0,[R3, #+32]
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x6218             STR      R0,[R3, #+32]
   \   0000001E   0x4770             BX       LR
    654              }
    655              /* Enable the selected FSMC_Bank4 interrupts */
    656              else
    657              {
    658                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_2: (+1)
   \   00000020   0x6C18             LDR      R0,[R3, #+64]
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x6418             STR      R0,[R3, #+64]
   \   00000026   0x4770             BX       LR
    659              }
    660            }
    661            else
    662            {
    663              /* Disable the selected FSMC_Bank2 interrupts */
    664              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_0: (+1)
   \   00000028   0x43C9             MVNS     R1,R1
   \   0000002A   0x2810             CMP      R0,#+16
   \   0000002C   0xD103             BNE.N    ??FSMC_ITConfig_3
    665              {
    666                
    667                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
   \   0000002E   0x6818             LDR      R0,[R3, #+0]
   \   00000030   0x4008             ANDS     R0,R1,R0
   \   00000032   0x6018             STR      R0,[R3, #+0]
   \   00000034   0x4770             BX       LR
    668              }
    669              /* Disable the selected FSMC_Bank3 interrupts */
    670              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_3: (+1)
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD103             BNE.N    ??FSMC_ITConfig_4
    671              {
    672                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
   \   0000003C   0x6A18             LDR      R0,[R3, #+32]
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x6218             STR      R0,[R3, #+32]
   \   00000042   0x4770             BX       LR
    673              }
    674              /* Disable the selected FSMC_Bank4 interrupts */
    675              else
    676              {
    677                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
   \                     ??FSMC_ITConfig_4: (+1)
   \   00000044   0x6C18             LDR      R0,[R3, #+64]
   \   00000046   0x4008             ANDS     R0,R1,R0
   \   00000048   0x6418             STR      R0,[R3, #+64]
    678              }
    679            }
    680          }
   \   0000004A   0x4770             BX       LR               ;; return
    681          
    682          /**
    683            * @brief  Checks whether the specified FSMC flag is set or not.
    684            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    685            *   This parameter can be one of the following values:
    686            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    687            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    688            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    689            * @param  FSMC_FLAG: specifies the flag to check.
    690            *   This parameter can be one of the following values:
    691            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    692            *     @arg FSMC_FLAG_Level: Level detection Flag.
    693            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    694            *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    695            * @retval The new state of FSMC_FLAG (SET or RESET).
    696            */

   \                                 In section .text, align 2, keep-with-next
    697          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    698          {
    699            FlagStatus bitstatus = RESET;
   \                     FSMC_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    700            uint32_t tmpsr = 0x00000000;
    701            
    702            /* Check the parameters */
    703            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    704            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    705            
    706            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000002   0x....             LDR.N    R3,??DataTable15_7  ;; 0xa0000064
   \   00000004   0x2810             CMP      R0,#+16
   \   00000006   0xD101             BNE.N    ??FSMC_GetFlagStatus_0
    707            {
    708              tmpsr = FSMC_Bank2->SR2;
   \   00000008   0x6818             LDR      R0,[R3, #+0]
   \   0000000A   0xE005             B.N      ??FSMC_GetFlagStatus_1
    709            }  
    710            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetFlagStatus_0: (+1)
   \   0000000C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000010   0xD101             BNE.N    ??FSMC_GetFlagStatus_2
    711            {
    712              tmpsr = FSMC_Bank3->SR3;
   \   00000012   0x6A18             LDR      R0,[R3, #+32]
   \   00000014   0xE000             B.N      ??FSMC_GetFlagStatus_1
    713            }
    714            /* FSMC_Bank4_PCCARD*/
    715            else
    716            {
    717              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetFlagStatus_2: (+1)
   \   00000016   0x6C18             LDR      R0,[R3, #+64]
    718            } 
    719            
    720            /* Get the flag status */
    721            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
   \                     ??FSMC_GetFlagStatus_1: (+1)
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD000             BEQ.N    ??FSMC_GetFlagStatus_3
    722            {
    723              bitstatus = SET;
   \   0000001C   0x2201             MOVS     R2,#+1
    724            }
    725            else
    726            {
    727              bitstatus = RESET;
    728            }
    729            /* Return the flag status */
    730            return bitstatus;
   \                     ??FSMC_GetFlagStatus_3: (+1)
   \   0000001E   0x4610             MOV      R0,R2
   \   00000020   0x4770             BX       LR               ;; return
    731          }
    732          
    733          /**
    734            * @brief  Clears the FSMC's pending flags.
    735            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    736            *   This parameter can be one of the following values:
    737            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    738            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    739            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    740            * @param  FSMC_FLAG: specifies the flag to clear.
    741            *   This parameter can be any combination of the following values:
    742            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    743            *     @arg FSMC_FLAG_Level: Level detection Flag.
    744            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    745            * @retval None
    746            */

   \                                 In section .text, align 2, keep-with-next
    747          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    748          {
    749           /* Check the parameters */
    750            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    751            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    752              
    753            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearFlag: (+1)
   \   00000000   0x43C9             MVNS     R1,R1
   \   00000002   0x....             LDR.N    R2,??DataTable15_7  ;; 0xa0000064
   \   00000004   0x2810             CMP      R0,#+16
   \   00000006   0xD103             BNE.N    ??FSMC_ClearFlag_0
    754            {
    755              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \   00000008   0x6810             LDR      R0,[R2, #+0]
   \   0000000A   0x4008             ANDS     R0,R1,R0
   \   0000000C   0x6010             STR      R0,[R2, #+0]
   \   0000000E   0x4770             BX       LR
    756            }  
    757            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_0: (+1)
   \   00000010   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000014   0xD103             BNE.N    ??FSMC_ClearFlag_1
    758            {
    759              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \   00000016   0x6A10             LDR      R0,[R2, #+32]
   \   00000018   0x4008             ANDS     R0,R1,R0
   \   0000001A   0x6210             STR      R0,[R2, #+32]
   \   0000001C   0x4770             BX       LR
    760            }
    761            /* FSMC_Bank4_PCCARD*/
    762            else
    763            {
    764              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_1: (+1)
   \   0000001E   0x6C10             LDR      R0,[R2, #+64]
   \   00000020   0x4008             ANDS     R0,R1,R0
   \   00000022   0x6410             STR      R0,[R2, #+64]
    765            }
    766          }
   \   00000024   0x4770             BX       LR               ;; return
    767          
    768          /**
    769            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    770            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    771            *   This parameter can be one of the following values:
    772            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    773            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    774            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    775            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    776            *   This parameter can be one of the following values:
    777            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    778            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    779            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    780            * @retval The new state of FSMC_IT (SET or RESET).
    781            */

   \                                 In section .text, align 2, keep-with-next
    782          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    783          {
    784            ITStatus bitstatus = RESET;
   \                     FSMC_GetITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    785            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
    786            
    787            /* Check the parameters */
    788            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    789            assert_param(IS_FSMC_GET_IT(FSMC_IT));
    790            
    791            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000002   0x....             LDR.N    R3,??DataTable15_7  ;; 0xa0000064
   \   00000004   0x2810             CMP      R0,#+16
   \   00000006   0xD101             BNE.N    ??FSMC_GetITStatus_0
    792            {
    793              tmpsr = FSMC_Bank2->SR2;
   \   00000008   0x6818             LDR      R0,[R3, #+0]
   \   0000000A   0xE005             B.N      ??FSMC_GetITStatus_1
    794            }  
    795            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetITStatus_0: (+1)
   \   0000000C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000010   0xD101             BNE.N    ??FSMC_GetITStatus_2
    796            {
    797              tmpsr = FSMC_Bank3->SR3;
   \   00000012   0x6A18             LDR      R0,[R3, #+32]
   \   00000014   0xE000             B.N      ??FSMC_GetITStatus_1
    798            }
    799            /* FSMC_Bank4_PCCARD*/
    800            else
    801            {
    802              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetITStatus_2: (+1)
   \   00000016   0x6C18             LDR      R0,[R3, #+64]
    803            } 
    804            
    805            itstatus = tmpsr & FSMC_IT;
    806            
    807            itenable = tmpsr & (FSMC_IT >> 3);
   \                     ??FSMC_GetITStatus_1: (+1)
   \   00000018   0xEA00 0x03D1      AND      R3,R0,R1, LSR #+3
    808            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \   0000001C   0x4208             TST      R0,R1
   \   0000001E   0xD002             BEQ.N    ??FSMC_GetITStatus_3
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD000             BEQ.N    ??FSMC_GetITStatus_3
    809            {
    810              bitstatus = SET;
   \   00000024   0x2201             MOVS     R2,#+1
    811            }
    812            else
    813            {
    814              bitstatus = RESET;
    815            }
    816            return bitstatus; 
   \                     ??FSMC_GetITStatus_3: (+1)
   \   00000026   0x4610             MOV      R0,R2
   \   00000028   0x4770             BX       LR               ;; return
    817          }
    818          
    819          /**
    820            * @brief  Clears the FSMC's interrupt pending bits.
    821            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    822            *   This parameter can be one of the following values:
    823            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    824            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    825            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    826            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    827            *   This parameter can be any combination of the following values:
    828            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    829            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    830            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    831            * @retval None
    832            */

   \                                 In section .text, align 2, keep-with-next
    833          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    834          {
    835            /* Check the parameters */
    836            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    837            assert_param(IS_FSMC_IT(FSMC_IT));
    838              
    839            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearITPendingBit: (+1)
   \   00000000   0xEA6F 0x01D1      MVN      R1,R1, LSR #+3
   \   00000004   0x....             LDR.N    R2,??DataTable15_7  ;; 0xa0000064
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD103             BNE.N    ??FSMC_ClearITPendingBit_0
    840            {
    841              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0x4008             ANDS     R0,R1,R0
   \   0000000E   0x6010             STR      R0,[R2, #+0]
   \   00000010   0x4770             BX       LR
    842            }  
    843            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_0: (+1)
   \   00000012   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000016   0xD103             BNE.N    ??FSMC_ClearITPendingBit_1
    844            {
    845              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \   00000018   0x6A10             LDR      R0,[R2, #+32]
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x6210             STR      R0,[R2, #+32]
   \   0000001E   0x4770             BX       LR
    846            }
    847            /* FSMC_Bank4_PCCARD*/
    848            else
    849            {
    850              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_1: (+1)
   \   00000020   0x6C10             LDR      R0,[R2, #+64]
   \   00000022   0x4008             ANDS     R0,R1,R0
   \   00000024   0x6410             STR      R0,[R2, #+64]
    851            }
    852          }
   \   00000026   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xA0000104         DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xA0000060         DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xA00000A0         DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x000FFFFE         DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x000FFFFB         DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x000FFFBF         DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0xA0000074         DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0xA0000064         DC32     0xa0000064
    853          
    854          /**
    855            * @}
    856            */ 
    857          
    858          /**
    859            * @}
    860            */
    861          
    862          /**
    863            * @}
    864            */
    865          
    866          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FSMC_ClearFlag
       0   FSMC_ClearITPendingBit
       0   FSMC_GetECC
       0   FSMC_GetFlagStatus
       0   FSMC_GetITStatus
       0   FSMC_ITConfig
       0   FSMC_NANDCmd
       0   FSMC_NANDDeInit
       0   FSMC_NANDECCCmd
       8   FSMC_NANDInit
       0   FSMC_NANDStructInit
       0   FSMC_NORSRAMCmd
       0   FSMC_NORSRAMDeInit
       4   FSMC_NORSRAMInit
       0   FSMC_NORSRAMStructInit
       0   FSMC_PCCARDCmd
       0   FSMC_PCCARDDeInit
       4   FSMC_PCCARDInit
       0   FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
      38  FSMC_ClearFlag
      40  FSMC_ClearITPendingBit
      14  FSMC_GetECC
      34  FSMC_GetFlagStatus
      42  FSMC_GetITStatus
      76  FSMC_ITConfig
      52  FSMC_NANDCmd
      40  FSMC_NANDDeInit
      52  FSMC_NANDECCCmd
     102  FSMC_NANDInit
      54  FSMC_NANDStructInit
      32  FSMC_NORSRAMCmd
      46  FSMC_NORSRAMDeInit
     190  FSMC_NORSRAMInit
     114  FSMC_NORSRAMStructInit
      24  FSMC_PCCARDCmd
      24  FSMC_PCCARDDeInit
     100  FSMC_PCCARDInit
      60  FSMC_PCCARDStructInit

 
 1 166 bytes in section .text
 
 1 166 bytes of CODE memory

Errors: none
Warnings: none
