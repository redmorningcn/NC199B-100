###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  20:53:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_q.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_q.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -D RELEASE -D IMAGE_A -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\List\os_q.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Relase-107C-APP\Obj\os_q.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_q.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                               MESSAGE QUEUE MANAGEMENT
     10          *
     11          * File    : OS_Q.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_q__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_Q_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                               CREATE A MESSAGE QUEUE
     45          *
     46          * Description: This function is called by your application to create a message queue.  Message queues MUST be created
     47          *              before they can be used.
     48          *
     49          * Arguments  : p_q         is a pointer to the message queue
     50          *
     51          *              p_name      is a pointer to an ASCII string that will be used to name the message queue
     52          *
     53          *              max_qty     indicates the maximum size of the message queue (must be non-zero).  Note that it's also not
     54          *                          possible to have a size higher than the maximum number of OS_MSGs available.
     55          *
     56          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
     57          *
     58          *                              OS_ERR_NONE                    the call was successful
     59          *                              OS_ERR_CREATE_ISR              can't create from an ISR
     60          *                              OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the Queue after you called
     61          *                                                               OSSafetyCriticalStart().
     62          *                              OS_ERR_NAME                    if 'p_name' is a NULL pointer
     63          *                              OS_ERR_OBJ_CREATED             if the message queue has already been created
     64          *                              OS_ERR_OBJ_PTR_NULL            if you passed a NULL pointer for 'p_q'
     65          *                              OS_ERR_Q_SIZE                  if the size you specified is 0
     66          *
     67          * Returns    : none
     68          ************************************************************************************************************************
     69          */
     70          

   \                                 In section .text, align 2, keep-with-next
     71          void  OSQCreate (OS_Q        *p_q,
     72                           CPU_CHAR    *p_name,
     73                           OS_MSG_QTY   max_qty,
     74                           OS_ERR      *p_err)
     75          
     76          {
   \                     OSQCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461C             MOV      R4,R3
     77              CPU_SR_ALLOC();
     78          
     79          
     80          
     81          #ifdef OS_SAFETY_CRITICAL
     82              if (p_err == (OS_ERR *)0) {
     83                  OS_SAFETY_CRITICAL_EXCEPTION();
     84                  return;
     85              }
     86          #endif
     87          
     88          #ifdef OS_SAFETY_CRITICAL_IEC61508
     89              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     90                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     91                  return;
     92              }
     93          #endif
     94          
     95          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     96              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSQCreate_0
     97                 *p_err = OS_ERR_CREATE_ISR;
   \   00000016   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
     98                  return;
   \   0000001C   0xE02A             B.N      ??OSQCreate_1
     99              }
    100          #endif
    101          
    102          #if OS_CFG_ARG_CHK_EN > 0u
    103              if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
   \                     ??OSQCreate_0: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD103             BNE.N    ??OSQCreate_2
    104                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    105                  return;
   \   00000028   0xE024             B.N      ??OSQCreate_1
    106              }
    107              if (max_qty == (OS_MSG_QTY)0) {                         /* Cannot specify a zero size queue                       */
   \                     ??OSQCreate_2: (+1)
   \   0000002A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002E   0xD103             BNE.N    ??OSQCreate_3
    108                 *p_err = OS_ERR_Q_SIZE;
   \   00000030   0xF246 0x5094      MOVW     R0,#+26004
   \   00000034   0x8020             STRH     R0,[R4, #+0]
    109                  return;
   \   00000036   0xE01D             B.N      ??OSQCreate_1
    110              }
    111          #endif
    112          
    113              OS_CRITICAL_ENTER();
   \                     ??OSQCreate_3: (+1)
   \   00000038   0x.... 0x....      BL       CPU_SR_Save
   \   0000003C   0x4605             MOV      R5,R0
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStart
    114              p_q->Type    = OS_OBJ_TYPE_Q;                           /* Mark the data structure as a message queue             */
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x55455551
   \   00000046   0x6030             STR      R0,[R6, #+0]
    115              p_q->NamePtr = p_name;
   \   00000048   0x6077             STR      R7,[R6, #+4]
    116              OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the queue                                   */
    117                          max_qty);
   \   0000004A   0x4641             MOV      R1,R8
   \   0000004C   0xF106 0x0014      ADD      R0,R6,#+20
   \   00000050   0x.... 0x....      BL       OS_MsgQInit
    118              OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
   \   00000054   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000058   0x.... 0x....      BL       OS_PendListInit
    119          
    120          #if OS_CFG_DBG_EN > 0u
    121              OS_QDbgListAdd(p_q);
    122          #endif
    123              OSQQty++;                                               /* One more queue created                                 */
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000060   0x8801             LDRH     R1,[R0, #+0]
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \   00000064   0x8001             STRH     R1,[R0, #+0]
    124          
    125              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
    126             *p_err = OS_ERR_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x8020             STRH     R0,[R4, #+0]
    127          }
   \                     ??OSQCreate_1: (+1)
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    128          
    129          /*$PAGE*/
    130          /*
    131          ************************************************************************************************************************
    132          *                                               DELETE A MESSAGE QUEUE
    133          *
    134          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    135          *
    136          * Arguments  : p_q       is a pointer to the message queue you want to delete
    137          *
    138          *              opt       determines delete options as follows:
    139          *
    140          *                            OS_OPT_DEL_NO_PEND          Delete the queue ONLY if no task pending
    141          *                            OS_OPT_DEL_ALWAYS           Deletes the queue even if tasks are waiting.
    142          *                                                        In this case, all the tasks pending will be readied.
    143          *
    144          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    145          *
    146          *                            OS_ERR_NONE                 The call was successful and the queue was deleted
    147          *                            OS_ERR_DEL_ISR              If you tried to delete the queue from an ISR
    148          *                            OS_ERR_OBJ_PTR_NULL         if you pass a NULL pointer for 'p_q'
    149          *                            OS_ERR_OBJ_TYPE             if the message queue was not created
    150          *                            OS_ERR_OPT_INVALID          An invalid option was specified
    151          *                            OS_ERR_TASK_WAITING         One or more tasks were waiting on the queue
    152          *
    153          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    154          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    155          *
    156          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the queue MUST
    157          *                 check the return code of OSQPend().
    158          *
    159          *              2) OSQAccept() callers will not know that the intended queue has been deleted.
    160          *
    161          *              3) Because ALL tasks pending on the queue will be readied, you MUST be careful in applications where the
    162          *                 queue is used for mutual exclusion because the resource(s) will no longer be guarded by the queue.
    163          ************************************************************************************************************************
    164          */
    165          
    166          #if OS_CFG_Q_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    167          OS_OBJ_QTY  OSQDel (OS_Q    *p_q,
    168                              OS_OPT   opt,
    169                              OS_ERR  *p_err)
    170          {
   \                     OSQDel: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4615             MOV      R5,R2
    171              OS_OBJ_QTY     cnt;
    172              OS_OBJ_QTY     nbr_tasks;
    173              OS_PEND_DATA  *p_pend_data;
    174              OS_PEND_LIST  *p_pend_list;
    175              OS_TCB        *p_tcb;
    176              CPU_TS         ts;
    177              CPU_SR_ALLOC();
    178          
    179          
    180          
    181          #ifdef OS_SAFETY_CRITICAL
    182              if (p_err == (OS_ERR *)0) {
    183                  OS_SAFETY_CRITICAL_EXCEPTION();
    184                  return ((OS_OBJ_QTY)0);
    185              }
    186          #endif
    187          
    188          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    189              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't delete a message queue from an ISR               */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSQDel_0
    190                 *p_err = OS_ERR_DEL_ISR;
   \   00000014   0xF243 0x20C9      MOVW     R0,#+13001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    191                  return ((OS_OBJ_QTY)0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06C             B.N      ??OSQDel_1
    192              }
    193          #endif
    194          
    195          #if OS_CFG_ARG_CHK_EN > 0u
    196              if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
   \                     ??OSQDel_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD104             BNE.N    ??OSQDel_2
    197                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    198                  return ((OS_OBJ_QTY)0u);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE065             B.N      ??OSQDel_1
    199              }
    200              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSQDel_2: (+1)
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD826             BHI.N    ??OSQDel_3
    201                  case OS_OPT_DEL_NO_PEND:
    202                  case OS_OPT_DEL_ALWAYS:
    203                       break;
    204          
    205                  default:
    206                      *p_err =  OS_ERR_OPT_INVALID;
    207                       return ((OS_OBJ_QTY)0u);
    208              }
    209          #endif
    210          
    211          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    212              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable8_2  ;; 0x55455551
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD126             BNE.N    ??OSQDel_4
    213                 *p_err = OS_ERR_OBJ_TYPE;
    214                  return ((OS_OBJ_QTY)0);
    215              }
    216          #endif
    217          
    218              CPU_CRITICAL_ENTER();
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x4607             MOV      R7,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    219              p_pend_list = &p_q->PendList;
   \   00000046   0xF104 0x0908      ADD      R9,R4,#+8
    220              cnt         = p_pend_list->NbrEntries;
   \   0000004A   0xF8B9 0xA008      LDRH     R10,[R9, #+8]
    221              nbr_tasks   = cnt;
   \   0000004E   0x46D0             MOV      R8,R10
    222              switch (opt) {
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD002             BEQ.N    ??OSQDel_5
   \   00000054   0x2E01             CMP      R6,#+1
   \   00000056   0xD02F             BEQ.N    ??OSQDel_6
   \   00000058   0xE045             B.N      ??OSQDel_7
    223                  case OS_OPT_DEL_NO_PEND:                            /* Delete message queue only if no task waiting           */
    224                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSQDel_5: (+1)
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD119             BNE.N    ??OSQDel_8
    225          #if OS_CFG_DBG_EN > 0u
    226                           OS_QDbgListRemove(p_q);
    227          #endif
    228                           OSQQty--;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000064   0x8801             LDRH     R1,[R0, #+0]
   \   00000066   0x1E49             SUBS     R1,R1,#+1
   \   00000068   0x8001             STRH     R1,[R0, #+0]
    229                           OS_QClr(p_q);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       OS_QClr
    230                           CPU_CRITICAL_EXIT();
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    231                          *p_err = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x8028             STRH     R0,[R5, #+0]
   \   0000007E   0xE03A             B.N      ??OSQDel_9
    232                       } else {
   \                     ??OSQDel_3: (+1)
   \   00000080   0xF645 0x6025      MOVW     R0,#+24101
   \   00000084   0x8028             STRH     R0,[R5, #+0]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE036             B.N      ??OSQDel_1
   \                     ??OSQDel_4: (+1)
   \   0000008A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE031             B.N      ??OSQDel_1
    233                           CPU_CRITICAL_EXIT();
   \                     ??OSQDel_8: (+1)
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000098   0x4638             MOV      R0,R7
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
    234                          *p_err = OS_ERR_TASK_WAITING;
   \   0000009E   0xF247 0x105F      MOVW     R0,#+29023
   \   000000A2   0x8028             STRH     R0,[R5, #+0]
   \   000000A4   0xE027             B.N      ??OSQDel_9
    235                       }
    236                       break;
    237          
    238                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the message queue                        */
    239                       OS_CRITICAL_ENTER_CPU_EXIT();
    240                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
    241                       while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
    242                           p_pend_data = p_pend_list->HeadPtr;
    243                           p_tcb       = p_pend_data->TCBPtr;
    244                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_q),
    245                                         p_tcb,
    246                                         ts);
   \                     ??OSQDel_10: (+1)
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000AC   0x6881             LDR      R1,[R0, #+8]
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       OS_PendObjDel
    247                           cnt--;
   \   000000B4   0xF1AA 0x0A01      SUB      R10,R10,#+1
    248                       }
   \                     ??OSQDel_6: (+1)
   \   000000B8   0xFA1F 0xFA8A      UXTH     R10,R10
   \   000000BC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000C0   0xD1F1             BNE.N    ??OSQDel_10
    249          #if OS_CFG_DBG_EN > 0u
    250                       OS_QDbgListRemove(p_q);
    251          #endif
    252                       OSQQty--;
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   000000C6   0x8801             LDRH     R1,[R0, #+0]
   \   000000C8   0x1E49             SUBS     R1,R1,#+1
   \   000000CA   0x8001             STRH     R1,[R0, #+0]
    253                       OS_QClr(p_q);
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       OS_QClr
    254                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000D2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D6   0x4638             MOV      R0,R7
   \   000000D8   0x.... 0x....      BL       CPU_SR_Restore
    255                       OSSched();                                     /* Find highest priority task ready to run                */
   \   000000DC   0x.... 0x....      BL       OSSched
    256                      *p_err = OS_ERR_NONE;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x8028             STRH     R0,[R5, #+0]
    257                       break;
   \   000000E4   0xE007             B.N      ??OSQDel_9
    258          
    259                  default:
    260                       CPU_CRITICAL_EXIT();
   \                     ??OSQDel_7: (+1)
   \   000000E6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000EA   0x4638             MOV      R0,R7
   \   000000EC   0x.... 0x....      BL       CPU_SR_Restore
    261                      *p_err = OS_ERR_OPT_INVALID;
   \   000000F0   0xF645 0x6025      MOVW     R0,#+24101
   \   000000F4   0x8028             STRH     R0,[R5, #+0]
    262                       break;
    263              }
    264              return (nbr_tasks);
   \                     ??OSQDel_9: (+1)
   \   000000F6   0x4640             MOV      R0,R8
   \                     ??OSQDel_1: (+1)
   \   000000F8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    265          }
    266          #endif
    267          
    268          /*$PAGE*/
    269          /*
    270          ************************************************************************************************************************
    271          *                                                     FLUSH QUEUE
    272          *
    273          * Description : This function is used to flush the contents of the message queue.
    274          *
    275          * Arguments   : p_q        is a pointer to the message queue to flush
    276          *
    277          *               p_err      is a pointer to a variable that will contain an error code returned by this function.
    278          *
    279          *                              OS_ERR_NONE           upon success
    280          *                              OS_ERR_FLUSH_ISR      if you called this function from an ISR
    281          *                              OS_ERR_OBJ_PTR_NULL   If you passed a NULL pointer for 'p_q'
    282          *                              OS_ERR_OBJ_TYPE       If you didn't create the message queue
    283          *
    284          * Returns     : The number of entries freed from the queue
    285          *
    286          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    287          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    288          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    289          *                  likely, need to be de-allocated (i.e. freed).
    290          ************************************************************************************************************************
    291          */
    292          
    293          #if OS_CFG_Q_FLUSH_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    294          OS_MSG_QTY  OSQFlush (OS_Q    *p_q,
    295                                OS_ERR  *p_err)
    296          {
   \                     OSQFlush: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    297              OS_MSG_QTY  entries;
    298              CPU_SR_ALLOC();
    299          
    300          
    301          
    302          #ifdef OS_SAFETY_CRITICAL
    303              if (p_err == (OS_ERR *)0) {
    304                  OS_SAFETY_CRITICAL_EXCEPTION();
    305                  return ((OS_MSG_QTY)0);
    306              }
    307          #endif
    308          
    309          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    310              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
   \   00000006   0x....             LDR.N    R0,??DataTable8_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??OSQFlush_0
    311                 *p_err = OS_ERR_FLUSH_ISR;
   \   0000000E   0xF44F 0x506C      MOV      R0,#+15104
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    312                  return ((OS_MSG_QTY)0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD70             POP      {R4-R6,PC}
    313              }
    314          #endif
    315          
    316          #if OS_CFG_ARG_CHK_EN > 0u
    317              if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
   \                     ??OSQFlush_0: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD104             BNE.N    ??OSQFlush_1
    318                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001C   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    319                  return ((OS_MSG_QTY)0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}
    320              }
    321          #endif
    322          
    323          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    324              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQFlush_1: (+1)
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x....             LDR.N    R1,??DataTable8_2  ;; 0x55455551
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD004             BEQ.N    ??OSQFlush_2
    325                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000032   0x8020             STRH     R0,[R4, #+0]
    326                  return ((OS_MSG_QTY)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD70             POP      {R4-R6,PC}
    327              }
    328          #endif
    329          
    330              OS_CRITICAL_ENTER();
   \                     ??OSQFlush_2: (+1)
   \   00000038   0x.... 0x....      BL       CPU_SR_Save
   \   0000003C   0x4606             MOV      R6,R0
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStart
    331              entries = OS_MsgQFreeAll(&p_q->MsgQ);                   /* Return all OS_MSGs to the OS_MSG pool                  */
   \   00000042   0xF105 0x0014      ADD      R0,R5,#+20
   \   00000046   0x.... 0x....      BL       OS_MsgQFreeAll
   \   0000004A   0x4605             MOV      R5,R0
    332              OS_CRITICAL_EXIT();
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    333             *p_err   = OS_ERR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x8020             STRH     R0,[R4, #+0]
    334              return ((OS_MSG_QTY)entries);
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    335          }
    336          #endif
    337          
    338          /*$PAGE*/
    339          /*
    340          ************************************************************************************************************************
    341          *                                            PEND ON A QUEUE FOR A MESSAGE
    342          *
    343          * Description: This function waits for a message to be sent to a queue
    344          *
    345          * Arguments  : p_q           is a pointer to the message queue
    346          *
    347          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    348          *                            message to arrive at the queue up to the amount of time specified by this argument.  If you
    349          *                            specify 0, however, your task will wait forever at the specified queue or, until a message
    350          *                            arrives.
    351          *
    352          *              opt           determines whether the user wants to block if the queue is empty or not:
    353          *
    354          *                                OS_OPT_PEND_BLOCKING
    355          *                                OS_OPT_PEND_NON_BLOCKING
    356          *
    357          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    358          *
    359          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    360          *                            received, pend aborted or the message queue deleted,  If you pass a  pointer (i.e.
    361          *                            (CPU_TS *)0) then you will not get the timestamp.  In other words, passing a NULL pointer
    362          *                            is valid and indicates that you don't need the timestamp.
    363          *
    364          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    365          *
    366          *                                OS_ERR_NONE               The call was successful and your task received a message.
    367          *                                OS_ERR_OBJ_PTR_NULL       if you pass a NULL pointer for 'p_q'
    368          *                                OS_ERR_OBJ_TYPE           if the message queue was not created
    369          *                                OS_ERR_PEND_ABORT         the pend was aborted
    370          *                                OS_ERR_PEND_ISR           if you called this function from an ISR
    371          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    372          *                                OS_ERR_SCHED_LOCKED       the scheduler is locked
    373          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    374          *                                                          would lead to a suspension.
    375          *
    376          * Returns    : != (void *)0  is a pointer to the message received
    377          *              == (void *)0  if you received a NULL pointer message or,
    378          *                            if no message was received or,
    379          *                            if 'p_q' is a NULL pointer or,
    380          *                            if you didn't pass a pointer to a queue.
    381          ************************************************************************************************************************
    382          */
    383          

   \                                 In section .text, align 4, keep-with-next
    384          void  *OSQPend (OS_Q         *p_q,
    385                          OS_TICK       timeout,
    386                          OS_OPT        opt,
    387                          OS_MSG_SIZE  *p_msg_size,
    388                          CPU_TS       *p_ts,
    389                          OS_ERR       *p_err)
    390          {
   \                     OSQPend: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x468A             MOV      R10,R1
   \   0000000A   0x4693             MOV      R11,R2
   \   0000000C   0x461C             MOV      R4,R3
   \   0000000E   0x9D13             LDR      R5,[SP, #+76]
    391              OS_PEND_DATA  pend_data;
    392              void         *p_void;
    393              CPU_SR_ALLOC();
    394          
    395          
    396          
    397          #ifdef OS_SAFETY_CRITICAL
    398              if (p_err == (OS_ERR *)0) {
    399                  OS_SAFETY_CRITICAL_EXCEPTION();
    400                  return ((void *)0);
    401              }
    402          #endif
    403          
    404          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    405              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000010   0x....             LDR.N    R0,??DataTable8_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSQPend_1
    406                 *p_err = OS_ERR_PEND_ISR;
   \   00000018   0xF246 0x10AE      MOVW     R0,#+25006
   \   0000001C   0x8028             STRH     R0,[R5, #+0]
    407                  return ((void *)0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE0AF             B.N      ??OSQPend_2
    408              }
    409          #endif
    410          
    411          #if OS_CFG_ARG_CHK_EN > 0u
    412              if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
   \                     ??OSQPend_1: (+1)
   \   00000022   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000026   0xD104             BNE.N    ??OSQPend_3
    413                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8028             STRH     R0,[R5, #+0]
    414                  return ((void *)0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE0A7             B.N      ??OSQPend_2
    415              }
    416              if (p_msg_size == (OS_MSG_SIZE *)0) {
   \                     ??OSQPend_3: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD104             BNE.N    ??OSQPend_4
    417                 *p_err = OS_ERR_PTR_INVALID;
   \   00000036   0xF246 0x20D5      MOVW     R0,#+25301
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    418                  return ((void *)0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE0A0             B.N      ??OSQPend_2
    419              }
    420              switch (opt) {
   \                     ??OSQPend_4: (+1)
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??OSQPend_5
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xD127             BNE.N    ??OSQPend_6
    421                  case OS_OPT_PEND_BLOCKING:
    422                  case OS_OPT_PEND_NON_BLOCKING:
    423                       break;
    424          
    425                  default:
    426                      *p_err = OS_ERR_OPT_INVALID;
    427                       return ((void *)0);
    428              }
    429          #endif
    430          
    431          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    432              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQPend_5: (+1)
   \   0000004C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000050   0x....             LDR.N    R1,??DataTable8_2  ;; 0x55455551
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD127             BNE.N    ??OSQPend_7
   \   00000056   0x9E12             LDR      R6,[SP, #+72]
    433                 *p_err = OS_ERR_OBJ_TYPE;
    434                  return ((void *)0);
    435              }
    436          #endif
    437          
    438              if (p_ts != (CPU_TS *)0) {
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD001             BEQ.N    ??OSQPend_8
    439                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6030             STR      R0,[R6, #+0]
    440              }
    441          
    442              CPU_CRITICAL_ENTER();
   \                     ??OSQPend_8: (+1)
   \   00000060   0x.... 0x....      BL       CPU_SR_Save
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStart
    443              p_void = OS_MsgQGet(&p_q->MsgQ,                         /* Any message waiting in the message queue?              */
    444                                  p_msg_size,
    445                                  p_ts,
    446                                  p_err);
   \   0000006A   0x462B             MOV      R3,R5
   \   0000006C   0x4632             MOV      R2,R6
   \   0000006E   0x4621             MOV      R1,R4
   \   00000070   0xF109 0x0014      ADD      R0,R9,#+20
   \   00000074   0x.... 0x....      BL       OS_MsgQGet
   \   00000078   0x4680             MOV      R8,R0
    447              if (*p_err == OS_ERR_NONE) {
   \   0000007A   0x8828             LDRH     R0,[R5, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xF000 0x807A      BEQ.W    ??OSQPend_9
    448                  CPU_CRITICAL_EXIT();
    449                  return (p_void);                                    /* Yes, Return message received                           */
    450              }
    451          
    452              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \   00000082   0xEA5F 0x400B      LSLS     R0,R11,#+16
   \   00000086   0xD513             BPL.N    ??OSQPend_10
    453                  CPU_CRITICAL_EXIT();
   \   00000088   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008C   0x4638             MOV      R0,R7
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
    454                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \   00000092   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000096   0x8028             STRH     R0,[R5, #+0]
    455                  return ((void *)0);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE072             B.N      ??OSQPend_2
    456              } else {
   \                     ??OSQPend_6: (+1)
   \   0000009C   0xF645 0x6025      MOVW     R0,#+24101
   \   000000A0   0x8028             STRH     R0,[R5, #+0]
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xE06D             B.N      ??OSQPend_2
   \                     ??OSQPend_7: (+1)
   \   000000A6   0xF645 0x50C4      MOVW     R0,#+24004
   \   000000AA   0x8028             STRH     R0,[R5, #+0]
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE068             B.N      ??OSQPend_2
    457                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSQPend_10: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable8_4
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD009             BEQ.N    ??OSQPend_11
    458                      CPU_CRITICAL_EXIT();
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0x.... 0x....      BL       CPU_SR_Restore
    459                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000C2   0xF646 0x5063      MOVW     R0,#+28003
   \   000000C6   0x8028             STRH     R0,[R5, #+0]
    460                      return ((void *)0);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xE05A             B.N      ??OSQPend_2
    461                  }
    462              }
    463                                                                      /* Lock the scheduler/re-enable interrupts                */
    464              OS_CRITICAL_ENTER_CPU_EXIT();
    465              OS_Pend(&pend_data,                                     /* Block task pending on Message Queue                    */
    466                      (OS_PEND_OBJ *)((void *)p_q),
    467                      OS_TASK_PEND_ON_Q,
    468                      timeout);
   \                     ??OSQPend_11: (+1)
   \   000000CC   0x4653             MOV      R3,R10
   \   000000CE   0x2205             MOVS     R2,#+5
   \   000000D0   0x4649             MOV      R1,R9
   \   000000D2   0x4668             MOV      R0,SP
   \   000000D4   0x.... 0x....      BL       OS_Pend
    469              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000D8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000DC   0x4638             MOV      R0,R7
   \   000000DE   0x.... 0x....      BL       CPU_SR_Restore
    470          
    471              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   000000E2   0x.... 0x....      BL       OSSched
    472          
    473              CPU_CRITICAL_ENTER();
   \   000000E6   0x.... 0x....      BL       CPU_SR_Save
   \   000000EA   0x4607             MOV      R7,R0
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStart
    474              switch (OSTCBCurPtr->PendStatus) {
   \   000000F0   0x....             LDR.N    R0,??DataTable8_5
   \   000000F2   0x6801             LDR      R1,[R0, #+0]
   \   000000F4   0xF891 0x2035      LDRB     R2,[R1, #+53]
   \   000000F8   0x2A03             CMP      R2,#+3
   \   000000FA   0xD835             BHI.N    ??OSQPend_12
   \   000000FC   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??OSQPend_0:
   \   00000100   0x02 0x0F          DC8      0x2,0xF,0x27,0x1C
   \              0x27 0x1C    
    475                  case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
    476                       p_void     = OSTCBCurPtr->MsgPtr;
   \                     ??OSQPend_13: (+1)
   \   00000104   0x315C             ADDS     R1,R1,#+92
   \   00000106   0xF8D1 0x8000      LDR      R8,[R1, #+0]
    477                      *p_msg_size = OSTCBCurPtr->MsgSize;
   \   0000010A   0x8889             LDRH     R1,[R1, #+4]
   \   0000010C   0x8021             STRH     R1,[R4, #+0]
    478                       if (p_ts  != (CPU_TS *)0) {
   \   0000010E   0x2E00             CMP      R6,#+0
   \   00000110   0xD002             BEQ.N    ??OSQPend_14
    479                          *p_ts   =  OSTCBCurPtr->TS;
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0x6C00             LDR      R0,[R0, #+64]
   \   00000116   0x6030             STR      R0,[R6, #+0]
    480                       }
    481                      *p_err      = OS_ERR_NONE;
   \                     ??OSQPend_14: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x8028             STRH     R0,[R5, #+0]
    482                       break;
   \   0000011C   0xE02B             B.N      ??OSQPend_9
    483          
    484                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    485                       p_void     = (void      *)0;
   \                     ??OSQPend_15: (+1)
   \   0000011E   0xF04F 0x0800      MOV      R8,#+0
    486                      *p_msg_size = (OS_MSG_SIZE)0;
   \   00000122   0x4641             MOV      R1,R8
   \   00000124   0x8021             STRH     R1,[R4, #+0]
    487                       if (p_ts  != (CPU_TS *)0) {
   \   00000126   0x2E00             CMP      R6,#+0
   \   00000128   0xD002             BEQ.N    ??OSQPend_16
    488                          *p_ts   =  OSTCBCurPtr->TS;
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x6C00             LDR      R0,[R0, #+64]
   \   0000012E   0x6030             STR      R0,[R6, #+0]
    489                       }
    490                      *p_err      = OS_ERR_PEND_ABORT;
   \                     ??OSQPend_16: (+1)
   \   00000130   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000134   0x8028             STRH     R0,[R5, #+0]
    491                       break;
   \   00000136   0xE01E             B.N      ??OSQPend_9
    492          
    493                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
    494                       p_void     = (void      *)0;
   \                     ??OSQPend_17: (+1)
   \   00000138   0xF04F 0x0800      MOV      R8,#+0
    495                      *p_msg_size = (OS_MSG_SIZE)0;
   \   0000013C   0x4640             MOV      R0,R8
   \   0000013E   0x8020             STRH     R0,[R4, #+0]
    496                       if (p_ts  != (CPU_TS *)0) {
   \   00000140   0x2E00             CMP      R6,#+0
   \   00000142   0xD000             BEQ.N    ??OSQPend_18
    497                          *p_ts   = (CPU_TS  )0;
   \   00000144   0x6030             STR      R0,[R6, #+0]
    498                       }
    499                      *p_err      = OS_ERR_TIMEOUT;
   \                     ??OSQPend_18: (+1)
   \   00000146   0xF247 0x20D9      MOVW     R0,#+29401
   \   0000014A   0x8028             STRH     R0,[R5, #+0]
    500                       break;
   \   0000014C   0xE013             B.N      ??OSQPend_9
    501          
    502                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    503                       p_void     = (void      *)0;
   \                     ??OSQPend_19: (+1)
   \   0000014E   0xF04F 0x0800      MOV      R8,#+0
    504                      *p_msg_size = (OS_MSG_SIZE)0;
   \   00000152   0x4641             MOV      R1,R8
   \   00000154   0x8021             STRH     R1,[R4, #+0]
    505                       if (p_ts  != (CPU_TS *)0) {
   \   00000156   0x2E00             CMP      R6,#+0
   \   00000158   0xD002             BEQ.N    ??OSQPend_20
    506                          *p_ts   =  OSTCBCurPtr->TS;
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0x6C00             LDR      R0,[R0, #+64]
   \   0000015E   0x6030             STR      R0,[R6, #+0]
    507                       }
    508                      *p_err      = OS_ERR_OBJ_DEL;
   \                     ??OSQPend_20: (+1)
   \   00000160   0xF645 0x50C2      MOVW     R0,#+24002
   \   00000164   0x8028             STRH     R0,[R5, #+0]
    509                       break;
   \   00000166   0xE006             B.N      ??OSQPend_9
    510          
    511                  default:
    512                       p_void     = (void      *)0;
   \                     ??OSQPend_12: (+1)
   \   00000168   0xF04F 0x0800      MOV      R8,#+0
    513                      *p_msg_size = (OS_MSG_SIZE)0;
   \   0000016C   0x4640             MOV      R0,R8
   \   0000016E   0x8020             STRH     R0,[R4, #+0]
    514                      *p_err      = OS_ERR_STATUS_INVALID;
   \   00000170   0xF646 0x602E      MOVW     R0,#+28206
   \   00000174   0x8028             STRH     R0,[R5, #+0]
    515                       break;
    516              }
    517              CPU_CRITICAL_EXIT();
   \                     ??OSQPend_9: (+1)
   \   00000176   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000017A   0x4638             MOV      R0,R7
   \   0000017C   0x.... 0x....      BL       CPU_SR_Restore
    518              return (p_void);
   \   00000180   0x4640             MOV      R0,R8
   \                     ??OSQPend_2: (+1)
   \   00000182   0xB009             ADD      SP,SP,#+36
   \   00000184   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    519          }
    520          
    521          
    522          /*$PAGE*/
    523          /*
    524          ************************************************************************************************************************
    525          *                                             ABORT WAITING ON A MESSAGE QUEUE
    526          *
    527          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function should be used to
    528          *              fault-abort the wait on the queue, rather than to normally signal the queue via OSQPost().
    529          *
    530          * Arguments  : p_q       is a pointer to the message queue
    531          *
    532          *              opt       determines the type of ABORT performed:
    533          *
    534          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the queue
    535          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the queue
    536          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    537          *
    538          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    539          *
    540          *                            OS_ERR_NONE                  At least one task waiting on the queue was readied and
    541          *                                                         informed of the aborted wait; check return value for the
    542          *                                                         number of tasks whose wait on the queue was aborted.
    543          *                            OS_ERR_OPT_INVALID           if you specified an invalid option
    544          *                            OS_ERR_OBJ_PTR_NULL          if you pass a NULL pointer for 'p_q'
    545          *                            OS_ERR_OBJ_TYPE              if the message queue was not created
    546          *                            OS_ERR_PEND_ABORT_ISR        If this function was called from an ISR
    547          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    548          *
    549          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    550          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    551          ************************************************************************************************************************
    552          */
    553          
    554          #if OS_CFG_Q_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    555          OS_OBJ_QTY  OSQPendAbort (OS_Q    *p_q,
    556                                    OS_OPT   opt,
    557                                    OS_ERR  *p_err)
    558          {
   \                     OSQPendAbort: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
    559              OS_PEND_LIST  *p_pend_list;
    560              OS_TCB        *p_tcb;
    561              CPU_TS         ts;
    562              OS_OBJ_QTY     nbr_tasks;
    563              CPU_SR_ALLOC();
    564          
    565          
    566          
    567          #ifdef OS_SAFETY_CRITICAL
    568              if (p_err == (OS_ERR *)0) {
    569                  OS_SAFETY_CRITICAL_EXCEPTION();
    570                  return ((OS_OBJ_QTY)0u);
    571              }
    572          #endif
    573          
    574          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    575              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   0000000A   0x....             LDR.N    R0,??DataTable8_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSQPendAbort_0
    576                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000012   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    577                  return ((OS_OBJ_QTY)0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE053             B.N      ??OSQPendAbort_1
    578              }
    579          #endif
    580          
    581          #if OS_CFG_ARG_CHK_EN > 0u
    582              if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
   \                     ??OSQPendAbort_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD104             BNE.N    ??OSQPendAbort_2
    583                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    584                  return ((OS_OBJ_QTY)0u);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE04C             B.N      ??OSQPendAbort_1
    585              }
    586              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSQPendAbort_2: (+1)
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xD008             BEQ.N    ??OSQPendAbort_3
   \   0000002E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000032   0xD005             BEQ.N    ??OSQPendAbort_3
   \   00000034   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000038   0xD002             BEQ.N    ??OSQPendAbort_3
   \   0000003A   0xF5B0 0x4F01      CMP      R0,#+33024
   \   0000003E   0xD118             BNE.N    ??OSQPendAbort_4
    587                  case OS_OPT_PEND_ABORT_1:
    588                  case OS_OPT_PEND_ABORT_ALL:
    589                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    590                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    591                       break;
    592          
    593                  default:
    594                      *p_err =  OS_ERR_OPT_INVALID;
    595                       return ((OS_OBJ_QTY)0u);
    596              }
    597          #endif
    598          
    599          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    600              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure queue was created                            */
   \                     ??OSQPendAbort_3: (+1)
   \   00000040   0x6828             LDR      R0,[R5, #+0]
   \   00000042   0x....             LDR.N    R1,??DataTable8_2  ;; 0x55455551
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD119             BNE.N    ??OSQPendAbort_5
    601                 *p_err =  OS_ERR_OBJ_TYPE;
    602                  return ((OS_OBJ_QTY)0u);
    603              }
    604          #endif
    605          
    606              CPU_CRITICAL_ENTER();
   \   00000048   0x.... 0x....      BL       CPU_SR_Save
   \   0000004C   0x4607             MOV      R7,R0
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStart
    607              p_pend_list = &p_q->PendList;
   \   00000052   0xF105 0x0808      ADD      R8,R5,#+8
    608              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on queue?                             */
   \   00000056   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD113             BNE.N    ??OSQPendAbort_6
    609                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x4638             MOV      R0,R7
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
    610                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000068   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    611                  return ((OS_OBJ_QTY)0u);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE028             B.N      ??OSQPendAbort_1
    612              }
   \                     ??OSQPendAbort_4: (+1)
   \   00000072   0xF645 0x6025      MOVW     R0,#+24101
   \   00000076   0x8020             STRH     R0,[R4, #+0]
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE023             B.N      ??OSQPendAbort_1
   \                     ??OSQPendAbort_5: (+1)
   \   0000007C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000080   0x8020             STRH     R0,[R4, #+0]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE01E             B.N      ??OSQPendAbort_1
    613          
    614              OS_CRITICAL_ENTER_CPU_EXIT();
    615              nbr_tasks = 0u;
   \                     ??OSQPendAbort_6: (+1)
   \   00000086   0xF04F 0x0900      MOV      R9,#+0
    616              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
    617              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSQPendAbort_7: (+1)
   \   0000008A   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00B             BEQ.N    ??OSQPendAbort_8
    618                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
    619                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_q),
    620                               p_tcb,
    621                               ts);
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000098   0x6881             LDR      R1,[R0, #+8]
   \   0000009A   0x4628             MOV      R0,R5
   \   0000009C   0x.... 0x....      BL       OS_PendAbort
    622                  nbr_tasks++;
   \   000000A0   0xF109 0x0901      ADD      R9,R9,#+1
    623                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000A4   0xF5B6 0x7F80      CMP      R6,#+256
   \   000000A8   0xD0EF             BEQ.N    ??OSQPendAbort_7
    624                      break;                                          /* No                                                     */
    625                  }
    626              }
    627              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSQPendAbort_8: (+1)
   \   000000AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0x.... 0x....      BL       CPU_SR_Restore
    628          
    629              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   000000B4   0x0430             LSLS     R0,R6,#+16
   \   000000B6   0xD401             BMI.N    ??OSQPendAbort_9
    630                  OSSched();                                          /* Run the scheduler                                      */
   \   000000B8   0x.... 0x....      BL       OSSched
    631              }
    632          
    633             *p_err = OS_ERR_NONE;
   \                     ??OSQPendAbort_9: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x8020             STRH     R0,[R4, #+0]
    634              return (nbr_tasks);
   \   000000C0   0x4648             MOV      R0,R9
   \   000000C2   0xB280             UXTH     R0,R0
   \                     ??OSQPendAbort_1: (+1)
   \   000000C4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    635          }
    636          #endif
    637          
    638          /*$PAGE*/
    639          /*
    640          ************************************************************************************************************************
    641          *                                               POST MESSAGE TO A QUEUE
    642          *
    643          * Description: This function sends a message to a queue.  With the 'opt' argument, you can specify whether the message
    644          *              is broadcast to all waiting tasks and/or whether you post the message to the front of the queue (LIFO)
    645          *              or normally (FIFO) at the end of the queue.
    646          *
    647          * Arguments  : p_q           is a pointer to a message queue that must have been created by OSQCreate().
    648          *
    649          *              p_void        is a pointer to the message to send.
    650          *
    651          *              msg_size      specifies the size of the message (in bytes)
    652          *
    653          *              opt           determines the type of POST performed:
    654          *
    655          *                                OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the queue.  This option
    656          *                                                         can be added to either OS_OPT_POST_FIFO or OS_OPT_POST_LIFO
    657          *                                OS_OPT_POST_FIFO         POST message to end of queue (FIFO) and wake up a single
    658          *                                                         waiting task.
    659          *                                OS_OPT_POST_LIFO         POST message to the front of the queue (LIFO) and wake up
    660          *                                                         a single waiting task.
    661          *                                OS_OPT_POST_NO_SCHED     Do not call the scheduler
    662          *
    663          *                            Note(s): 1) OS_OPT_POST_NO_SCHED can be added (or OR'd) with one of the other options.
    664          *                                     2) OS_OPT_POST_ALL      can be added (or OR'd) with one of the other options.
    665          *                                     3) Possible combination of options are:
    666          *
    667          *                                        OS_OPT_POST_FIFO
    668          *                                        OS_OPT_POST_LIFO
    669          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL
    670          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL
    671          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_NO_SCHED
    672          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_NO_SCHED
    673          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    674          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    675          *
    676          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    677          *
    678          *                                OS_ERR_NONE            The call was successful and the message was sent
    679          *                                OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs to use to place the message into
    680          *                                OS_ERR_OBJ_PTR_NULL    If 'p_q' is a NULL pointer
    681          *                                OS_ERR_OBJ_TYPE        If the message queue was not initialized
    682          *                                OS_ERR_Q_MAX           If the queue is full
    683          *
    684          * Returns    : None
    685          ************************************************************************************************************************
    686          */
    687          

   \                                 In section .text, align 2, keep-with-next
    688          void  OSQPost (OS_Q         *p_q,
    689                         void         *p_void,
    690                         OS_MSG_SIZE   msg_size,
    691                         OS_OPT        opt,
    692                         OS_ERR       *p_err)
    693          {
   \                     OSQPost: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x9C06             LDR      R4,[SP, #+24]
    694              CPU_TS  ts;
    695          
    696          
    697          
    698          #ifdef OS_SAFETY_CRITICAL
    699              if (p_err == (OS_ERR *)0) {
    700                  OS_SAFETY_CRITICAL_EXCEPTION();
    701                  return;
    702              }
    703          #endif
    704          
    705          #if OS_CFG_ARG_CHK_EN > 0u
    706              if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD103             BNE.N    ??OSQPost_0
    707                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000008   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000000C   0x8020             STRH     R0,[R4, #+0]
    708                  return;
   \   0000000E   0xBD73             POP      {R0,R1,R4-R6,PC}
    709              }
    710              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSQPost_0: (+1)
   \   00000010   0x001D             MOVS     R5,R3
   \   00000012   0xD015             BEQ.N    ??OSQPost_1
   \   00000014   0x2D10             CMP      R5,#+16
   \   00000016   0xD013             BEQ.N    ??OSQPost_1
   \   00000018   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000001C   0xD010             BEQ.N    ??OSQPost_1
   \   0000001E   0xF5B5 0x7F04      CMP      R5,#+528
   \   00000022   0xD00D             BEQ.N    ??OSQPost_1
   \   00000024   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000028   0xD00A             BEQ.N    ??OSQPost_1
   \   0000002A   0xF248 0x0610      MOVW     R6,#+32784
   \   0000002E   0x42B5             CMP      R5,R6
   \   00000030   0xD006             BEQ.N    ??OSQPost_1
   \   00000032   0xF5B5 0x4F02      CMP      R5,#+33280
   \   00000036   0xD003             BEQ.N    ??OSQPost_1
   \   00000038   0xF248 0x2610      MOVW     R6,#+33296
   \   0000003C   0x42B5             CMP      R5,R6
   \   0000003E   0xD109             BNE.N    ??OSQPost_2
    711                  case OS_OPT_POST_FIFO:
    712                  case OS_OPT_POST_LIFO:
    713                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL:
    714                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL:
    715                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
    716                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
    717                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    718                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    719                       break;
    720          
    721                  default:
    722                      *p_err =  OS_ERR_OPT_INVALID;
    723                       return;
    724              }
    725          #endif
    726          
    727          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    728              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQPost_1: (+1)
   \   00000040   0x6805             LDR      R5,[R0, #+0]
   \   00000042   0x....             LDR.N    R6,??DataTable8_2  ;; 0x55455551
   \   00000044   0x42B5             CMP      R5,R6
   \   00000046   0xD109             BNE.N    ??OSQPost_3
    729                 *p_err = OS_ERR_OBJ_TYPE;
    730                  return;
    731              }
    732          #endif
    733          
    734              ts = OS_TS_GET();                                       /* Get timestamp                                          */
    735          
    736          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    737              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
    738                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_Q,             /* Post to ISR queue                                      */
    739                              (void      *)p_q,
    740                              (void      *)p_void,
    741                              (OS_MSG_SIZE)msg_size,
    742                              (OS_FLAGS   )0,
    743                              (OS_OPT     )opt,
    744                              (CPU_TS     )ts,
    745                              (OS_ERR    *)p_err);
    746                  return;
    747              }
    748          #endif
    749          
    750              OS_QPost(p_q,
    751                       p_void,
    752                       msg_size,
    753                       opt,
    754                       ts,
    755                       p_err);
   \   00000048   0x9401             STR      R4,[SP, #+4]
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0x9400             STR      R4,[SP, #+0]
   \   0000004E   0x.... 0x....      BL       OS_QPost
    756          }
   \   00000052   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   \                     ??OSQPost_2: (+1)
   \   00000054   0xF645 0x6025      MOVW     R0,#+24101
   \   00000058   0x8020             STRH     R0,[R4, #+0]
   \   0000005A   0xBD73             POP      {R0,R1,R4-R6,PC}
   \                     ??OSQPost_3: (+1)
   \   0000005C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000060   0x8020             STRH     R0,[R4, #+0]
   \   00000062   0xBD73             POP      {R0,R1,R4-R6,PC}
    757          
    758          /*$PAGE*/
    759          /*
    760          ************************************************************************************************************************
    761          *                                        CLEAR THE CONTENTS OF A MESSAGE QUEUE
    762          *
    763          * Description: This function is called by OSQDel() to clear the contents of a message queue
    764          *
    765          
    766          * Argument(s): p_q      is a pointer to the queue to clear
    767          *              ---
    768          *
    769          * Returns    : none
    770          *
    771          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    772          ************************************************************************************************************************
    773          */
    774          

   \                                 In section .text, align 2, keep-with-next
    775          void  OS_QClr (OS_Q  *p_q)
    776          {
   \                     OS_QClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    777              (void)OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the free list                    */
   \   00000004   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000008   0x.... 0x....      BL       OS_MsgQFreeAll
    778              p_q->Type    =  OS_OBJ_TYPE_NONE;                       /* Mark the data structure as a NONE                      */
   \   0000000C   0x....             LDR.N    R0,??DataTable8_6  ;; 0x454e4f4e
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    779              p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
   \   00000010   0x....             ADR.N    R0,??DataTable8  ;; 0x3F, 0x51, 0x00, 0x00
   \   00000012   0x6060             STR      R0,[R4, #+4]
    780              OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the list of OS_MSGs                         */
    781                          0u);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000001A   0x.... 0x....      BL       OS_MsgQInit
    782              OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
   \   0000001E   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      OS_PendListInit
    783          }
    784          
    785          /*$PAGE*/
    786          /*
    787          ************************************************************************************************************************
    788          *                                      ADD/REMOVE MESSAGE QUEUE TO/FROM DEBUG LIST
    789          *
    790          * Description: These functions are called by uC/OS-III to add or remove a message queue to/from a message queue debug
    791          *              list.
    792          *
    793          * Arguments  : p_q     is a pointer to the message queue to add/remove
    794          *
    795          * Returns    : none
    796          *
    797          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    798          ************************************************************************************************************************
    799          */
    800          
    801          
    802          #if OS_CFG_DBG_EN > 0u
    803          void  OS_QDbgListAdd (OS_Q  *p_q)
    804          {
    805              p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    806              p_q->DbgPrevPtr               = (OS_Q     *)0;
    807              if (OSQDbgListPtr == (OS_Q *)0) {
    808                  p_q->DbgNextPtr           = (OS_Q     *)0;
    809              } else {
    810                  p_q->DbgNextPtr           =  OSQDbgListPtr;
    811                  OSQDbgListPtr->DbgPrevPtr =  p_q;
    812              }
    813              OSQDbgListPtr                 =  p_q;
    814          }
    815          
    816          
    817          
    818          void  OS_QDbgListRemove (OS_Q  *p_q)
    819          {
    820              OS_Q  *p_q_next;
    821              OS_Q  *p_q_prev;
    822          
    823          
    824              p_q_prev = p_q->DbgPrevPtr;
    825              p_q_next = p_q->DbgNextPtr;
    826          
    827              if (p_q_prev == (OS_Q *)0) {
    828                  OSQDbgListPtr = p_q_next;
    829                  if (p_q_next != (OS_Q *)0) {
    830                      p_q_next->DbgPrevPtr = (OS_Q *)0;
    831                  }
    832                  p_q->DbgNextPtr = (OS_Q *)0;
    833          
    834              } else if (p_q_next == (OS_Q *)0) {
    835                  p_q_prev->DbgNextPtr = (OS_Q *)0;
    836                  p_q->DbgPrevPtr      = (OS_Q *)0;
    837          
    838              } else {
    839                  p_q_prev->DbgNextPtr =  p_q_next;
    840                  p_q_next->DbgPrevPtr =  p_q_prev;
    841                  p_q->DbgNextPtr      = (OS_Q *)0;
    842                  p_q->DbgPrevPtr      = (OS_Q *)0;
    843              }
    844          }
    845          #endif
    846          
    847          /*$PAGE*/
    848          /*
    849          ************************************************************************************************************************
    850          *                                              MESSAGE QUEUE INITIALIZATION
    851          *
    852          * Description: This function is called by OSInit() to initialize the message queue management.
    853          *
    854          
    855          * Arguments  : p_err         is a pointer to a variable that will receive an error code.
    856          *
    857          *                                OS_ERR_NONE     the call was successful
    858          *
    859          * Returns    : none
    860          *
    861          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    862          ************************************************************************************************************************
    863          */
    864          

   \                                 In section .text, align 2, keep-with-next
    865          void  OS_QInit (OS_ERR  *p_err)
    866          {
    867          #ifdef OS_SAFETY_CRITICAL
    868              if (p_err == (OS_ERR *)0) {
    869                  OS_SAFETY_CRITICAL_EXCEPTION();
    870                  return;
    871              }
    872          #endif
    873          
    874          #if OS_CFG_DBG_EN > 0u
    875              OSQDbgListPtr = (OS_Q *)0;
    876          #endif
    877          
    878              OSQQty        = (OS_OBJ_QTY)0;
   \                     OS_QInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable8_3
   \   00000004   0x8011             STRH     R1,[R2, #+0]
    879             *p_err         = OS_ERR_NONE;
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    880          }
   \   00000008   0x4770             BX       LR               ;; return
    881          
    882          /*$PAGE*/
    883          /*
    884          ************************************************************************************************************************
    885          *                                               POST MESSAGE TO A QUEUE
    886          *
    887          * Description: This function sends a message to a queue.  With the 'opt' argument, you can specify whether the message
    888          *              is broadcast to all waiting tasks and/or whether you post the message to the front of the queue (LIFO)
    889          *              or normally (FIFO) at the end of the queue.
    890          *
    891          * Arguments  : p_q           is a pointer to a message queue that must have been created by OSQCreate().
    892          *
    893          *              p_void        is a pointer to the message to send.
    894          *
    895          *              msg_size      specifies the size of the message (in bytes)
    896          *
    897          *              opt           determines the type of POST performed:
    898          *
    899          *                                OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the queue
    900          *
    901          *                                OS_OPT_POST_FIFO         POST as FIFO and wake up single waiting task
    902          *                                OS_OPT_POST_LIFO         POST as LIFO and wake up single waiting task
    903          *
    904          *                                OS_OPT_POST_NO_SCHED     Do not call the scheduler
    905          *
    906          *              ts            is the timestamp of the post
    907          *
    908          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    909          *
    910          *                                OS_ERR_NONE            The call was successful and the message was sent
    911          *                                OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs to use to place the message into
    912          *                                OS_ERR_OBJ_PTR_NULL    If 'p_q' is a NULL pointer
    913          *                                OS_ERR_OBJ_TYPE        If the message queue was not initialized
    914          *                                OS_ERR_Q_MAX           If the queue is full
    915          *
    916          * Returns    : None
    917          *
    918          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    919          ************************************************************************************************************************
    920          */
    921          

   \                                 In section .text, align 2, keep-with-next
    922          void  OS_QPost (OS_Q         *p_q,
    923                          void         *p_void,
    924                          OS_MSG_SIZE   msg_size,
    925                          OS_OPT        opt,
    926                          CPU_TS        ts,
    927                          OS_ERR       *p_err)
    928          {
   \                     OS_QPost: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    929              OS_OBJ_QTY     cnt;
    930              OS_OPT         post_type;
    931              OS_PEND_LIST  *p_pend_list;
    932              OS_PEND_DATA  *p_pend_data;
    933              OS_PEND_DATA  *p_pend_data_next;
    934              OS_TCB        *p_tcb;
    935              CPU_SR_ALLOC();
    936          
    937          
    938          
    939              OS_CRITICAL_ENTER();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x4682             MOV      R10,R0
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStart
    940              p_pend_list = &p_q->PendList;
   \   00000018   0xF104 0x0008      ADD      R0,R4,#+8
    941              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on message queue?                     */
   \   0000001C   0xF8B0 0xB008      LDRH     R11,[R0, #+8]
   \   00000020   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000024   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \   00000028   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000002C   0xD115             BNE.N    ??OS_QPost_0
    942                  if ((opt & OS_OPT_POST_LIFO) == (OS_OPT)0) {        /* Determine whether we post FIFO or LIFO                 */
   \   0000002E   0x06F8             LSLS     R0,R7,#+27
   \   00000030   0xD401             BMI.N    ??OS_QPost_1
    943                      post_type = OS_OPT_POST_FIFO;
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0xE000             B.N      ??OS_QPost_2
    944                  } else {
    945                      post_type = OS_OPT_POST_LIFO;
   \                     ??OS_QPost_1: (+1)
   \   00000036   0x2310             MOVS     R3,#+16
    946                  }
    947                  OS_MsgQPut(&p_q->MsgQ,                              /* Place message in the message queue                     */
    948                             p_void,
    949                             msg_size,
    950                             post_type,
    951                             ts,
    952                             p_err);
   \                     ??OS_QPost_2: (+1)
   \   00000038   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000003C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000040   0x4632             MOV      R2,R6
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000048   0x.... 0x....      BL       OS_MsgQPut
    953                  OS_CRITICAL_EXIT();
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x4650             MOV      R0,R10
   \   00000052   0xE8BD 0x4FFE      POP      {R1-R11,LR}
   \   00000056   0x.... 0x....      B.W      CPU_SR_Restore
    954                  return;
    955              }
    956          
    957              if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
   \                     ??OS_QPost_0: (+1)
   \   0000005A   0x05B9             LSLS     R1,R7,#+22
   \   0000005C   0xD401             BMI.N    ??OS_QPost_3
    958                  cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    959              } else {
    960                  cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
   \   0000005E   0xF04F 0x0B01      MOV      R11,#+1
    961              }
    962              p_pend_data = p_pend_list->HeadPtr;
   \                     ??OS_QPost_3: (+1)
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xE00C             B.N      ??OS_QPost_4
    963              while (cnt > 0u) {
    964                  p_tcb            = p_pend_data->TCBPtr;
    965                  p_pend_data_next = p_pend_data->NextPtr;
   \                     ??OS_QPost_5: (+1)
   \   00000066   0x6841             LDR      R1,[R0, #+4]
   \   00000068   0x9101             STR      R1,[SP, #+4]
    966                  OS_Post((OS_PEND_OBJ *)((void *)p_q),
    967                          p_tcb,
    968                          p_void,
    969                          msg_size,
    970                          ts);
   \   0000006A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000006E   0x4633             MOV      R3,R6
   \   00000070   0x462A             MOV      R2,R5
   \   00000072   0x6881             LDR      R1,[R0, #+8]
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       OS_Post
    971                  p_pend_data = p_pend_data_next;
   \   0000007A   0x9801             LDR      R0,[SP, #+4]
    972                  cnt--;
   \   0000007C   0xF1AB 0x0B01      SUB      R11,R11,#+1
    973              }
   \                     ??OS_QPost_4: (+1)
   \   00000080   0xFA1F 0xFB8B      UXTH     R11,R11
   \   00000084   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000088   0xD1ED             BNE.N    ??OS_QPost_5
    974              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000008A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008E   0x4650             MOV      R0,R10
   \   00000090   0x.... 0x....      BL       CPU_SR_Restore
    975              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   00000094   0x0438             LSLS     R0,R7,#+16
   \   00000096   0xD401             BMI.N    ??OS_QPost_6
    976                  OSSched();                                          /* Run the scheduler                                      */
   \   00000098   0x.... 0x....      BL       OSSched
    977              }
    978             *p_err = OS_ERR_NONE;
   \                     ??OS_QPost_6: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    979          }
   \   000000A2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x3F 0x51          DC8      0x3F, 0x51, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x55455551         DC32     0x55455551

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     OSQQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x3F 0x51          DC8 "?Q"
   \              0x00         
   \   00000003   0x00               DC8 0
    980          
    981          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSQCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQInit
        24   -> OS_PendListInit
      32   OSQDel
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendObjDel
        32   -> OS_QClr
      16   OSQFlush
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_MsgQFreeAll
      72   OSQPend
        72   -> CPU_IntDisMeasStart
        72   -> CPU_IntDisMeasStop
        72   -> CPU_SR_Restore
        72   -> CPU_SR_Save
        72   -> OSSched
        72   -> OS_MsgQGet
        72   -> OS_Pend
      32   OSQPendAbort
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      24   OSQPost
        24   -> OS_QPost
       8   OS_QClr
         8   -> OS_MsgQFreeAll
         8   -> OS_MsgQInit
         0   -> OS_PendListInit
       0   OS_QInit
      48   OS_QPost
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OS_MsgQPut
        48   -> OS_Post


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ?_0
     120  OSQCreate
     252  OSQDel
      94  OSQFlush
     392  OSQPend
     200  OSQPendAbort
     100  OSQPost
      42  OS_QClr
      10  OS_QInit
     166  OS_QPost

 
     4 bytes in section .rodata
 1 404 bytes in section .text
 
 1 404 bytes of CODE  memory
     4 bytes of CONST memory

Errors: none
Warnings: none
