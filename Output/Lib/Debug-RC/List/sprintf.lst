###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       13/Dec/2017  10:37:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\APP\User\sprintf.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\User\sprintf.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\sprintf.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\sprintf.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\User\sprintf.c
      1          
      2          //#include "stdafx.h"
      3          
      4          #include <mb.h>
      5          
      6          #ifndef TRUE
      7            #define TRUE    1
      8          #endif
      9          #ifndef FALSE
     10            #define FALSE   0
     11          #endif 
     12          #ifndef BOOL
     13            #define BOOL    unsigned char
     14          #endif
     15          #define INCLUDE_STRING
     16          
     17          #ifdef INCLUDE_STRING
     18              #include "string.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char const *, int)
   \                     strchr: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr
     19          #endif
     20          
     21          #ifdef KERNEL
     22              #define NOFLOAT
     23          #endif
     24          
     25          #define sprintf  my_sprintf
     26          #define vsprintf my_vsprintf
     27          #define atoi     my_atoi
     28          #define ftoa     my_ftoa
     29          #define strnlen  my_strnlen
     30          
     31          #define DOUBLE_ZERO 1E-307
     32          
     33          #define IS_DOUBLE_ZERO(D) (((double)D <= 1E-307) && ((double)D >= -1E-307))
     34          
     35          typedef char* va_list;
     36          #ifndef __va_rounded_size
     37          #define __va_rounded_size(TYPE) (((sizeof(TYPE)+sizeof(int)-1)/sizeof(int))*sizeof(int))
     38          #endif
     39          
     40          #ifndef va_start
     41          #define va_start(AP, LASTARG)   (AP = ((char *)& (LASTARG) + __va_rounded_size(LASTARG)))
     42          #endif
     43          
     44          #ifndef va_arg
     45          #define va_arg(AP, TYPE)        (AP += __va_rounded_size(TYPE), *((TYPE *)(AP - __va_rounded_size(TYPE))))
     46          #endif
     47          
     48          #ifndef va_end
     49          #define va_end(AP)              (AP = (va_list)0 )
     50          #endif
     51          
     52          
     53          #define ZEROPAD 1               // Pad with zero
     54          #define SIGN    2               // Unsigned/signed long
     55          #define PLUS    4               // Show plus
     56          #define SPACE   8               // Space if plus
     57          #define LEFT    16              // Left justified
     58          #define SPECIAL 32              // 0x
     59          #define LARGE   64              // Use 'ABCDEF' instead of 'abcdef'
     60          
     61          #define abs(a)  ((a) < 0 ?  -(a) :(a))
     62          #define is_digit(c) ((c) >= '0' && (c) <= '9')
     63          /////////////////////////////////////////////////////////////////////////////
     64          
     65          #define FLT_MAX_10_EXP     38
     66          #define DBL_MAX_10_EXP     308
     67          #define LDBL_MAX_10_EXP    308
     68          

   \                                 In section .data, align 4
     69          static char *digits = "0123456789abcdefghijklmnopqrstuvwxyz";
   \                     digits:
   \   00000000   0x........         DC32 ?_0
   \   00000004   0x........         DC32 ?_1
     70          static char *upper_digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

   \                                 In section .text, align 2, keep-with-next
     71          static int is_space( int ch )
     72          {
     73              return (unsigned long)(ch - 9) < 5u || ' ' == ch;
   \                     is_space: (+1)
   \   00000000   0xF1A0 0x0109      SUB      R1,R0,#+9
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xD301             BCC.N    ??is_space_0
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD101             BNE.N    ??is_space_1
   \                     ??is_space_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??is_space_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          static int atoi(char *str)
     77          {
   \                     my_atoi: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     78             int sign;
     79             int n;
     80             char *p = str;
   \   00000004   0xE000             B.N      ??my_atoi_0
     81          
     82             while (is_space(*p) ) p++;
   \                     ??my_atoi_1: (+1)
   \   00000006   0x1C64             ADDS     R4,R4,#+1
   \                     ??my_atoi_0: (+1)
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       is_space
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1F9             BNE.N    ??my_atoi_1
     83          
     84             sign = ('-' == *p) ? -1 : 1;
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x282D             CMP      R0,#+45
   \   00000016   0xD102             BNE.N    ??my_atoi_2
   \   00000018   0xF04F 0x31FF      MOV      R1,#-1
   \   0000001C   0xE000             B.N      ??my_atoi_3
   \                     ??my_atoi_2: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
     85             if ('+' == *p || '-' == *p) p++;
   \                     ??my_atoi_3: (+1)
   \   00000020   0x282B             CMP      R0,#+43
   \   00000022   0xD001             BEQ.N    ??my_atoi_4
   \   00000024   0x282D             CMP      R0,#+45
   \   00000026   0xD100             BNE.N    ??my_atoi_5
   \                     ??my_atoi_4: (+1)
   \   00000028   0x1C64             ADDS     R4,R4,#+1
     86          
     87             for (n = 0; is_digit(*p); p++)
   \                     ??my_atoi_5: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE006             B.N      ??my_atoi_6
     88                n = 10 * n + (*p - '0');
   \                     ??my_atoi_7: (+1)
   \   0000002E   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000032   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000036   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   0000003A   0x3830             SUBS     R0,R0,#+48
   \                     ??my_atoi_6: (+1)
   \   0000003C   0x7822             LDRB     R2,[R4, #+0]
   \   0000003E   0x3A30             SUBS     R2,R2,#+48
   \   00000040   0x2A0A             CMP      R2,#+10
   \   00000042   0xD3F4             BCC.N    ??my_atoi_7
     89          
     90             return sign*n;
   \   00000044   0x4348             MULS     R0,R0,R1
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
     91          }
     92          #ifndef INCLUDE_STRING
     93              #define memset   my_memset
     94              #define memcpy   my_memcpy
     95              #define strlen   my_strlen
     96              #define strcmp   my_strcmp
     97              #define strchr   my_strchr
     98          
     99          static char * strchr(const char *str, int ch)
    100          {
    101              while (*str && *str != (char)ch) str++;
    102          
    103              if (*str == (char)ch)
    104                  return((char *)str);
    105          
    106              return 0;
    107          }
    108          static void * memset(void *dst, int val, unsigned long ulcount)
    109          {
    110              if(!dst) return 0;
    111              char * pchdst = (char*)dst;
    112              while(ulcount--) *pchdst++ = (char)val;
    113          
    114              return dst;
    115          }
    116          
    117          static void * memcpy(void *dst, const void *src, unsigned long ulcount)
    118          {
    119             if(!(dst && src)) return 0;
    120             char * pchdst = (char*)dst;
    121             char * pchsrc = (char*)src;
    122             while(ulcount--) *pchdst++ = *pchsrc++;
    123             
    124             return dst;
    125          }
    126          
    127          static int strlen(const char * str)
    128          {
    129              const char *p = str;
    130              while(*p++);
    131          
    132              return (int)(p - str - 1);
    133          }
    134          
    135          int strcmp(const char *source,const char *dest)
    136          {
    137              int ret = 0;
    138              if(!source || !dest) return -2;
    139              while( ! (ret = *( unsigned char *)source - *(unsigned char *)dest) && *dest)
    140              {
    141                  source++;
    142                  dest++;
    143              }
    144              
    145              if ( ret < 0 )
    146                  ret = -1 ;
    147              else if ( ret > 0 )
    148                  ret = 1 ;
    149          
    150              return(ret);
    151          }
    152          
    153          static int strncmp(const char *first,const char *last,int count)
    154          {
    155             if (!count)  return 0;
    156          
    157             while (--count && *first && *first == *last) first++,last++;
    158          
    159             return ( *(unsigned char *)first - *(unsigned char *)last );
    160          }
    161          
    162          #endif  /*NO_INCLUDE_STRING*/

   \                                 In section .text, align 2, keep-with-next
    163          static unsigned long strnlen(const char *s, int count)
    164          {
    165              const char *sc;
    166              for (sc = s; *sc != '\0' && count--; ++sc);
   \                     my_strnlen: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0xE000             B.N      ??my_strnlen_0
   \                     ??my_strnlen_1: (+1)
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \                     ??my_strnlen_0: (+1)
   \   00000006   0x7813             LDRB     R3,[R2, #+0]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD003             BEQ.N    ??my_strnlen_2
   \   0000000C   0x460B             MOV      R3,R1
   \   0000000E   0x1E59             SUBS     R1,R3,#+1
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD1F7             BNE.N    ??my_strnlen_1
    167              return sc - s;
   \                     ??my_strnlen_2: (+1)
   \   00000014   0x1A10             SUBS     R0,R2,R0
   \   00000016   0x4770             BX       LR               ;; return
    168          }
    169          

   \                                 In section .text, align 2, keep-with-next
    170          static char * itoa(int n, char * chBuffer)
    171          {
   \                     itoa: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    172              int i = 1;
   \   00000002   0x2201             MOVS     R2,#+1
    173              char * pch = chBuffer;
   \   00000004   0x000B             MOVS     R3,R1
    174              if(!pch) return 0;
   \   00000006   0xD104             BNE.N    ??itoa_0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE020             B.N      ??itoa_1
    175              while(n / i) i *= 10;
   \                     ??itoa_2: (+1)
   \   0000000C   0xEB02 0x0482      ADD      R4,R2,R2, LSL #+2
   \   00000010   0x0062             LSLS     R2,R4,#+1
   \                     ??itoa_0: (+1)
   \   00000012   0xFB90 0xF4F2      SDIV     R4,R0,R2
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD1F8             BNE.N    ??itoa_2
    176              
    177              if(n < 0)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD503             BPL.N    ??itoa_3
    178              {
    179                  n = -n;
   \   0000001E   0x4240             RSBS     R0,R0,#+0
    180                  *pch++ = '-';
   \   00000020   0x242D             MOVS     R4,#+45
   \   00000022   0xF803 0x4B01      STRB     R4,[R3], #+1
    181              }
    182              if (0 == n) i = 10;
   \                     ??itoa_3: (+1)
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD109             BNE.N    ??itoa_4
   \   0000002A   0x220A             MOVS     R2,#+10
   \   0000002C   0xE007             B.N      ??itoa_4
    183              
    184              while(i /= 10)
    185              {
    186                  *pch++ = n / i + '0';
   \                     ??itoa_5: (+1)
   \   0000002E   0xFB90 0xF4F2      SDIV     R4,R0,R2
   \   00000032   0xF104 0x0530      ADD      R5,R4,#+48
   \   00000036   0xF803 0x5B01      STRB     R5,[R3], #+1
    187                  n %= i;
   \   0000003A   0xFB02 0x0014      MLS      R0,R2,R4,R0
    188              }
   \                     ??itoa_4: (+1)
   \   0000003E   0x240A             MOVS     R4,#+10
   \   00000040   0xFB92 0xF2F4      SDIV     R2,R2,R4
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD1F2             BNE.N    ??itoa_5
    189              *pch = '\0';
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7018             STRB     R0,[R3, #+0]
    190              return chBuffer;
   \   0000004C   0x4608             MOV      R0,R1
   \                     ??itoa_1: (+1)
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
    191          }
    192          

   \                                 In section .text, align 2, keep-with-next
    193          static int skip_atoi(const char **s)
    194          {
    195              int i = 0;
   \                     skip_atoi: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE007             B.N      ??skip_atoi_0
    196              while (is_digit(**s))
    197              {
    198                  i = i*10 + *((*s)++) - '0';
   \                     ??skip_atoi_1: (+1)
   \   00000004   0x1C53             ADDS     R3,R2,#+1
   \   00000006   0x6003             STR      R3,[R0, #+0]
   \   00000008   0xEB01 0x0381      ADD      R3,R1,R1, LSL #+2
   \   0000000C   0x7811             LDRB     R1,[R2, #+0]
   \   0000000E   0xEB01 0x0143      ADD      R1,R1,R3, LSL #+1
   \   00000012   0x3930             SUBS     R1,R1,#+48
    199              }
   \                     ??skip_atoi_0: (+1)
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x7813             LDRB     R3,[R2, #+0]
   \   00000018   0x3B30             SUBS     R3,R3,#+48
   \   0000001A   0x2B0A             CMP      R3,#+10
   \   0000001C   0xD3F2             BCC.N    ??skip_atoi_1
    200              return i;
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x4770             BX       LR               ;; return
    201          }
    202          

   \                                 In section .text, align 2, keep-with-next
    203          static char * number(char *str, long num, int base, int size, int precision, int type)
    204          {
   \                     number: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
    205              char c, sign, tmp[66];
    206              char *dig = digits;
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable12
   \   0000000A   0x6835             LDR      R5,[R6, #+0]
   \   0000000C   0x46AC             MOV      R12,R5
   \   0000000E   0x9C19             LDR      R4,[SP, #+100]
    207              int i;
    208          
    209              if (type & LARGE)  dig = upper_digits;
   \   00000010   0x0667             LSLS     R7,R4,#+25
   \   00000012   0xD501             BPL.N    ??number_0
   \   00000014   0xF8D6 0xC004      LDR      R12,[R6, #+4]
    210              if (type & LEFT) type &= ~ZEROPAD;
   \                     ??number_0: (+1)
   \   00000018   0x06E6             LSLS     R6,R4,#+27
   \   0000001A   0xD501             BPL.N    ??number_1
   \   0000001C   0xF024 0x0401      BIC      R4,R4,#0x1
    211              if (base < 2 || base > 36) return 0;
   \                     ??number_1: (+1)
   \   00000020   0x1E96             SUBS     R6,R2,#+2
   \   00000022   0x2E23             CMP      R6,#+35
   \   00000024   0xD301             BCC.N    ??number_2
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE083             B.N      ??number_3
    212          
    213              c = (type & ZEROPAD) ? '0' : ' ';
   \                     ??number_2: (+1)
   \   0000002A   0x07E6             LSLS     R6,R4,#+31
   \   0000002C   0xD501             BPL.N    ??number_4
   \   0000002E   0x2630             MOVS     R6,#+48
   \   00000030   0xE000             B.N      ??number_5
   \                     ??number_4: (+1)
   \   00000032   0x2620             MOVS     R6,#+32
    214              sign = 0;
   \                     ??number_5: (+1)
   \   00000034   0xF04F 0x0E00      MOV      LR,#+0
    215              if (type & SIGN)
   \   00000038   0x07A7             LSLS     R7,R4,#+30
   \   0000003A   0xD511             BPL.N    ??number_6
    216              {
    217                  if (num < 0)
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD504             BPL.N    ??number_7
    218                  {
    219                      sign = '-';
   \   00000040   0xF04F 0x0E2D      MOV      LR,#+45
    220                      num = -num;
   \   00000044   0x4249             RSBS     R1,R1,#+0
    221                      size--;
   \   00000046   0x1E5B             SUBS     R3,R3,#+1
   \   00000048   0xE00A             B.N      ??number_6
    222                  }
    223                  else if (type & PLUS)
   \                     ??number_7: (+1)
   \   0000004A   0x0767             LSLS     R7,R4,#+29
   \   0000004C   0xD503             BPL.N    ??number_8
    224                  {
    225                      sign = '+';
   \   0000004E   0xF04F 0x0E2B      MOV      LR,#+43
    226                      size--;
   \   00000052   0x1E5B             SUBS     R3,R3,#+1
   \   00000054   0xE004             B.N      ??number_6
    227                  }
    228                  else if (type & SPACE)
   \                     ??number_8: (+1)
   \   00000056   0x0727             LSLS     R7,R4,#+28
   \   00000058   0xD502             BPL.N    ??number_6
    229                  {
    230                      sign = ' ';
   \   0000005A   0xF04F 0x0E20      MOV      LR,#+32
    231                      size--;
   \   0000005E   0x1E5B             SUBS     R3,R3,#+1
    232                  }
    233              }
    234          
    235              if (type & SPECIAL)
   \                     ??number_6: (+1)
   \   00000060   0x06A7             LSLS     R7,R4,#+26
   \   00000062   0xD506             BPL.N    ??number_9
    236              {
    237                  if (16 == base)
   \   00000064   0x2A10             CMP      R2,#+16
   \   00000066   0xD101             BNE.N    ??number_10
    238                      size -= 2;
   \   00000068   0x1E9B             SUBS     R3,R3,#+2
   \   0000006A   0xE002             B.N      ??number_9
    239                  else if (8 == base)
   \                     ??number_10: (+1)
   \   0000006C   0x2A08             CMP      R2,#+8
   \   0000006E   0xD100             BNE.N    ??number_9
    240                      size--;
   \   00000070   0x1E5B             SUBS     R3,R3,#+1
    241              }
    242          
    243              i = 0;
   \                     ??number_9: (+1)
   \   00000072   0x2700             MOVS     R7,#+0
    244          
    245              if (0 == num)
   \   00000074   0x2900             CMP      R1,#+0
   \   00000076   0x46E9             MOV      R9,SP
   \   00000078   0xD10E             BNE.N    ??number_11
    246              {
    247                  tmp[i++] = '0';
   \   0000007A   0x2130             MOVS     R1,#+48
   \   0000007C   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   00000080   0x2701             MOVS     R7,#+1
   \   00000082   0xE00B             B.N      ??number_12
    248              }
    249              else
    250              {
    251                  while (num != 0)
    252                  {
    253                      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
   \                     ??number_13: (+1)
   \   00000084   0xFBB1 0xF8F2      UDIV     R8,R1,R2
   \   00000088   0xFB02 0x1118      MLS      R1,R2,R8,R1
   \   0000008C   0xF811 0x100C      LDRB     R1,[R1, R12]
   \   00000090   0xF807 0x1009      STRB     R1,[R7, R9]
   \   00000094   0x1C7F             ADDS     R7,R7,#+1
    254                      num = ((unsigned long) num) / (unsigned) base;
   \   00000096   0x4641             MOV      R1,R8
    255                  }
   \                     ??number_11: (+1)
   \   00000098   0x2900             CMP      R1,#+0
   \   0000009A   0xD1F3             BNE.N    ??number_13
   \                     ??number_12: (+1)
   \   0000009C   0x9918             LDR      R1,[SP, #+96]
    256              }
    257          
    258              if (i > precision) precision = i;
   \   0000009E   0x42B9             CMP      R1,R7
   \   000000A0   0xDA00             BGE.N    ??number_14
   \   000000A2   0x4639             MOV      R1,R7
    259              size -= precision;
   \                     ??number_14: (+1)
   \   000000A4   0x1A5B             SUBS     R3,R3,R1
    260              if (!(type & (ZEROPAD | LEFT)))
   \   000000A6   0xF014 0x0F11      TST      R4,#0x11
   \   000000AA   0xD10A             BNE.N    ??number_15
   \   000000AC   0xE003             B.N      ??number_16
    261              {
    262                  while(size-- > 0) *str++ = ' ';
   \                     ??number_17: (+1)
   \   000000AE   0xF04F 0x0C20      MOV      R12,#+32
   \   000000B2   0xF800 0xCB01      STRB     R12,[R0], #+1
   \                     ??number_16: (+1)
   \   000000B6   0x469C             MOV      R12,R3
   \   000000B8   0xF1AC 0x0301      SUB      R3,R12,#+1
   \   000000BC   0xF1BC 0x0F01      CMP      R12,#+1
   \   000000C0   0xDAF5             BGE.N    ??number_17
    263              }
    264              if (sign) *str++ = sign;
   \                     ??number_15: (+1)
   \   000000C2   0xF1BE 0x0F00      CMP      LR,#+0
   \   000000C6   0xD001             BEQ.N    ??number_18
   \   000000C8   0xF800 0xEB01      STRB     LR,[R0], #+1
    265          
    266              if (type & SPECIAL)
   \                     ??number_18: (+1)
   \   000000CC   0xEA5F 0x6C84      LSLS     R12,R4,#+26
   \   000000D0   0xD50E             BPL.N    ??number_19
    267              {
    268                  if (8 == base)
   \   000000D2   0x2A08             CMP      R2,#+8
   \   000000D4   0xD103             BNE.N    ??number_20
    269                  {
    270                      *str++ = '0';
   \   000000D6   0x2230             MOVS     R2,#+48
   \   000000D8   0xF800 0x2B01      STRB     R2,[R0], #+1
   \   000000DC   0xE008             B.N      ??number_19
    271                  }
    272                  else if (16 == base)
   \                     ??number_20: (+1)
   \   000000DE   0x2A10             CMP      R2,#+16
   \   000000E0   0xD106             BNE.N    ??number_19
    273                  {
    274                      *str++ = '0';
   \   000000E2   0x2230             MOVS     R2,#+48
   \   000000E4   0xF800 0x2B01      STRB     R2,[R0], #+1
    275                      *str++ = digits[33];
   \   000000E8   0xF895 0x2021      LDRB     R2,[R5, #+33]
   \   000000EC   0xF800 0x2B01      STRB     R2,[R0], #+1
    276                  }
    277              }
    278          
    279              if(!(type & LEFT))
   \                     ??number_19: (+1)
   \   000000F0   0x06E2             LSLS     R2,R4,#+27
   \   000000F2   0xD406             BMI.N    ??number_21
   \   000000F4   0xE001             B.N      ??number_22
    280              {
    281                  while(size-- > 0) *str++ = c;
   \                     ??number_23: (+1)
   \   000000F6   0xF800 0x6B01      STRB     R6,[R0], #+1
   \                     ??number_22: (+1)
   \   000000FA   0x461A             MOV      R2,R3
   \   000000FC   0x1E53             SUBS     R3,R2,#+1
   \   000000FE   0x2A01             CMP      R2,#+1
   \   00000100   0xDAF9             BGE.N    ??number_23
    282              }
    283              while(i < precision--) *str++ = '0';
   \                     ??number_21: (+1)
   \   00000102   0x460A             MOV      R2,R1
   \   00000104   0x1E51             SUBS     R1,R2,#+1
   \   00000106   0x4297             CMP      R7,R2
   \   00000108   0xDA07             BGE.N    ??number_24
   \   0000010A   0x2230             MOVS     R2,#+48
   \   0000010C   0xF800 0x2B01      STRB     R2,[R0], #+1
   \   00000110   0xE7F7             B.N      ??number_21
    284              while(i-- > 0) *str++ = tmp[i];
   \                     ??number_25: (+1)
   \   00000112   0x4669             MOV      R1,SP
   \   00000114   0x5C79             LDRB     R1,[R7, R1]
   \   00000116   0xF800 0x1B01      STRB     R1,[R0], #+1
   \                     ??number_24: (+1)
   \   0000011A   0x4639             MOV      R1,R7
   \   0000011C   0x1E4F             SUBS     R7,R1,#+1
   \   0000011E   0x2901             CMP      R1,#+1
   \   00000120   0xDAF7             BGE.N    ??number_25
    285              while(size-- > 0) *str++ = ' ';
   \                     ??number_26: (+1)
   \   00000122   0x4619             MOV      R1,R3
   \   00000124   0x1E4B             SUBS     R3,R1,#+1
   \   00000126   0x2901             CMP      R1,#+1
   \   00000128   0xDB03             BLT.N    ??number_3
   \   0000012A   0x2120             MOVS     R1,#+32
   \   0000012C   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000130   0xE7F7             B.N      ??number_26
    286          
    287              return str;
   \                     ??number_3: (+1)
   \   00000132   0xB011             ADD      SP,SP,#+68
   \   00000134   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    288          }
    289          

   \                                 In section .text, align 2, keep-with-next
    290          static char * eaddr(char *str, unsigned char *addr, int size, int precision, int type)
    291          {
   \                     eaddr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    292              char tmp[24];
    293              char *dig = digits;
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable12
   \   00000008   0x6835             LDR      R5,[R6, #+0]
    294              int len = 0;
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x9C0B             LDR      R4,[SP, #+44]
    295              if (type & LARGE)  dig = upper_digits;
   \   0000000E   0x0667             LSLS     R7,R4,#+25
   \   00000010   0xD500             BPL.N    ??eaddr_0
   \   00000012   0x6875             LDR      R5,[R6, #+4]
    296              for (int i = 0; i < 6; i++)
   \                     ??eaddr_0: (+1)
   \   00000014   0x461E             MOV      R6,R3
   \   00000016   0x466F             MOV      R7,SP
   \   00000018   0xE017             B.N      ??eaddr_1
    297              {
    298                  if (i != 0) tmp[len++] = ':';
   \                     ??eaddr_2: (+1)
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD004             BEQ.N    ??eaddr_3
   \   0000001E   0xF04F 0x0C3A      MOV      R12,#+58
   \   00000022   0xF803 0xC007      STRB     R12,[R3, R7]
   \   00000026   0x1C5B             ADDS     R3,R3,#+1
    299                  tmp[len++] = dig[addr[i] >> 4];
   \                     ??eaddr_3: (+1)
   \   00000028   0xF816 0xC001      LDRB     R12,[R6, R1]
   \   0000002C   0xEA4F 0x1E2C      ASR      LR,R12,#+4
   \   00000030   0xF81E 0xE005      LDRB     LR,[LR, R5]
   \   00000034   0xF803 0xE007      STRB     LR,[R3, R7]
   \   00000038   0x1C5B             ADDS     R3,R3,#+1
    300                  tmp[len++] = dig[addr[i] & 0x0F];
   \   0000003A   0xF00C 0x0C0F      AND      R12,R12,#0xF
   \   0000003E   0xF81C 0xC005      LDRB     R12,[R12, R5]
   \   00000042   0xF803 0xC007      STRB     R12,[R3, R7]
   \   00000046   0x1C5B             ADDS     R3,R3,#+1
    301              }
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \                     ??eaddr_1: (+1)
   \   0000004A   0x2E06             CMP      R6,#+6
   \   0000004C   0xDBE5             BLT.N    ??eaddr_2
    302          
    303              if (!(type & LEFT))
   \   0000004E   0x06E1             LSLS     R1,R4,#+27
   \   00000050   0xD407             BMI.N    ??eaddr_4
   \   00000052   0xE002             B.N      ??eaddr_5
    304              {
    305                  while (len < size--) *str++ = ' ';
   \                     ??eaddr_6: (+1)
   \   00000054   0x2120             MOVS     R1,#+32
   \   00000056   0xF800 0x1B01      STRB     R1,[R0], #+1
   \                     ??eaddr_5: (+1)
   \   0000005A   0x4611             MOV      R1,R2
   \   0000005C   0x1E4A             SUBS     R2,R1,#+1
   \   0000005E   0x428B             CMP      R3,R1
   \   00000060   0xDBF8             BLT.N    ??eaddr_6
    306              }
    307              
    308              for (int i = 0; i < len; ++i)
   \                     ??eaddr_4: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0xE004             B.N      ??eaddr_7
    309              {
    310                  *str++ = tmp[i];
   \                     ??eaddr_8: (+1)
   \   00000066   0x466C             MOV      R4,SP
   \   00000068   0x5D0C             LDRB     R4,[R1, R4]
   \   0000006A   0xF800 0x4B01      STRB     R4,[R0], #+1
    311              }
   \   0000006E   0x1C49             ADDS     R1,R1,#+1
   \                     ??eaddr_7: (+1)
   \   00000070   0x4299             CMP      R1,R3
   \   00000072   0xDBF8             BLT.N    ??eaddr_8
    312              
    313              while (len < size--) *str++ = ' ';
   \                     ??eaddr_9: (+1)
   \   00000074   0x4611             MOV      R1,R2
   \   00000076   0x1E4A             SUBS     R2,R1,#+1
   \   00000078   0x428B             CMP      R3,R1
   \   0000007A   0xDA03             BGE.N    ??eaddr_10
   \   0000007C   0x2120             MOVS     R1,#+32
   \   0000007E   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000082   0xE7F7             B.N      ??eaddr_9
    314          
    315              return str;
   \                     ??eaddr_10: (+1)
   \   00000084   0xB006             ADD      SP,SP,#+24
   \   00000086   0xBDF0             POP      {R4-R7,PC}       ;; return
    316          }
    317          

   \                                 In section .text, align 2, keep-with-next
    318          static char * iaddr(char *str, unsigned char *addr, int size, int precision, int type)
    319          {
   \                     iaddr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    320              char tmp[24];
    321              int len = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    322              for (int i = 0; i < 4; i++)
   \   00000006   0x461C             MOV      R4,R3
   \   00000008   0xE018             B.N      ??iaddr_0
    323              {
    324                  int n = addr[i];
    325                  if (i != 0) tmp[len++] = '.';
    326                  
    327                  if (0 == n)
    328                  {
    329                      tmp[len++] = digits[0];
    330                  }
    331                  else
    332                  {
    333                      if (n >= 100) 
    334                      {
    335                          tmp[len++] = digits[n / 100];
    336                          n %= 100;
    337                          tmp[len++] = digits[n / 10];
    338                          n %= 10;
    339                      }
    340                      else if (n >= 10)
   \                     ??iaddr_1: (+1)
   \   0000000A   0x2D0A             CMP      R5,#+10
   \   0000000C   0xDB0E             BLT.N    ??iaddr_2
    341                      {
    342                          tmp[len++] = digits[n / 10];
   \   0000000E   0x260A             MOVS     R6,#+10
   \   00000010   0xFB95 0xF6F6      SDIV     R6,R5,R6
   \   00000014   0x.... 0x....      LDR.W    R7,??DataTable12
   \   00000018   0x683F             LDR      R7,[R7, #+0]
   \   0000001A   0x5DF7             LDRB     R7,[R6, R7]
   \   0000001C   0x46EC             MOV      R12,SP
   \   0000001E   0xF803 0x700C      STRB     R7,[R3, R12]
   \   00000022   0x1C5B             ADDS     R3,R3,#+1
    343                          n %= 10;
   \   00000024   0xEB06 0x0786      ADD      R7,R6,R6, LSL #+2
   \   00000028   0xEBA5 0x0547      SUB      R5,R5,R7, LSL #+1
    344                      }
    345          
    346                      tmp[len++] = digits[n];
   \                     ??iaddr_2: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R6,??DataTable12
   \   00000030   0x6836             LDR      R6,[R6, #+0]
   \   00000032   0x5DAD             LDRB     R5,[R5, R6]
   \   00000034   0x466E             MOV      R6,SP
   \   00000036   0x559D             STRB     R5,[R3, R6]
   \   00000038   0x1C5B             ADDS     R3,R3,#+1
   \                     ??iaddr_3: (+1)
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   \                     ??iaddr_0: (+1)
   \   0000003C   0x2C04             CMP      R4,#+4
   \   0000003E   0xDA2F             BGE.N    ??iaddr_4
   \   00000040   0x5C65             LDRB     R5,[R4, R1]
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD003             BEQ.N    ??iaddr_5
   \   00000046   0x262E             MOVS     R6,#+46
   \   00000048   0x466F             MOV      R7,SP
   \   0000004A   0x55DE             STRB     R6,[R3, R7]
   \   0000004C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??iaddr_5: (+1)
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD107             BNE.N    ??iaddr_6
   \   00000052   0x.... 0x....      LDR.W    R5,??DataTable12
   \   00000056   0x682D             LDR      R5,[R5, #+0]
   \   00000058   0x782D             LDRB     R5,[R5, #+0]
   \   0000005A   0x466E             MOV      R6,SP
   \   0000005C   0x559D             STRB     R5,[R3, R6]
   \   0000005E   0x1C5B             ADDS     R3,R3,#+1
   \   00000060   0xE7EB             B.N      ??iaddr_3
   \                     ??iaddr_6: (+1)
   \   00000062   0x2D64             CMP      R5,#+100
   \   00000064   0xDBD1             BLT.N    ??iaddr_1
   \   00000066   0x2664             MOVS     R6,#+100
   \   00000068   0xFB95 0xFCF6      SDIV     R12,R5,R6
   \   0000006C   0x.... 0x....      LDR.W    R6,??DataTable12
   \   00000070   0x6836             LDR      R6,[R6, #+0]
   \   00000072   0x466F             MOV      R7,SP
   \   00000074   0xF81C 0xE006      LDRB     LR,[R12, R6]
   \   00000078   0xF803 0xE007      STRB     LR,[R3, R7]
   \   0000007C   0x1C5B             ADDS     R3,R3,#+1
   \   0000007E   0xF04F 0x0E64      MOV      LR,#+100
   \   00000082   0xFB0E 0x551C      MLS      R5,LR,R12,R5
   \   00000086   0xF04F 0x0C0A      MOV      R12,#+10
   \   0000008A   0xFB95 0xFCFC      SDIV     R12,R5,R12
   \   0000008E   0xF81C 0x6006      LDRB     R6,[R12, R6]
   \   00000092   0x55DE             STRB     R6,[R3, R7]
   \   00000094   0x1C5B             ADDS     R3,R3,#+1
   \   00000096   0xEB0C 0x068C      ADD      R6,R12,R12, LSL #+2
   \   0000009A   0xEBA5 0x0546      SUB      R5,R5,R6, LSL #+1
   \   0000009E   0xE7C5             B.N      ??iaddr_2
    347                  }
    348              }
    349          
    350              if (!(type & LEFT))
   \                     ??iaddr_4: (+1)
   \   000000A0   0x990B             LDR      R1,[SP, #+44]
   \   000000A2   0x06C9             LSLS     R1,R1,#+27
   \   000000A4   0xD407             BMI.N    ??iaddr_7
   \   000000A6   0xE002             B.N      ??iaddr_8
    351              {
    352                  while(len < size--) *str++ = ' ';
   \                     ??iaddr_9: (+1)
   \   000000A8   0x2120             MOVS     R1,#+32
   \   000000AA   0xF800 0x1B01      STRB     R1,[R0], #+1
   \                     ??iaddr_8: (+1)
   \   000000AE   0x4611             MOV      R1,R2
   \   000000B0   0x1E4A             SUBS     R2,R1,#+1
   \   000000B2   0x428B             CMP      R3,R1
   \   000000B4   0xDBF8             BLT.N    ??iaddr_9
    353              }
    354              
    355              for (int i = 0; i < len; ++i)
   \                     ??iaddr_7: (+1)
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0xE004             B.N      ??iaddr_10
    356              {
    357                  *str++ = tmp[i];
   \                     ??iaddr_11: (+1)
   \   000000BA   0x466C             MOV      R4,SP
   \   000000BC   0x5D0C             LDRB     R4,[R1, R4]
   \   000000BE   0xF800 0x4B01      STRB     R4,[R0], #+1
    358              }
   \   000000C2   0x1C49             ADDS     R1,R1,#+1
   \                     ??iaddr_10: (+1)
   \   000000C4   0x4299             CMP      R1,R3
   \   000000C6   0xDBF8             BLT.N    ??iaddr_11
    359              
    360              while (len < size--) *str++ = ' ';
   \                     ??iaddr_12: (+1)
   \   000000C8   0x4611             MOV      R1,R2
   \   000000CA   0x1E4A             SUBS     R2,R1,#+1
   \   000000CC   0x428B             CMP      R3,R1
   \   000000CE   0xDA03             BGE.N    ??iaddr_13
   \   000000D0   0x2120             MOVS     R1,#+32
   \   000000D2   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   000000D6   0xE7F7             B.N      ??iaddr_12
    361              
    362              return str;
   \                     ??iaddr_13: (+1)
   \   000000D8   0xB006             ADD      SP,SP,#+24
   \   000000DA   0xBDF0             POP      {R4-R7,PC}       ;; return
    363          }
    364          
    365          #ifndef NOFLOAT

   \                                 In section .text, align 2, keep-with-next
    366          static char * ftoaE(char* pchBuffer, int dppos, double value)
    367          {
   \                     ftoaE: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
    368              double roundingValue = 0.5;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
   \   00000010   0x.... 0x....      LDR.W    R9,??DataTable12_1  ;; 0x3fe00000
    369              int roundingPos = dppos;
   \   00000014   0x46DA             MOV      R10,R11
    370              double temp = value;
    371              int exp = 0;    // Exponent value
   \   00000016   0x4647             MOV      R7,R8
    372              char * pch = pchBuffer;
   \   00000018   0x9600             STR      R6,[SP, #+0]
    373              if(0 == pchBuffer) return 0;
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD101             BNE.N    ??ftoaE_0
   \   0000001E   0x4638             MOV      R0,R7
   \   00000020   0xE0B0             B.N      ??ftoaE_1
    374              // Process value sign
    375              if (value < 0.0)
   \                     ??ftoaE_0: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x463A             MOV      R2,R7
   \   00000028   0x4613             MOV      R3,R2
   \   0000002A   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000002E   0xD205             BCS.N    ??ftoaE_2
    376              {
    377                  value = -value;
   \   00000030   0xF085 0x4500      EOR      R5,R5,#0x80000000
    378                  *pchBuffer++ = '-';
   \   00000034   0x202D             MOVS     R0,#+45
   \   00000036   0xF806 0x0B01      STRB     R0,[R6], #+1
   \   0000003A   0xE002             B.N      ??ftoaE_3
    379              }
    380              else
    381              {
    382                  *pchBuffer++ = '+';
   \                     ??ftoaE_2: (+1)
   \   0000003C   0x202B             MOVS     R0,#+43
   \   0000003E   0xF806 0x0B01      STRB     R0,[R6], #+1
    383              }
    384          
    385              // Round value and get exponent
    386              if(!IS_DOUBLE_ZERO(value))  /*if (value != 0.0)*/
   \                     ??ftoaE_3: (+1)
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable12_2  ;; 0x2c40c60e
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable12_3  ;; 0x31fa18
   \   0000004E   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000052   0xD20C             BCS.N    ??ftoaE_4
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable12_4  ;; 0x2c40c60d
   \   00000058   0x.... 0x....      LDR.W    R3,??DataTable12_5  ;; 0x8031fa18
   \   0000005C   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000060   0xD956             BLS.N    ??ftoaE_5
    387              {
    388                  // Get exponent of unrounded value for rounding
    389                  temp = value;
    390                  exp = 0;
   \   00000062   0xE004             B.N      ??ftoaE_4
    391                  while(temp < 1.0)
    392                  {
    393                      temp *= 10.0;
   \                     ??ftoaE_6: (+1)
   \   00000064   0x.... 0x....      LDR.W    R3,??DataTable12_6  ;; 0x40240000
   \   00000068   0x.... 0x....      BL       __aeabi_dmul
    394                      exp--;
   \   0000006C   0x1E7F             SUBS     R7,R7,#+1
    395                  }
   \                     ??ftoaE_4: (+1)
   \   0000006E   0x4642             MOV      R2,R8
   \   00000070   0x.... 0x....      LDR.W    R3,??DataTable12_7  ;; 0x3ff00000
   \   00000074   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000078   0xD3F4             BCC.N    ??ftoaE_6
    396                  while(temp >= 10.0)
   \                     ??ftoaE_7: (+1)
   \   0000007A   0x4642             MOV      R2,R8
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable12_6  ;; 0x40240000
   \   00000080   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000084   0xD807             BHI.N    ??ftoaE_8
    397                  {
    398                      temp *= 0.1;
   \   00000086   0x.... 0x....      LDR.W    R2,??DataTable12_8  ;; 0x9999999a
   \   0000008A   0x.... 0x....      LDR.W    R3,??DataTable12_9  ;; 0x3fb99999
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
    399                      exp++;
   \   00000092   0x1C7F             ADDS     R7,R7,#+1
   \   00000094   0xE7F1             B.N      ??ftoaE_7
    400                  }
    401          
    402                  // Round value
    403                  if(dppos < 0) roundingPos = 0;
   \                     ??ftoaE_8: (+1)
   \   00000096   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000009A   0xD500             BPL.N    ??ftoaE_9
   \   0000009C   0x4692             MOV      R10,R2
    404                  
    405                  for(int i = (roundingPos - exp); i > 0; i--)
   \                     ??ftoaE_9: (+1)
   \   0000009E   0xEBAA 0x0707      SUB      R7,R10,R7
   \   000000A2   0xE008             B.N      ??ftoaE_10
    406                  {
    407                      roundingValue *= 0.1;
   \                     ??ftoaE_11: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x9999999a
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable12_9  ;; 0x3fb99999
   \   000000AC   0x.... 0x....      BL       __aeabi_dmul
   \   000000B0   0x4680             MOV      R8,R0
   \   000000B2   0x4689             MOV      R9,R1
    408                  }
   \   000000B4   0x1E7F             SUBS     R7,R7,#+1
   \                     ??ftoaE_10: (+1)
   \   000000B6   0x2F01             CMP      R7,#+1
   \   000000B8   0x4642             MOV      R2,R8
   \   000000BA   0x464B             MOV      R3,R9
   \   000000BC   0xDAF2             BGE.N    ??ftoaE_11
    409                  value += roundingValue;
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x4629             MOV      R1,R5
   \   000000C2   0x.... 0x....      BL       __aeabi_dadd
   \   000000C6   0x4604             MOV      R4,R0
   \   000000C8   0x460D             MOV      R5,R1
    410          
    411                  // Get exponent of rounded value and limit value to 9.999...1.000
    412                  exp = 0;
   \   000000CA   0x2700             MOVS     R7,#+0
   \   000000CC   0xE006             B.N      ??ftoaE_12
    413                  while(value < 1.0)
    414                  {
    415                      value *= 10.0;
   \                     ??ftoaE_13: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R3,??DataTable12_6  ;; 0x40240000
   \   000000D2   0x.... 0x....      BL       __aeabi_dmul
   \   000000D6   0x4604             MOV      R4,R0
   \   000000D8   0x460D             MOV      R5,R1
    416                      exp--;
   \   000000DA   0x1E7F             SUBS     R7,R7,#+1
    417                  }
   \                     ??ftoaE_12: (+1)
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0x4629             MOV      R1,R5
   \   000000E0   0x2200             MOVS     R2,#+0
   \   000000E2   0x.... 0x....      LDR.W    R3,??DataTable12_7  ;; 0x3ff00000
   \   000000E6   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000EA   0xD3F0             BCC.N    ??ftoaE_13
    418                  while(value >= 10.0)
   \                     ??ftoaE_14: (+1)
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x4629             MOV      R1,R5
   \   000000F0   0x2200             MOVS     R2,#+0
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable12_6  ;; 0x40240000
   \   000000F6   0x.... 0x....      BL       __aeabi_cdrcmple
   \   000000FA   0xD809             BHI.N    ??ftoaE_5
    419                  {
    420                      value *= 0.1;
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable12_8  ;; 0x9999999a
   \   00000100   0x.... 0x....      LDR.W    R3,??DataTable12_9  ;; 0x3fb99999
   \   00000104   0x.... 0x....      BL       __aeabi_dmul
   \   00000108   0x4604             MOV      R4,R0
   \   0000010A   0x460D             MOV      R5,R1
    421                      exp++;
   \   0000010C   0x1C7F             ADDS     R7,R7,#+1
   \   0000010E   0xE7ED             B.N      ??ftoaE_14
    422                  }
    423              }
    424          
    425              // Compose mantissa output string
    426              for (int i = ((dppos < 0) ? 1 : (dppos + 1) - 1); i >= 0; i--)
   \                     ??ftoaE_5: (+1)
   \   00000110   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000114   0xD502             BPL.N    ??ftoaE_15
   \   00000116   0xF04F 0x0801      MOV      R8,#+1
   \   0000011A   0xE028             B.N      ??ftoaE_16
   \                     ??ftoaE_15: (+1)
   \   0000011C   0x46D8             MOV      R8,R11
   \   0000011E   0xE026             B.N      ??ftoaE_16
    427              {
    428                  // Output digit
    429                  int digit = (int)value % 10;
   \                     ??ftoaE_17: (+1)
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x4629             MOV      R1,R5
   \   00000124   0x.... 0x....      BL       __aeabi_d2iz
   \   00000128   0x210A             MOVS     R1,#+10
   \   0000012A   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000012E   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000132   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
    430                  *pchBuffer++ = (char)(digit + '0');
   \   00000136   0xF100 0x0130      ADD      R1,R0,#+48
   \   0000013A   0xF806 0x1B01      STRB     R1,[R6], #+1
    431          
    432                  // Output decimal point
    433                  if (i == dppos) *pchBuffer++ = '.';
   \   0000013E   0x45D8             CMP      R8,R11
   \   00000140   0xD102             BNE.N    ??ftoaE_18
   \   00000142   0x212E             MOVS     R1,#+46
   \   00000144   0xF806 0x1B01      STRB     R1,[R6], #+1
    434          
    435                  value = (value - (double)digit) * 10.0;
   \                     ??ftoaE_18: (+1)
   \   00000148   0x.... 0x....      BL       __aeabi_i2d
   \   0000014C   0x4602             MOV      R2,R0
   \   0000014E   0x460B             MOV      R3,R1
   \   00000150   0x4620             MOV      R0,R4
   \   00000152   0x4629             MOV      R1,R5
   \   00000154   0x.... 0x....      BL       __aeabi_dsub
   \   00000158   0x4602             MOV      R2,R0
   \   0000015A   0x460B             MOV      R3,R1
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable12_6  ;; 0x40240000
   \   00000162   0x.... 0x....      BL       __aeabi_dmul
   \   00000166   0x4604             MOV      R4,R0
   \   00000168   0x460D             MOV      R5,R1
    436              }
   \   0000016A   0xF1A8 0x0801      SUB      R8,R8,#+1
   \                     ??ftoaE_16: (+1)
   \   0000016E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000172   0xD5D5             BPL.N    ??ftoaE_17
    437          
    438              // Compose exponent output string
    439              *pchBuffer++ = 'E';
   \   00000174   0x2045             MOVS     R0,#+69
   \   00000176   0xF806 0x0B01      STRB     R0,[R6], #+1
    440              itoa(exp, pchBuffer);
   \   0000017A   0x4631             MOV      R1,R6
   \   0000017C   0x4638             MOV      R0,R7
   \   0000017E   0x.... 0x....      BL       itoa
    441          
    442              return pch;
   \   00000182   0x9800             LDR      R0,[SP, #+0]
   \                     ??ftoaE_1: (+1)
   \   00000184   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    443          }
    444          
    445          #define MAX_DIGITS     15

   \                                 In section .text, align 2, keep-with-next
    446          static char * ftoa(double dValue, char * chBuffer)
    447          {
   \                     my_ftoa: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4692             MOV      R10,R2
    448              char * pch = chBuffer;
    449              if(!pch) return 0;
   \   0000000A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000000E   0xD101             BNE.N    ??my_ftoa_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE085             B.N      ??my_ftoa_1
    450              if(!IS_DOUBLE_ZERO(dValue))
   \                     ??my_ftoa_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable12_2  ;; 0x2c40c60e
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable12_3  ;; 0x31fa18
   \   0000001C   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000020   0xD206             BCS.N    ??my_ftoa_2
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable12_4  ;; 0x2c40c60d
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable12_5  ;; 0x8031fa18
   \   0000002A   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000002E   0xD970             BLS.N    ??my_ftoa_3
    451              {
    452                  double dRound = 5;
   \                     ??my_ftoa_2: (+1)
   \   00000030   0x2600             MOVS     R6,#+0
   \   00000032   0x.... 0x....      LDR.W    R7,??DataTable12_10  ;; 0x40140000
    453                  if(dValue < 0)
   \   00000036   0x4632             MOV      R2,R6
   \   00000038   0x4613             MOV      R3,R2
   \   0000003A   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000003E   0xD207             BCS.N    ??my_ftoa_4
    454                  {
    455                      *pch++ = '-';
   \   00000040   0x202D             MOVS     R0,#+45
   \   00000042   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000046   0xF10A 0x0801      ADD      R8,R10,#+1
    456                      dValue = -dValue;
   \   0000004A   0xF085 0x4500      EOR      R5,R5,#0x80000000
   \   0000004E   0xE004             B.N      ??my_ftoa_5
    457                  }
    458                  else
    459                  {
    460                      *pch++ = '+';
   \                     ??my_ftoa_4: (+1)
   \   00000050   0x202B             MOVS     R0,#+43
   \   00000052   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000056   0xF10A 0x0801      ADD      R8,R10,#+1
    461                  }
    462                  itoa((int)dValue, pch);
   \                     ??my_ftoa_5: (+1)
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x4629             MOV      R1,R5
   \   0000005E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000062   0x4681             MOV      R9,R0
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x.... 0x....      BL       itoa
    463                  unsigned char ucLen = strlen(pch);
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       strlen
   \   00000070   0x4683             MOV      R11,R0
   \   00000072   0xFA5F 0xFB8B      UXTB     R11,R11
    464                  pch += ucLen;
   \   00000076   0x44D8             ADD      R8,R11,R8
    465                  *pch++ = '.';
   \   00000078   0x202E             MOVS     R0,#+46
   \   0000007A   0xF808 0x0B01      STRB     R0,[R8], #+1
    466                  dValue -= (int)dValue;
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0x.... 0x....      BL       __aeabi_i2d
   \   00000084   0x4602             MOV      R2,R0
   \   00000086   0x460B             MOV      R3,R1
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x4629             MOV      R1,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_dsub
   \   00000090   0x4604             MOV      R4,R0
   \   00000092   0x460D             MOV      R5,R1
    467                  ucLen = MAX_DIGITS - ucLen;
   \   00000094   0xF1CB 0x000F      RSB      R0,R11,#+15
   \   00000098   0xB2C0             UXTB     R0,R0
   \   0000009A   0x9000             STR      R0,[SP, #+0]
    468                  for(int i = 0; i < MAX_DIGITS; i++) dRound *= 0.1;
   \   0000009C   0x46B1             MOV      R9,R6
   \   0000009E   0xE00B             B.N      ??my_ftoa_6
   \                     ??my_ftoa_7: (+1)
   \   000000A0   0x4630             MOV      R0,R6
   \   000000A2   0x4639             MOV      R1,R7
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable12_8  ;; 0x9999999a
   \   000000A8   0x.... 0x....      LDR.W    R3,??DataTable12_9  ;; 0x3fb99999
   \   000000AC   0x.... 0x....      BL       __aeabi_dmul
   \   000000B0   0x4606             MOV      R6,R0
   \   000000B2   0x460F             MOV      R7,R1
   \   000000B4   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??my_ftoa_6: (+1)
   \   000000B8   0xF1B9 0x0F0F      CMP      R9,#+15
   \   000000BC   0xDBF0             BLT.N    ??my_ftoa_7
    469                  
    470                  for(int i = 0; i < ucLen; i++)
   \   000000BE   0xF04F 0x0900      MOV      R9,#+0
   \                     ??my_ftoa_8: (+1)
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \   000000C4   0x4581             CMP      R9,R0
   \   000000C6   0xDA2A             BGE.N    ??my_ftoa_9
    471                  {
    472                      dValue = (dValue + dRound) * 10;
   \   000000C8   0x4632             MOV      R2,R6
   \   000000CA   0x463B             MOV      R3,R7
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x4629             MOV      R1,R5
   \   000000D0   0x.... 0x....      BL       __aeabi_dadd
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0x.... 0x....      LDR.W    R3,??DataTable12_6  ;; 0x40240000
   \   000000DA   0x.... 0x....      BL       __aeabi_dmul
   \   000000DE   0x4604             MOV      R4,R0
   \   000000E0   0x460D             MOV      R5,R1
    473                      itoa((int)dValue, pch);
   \   000000E2   0x.... 0x....      BL       __aeabi_d2iz
   \   000000E6   0x4683             MOV      R11,R0
   \   000000E8   0x4641             MOV      R1,R8
   \   000000EA   0x.... 0x....      BL       itoa
    474                      pch += strlen(pch);
   \   000000EE   0x4640             MOV      R0,R8
   \   000000F0   0x.... 0x....      BL       strlen
   \   000000F4   0x4480             ADD      R8,R0,R8
    475                      dValue -= (int)dValue;
   \   000000F6   0x4658             MOV      R0,R11
   \   000000F8   0x.... 0x....      BL       __aeabi_i2d
   \   000000FC   0x4602             MOV      R2,R0
   \   000000FE   0x460B             MOV      R3,R1
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x4629             MOV      R1,R5
   \   00000104   0x.... 0x....      BL       __aeabi_dsub
   \   00000108   0x4604             MOV      R4,R0
   \   0000010A   0x460D             MOV      R5,R1
    476                  }
   \   0000010C   0xF109 0x0901      ADD      R9,R9,#+1
   \   00000110   0xE7D7             B.N      ??my_ftoa_8
    477              }
    478              else
    479              {
    480                  *pch++ = '0';
   \                     ??my_ftoa_3: (+1)
   \   00000112   0x2030             MOVS     R0,#+48
   \   00000114   0xF88A 0x0000      STRB     R0,[R10, #+0]
    481                  *pch = '\0';
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF88A 0x0001      STRB     R0,[R10, #+1]
    482              }
    483              pch--;
    484              //while ('0' == *pch) *pch-- = '\0';
    485              return chBuffer;
   \                     ??my_ftoa_9: (+1)
   \   0000011E   0x4650             MOV      R0,R10
   \                     ??my_ftoa_1: (+1)
   \   00000120   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    486          }
    487          

   \                                 In section .text, align 2, keep-with-next
    488          static void __ecvround(char *numbuf, char *last_digit, const char *after_last, int *decpt)
    489          {
    490              /* Do we have at all to round the last digit?  */
    491              if (*after_last > '4')
   \                     __ecvround: (+1)
   \   00000000   0x7812             LDRB     R2,[R2, #+0]
   \   00000002   0x2A35             CMP      R2,#+53
   \   00000004   0xDA00             BGE.N    ??__ecvround_0
   \   00000006   0x4770             BX       LR
    492              {
    493                  char *p = last_digit;
    494                  int carry = 1;
   \                     ??__ecvround_0: (+1)
   \   00000008   0xB430             PUSH     {R4,R5}
   \   0000000A   0x2201             MOVS     R2,#+1
    495          
    496                  /* Propagate the rounding through trailing '9' digits.  */
    497                  do
    498                  {
    499                      int sum = *p + carry;
   \                     ??__ecvround_1: (+1)
   \   0000000C   0x780C             LDRB     R4,[R1, #+0]
   \   0000000E   0x1914             ADDS     R4,R2,R4
    500                      carry = sum > '9';
   \   00000010   0x2C3A             CMP      R4,#+58
   \   00000012   0xDB01             BLT.N    ??__ecvround_2
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0xE000             B.N      ??__ecvround_3
   \                     ??__ecvround_2: (+1)
   \   00000018   0x2200             MOVS     R2,#+0
    501                      *p-- = sum - carry * 10;
   \                     ??__ecvround_3: (+1)
   \   0000001A   0xEB02 0x0582      ADD      R5,R2,R2, LSL #+2
   \   0000001E   0xEBA4 0x0445      SUB      R4,R4,R5, LSL #+1
   \   00000022   0xF801 0x4901      STRB     R4,[R1], #-1
    502                  } while (carry && p >= numbuf);
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD001             BEQ.N    ??__ecvround_4
   \   0000002A   0x4281             CMP      R1,R0
   \   0000002C   0xD2EE             BCS.N    ??__ecvround_1
    503          
    504                  /* We have 9999999... which needs to be rounded to 100000..  */
    505                  if (carry && p == numbuf)
   \                     ??__ecvround_4: (+1)
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD006             BEQ.N    ??__ecvround_5
   \   00000032   0x4281             CMP      R1,R0
   \   00000034   0xD104             BNE.N    ??__ecvround_5
    506                  {
    507                      *p = '1';
   \   00000036   0x2031             MOVS     R0,#+49
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    508                      *decpt += 1;
   \   0000003A   0x6818             LDR      R0,[R3, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x6018             STR      R0,[R3, #+0]
    509                  }
    510              }
    511          }
   \                     ??__ecvround_5: (+1)
   \   00000040   0xBC30             POP      {R4,R5}
   \   00000042   0x4770             BX       LR               ;; return
    512          
    513          //char *ecvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);
    514          //char *fcvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);

   \                                 In section .text, align 2, keep-with-next
    515          static char * ecvtbuf (double value, int ndigits, int *decpt, int *sign, char *buf)
    516          {
   \                     ecvtbuf: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x461E             MOV      R6,R3
    517              static char INFINITY[] = "Infinity";
    518              char chBuffer[20];
    519              char decimal = '.' /* localeconv()->decimal_point[0] */;
    520              //char *cvtbuf = (char *)malloc(ndigits + 20); /* +3 for sign, dot, null; */
    521              if (ndigits > 15) ndigits = 15;
   \   0000000E   0x2F10             CMP      R7,#+16
   \   00000010   0xDB00             BLT.N    ??ecvtbuf_0
   \   00000012   0x270F             MOVS     R7,#+15
    522              memset(chBuffer, 0, sizeof(chBuffer));
   \                     ??ecvtbuf_0: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2114             MOVS     R1,#+20
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x.... 0x....      BL       __aeabi_memset4
   \   0000001E   0xF8DD 0x803C      LDR      R8,[SP, #+60]
    523              char *cvtbuf = chBuffer; /* new char(ndigits + 20 + 1);*/
    524              /* two extra for rounding */
    525              /* 15 extra for alignment */
    526              char *s = cvtbuf, *d = buf;
   \   00000022   0x46C1             MOV      R9,R8
    527              
    528              /* Produce two extra digits, so we could round properly.  */
    529              //sprintf (cvtbuf, "%-+.*E", ndigits + 2, value);
    530              /* add by wdg*/
    531              ftoaE(cvtbuf, ndigits + 2, value);
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x1CB9             ADDS     R1,R7,#+2
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x.... 0x....      BL       ftoaE
    532          
    533              /* add end*/
    534              *decpt = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6030             STR      R0,[R6, #+0]
    535              
    536              /* The sign.  */
    537              *sign = ('=' == *s++) ? 1 : 0;
   \   00000034   0xF10D 0x0401      ADD      R4,SP,#+1
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x283D             CMP      R0,#+61
   \   0000003E   0xD101             BNE.N    ??ecvtbuf_1
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??ecvtbuf_2
   \                     ??ecvtbuf_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??ecvtbuf_2: (+1)
   \   00000046   0x990E             LDR      R1,[SP, #+56]
   \   00000048   0x6008             STR      R0,[R1, #+0]
    538              /* Special values get special treatment.  */
    539              if (strncmp(s, "Inf", 3) == 0)
   \   0000004A   0x2203             MOVS     R2,#+3
   \   0000004C   0x....             ADR.N    R1,??DataTable11  ;; "Inf"
   \   0000004E   0xF10D 0x0001      ADD      R0,SP,#+1
   \   00000052   0x.... 0x....      BL       strncmp
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD10F             BNE.N    ??ecvtbuf_3
    540              {
    541                  /* SunOS docs says we have return "Infinity" for NDIGITS >= 8.  */
    542                  memcpy (buf, INFINITY, ndigits >= 8 ? 9 : 3);
   \   0000005A   0x2F08             CMP      R7,#+8
   \   0000005C   0xDB01             BLT.N    ??ecvtbuf_4
   \   0000005E   0x2209             MOVS     R2,#+9
   \   00000060   0xE000             B.N      ??ecvtbuf_5
   \                     ??ecvtbuf_4: (+1)
   \   00000062   0x2203             MOVS     R2,#+3
   \                     ??ecvtbuf_5: (+1)
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable12_11
   \   00000068   0x4640             MOV      R0,R8
   \   0000006A   0x.... 0x....      BL       __aeabi_memcpy
    543                  if (ndigits < 8) buf[3] = '\0';
   \   0000006E   0x2F08             CMP      R7,#+8
   \   00000070   0xDA59             BGE.N    ??ecvtbuf_6
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF888 0x0003      STRB     R0,[R8, #+3]
   \   00000078   0xE055             B.N      ??ecvtbuf_6
    544              }
    545              else if (strcmp(s, "NaN") == 0)
   \                     ??ecvtbuf_3: (+1)
   \   0000007A   0x....             ADR.N    R1,??DataTable11_1  ;; "NaN"
   \   0000007C   0xF10D 0x0001      ADD      R0,SP,#+1
   \   00000080   0x.... 0x....      BL       strcmp
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0x4645             MOV      R5,R8
   \   00000088   0xD10A             BNE.N    ??ecvtbuf_7
    546              {
    547                  memcpy(buf, s, 4);
   \   0000008A   0x2204             MOVS     R2,#+4
   \   0000008C   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       __aeabi_memcpy
    548              }
   \   00000096   0xE046             B.N      ??ecvtbuf_6
    549              else
    550              {
    551                  char *last_digit, *digit_after_last;
    552                  
    553                  /* Copy (the single) digit before the decimal.  */
    554                  while (*s && *s != decimal && d - buf < ndigits)
    555                      *d++ = *s++;
   \                     ??ecvtbuf_8: (+1)
   \   00000098   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000009C   0xF809 0x0B01      STRB     R0,[R9], #+1
   \                     ??ecvtbuf_7: (+1)
   \   000000A0   0x7820             LDRB     R0,[R4, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD005             BEQ.N    ??ecvtbuf_9
   \   000000A6   0x282E             CMP      R0,#+46
   \   000000A8   0xD003             BEQ.N    ??ecvtbuf_9
   \   000000AA   0xEBA9 0x0005      SUB      R0,R9,R5
   \   000000AE   0x42B8             CMP      R0,R7
   \   000000B0   0xDBF2             BLT.N    ??ecvtbuf_8
    556                  
    557                  /* If we don't see any exponent, here's our decimal point.  */
    558                  *decpt = d - buf;
   \                     ??ecvtbuf_9: (+1)
   \   000000B2   0xEBA9 0x0005      SUB      R0,R9,R5
   \   000000B6   0x6030             STR      R0,[R6, #+0]
    559                  if(*s) s++;
   \   000000B8   0x7820             LDRB     R0,[R4, #+0]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD005             BEQ.N    ??ecvtbuf_10
   \   000000BE   0x1C64             ADDS     R4,R4,#+1
   \   000000C0   0xE003             B.N      ??ecvtbuf_10
    560                  
    561                  /* Copy the fraction digits.  */
    562                  while (*s && *s != 'E' && d - buf < ndigits)
    563                      *d++ = *s++;
   \                     ??ecvtbuf_11: (+1)
   \   000000C2   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   000000C6   0xF809 0x0B01      STRB     R0,[R9], #+1
   \                     ??ecvtbuf_10: (+1)
   \   000000CA   0x7820             LDRB     R0,[R4, #+0]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD005             BEQ.N    ??ecvtbuf_12
   \   000000D0   0x2845             CMP      R0,#+69
   \   000000D2   0xD003             BEQ.N    ??ecvtbuf_12
   \   000000D4   0xEBA9 0x0005      SUB      R0,R9,R5
   \   000000D8   0x42B8             CMP      R0,R7
   \   000000DA   0xDBF2             BLT.N    ??ecvtbuf_11
    564                  
    565                  /* Remember the last digit copied and the one after it.  */
    566                  last_digit = d > buf ? (d - 1) : d;
   \                     ??ecvtbuf_12: (+1)
   \   000000DC   0x454D             CMP      R5,R9
   \   000000DE   0xD202             BCS.N    ??ecvtbuf_13
   \   000000E0   0xF1A9 0x0A01      SUB      R10,R9,#+1
   \   000000E4   0xE000             B.N      ??ecvtbuf_14
   \                     ??ecvtbuf_13: (+1)
   \   000000E6   0x46CA             MOV      R10,R9
    567                  digit_after_last = s;
   \                     ??ecvtbuf_14: (+1)
   \   000000E8   0x46A3             MOV      R11,R4
    568                  
    569                  /* Get past the E in exponent field.  */
    570                  while (*s && *s++ != 'E');
   \                     ??ecvtbuf_15: (+1)
   \   000000EA   0x7820             LDRB     R0,[R4, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD003             BEQ.N    ??ecvtbuf_16
   \   000000F0   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   000000F4   0x2845             CMP      R0,#+69
   \   000000F6   0xD1F8             BNE.N    ??ecvtbuf_15
    571                  
    572                  /* Adjust the decimal point by the exponent value.  */
    573                  *decpt += atoi (s);
   \                     ??ecvtbuf_16: (+1)
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       my_atoi
   \   000000FE   0x6831             LDR      R1,[R6, #+0]
   \   00000100   0x1840             ADDS     R0,R0,R1
   \   00000102   0x6030             STR      R0,[R6, #+0]
   \   00000104   0xE002             B.N      ??ecvtbuf_17
    574                  
    575                  /* Pad with zeroes if needed.  */
    576                  while (d - buf < ndigits) *d++ = '0';
   \                     ??ecvtbuf_18: (+1)
   \   00000106   0x2030             MOVS     R0,#+48
   \   00000108   0xF809 0x0B01      STRB     R0,[R9], #+1
   \                     ??ecvtbuf_17: (+1)
   \   0000010C   0xEBA9 0x0005      SUB      R0,R9,R5
   \   00000110   0x42B8             CMP      R0,R7
   \   00000112   0xDBF8             BLT.N    ??ecvtbuf_18
    577                  
    578                  /* Zero-terminate.  */
    579                  *d = '\0';
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF889 0x0000      STRB     R0,[R9, #+0]
    580                  /* Round if necessary.  */
    581                  __ecvround (buf, last_digit, digit_after_last, decpt);
   \   0000011A   0x4633             MOV      R3,R6
   \   0000011C   0x465A             MOV      R2,R11
   \   0000011E   0x4651             MOV      R1,R10
   \   00000120   0x4640             MOV      R0,R8
   \   00000122   0x.... 0x....      BL       __ecvround
    582              }
    583          
    584              return buf;
   \                     ??ecvtbuf_6: (+1)
   \   00000126   0x4640             MOV      R0,R8
   \   00000128   0xB005             ADD      SP,SP,#+20
   \   0000012A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    585          }

   \                                 In section .data, align 4
   \                     ??INFINITY:
   \   00000000   0x49 0x6E          DC8 "Infinity"
   \              0x66 0x69    
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    586          

   \                                 In section .text, align 2, keep-with-next
    587          static char * fcvtbuf (double value, int ndigits, int *decpt, int *sign, char *buf)
    588          {
   \                     fcvtbuf: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    589              static char INFINITY[] = "Infinity";
    590              char decimal = '.' /* localeconv()->decimal_point[0] */;
    591              //int digits = ndigits >= 0 ? ndigits : 0;
    592              //char *cvtbuf = (char *)malloc(2*DBL_MAX_10_EXP + 16);
    593              char chBuffer[20];
    594              char *cvtbuf = chBuffer;
    595              char *s = cvtbuf;
    596              char *dot;
    597              char *pchRet = 0;
    598              //sprintf (cvtbuf, "%-+#.*f", DBL_MAX_10_EXP + digits + 1, value);
    599              //ftoa(cvtbuf, DBL_MAX_10_EXP + digits + 1, value);
    600              ftoa(value, cvtbuf);
   \   0000000E   0xAA02             ADD      R2,SP,#+8
   \   00000010   0x.... 0x....      BL       my_ftoa
    601              
    602              *sign = ('-' == *s++) ? 1 : 0; /* The sign.  */
   \   00000014   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000018   0x282D             CMP      R0,#+45
   \   0000001A   0xD101             BNE.N    ??fcvtbuf_0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE000             B.N      ??fcvtbuf_1
   \                     ??fcvtbuf_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??fcvtbuf_1: (+1)
   \   00000022   0x9F0E             LDR      R7,[SP, #+56]
   \   00000024   0x6038             STR      R0,[R7, #+0]
    603              /* Where's the decimal point?  */
    604              dot = strchr(s, decimal);
   \   00000026   0x212E             MOVS     R1,#+46
   \   00000028   0xF10D 0x0009      ADD      R0,SP,#+9
   \   0000002C   0x.... 0x....      BL       strchr
    605              
    606              *decpt = dot ? (dot - s) : strlen(s);
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD003             BEQ.N    ??fcvtbuf_2
   \   00000034   0xF10D 0x0109      ADD      R1,SP,#+9
   \   00000038   0x1A40             SUBS     R0,R0,R1
   \   0000003A   0xE003             B.N      ??fcvtbuf_3
   \                     ??fcvtbuf_2: (+1)
   \   0000003C   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000040   0x.... 0x....      BL       strlen
   \                     ??fcvtbuf_3: (+1)
   \   00000044   0x6030             STR      R0,[R6, #+0]
   \   00000046   0x9C0F             LDR      R4,[SP, #+60]
    607              
    608              /* SunOS docs says if NDIGITS is 8 or more, produce "Infinity"   instead of "Inf".  */
    609              if (strncmp (s, "Inf", 3) == 0)
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0x....             ADR.N    R1,??DataTable11  ;; "Inf"
   \   0000004C   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000050   0x.... 0x....      BL       strncmp
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD10E             BNE.N    ??fcvtbuf_4
    610              {
    611                  memcpy (buf, INFINITY, ndigits >= 8 ? 9 : 3);
   \   00000058   0x2D08             CMP      R5,#+8
   \   0000005A   0xDB01             BLT.N    ??fcvtbuf_5
   \   0000005C   0x2209             MOVS     R2,#+9
   \   0000005E   0xE000             B.N      ??fcvtbuf_6
   \                     ??fcvtbuf_5: (+1)
   \   00000060   0x2203             MOVS     R2,#+3
   \                     ??fcvtbuf_6: (+1)
   \   00000062   0x....             LDR.N    R1,??DataTable12_12
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       __aeabi_memcpy
    612                  if (ndigits < 8) buf[3] = '\0';
   \   0000006A   0x2D08             CMP      R5,#+8
   \   0000006C   0xDA01             BGE.N    ??fcvtbuf_7
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x70E0             STRB     R0,[R4, #+3]
    613                  pchRet = buf; /*return buf;*/
   \                     ??fcvtbuf_7: (+1)
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0xE047             B.N      ??fcvtbuf_8
    614              }
    615              else if (ndigits < 0)
   \                     ??fcvtbuf_4: (+1)
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD509             BPL.N    ??fcvtbuf_9
    616              {/*return ecvtbuf (value, *decpt + ndigits, decpt, sign, buf);*/
    617                  pchRet = ecvtbuf (value, *decpt + ndigits, decpt, sign, buf);
   \   0000007A   0x9401             STR      R4,[SP, #+4]
   \   0000007C   0x9700             STR      R7,[SP, #+0]
   \   0000007E   0x4633             MOV      R3,R6
   \   00000080   0x6830             LDR      R0,[R6, #+0]
   \   00000082   0x182A             ADDS     R2,R5,R0
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x4649             MOV      R1,R9
   \   00000088   0x.... 0x....      BL       ecvtbuf
   \   0000008C   0xE03B             B.N      ??fcvtbuf_8
    618              }
    619              else if (*s == '0' && !IS_DOUBLE_ZERO(value)/*value != 0.0*/)
   \                     ??fcvtbuf_9: (+1)
   \   0000008E   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000092   0x2830             CMP      R0,#+48
   \   00000094   0xD112             BNE.N    ??fcvtbuf_10
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0x....             LDR.N    R2,??DataTable12_2  ;; 0x2c40c60e
   \   0000009C   0x....             LDR.N    R3,??DataTable12_3  ;; 0x31fa18
   \   0000009E   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000A2   0xD204             BCS.N    ??fcvtbuf_11
   \   000000A4   0x....             LDR.N    R2,??DataTable12_4  ;; 0x2c40c60d
   \   000000A6   0x....             LDR.N    R3,??DataTable12_5  ;; 0x8031fa18
   \   000000A8   0x.... 0x....      BL       __aeabi_cdrcmple
   \   000000AC   0xD906             BLS.N    ??fcvtbuf_10
    620              {/*return ecvtbuf (value, ndigits, decpt, sign, buf);*/
    621                  pchRet = ecvtbuf(value, ndigits, decpt, sign, buf);
   \                     ??fcvtbuf_11: (+1)
   \   000000AE   0x9401             STR      R4,[SP, #+4]
   \   000000B0   0x9700             STR      R7,[SP, #+0]
   \   000000B2   0x4633             MOV      R3,R6
   \   000000B4   0x462A             MOV      R2,R5
   \   000000B6   0x.... 0x....      BL       ecvtbuf
   \   000000BA   0xE024             B.N      ??fcvtbuf_8
    622              }
    623              else
    624              {
    625                  memcpy (buf, s, *decpt);
   \                     ??fcvtbuf_10: (+1)
   \   000000BC   0x6832             LDR      R2,[R6, #+0]
   \   000000BE   0xF10D 0x0109      ADD      R1,SP,#+9
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       __aeabi_memcpy
    626                  if (s[*decpt] == decimal)
   \   000000C8   0x6830             LDR      R0,[R6, #+0]
   \   000000CA   0xA902             ADD      R1,SP,#+8
   \   000000CC   0x1841             ADDS     R1,R0,R1
   \   000000CE   0x784A             LDRB     R2,[R1, #+1]
   \   000000D0   0x2A2E             CMP      R2,#+46
   \   000000D2   0xD109             BNE.N    ??fcvtbuf_12
    627                  {
    628                      memcpy (buf + *decpt, s + *decpt + 1, ndigits);
   \   000000D4   0x462A             MOV      R2,R5
   \   000000D6   0x1C89             ADDS     R1,R1,#+2
   \   000000D8   0x1900             ADDS     R0,R0,R4
   \   000000DA   0x.... 0x....      BL       __aeabi_memcpy
    629                      buf[*decpt + ndigits] = '\0';
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x6831             LDR      R1,[R6, #+0]
   \   000000E2   0x1869             ADDS     R1,R5,R1
   \   000000E4   0x5508             STRB     R0,[R1, R4]
   \   000000E6   0xE001             B.N      ??fcvtbuf_13
    630                  }
    631                  else
    632                  {
    633                      buf[*decpt] = '\0';
   \                     ??fcvtbuf_12: (+1)
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x5501             STRB     R1,[R0, R4]
    634                  }
    635                  __ecvround (buf, buf + *decpt + ndigits - 1,
    636                      s + *decpt + ndigits + 1, decpt);
   \                     ??fcvtbuf_13: (+1)
   \   000000EC   0x6830             LDR      R0,[R6, #+0]
   \   000000EE   0x4633             MOV      R3,R6
   \   000000F0   0xA902             ADD      R1,SP,#+8
   \   000000F2   0x1841             ADDS     R1,R0,R1
   \   000000F4   0x1869             ADDS     R1,R5,R1
   \   000000F6   0x1C8A             ADDS     R2,R1,#+2
   \   000000F8   0x1900             ADDS     R0,R0,R4
   \   000000FA   0x1828             ADDS     R0,R5,R0
   \   000000FC   0x1E41             SUBS     R1,R0,#+1
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       __ecvround
    637                  pchRet = buf; /*return buf;*/
   \   00000104   0x4620             MOV      R0,R4
    638              }
    639              /*delete [] cvtbuf; */
    640              return pchRet;
   \                     ??fcvtbuf_8: (+1)
   \   00000106   0xB007             ADD      SP,SP,#+28
   \   00000108   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    641          }

   \                                 In section .data, align 4
   \                     ??INFINITY_1:
   \   00000000   0x49 0x6E          DC8 "Infinity"
   \              0x66 0x69    
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    642          

   \                                 In section .text, align 2, keep-with-next
    643          static void cfltcvt(double value, char *buffer, char fmt, int precision)
    644          {
   \                     cfltcvt: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB099             SUB      SP,SP,#+100
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4617             MOV      R7,R2
    645              int decpt, sign;
    646              char cvtbuf[80];
    647              int capexp = 0;
   \   0000000C   0xF04F 0x0900      MOV      R9,#+0
    648          
    649              if ('G' == fmt || 'E' == fmt)
   \   00000010   0x4618             MOV      R0,R3
   \   00000012   0x2847             CMP      R0,#+71
   \   00000014   0xD001             BEQ.N    ??cfltcvt_0
   \   00000016   0x2845             CMP      R0,#+69
   \   00000018   0xD102             BNE.N    ??cfltcvt_1
    650              {
    651                  capexp = 1;
   \                     ??cfltcvt_0: (+1)
   \   0000001A   0xF04F 0x0901      MOV      R9,#+1
    652                  fmt += 'a' - 'A';
   \   0000001E   0x3320             ADDS     R3,R3,#+32
   \                     ??cfltcvt_1: (+1)
   \   00000020   0xF8DD 0x8080      LDR      R8,[SP, #+128]
    653              }
    654          
    655              if (fmt == 'g')
   \   00000024   0xB2DB             UXTB     R3,R3
   \   00000026   0x2B67             CMP      R3,#+103
   \   00000028   0xD118             BNE.N    ??cfltcvt_2
    656              {
    657                  char * digits = ecvtbuf(value, precision, &decpt, &sign, cvtbuf);
   \   0000002A   0xA804             ADD      R0,SP,#+16
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0xA803             ADD      R0,SP,#+12
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0xAB02             ADD      R3,SP,#+8
   \   00000034   0x4642             MOV      R2,R8
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       ecvtbuf
    658                  int magnitude = decpt - 1;
   \   0000003C   0x9802             LDR      R0,[SP, #+8]
   \   0000003E   0x1E40             SUBS     R0,R0,#+1
    659                  if (magnitude < -4  ||  magnitude > precision - 1)
   \   00000040   0xF1A8 0x0101      SUB      R1,R8,#+1
   \   00000044   0xF110 0x0F04      CMN      R0,#+4
   \   00000048   0xDB01             BLT.N    ??cfltcvt_3
   \   0000004A   0x4281             CMP      R1,R0
   \   0000004C   0xDA02             BGE.N    ??cfltcvt_4
    660                  {
    661                      fmt = 'e';
   \                     ??cfltcvt_3: (+1)
   \   0000004E   0x2365             MOVS     R3,#+101
    662                      precision -= 1;
   \   00000050   0x4688             MOV      R8,R1
   \   00000052   0xE003             B.N      ??cfltcvt_2
    663                  }
    664                  else
    665                  {
    666                      fmt = 'f';
   \                     ??cfltcvt_4: (+1)
   \   00000054   0x2366             MOVS     R3,#+102
    667                      precision -= decpt;
   \   00000056   0x9802             LDR      R0,[SP, #+8]
   \   00000058   0xEBA8 0x0800      SUB      R8,R8,R0
    668                  }
    669              }
    670          
    671              if ('e' == fmt)
   \                     ??cfltcvt_2: (+1)
   \   0000005C   0x2B65             CMP      R3,#+101
   \   0000005E   0xD15E             BNE.N    ??cfltcvt_5
    672              {
    673                  char * digits = ecvtbuf(value, precision + 1, &decpt, &sign, cvtbuf);
   \   00000060   0xA804             ADD      R0,SP,#+16
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0xA803             ADD      R0,SP,#+12
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xAB02             ADD      R3,SP,#+8
   \   0000006A   0xF108 0x0201      ADD      R2,R8,#+1
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x.... 0x....      BL       ecvtbuf
    674                  int exp = 0;
   \   00000076   0x2600             MOVS     R6,#+0
    675                  if (sign) *buffer++ = '-';
   \   00000078   0x9903             LDR      R1,[SP, #+12]
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD002             BEQ.N    ??cfltcvt_6
   \   0000007E   0x212D             MOVS     R1,#+45
   \   00000080   0xF807 0x1B01      STRB     R1,[R7], #+1
    676                  *buffer++ = *digits;
   \                     ??cfltcvt_6: (+1)
   \   00000084   0x7801             LDRB     R1,[R0, #+0]
   \   00000086   0xF807 0x1B01      STRB     R1,[R7], #+1
    677                  if (precision > 0) *buffer++ = '.';
   \   0000008A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000008E   0xDB02             BLT.N    ??cfltcvt_7
   \   00000090   0x212E             MOVS     R1,#+46
   \   00000092   0xF807 0x1B01      STRB     R1,[R7], #+1
    678                  memcpy(buffer, digits + 1, precision);
   \                     ??cfltcvt_7: (+1)
   \   00000096   0x4642             MOV      R2,R8
   \   00000098   0x1C41             ADDS     R1,R0,#+1
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_memcpy
    679                  buffer += precision;
    680                  *buffer++ = capexp ? 'E' : 'e';
   \   000000A0   0xEB08 0x0007      ADD      R0,R8,R7
   \   000000A4   0x1C47             ADDS     R7,R0,#+1
   \   000000A6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AA   0xD001             BEQ.N    ??cfltcvt_8
   \   000000AC   0x2145             MOVS     R1,#+69
   \   000000AE   0xE000             B.N      ??cfltcvt_9
   \                     ??cfltcvt_8: (+1)
   \   000000B0   0x2165             MOVS     R1,#+101
   \                     ??cfltcvt_9: (+1)
   \   000000B2   0x7001             STRB     R1,[R0, #+0]
    681          
    682                  if (decpt == 0)
   \   000000B4   0x9802             LDR      R0,[SP, #+8]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD10E             BNE.N    ??cfltcvt_10
    683                  {
    684                      exp = (IS_DOUBLE_ZERO(value)) ? 0 : -1; /*       if (value == 0.0)*/
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x4629             MOV      R1,R5
   \   000000BE   0x....             LDR.N    R2,??DataTable12_2  ;; 0x2c40c60e
   \   000000C0   0x....             LDR.N    R3,??DataTable12_3  ;; 0x31fa18
   \   000000C2   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000C6   0xD204             BCS.N    ??cfltcvt_11
   \   000000C8   0x....             LDR.N    R2,??DataTable12_4  ;; 0x2c40c60d
   \   000000CA   0x....             LDR.N    R3,??DataTable12_5  ;; 0x8031fa18
   \   000000CC   0x.... 0x....      BL       __aeabi_cdrcmple
   \   000000D0   0xD903             BLS.N    ??cfltcvt_12
   \                     ??cfltcvt_11: (+1)
   \   000000D2   0xF04F 0x36FF      MOV      R6,#-1
   \   000000D6   0xE000             B.N      ??cfltcvt_12
    685                  }
    686                  else
    687                  {
    688                      exp = decpt - 1;
   \                     ??cfltcvt_10: (+1)
   \   000000D8   0x1E46             SUBS     R6,R0,#+1
    689                  }
    690                  
    691                  if (exp < 0)
   \                     ??cfltcvt_12: (+1)
   \   000000DA   0x2E00             CMP      R6,#+0
   \   000000DC   0xD504             BPL.N    ??cfltcvt_13
    692                  {
    693                      *buffer++ = '-';
   \   000000DE   0x202D             MOVS     R0,#+45
   \   000000E0   0xF807 0x0B01      STRB     R0,[R7], #+1
    694                      exp = -exp;
   \   000000E4   0x4276             RSBS     R6,R6,#+0
   \   000000E6   0xE002             B.N      ??cfltcvt_14
    695                  }
    696                  else
    697                  {
    698                      *buffer++ = '+';
   \                     ??cfltcvt_13: (+1)
   \   000000E8   0x202B             MOVS     R0,#+43
   \   000000EA   0xF807 0x0B01      STRB     R0,[R7], #+1
    699                  }
    700                  
    701                  buffer[2] = (exp % 10) + '0';
   \                     ??cfltcvt_14: (+1)
   \   000000EE   0x200A             MOVS     R0,#+10
   \   000000F0   0xFB96 0xF0F0      SDIV     R0,R6,R0
   \   000000F4   0x210A             MOVS     R1,#+10
   \   000000F6   0xFB01 0x6210      MLS      R2,R1,R0,R6
   \   000000FA   0x3230             ADDS     R2,R2,#+48
   \   000000FC   0x70BA             STRB     R2,[R7, #+2]
    702                  exp /= 10;
    703                  buffer[1] = (exp % 10) + '0';
   \   000000FE   0x460A             MOV      R2,R1
   \   00000100   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000104   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000108   0x3030             ADDS     R0,R0,#+48
   \   0000010A   0x7078             STRB     R0,[R7, #+1]
    704                  exp /= 10;
    705                  buffer[0] = (exp % 10) + '0';
   \   0000010C   0x4608             MOV      R0,R1
   \   0000010E   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \   00000112   0xFB01 0x2010      MLS      R0,R1,R0,R2
   \   00000116   0x3030             ADDS     R0,R0,#+48
   \   00000118   0x7038             STRB     R0,[R7, #+0]
    706                  buffer += 3;
   \   0000011A   0x1CFF             ADDS     R7,R7,#+3
   \   0000011C   0xE050             B.N      ??cfltcvt_15
    707              }
    708              else if ('f' == fmt)
   \                     ??cfltcvt_5: (+1)
   \   0000011E   0x2B66             CMP      R3,#+102
   \   00000120   0xD14E             BNE.N    ??cfltcvt_15
    709              {
    710                  char * digits = fcvtbuf(value, precision, &decpt, &sign, cvtbuf);
   \   00000122   0xA804             ADD      R0,SP,#+16
   \   00000124   0x9001             STR      R0,[SP, #+4]
   \   00000126   0xA803             ADD      R0,SP,#+12
   \   00000128   0x9000             STR      R0,[SP, #+0]
   \   0000012A   0xAB02             ADD      R3,SP,#+8
   \   0000012C   0x4642             MOV      R2,R8
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0x4629             MOV      R1,R5
   \   00000132   0x.... 0x....      BL       fcvtbuf
    711                  if (sign) *buffer++ = '-';
   \   00000136   0x9903             LDR      R1,[SP, #+12]
   \   00000138   0x2900             CMP      R1,#+0
   \   0000013A   0xD002             BEQ.N    ??cfltcvt_16
   \   0000013C   0x212D             MOVS     R1,#+45
   \   0000013E   0xF807 0x1B01      STRB     R1,[R7], #+1
    712                  if (*digits)
   \                     ??cfltcvt_16: (+1)
   \   00000142   0x7801             LDRB     R1,[R0, #+0]
   \   00000144   0x2900             CMP      R1,#+0
   \   00000146   0xD02A             BEQ.N    ??cfltcvt_17
    713                  {
    714                      if (decpt <= 0)
   \   00000148   0x9902             LDR      R1,[SP, #+8]
   \   0000014A   0x2901             CMP      R1,#+1
   \   0000014C   0xDA16             BGE.N    ??cfltcvt_18
    715                      {
    716                          *buffer++ = '0';
   \   0000014E   0x2130             MOVS     R1,#+48
   \   00000150   0xF807 0x1B01      STRB     R1,[R7], #+1
    717                          *buffer++ = '.';
   \   00000154   0x212E             MOVS     R1,#+46
   \   00000156   0xF807 0x1B01      STRB     R1,[R7], #+1
    718                          for (int pos = 0; pos < -decpt; pos++)
   \   0000015A   0x2100             MOVS     R1,#+0
   \   0000015C   0xE003             B.N      ??cfltcvt_19
    719                          {
    720                              *buffer++ = '0';
   \                     ??cfltcvt_20: (+1)
   \   0000015E   0x2230             MOVS     R2,#+48
   \   00000160   0xF807 0x2B01      STRB     R2,[R7], #+1
    721                          }
   \   00000164   0x1C49             ADDS     R1,R1,#+1
   \                     ??cfltcvt_19: (+1)
   \   00000166   0x9A02             LDR      R2,[SP, #+8]
   \   00000168   0x42D1             CMN      R1,R2
   \   0000016A   0xDBF8             BLT.N    ??cfltcvt_20
    722                          while(*digits) *buffer++ = *digits++;
   \                     ??cfltcvt_21: (+1)
   \   0000016C   0x7801             LDRB     R1,[R0, #+0]
   \   0000016E   0x2900             CMP      R1,#+0
   \   00000170   0xD026             BEQ.N    ??cfltcvt_15
   \   00000172   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000176   0xF807 0x1B01      STRB     R1,[R7], #+1
   \   0000017A   0xE7F7             B.N      ??cfltcvt_21
    723                      }
    724                      else
    725                      {
    726                          int pos = 0;
   \                     ??cfltcvt_18: (+1)
   \   0000017C   0x2100             MOVS     R1,#+0
    727                          while(*digits)
   \                     ??cfltcvt_22: (+1)
   \   0000017E   0x7802             LDRB     R2,[R0, #+0]
   \   00000180   0x2A00             CMP      R2,#+0
   \   00000182   0xD01D             BEQ.N    ??cfltcvt_15
    728                          {
    729                              if (pos++ == decpt) *buffer++ = '.';
   \   00000184   0x460A             MOV      R2,R1
   \   00000186   0x1C51             ADDS     R1,R2,#+1
   \   00000188   0x9B02             LDR      R3,[SP, #+8]
   \   0000018A   0x429A             CMP      R2,R3
   \   0000018C   0xD102             BNE.N    ??cfltcvt_23
   \   0000018E   0x222E             MOVS     R2,#+46
   \   00000190   0xF807 0x2B01      STRB     R2,[R7], #+1
    730                              *buffer++ = *digits++;
   \                     ??cfltcvt_23: (+1)
   \   00000194   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \   00000198   0xF807 0x2B01      STRB     R2,[R7], #+1
   \   0000019C   0xE7EF             B.N      ??cfltcvt_22
    731                          }
    732                      }
    733                  }
    734                  else
    735                  {
    736                      *buffer++ = '0';
   \                     ??cfltcvt_17: (+1)
   \   0000019E   0x2030             MOVS     R0,#+48
   \   000001A0   0xF807 0x0B01      STRB     R0,[R7], #+1
    737                      if(precision > 0)
   \   000001A4   0xF1B8 0x0F01      CMP      R8,#+1
   \   000001A8   0xDB0A             BLT.N    ??cfltcvt_15
    738                      {
    739                          *buffer++ = '.';
   \   000001AA   0x202E             MOVS     R0,#+46
   \   000001AC   0xF807 0x0B01      STRB     R0,[R7], #+1
    740                          for(int pos = 0; pos < precision; pos++)
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x2130             MOVS     R1,#+48
   \   000001B4   0xE002             B.N      ??cfltcvt_24
    741                          {
    742                              *buffer++ = '0';
   \                     ??cfltcvt_25: (+1)
   \   000001B6   0xF807 0x1B01      STRB     R1,[R7], #+1
    743                          }
   \   000001BA   0x1C40             ADDS     R0,R0,#+1
   \                     ??cfltcvt_24: (+1)
   \   000001BC   0x4540             CMP      R0,R8
   \   000001BE   0xDBFA             BLT.N    ??cfltcvt_25
    744                      }
    745                  }
    746              }
    747          
    748              *buffer = '\0';
   \                     ??cfltcvt_15: (+1)
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0x7038             STRB     R0,[R7, #+0]
    749          }
   \   000001C4   0xB019             ADD      SP,SP,#+100
   \   000001C6   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    750          

   \                                 In section .text, align 2, keep-with-next
    751          static void forcdecpt(char *buffer)
    752          {
   \                     forcdecpt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE000             B.N      ??forcdecpt_0
    753              while (*buffer)
    754              {
    755                  if (*buffer == '.') return;
    756                  if (*buffer == 'e' || *buffer == 'E') break;
    757                  buffer++;
   \                     ??forcdecpt_1: (+1)
   \   00000006   0x1C64             ADDS     R4,R4,#+1
   \                     ??forcdecpt_0: (+1)
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD006             BEQ.N    ??forcdecpt_2
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0x292E             CMP      R1,#+46
   \   00000012   0xD016             BEQ.N    ??forcdecpt_3
   \   00000014   0x2965             CMP      R1,#+101
   \   00000016   0xD001             BEQ.N    ??forcdecpt_2
   \   00000018   0x2945             CMP      R1,#+69
   \   0000001A   0xD1F4             BNE.N    ??forcdecpt_1
    758              }
    759          
    760              if(*buffer)
   \                     ??forcdecpt_2: (+1)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00C             BEQ.N    ??forcdecpt_4
    761              {
    762                  int n = strlen(buffer);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       strlen
   \   00000026   0xE003             B.N      ??forcdecpt_5
    763                  while(n > 0) 
    764                  {
    765                      buffer[n + 1] = buffer[n];
   \                     ??forcdecpt_6: (+1)
   \   00000028   0x5D01             LDRB     R1,[R0, R4]
   \   0000002A   0x1902             ADDS     R2,R0,R4
   \   0000002C   0x7051             STRB     R1,[R2, #+1]
    766                      n--;
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
    767                  }
   \                     ??forcdecpt_5: (+1)
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xDAF9             BGE.N    ??forcdecpt_6
    768          
    769                  *buffer = '.';
   \   00000034   0x202E             MOVS     R0,#+46
   \   00000036   0x7020             STRB     R0,[R4, #+0]
   \   00000038   0xBD10             POP      {R4,PC}
    770              }
    771              else
    772              {
    773                  *buffer++ = '.';
   \                     ??forcdecpt_4: (+1)
   \   0000003A   0x202E             MOVS     R0,#+46
   \   0000003C   0x7020             STRB     R0,[R4, #+0]
    774                  *buffer = '\0';
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7060             STRB     R0,[R4, #+1]
    775              }
    776          }
   \                     ??forcdecpt_3: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    777          

   \                                 In section .text, align 2, keep-with-next
    778          static void cropzeros(char *buffer)
    779          {
   \                     cropzeros: (+1)
   \   00000000   0xE000             B.N      ??cropzeros_0
    780              char *stop;
    781              while (*buffer && *buffer != '.') buffer++;
   \                     ??cropzeros_1: (+1)
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??cropzeros_0: (+1)
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD001             BEQ.N    ??cropzeros_2
   \   0000000A   0x292E             CMP      R1,#+46
   \   0000000C   0xD1F9             BNE.N    ??cropzeros_1
    782          
    783              if (*buffer++)
   \                     ??cropzeros_2: (+1)
   \   0000000E   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD101             BNE.N    ??cropzeros_3
   \   00000016   0x4770             BX       LR
    784              {
    785                  while (*buffer && *buffer != 'e' && *buffer != 'E') buffer++;
   \                     ??cropzeros_4: (+1)
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \                     ??cropzeros_3: (+1)
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD003             BEQ.N    ??cropzeros_5
   \   00000020   0x2965             CMP      R1,#+101
   \   00000022   0xD001             BEQ.N    ??cropzeros_5
   \   00000024   0x2945             CMP      R1,#+69
   \   00000026   0xD1F7             BNE.N    ??cropzeros_4
    786                  stop = buffer--;
   \                     ??cropzeros_5: (+1)
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0xE000             B.N      ??cropzeros_6
    787                  while('0' == *buffer) buffer--;
   \                     ??cropzeros_7: (+1)
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \                     ??cropzeros_6: (+1)
   \   00000030   0x7802             LDRB     R2,[R0, #+0]
   \   00000032   0x2A30             CMP      R2,#+48
   \   00000034   0xD0FB             BEQ.N    ??cropzeros_7
    788                  if('.' == *buffer) buffer--;
   \   00000036   0x2A2E             CMP      R2,#+46
   \   00000038   0xD100             BNE.N    ??cropzeros_8
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
    789                  while(*++buffer = *stop++);
   \                     ??cropzeros_8: (+1)
   \   0000003C   0xF811 0x2B01      LDRB     R2,[R1], #+1
   \   00000040   0xF800 0x2F01      STRB     R2,[R0, #+1]!
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD1F9             BNE.N    ??cropzeros_8
    790              }
    791          }
   \   00000048   0x4770             BX       LR               ;; return
    792          

   \                                 In section .text, align 2, keep-with-next
    793          static char * flt(char *str, double num, int size, int precision, char fmt, int flags)
    794          {
   \                     flt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB096             SUB      SP,SP,#+88
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x9D21             LDR      R5,[SP, #+132]
    795              char tmp[80];
    796              char c, sign;
    797              int n, i;
    798          
    799              /* Left align means no zero padding */
    800              if (flags & LEFT) flags &= ~ZEROPAD;
   \   0000000E   0x06EA             LSLS     R2,R5,#+27
   \   00000010   0xD501             BPL.N    ??flt_0
   \   00000012   0xF025 0x0501      BIC      R5,R5,#0x1
    801          
    802              /* Determine padding and sign char */
    803              c = (flags & ZEROPAD) ? '0' : ' ';
   \                     ??flt_0: (+1)
   \   00000016   0x07EA             LSLS     R2,R5,#+31
   \   00000018   0xD502             BPL.N    ??flt_1
   \   0000001A   0xF04F 0x0A30      MOV      R10,#+48
   \   0000001E   0xE001             B.N      ??flt_2
   \                     ??flt_1: (+1)
   \   00000020   0xF04F 0x0A20      MOV      R10,#+32
    804              sign = 0;
   \                     ??flt_2: (+1)
   \   00000024   0x2600             MOVS     R6,#+0
   \   00000026   0x9F1E             LDR      R7,[SP, #+120]
    805              if (flags & SIGN)
   \   00000028   0x07AA             LSLS     R2,R5,#+30
   \   0000002A   0xD512             BPL.N    ??flt_3
    806              {
    807                  if (num < 0.0)
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4613             MOV      R3,R2
   \   00000030   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000034   0xD204             BCS.N    ??flt_4
    808                  {
    809                      sign = '-';
   \   00000036   0x262D             MOVS     R6,#+45
    810                      num = -num;
   \   00000038   0xF081 0x4100      EOR      R1,R1,#0x80000000
    811                      size--;
   \   0000003C   0x1E7F             SUBS     R7,R7,#+1
   \   0000003E   0xE008             B.N      ??flt_3
    812                  }
    813                  else if (flags & PLUS)
   \                     ??flt_4: (+1)
   \   00000040   0x076A             LSLS     R2,R5,#+29
   \   00000042   0xD502             BPL.N    ??flt_5
    814                  {
    815                      sign = '+';
   \   00000044   0x262B             MOVS     R6,#+43
    816                      size--;
   \   00000046   0x1E7F             SUBS     R7,R7,#+1
   \   00000048   0xE003             B.N      ??flt_3
    817                  }
    818                  else if (flags & SPACE)
   \                     ??flt_5: (+1)
   \   0000004A   0x072A             LSLS     R2,R5,#+28
   \   0000004C   0xD501             BPL.N    ??flt_3
    819                  {
    820                      sign = ' ';
   \   0000004E   0x2620             MOVS     R6,#+32
    821                      size--;
   \   00000050   0x1E7F             SUBS     R7,R7,#+1
   \                     ??flt_3: (+1)
   \   00000052   0xF8DD 0x907C      LDR      R9,[SP, #+124]
   \   00000056   0xF8DD 0x8080      LDR      R8,[SP, #+128]
    822                  }
    823              }
    824          
    825              /* Compute the precision value */
    826              if (precision < 0)
   \   0000005A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000005E   0xD502             BPL.N    ??flt_6
    827              {
    828                  precision = 6; /* Default precision: 6 */
   \   00000060   0xF04F 0x0906      MOV      R9,#+6
   \   00000064   0xE005             B.N      ??flt_7
    829              }
    830              else if (precision == 0 && fmt == 'g')
   \                     ??flt_6: (+1)
   \   00000066   0xD104             BNE.N    ??flt_7
   \   00000068   0xF1B8 0x0F67      CMP      R8,#+103
   \   0000006C   0xD101             BNE.N    ??flt_7
    831              {
    832                  precision = 1; /* ANSI specified */
   \   0000006E   0xF04F 0x0901      MOV      R9,#+1
    833              }
    834              /* Convert floating point number to text */
    835              cfltcvt(num, tmp, fmt, precision);
   \                     ??flt_7: (+1)
   \   00000072   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000076   0x4643             MOV      R3,R8
   \   00000078   0xAA01             ADD      R2,SP,#+4
   \   0000007A   0x.... 0x....      BL       cfltcvt
    836          
    837              /* '#' and precision == 0 means force a decimal point */
    838              if ((flags & SPECIAL) && precision == 0) forcdecpt(tmp);
   \   0000007E   0x06A8             LSLS     R0,R5,#+26
   \   00000080   0xD505             BPL.N    ??flt_8
   \   00000082   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000086   0xD102             BNE.N    ??flt_8
   \   00000088   0xA801             ADD      R0,SP,#+4
   \   0000008A   0x.... 0x....      BL       forcdecpt
    839          
    840              /* 'g' format means crop zero unless '#' given */
    841              if (fmt == 'g' && !(flags & SPECIAL)) cropzeros(tmp);
   \                     ??flt_8: (+1)
   \   0000008E   0xF1B8 0x0F67      CMP      R8,#+103
   \   00000092   0xD104             BNE.N    ??flt_9
   \   00000094   0x06A8             LSLS     R0,R5,#+26
   \   00000096   0xD402             BMI.N    ??flt_9
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x.... 0x....      BL       cropzeros
    842          
    843              n = strlen(tmp);
   \                     ??flt_9: (+1)
   \   0000009E   0xA801             ADD      R0,SP,#+4
   \   000000A0   0x.... 0x....      BL       strlen
    844          
    845              /* Output number with alignment and padding */
    846              size -= n;
   \   000000A4   0x1A39             SUBS     R1,R7,R0
    847              if(!(flags & (ZEROPAD | LEFT)))
   \   000000A6   0xF015 0x0F11      TST      R5,#0x11
   \   000000AA   0xD107             BNE.N    ??flt_10
   \   000000AC   0xE002             B.N      ??flt_11
    848              {
    849                  while(size-- > 0) *str++ = ' ';
   \                     ??flt_12: (+1)
   \   000000AE   0x2220             MOVS     R2,#+32
   \   000000B0   0xF804 0x2B01      STRB     R2,[R4], #+1
   \                     ??flt_11: (+1)
   \   000000B4   0x460A             MOV      R2,R1
   \   000000B6   0x1E51             SUBS     R1,R2,#+1
   \   000000B8   0x2A01             CMP      R2,#+1
   \   000000BA   0xDAF8             BGE.N    ??flt_12
    850              }
    851              if(sign) *str++ = sign;
   \                     ??flt_10: (+1)
   \   000000BC   0x2E00             CMP      R6,#+0
   \   000000BE   0xD001             BEQ.N    ??flt_13
   \   000000C0   0xF804 0x6B01      STRB     R6,[R4], #+1
    852              
    853              if(!(flags & LEFT))
   \                     ??flt_13: (+1)
   \   000000C4   0x06EA             LSLS     R2,R5,#+27
   \   000000C6   0xD406             BMI.N    ??flt_14
   \   000000C8   0xE001             B.N      ??flt_15
    854              {
    855                  while(size-- > 0) *str++ = c;
   \                     ??flt_16: (+1)
   \   000000CA   0xF804 0xAB01      STRB     R10,[R4], #+1
   \                     ??flt_15: (+1)
   \   000000CE   0x460A             MOV      R2,R1
   \   000000D0   0x1E51             SUBS     R1,R2,#+1
   \   000000D2   0x2A01             CMP      R2,#+1
   \   000000D4   0xDAF9             BGE.N    ??flt_16
    856              }
    857              for(i = 0; i < n; i++)
   \                     ??flt_14: (+1)
   \   000000D6   0x2200             MOVS     R2,#+0
   \   000000D8   0xE004             B.N      ??flt_17
    858              {
    859                  *str++ = tmp[i];
   \                     ??flt_18: (+1)
   \   000000DA   0xAB01             ADD      R3,SP,#+4
   \   000000DC   0x5CD3             LDRB     R3,[R2, R3]
   \   000000DE   0xF804 0x3B01      STRB     R3,[R4], #+1
    860              }
   \   000000E2   0x1C52             ADDS     R2,R2,#+1
   \                     ??flt_17: (+1)
   \   000000E4   0x4282             CMP      R2,R0
   \   000000E6   0xDBF8             BLT.N    ??flt_18
    861              
    862              while(size-- > 0) *str++ = ' ';
   \                     ??flt_19: (+1)
   \   000000E8   0x4608             MOV      R0,R1
   \   000000EA   0x1E41             SUBS     R1,R0,#+1
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xDB03             BLT.N    ??flt_20
   \   000000F0   0x2020             MOVS     R0,#+32
   \   000000F2   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   000000F6   0xE7F7             B.N      ??flt_19
    863          
    864              return str;
   \                     ??flt_20: (+1)
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0xB016             ADD      SP,SP,#+88
   \   000000FC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    865          }
    866          
    867          #endif
    868          

   \                                 In section .text, align 2, keep-with-next
    869          static int vsprintf(char *buf, const char *fmt, va_list args)
    870          {
   \                     my_vsprintf: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4615             MOV      R5,R2
    871              char *str;
    872              int field_width;      /* Width of output field */
    873          
    874              for (str = buf; *fmt; fmt++)
   \   0000000A   0x4626             MOV      R6,R4
   \   0000000C   0xE00F             B.N      ??my_vsprintf_0
    875              {
    876                  unsigned long num;
    877                  int base = 10;
    878                  int flags = 0; /* Flags to number()    Process flags */
    879                  int qualifier = -1;        /* 'h', 'l', or 'L' for integer fields */
    880                  int precision = -1;     /* Min. # of digits for integers; max number of chars for from string */
    881                  BOOL bFmt = TRUE;
    882                  if (*fmt != '%')
    883                  {
    884                      *str++ = *fmt;
    885                      continue;
    886                  }
    887                  
    888                  bFmt = TRUE;
    889                  while(bFmt)
    890                  {
    891                      fmt++; /* This also skips first '%' */
    892                      switch (*fmt)
    893                      {
    894                          case '-': flags |= LEFT; break;
    895                          case '+': flags |= PLUS; break;
    896                          case ' ': flags |= SPACE; break;
    897                          case '#': flags |= SPECIAL; break;
    898                          case '0': flags |= ZEROPAD; break;
    899                          default:  bFmt = FALSE;
    900                      }
    901                  }
    902                  
    903                  /* Get field width */
    904                  field_width = -1;
    905                  if (is_digit(*fmt))
    906                  {
    907                      field_width = skip_atoi(&fmt);
    908                  }
    909                  else if ('*' == *fmt)
    910                  {
    911                      fmt++;
    912                      field_width = va_arg(args, int);
    913                      if (field_width < 0)
    914                      {
    915                          field_width = -field_width;
    916                          flags |= LEFT;
    917                      }
    918                  }
    919          
    920                  /* Get the precision */
    921                  precision = -1;
    922                  if ('.' == *fmt)
    923                  {
    924                      ++fmt;
    925                      if (is_digit(*fmt))
    926                      {
    927                          precision = skip_atoi(&fmt);
    928                      }
    929                      else if ('*' == *fmt)
    930                      {
    931                          ++fmt;
    932                          precision = va_arg(args, int);
    933                      }
    934                      if (precision < 0) precision = 0;
    935                  }
    936          
    937                  /* Get the conversion qualifier */
    938                  qualifier = -1;
    939                  if ('h' == *fmt || 'l' == *fmt || 'L' == *fmt)
    940                  {
    941                      qualifier = *fmt;
    942                      fmt++;
    943                  }
    944          
    945                  /* Default base */
    946                  base = 10;
    947                  switch (*fmt)
    948                  {
    949                      case 'c':
    950                      {
    951                          if (!(flags & LEFT)) while (--field_width > 0) *str++ = ' ';
    952                          *str++ = (unsigned char) va_arg(args, int);
    953                          while (--field_width > 0) *str++ = ' ';
    954                          continue;
    955                      }
    956                      case 's':
    957                      {
    958                          int len;
    959                          char * s = va_arg(args, char *);
    960                          if (!s) s = "<NULL>";
    961                          len = strnlen(s, precision);
    962                          if (!(flags & LEFT)) while (len < field_width--) *str++ = ' ';
    963                          for (int i = 0; i < len; ++i) *str++ = *s++;
    964                          while (len < field_width--) *str++ = ' ';
    965                          continue;
    966                      }
    967                      case 'p':
    968                      {
    969                          if (-1 == field_width)
    970                          {
    971                              field_width = 2 * sizeof(void *);
    972                              flags |= ZEROPAD;
    973                          }
    974                          str = number(str, (unsigned long) va_arg(args, void *), 16, field_width, precision, flags);
    975                          continue;
    976                      }
    977                      case 'n':
    978                      {
    979                          if ('l' == qualifier)
    980                          {
    981                              long *ip = va_arg(args, long *);
    982                              *ip = (str - buf);
    983                          }
    984                          else
    985                          {
    986                              int *ip = va_arg(args, int *);
    987                              *ip = (str - buf);
    988                          }
    989                          continue;
    990                      }
    991                      case 'A':
    992                      {
    993                          flags |= LARGE; /* no break */
    994                      }
    995                      case 'a':
    996                      {
    997                          if ('l' == qualifier)
    998                          {
    999                              str = eaddr(str, va_arg(args, unsigned char *), field_width, precision, flags);
   1000                          }
   1001                          else
   1002                          {
   1003                              str = iaddr(str, va_arg(args, unsigned char *), field_width, precision, flags);
   1004                          }
   1005                          continue;
   1006                      }
   1007                          /* Integer number formats - set up the flags and "break" */
   1008                      case 'o':
   1009                      {
   1010                          base = 8;
   1011                          break;
   1012                      }
   1013                      case 'X':
   1014                      {
   1015                          flags |= LARGE; /* no break */
   1016                      }
   1017                      case 'x':
   1018                      {
   1019                          base = 16;
   1020                          break;
   1021                      }
   1022                      case 'd':
   1023                      case 'i':
   1024                      {
   1025                          flags |= SIGN; /* no break */
   1026                      }
   1027                      case 'u':
   1028                      {
   1029                          break;
   1030                      }
   1031          #ifndef NOFLOAT
   1032                      case 'E':
   1033                      case 'G':
   1034                      case 'e':
   1035                      case 'f':
   1036                      case 'g':
   1037                      {
   1038                          str = flt(str, va_arg(args, double), field_width, precision, *fmt, flags | SIGN);
   1039                          continue;
   1040                      }
   1041          #endif
   1042                      default:
   1043                      {
   1044                          if (*fmt != '%') *str++ = '%';
   1045                          if (*fmt)
   1046                          {
   1047                              *str++ = *fmt;
   1048                          }
   1049                          else
   1050                          {
   1051                              --fmt;
   1052                          }
   1053                          continue;
   1054                      }
   1055                  }  /* end of switch (*fmt) */
   1056          
   1057                  if (qualifier == 'l')
   1058                  {
   1059                      num = va_arg(args, unsigned long);
   1060                  }
   1061                  else if (qualifier == 'h')
   1062                  {
   1063                      if (flags & SIGN)
   1064                          num = va_arg(args, short);
   1065                      else
   1066                          num = va_arg(args, unsigned short);
   1067                  }
   1068                  else if (flags & SIGN)
   1069                  {
   1070                      num = va_arg(args, int);
   1071                  }
   1072                  else
   1073                  {
   1074                      num = va_arg(args, unsigned long);
   \                     ??my_vsprintf_1: (+1)
   \   0000000E   0x1D2D             ADDS     R5,R5,#+4
   \   00000010   0xF855 0x1C04      LDR      R1,[R5, #-4]
   1075                  }
   1076                  
   1077                  str = number(str, num, base, field_width, precision, flags);
   \                     ??my_vsprintf_2: (+1)
   \   00000014   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000018   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000001C   0x465B             MOV      R3,R11
   \   0000001E   0x463A             MOV      R2,R7
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       number
   \   00000026   0x4606             MOV      R6,R0
   \                     ??my_vsprintf_3: (+1)
   \   00000028   0x9804             LDR      R0,[SP, #+16]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x9004             STR      R0,[SP, #+16]
   \                     ??my_vsprintf_0: (+1)
   \   0000002E   0x9804             LDR      R0,[SP, #+16]
   \   00000030   0x7801             LDRB     R1,[R0, #+0]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xF000 0x816D      BEQ.W    ??my_vsprintf_4
   \   00000038   0x270A             MOVS     R7,#+10
   \   0000003A   0xF04F 0x0800      MOV      R8,#+0
   \   0000003E   0xF04F 0x3BFF      MOV      R11,#-1
   \   00000042   0x46D9             MOV      R9,R11
   \   00000044   0x46DA             MOV      R10,R11
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x2925             CMP      R1,#+37
   \   0000004A   0xF040 0x814D      BNE.W    ??my_vsprintf_5
   \   0000004E   0xE001             B.N      ??my_vsprintf_6
   \                     ??my_vsprintf_7: (+1)
   \   00000050   0xF048 0x0810      ORR      R8,R8,#0x10
   \                     ??my_vsprintf_6: (+1)
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD01C             BEQ.N    ??my_vsprintf_8
   \   00000058   0x9904             LDR      R1,[SP, #+16]
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \   0000005C   0x9104             STR      R1,[SP, #+16]
   \   0000005E   0x7809             LDRB     R1,[R1, #+0]
   \   00000060   0x2920             CMP      R1,#+32
   \   00000062   0xD00B             BEQ.N    ??my_vsprintf_9
   \   00000064   0x2923             CMP      R1,#+35
   \   00000066   0xD00C             BEQ.N    ??my_vsprintf_10
   \   00000068   0x292B             CMP      R1,#+43
   \   0000006A   0xD004             BEQ.N    ??my_vsprintf_11
   \   0000006C   0x292D             CMP      R1,#+45
   \   0000006E   0xD0EF             BEQ.N    ??my_vsprintf_7
   \   00000070   0x2930             CMP      R1,#+48
   \   00000072   0xD009             BEQ.N    ??my_vsprintf_12
   \   00000074   0xE00B             B.N      ??my_vsprintf_13
   \                     ??my_vsprintf_11: (+1)
   \   00000076   0xF048 0x0804      ORR      R8,R8,#0x4
   \   0000007A   0xE7EB             B.N      ??my_vsprintf_6
   \                     ??my_vsprintf_9: (+1)
   \   0000007C   0xF048 0x0808      ORR      R8,R8,#0x8
   \   00000080   0xE7E8             B.N      ??my_vsprintf_6
   \                     ??my_vsprintf_10: (+1)
   \   00000082   0xF048 0x0820      ORR      R8,R8,#0x20
   \   00000086   0xE7E5             B.N      ??my_vsprintf_6
   \                     ??my_vsprintf_12: (+1)
   \   00000088   0xF048 0x0801      ORR      R8,R8,#0x1
   \   0000008C   0xE7E2             B.N      ??my_vsprintf_6
   \                     ??my_vsprintf_13: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE7E0             B.N      ??my_vsprintf_6
   \                     ??my_vsprintf_8: (+1)
   \   00000092   0x9804             LDR      R0,[SP, #+16]
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   0000009A   0x290A             CMP      R1,#+10
   \   0000009C   0xD204             BCS.N    ??my_vsprintf_14
   \   0000009E   0xA804             ADD      R0,SP,#+16
   \   000000A0   0x.... 0x....      BL       skip_atoi
   \   000000A4   0x4683             MOV      R11,R0
   \   000000A6   0xE00E             B.N      ??my_vsprintf_15
   \                     ??my_vsprintf_14: (+1)
   \   000000A8   0x282A             CMP      R0,#+42
   \   000000AA   0xD10C             BNE.N    ??my_vsprintf_15
   \   000000AC   0x9804             LDR      R0,[SP, #+16]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x9004             STR      R0,[SP, #+16]
   \   000000B2   0x1D2D             ADDS     R5,R5,#+4
   \   000000B4   0xF855 0xBC04      LDR      R11,[R5, #-4]
   \   000000B8   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000BC   0xD503             BPL.N    ??my_vsprintf_15
   \   000000BE   0xF1CB 0x0B00      RSB      R11,R11,#+0
   \   000000C2   0xF048 0x0810      ORR      R8,R8,#0x10
   \                     ??my_vsprintf_15: (+1)
   \   000000C6   0x9804             LDR      R0,[SP, #+16]
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x282E             CMP      R0,#+46
   \   000000CC   0xD119             BNE.N    ??my_vsprintf_16
   \   000000CE   0x9804             LDR      R0,[SP, #+16]
   \   000000D0   0x1C40             ADDS     R0,R0,#+1
   \   000000D2   0x9004             STR      R0,[SP, #+16]
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   000000DA   0x290A             CMP      R1,#+10
   \   000000DC   0xD204             BCS.N    ??my_vsprintf_17
   \   000000DE   0xA804             ADD      R0,SP,#+16
   \   000000E0   0x.... 0x....      BL       skip_atoi
   \   000000E4   0x4682             MOV      R10,R0
   \   000000E6   0xE007             B.N      ??my_vsprintf_18
   \                     ??my_vsprintf_17: (+1)
   \   000000E8   0x282A             CMP      R0,#+42
   \   000000EA   0xD105             BNE.N    ??my_vsprintf_18
   \   000000EC   0x9804             LDR      R0,[SP, #+16]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x9004             STR      R0,[SP, #+16]
   \   000000F2   0x1D2D             ADDS     R5,R5,#+4
   \   000000F4   0xF855 0xAC04      LDR      R10,[R5, #-4]
   \                     ??my_vsprintf_18: (+1)
   \   000000F8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000FC   0xD501             BPL.N    ??my_vsprintf_16
   \   000000FE   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??my_vsprintf_16: (+1)
   \   00000102   0x9804             LDR      R0,[SP, #+16]
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x2868             CMP      R0,#+104
   \   00000108   0xD003             BEQ.N    ??my_vsprintf_19
   \   0000010A   0x286C             CMP      R0,#+108
   \   0000010C   0xD001             BEQ.N    ??my_vsprintf_19
   \   0000010E   0x284C             CMP      R0,#+76
   \   00000110   0xD103             BNE.N    ??my_vsprintf_20
   \                     ??my_vsprintf_19: (+1)
   \   00000112   0x4681             MOV      R9,R0
   \   00000114   0x9804             LDR      R0,[SP, #+16]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   \   00000118   0x9004             STR      R0,[SP, #+16]
   \                     ??my_vsprintf_20: (+1)
   \   0000011A   0x9804             LDR      R0,[SP, #+16]
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x4601             MOV      R1,R0
   \   00000120   0x2941             CMP      R1,#+65
   \   00000122   0xF000 0x8095      BEQ.W    ??my_vsprintf_21
   \   00000126   0x2945             CMP      R1,#+69
   \   00000128   0xF000 0x80C5      BEQ.W    ??my_vsprintf_22
   \   0000012C   0x2947             CMP      R1,#+71
   \   0000012E   0xF000 0x80C2      BEQ.W    ??my_vsprintf_22
   \   00000132   0x2958             CMP      R1,#+88
   \   00000134   0xF000 0x80B8      BEQ.W    ??my_vsprintf_23
   \   00000138   0x2961             CMP      R1,#+97
   \   0000013A   0xF000 0x808B      BEQ.W    ??my_vsprintf_24
   \   0000013E   0x2963             CMP      R1,#+99
   \   00000140   0xD01E             BEQ.N    ??my_vsprintf_25
   \   00000142   0x2964             CMP      R1,#+100
   \   00000144   0xF000 0x80B4      BEQ.W    ??my_vsprintf_26
   \   00000148   0x2965             CMP      R1,#+101
   \   0000014A   0xF000 0x80B4      BEQ.W    ??my_vsprintf_22
   \   0000014E   0x2966             CMP      R1,#+102
   \   00000150   0xF000 0x80B1      BEQ.W    ??my_vsprintf_22
   \   00000154   0x2967             CMP      R1,#+103
   \   00000156   0xF000 0x80AE      BEQ.W    ??my_vsprintf_22
   \   0000015A   0x2969             CMP      R1,#+105
   \   0000015C   0xF000 0x80A8      BEQ.W    ??my_vsprintf_26
   \   00000160   0x296E             CMP      R1,#+110
   \   00000162   0xD067             BEQ.N    ??my_vsprintf_27
   \   00000164   0x296F             CMP      R1,#+111
   \   00000166   0xF000 0x8090      BEQ.W    ??my_vsprintf_28
   \   0000016A   0x2970             CMP      R1,#+112
   \   0000016C   0xD04D             BEQ.N    ??my_vsprintf_29
   \   0000016E   0x2973             CMP      R1,#+115
   \   00000170   0xD021             BEQ.N    ??my_vsprintf_30
   \   00000172   0x2975             CMP      R1,#+117
   \   00000174   0xF000 0x808A      BEQ.W    ??my_vsprintf_31
   \   00000178   0x2978             CMP      R1,#+120
   \   0000017A   0xF000 0x8097      BEQ.W    ??my_vsprintf_32
   \   0000017E   0xE0AA             B.N      ??my_vsprintf_33
   \                     ??my_vsprintf_25: (+1)
   \   00000180   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \   00000184   0xD408             BMI.N    ??my_vsprintf_34
   \   00000186   0x2020             MOVS     R0,#+32
   \   00000188   0xE001             B.N      ??my_vsprintf_35
   \                     ??my_vsprintf_36: (+1)
   \   0000018A   0xF806 0x0B01      STRB     R0,[R6], #+1
   \                     ??my_vsprintf_35: (+1)
   \   0000018E   0xF1AB 0x0B01      SUB      R11,R11,#+1
   \   00000192   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000196   0xDAF8             BGE.N    ??my_vsprintf_36
   \                     ??my_vsprintf_34: (+1)
   \   00000198   0x1D2D             ADDS     R5,R5,#+4
   \   0000019A   0xF855 0x0C04      LDR      R0,[R5, #-4]
   \   0000019E   0xF806 0x0B01      STRB     R0,[R6], #+1
   \   000001A2   0x2020             MOVS     R0,#+32
   \                     ??my_vsprintf_37: (+1)
   \   000001A4   0xF1AB 0x0B01      SUB      R11,R11,#+1
   \   000001A8   0xF1BB 0x0F01      CMP      R11,#+1
   \   000001AC   0xF6FF 0xAF3C      BLT.W    ??my_vsprintf_3
   \   000001B0   0xF806 0x0B01      STRB     R0,[R6], #+1
   \   000001B4   0xE7F6             B.N      ??my_vsprintf_37
   \                     ??my_vsprintf_30: (+1)
   \   000001B6   0x1D2D             ADDS     R5,R5,#+4
   \   000001B8   0xF855 0x7C04      LDR      R7,[R5, #-4]
   \   000001BC   0x2F00             CMP      R7,#+0
   \   000001BE   0xD101             BNE.N    ??my_vsprintf_38
   \   000001C0   0x.... 0x....      ADR.W    R7,?_4
   \                     ??my_vsprintf_38: (+1)
   \   000001C4   0x4651             MOV      R1,R10
   \   000001C6   0x4638             MOV      R0,R7
   \   000001C8   0x.... 0x....      BL       my_strnlen
   \   000001CC   0xEA5F 0x61C8      LSLS     R1,R8,#+27
   \   000001D0   0xD408             BMI.N    ??my_vsprintf_39
   \   000001D2   0xE002             B.N      ??my_vsprintf_40
   \                     ??my_vsprintf_41: (+1)
   \   000001D4   0x2120             MOVS     R1,#+32
   \   000001D6   0xF806 0x1B01      STRB     R1,[R6], #+1
   \                     ??my_vsprintf_40: (+1)
   \   000001DA   0x4659             MOV      R1,R11
   \   000001DC   0xF1A1 0x0B01      SUB      R11,R1,#+1
   \   000001E0   0x4288             CMP      R0,R1
   \   000001E2   0xDBF7             BLT.N    ??my_vsprintf_41
   \                     ??my_vsprintf_39: (+1)
   \   000001E4   0x2100             MOVS     R1,#+0
   \   000001E6   0xE004             B.N      ??my_vsprintf_42
   \                     ??my_vsprintf_43: (+1)
   \   000001E8   0xF817 0x2B01      LDRB     R2,[R7], #+1
   \   000001EC   0xF806 0x2B01      STRB     R2,[R6], #+1
   \   000001F0   0x1C49             ADDS     R1,R1,#+1
   \                     ??my_vsprintf_42: (+1)
   \   000001F2   0x4281             CMP      R1,R0
   \   000001F4   0xDBF8             BLT.N    ??my_vsprintf_43
   \                     ??my_vsprintf_44: (+1)
   \   000001F6   0x4659             MOV      R1,R11
   \   000001F8   0xF1A1 0x0B01      SUB      R11,R1,#+1
   \   000001FC   0x4288             CMP      R0,R1
   \   000001FE   0xF6BF 0xAF13      BGE.W    ??my_vsprintf_3
   \   00000202   0x2120             MOVS     R1,#+32
   \   00000204   0xF806 0x1B01      STRB     R1,[R6], #+1
   \   00000208   0xE7F5             B.N      ??my_vsprintf_44
   \                     ??my_vsprintf_29: (+1)
   \   0000020A   0xF11B 0x0F01      CMN      R11,#+1
   \   0000020E   0xD103             BNE.N    ??my_vsprintf_45
   \   00000210   0xF04F 0x0B08      MOV      R11,#+8
   \   00000214   0xF048 0x0801      ORR      R8,R8,#0x1
   \                     ??my_vsprintf_45: (+1)
   \   00000218   0x1D2D             ADDS     R5,R5,#+4
   \   0000021A   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   0000021E   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000222   0x465B             MOV      R3,R11
   \   00000224   0x2210             MOVS     R2,#+16
   \   00000226   0xF855 0x1C04      LDR      R1,[R5, #-4]
   \   0000022A   0x4630             MOV      R0,R6
   \   0000022C   0x.... 0x....      BL       number
   \   00000230   0x4606             MOV      R6,R0
   \   00000232   0xE6F9             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_27: (+1)
   \   00000234   0x1B30             SUBS     R0,R6,R4
   \   00000236   0xF1B9 0x0F6C      CMP      R9,#+108
   \   0000023A   0xD104             BNE.N    ??my_vsprintf_46
   \   0000023C   0x1D2D             ADDS     R5,R5,#+4
   \   0000023E   0xF855 0x1C04      LDR      R1,[R5, #-4]
   \   00000242   0x6008             STR      R0,[R1, #+0]
   \   00000244   0xE6F0             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_46: (+1)
   \   00000246   0x1D2D             ADDS     R5,R5,#+4
   \   00000248   0xF855 0x1C04      LDR      R1,[R5, #-4]
   \   0000024C   0x6008             STR      R0,[R1, #+0]
   \   0000024E   0xE6EB             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_21: (+1)
   \   00000250   0xF048 0x0840      ORR      R8,R8,#0x40
   \                     ??my_vsprintf_24: (+1)
   \   00000254   0xF1B9 0x0F6C      CMP      R9,#+108
   \   00000258   0xD10B             BNE.N    ??my_vsprintf_47
   \   0000025A   0x1D2D             ADDS     R5,R5,#+4
   \   0000025C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000260   0x4653             MOV      R3,R10
   \   00000262   0x465A             MOV      R2,R11
   \   00000264   0xF855 0x1C04      LDR      R1,[R5, #-4]
   \   00000268   0x4630             MOV      R0,R6
   \   0000026A   0x.... 0x....      BL       eaddr
   \   0000026E   0x4606             MOV      R6,R0
   \   00000270   0xE6DA             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_47: (+1)
   \   00000272   0x1D2D             ADDS     R5,R5,#+4
   \   00000274   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000278   0x4653             MOV      R3,R10
   \   0000027A   0x465A             MOV      R2,R11
   \   0000027C   0xF855 0x1C04      LDR      R1,[R5, #-4]
   \   00000280   0x4630             MOV      R0,R6
   \   00000282   0x.... 0x....      BL       iaddr
   \   00000286   0x4606             MOV      R6,R0
   \   00000288   0xE6CE             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_28: (+1)
   \   0000028A   0x2708             MOVS     R7,#+8
   \                     ??my_vsprintf_31: (+1)
   \   0000028C   0xF1B9 0x0F6C      CMP      R9,#+108
   \   00000290   0xF43F 0xAEBD      BEQ.W    ??my_vsprintf_1
   \   00000294   0xF1B9 0x0F68      CMP      R9,#+104
   \   00000298   0xD133             BNE.N    ??my_vsprintf_48
   \   0000029A   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   0000029E   0xD52C             BPL.N    ??my_vsprintf_49
   \   000002A0   0x1D2D             ADDS     R5,R5,#+4
   \   000002A2   0xF935 0x1C04      LDRSH    R1,[R5, #-4]
   \   000002A6   0xE6B5             B.N      ??my_vsprintf_2
   \                     ??my_vsprintf_23: (+1)
   \   000002A8   0xF048 0x0840      ORR      R8,R8,#0x40
   \                     ??my_vsprintf_32: (+1)
   \   000002AC   0x2710             MOVS     R7,#+16
   \   000002AE   0xE7ED             B.N      ??my_vsprintf_31
   \                     ??my_vsprintf_26: (+1)
   \   000002B0   0xF048 0x0802      ORR      R8,R8,#0x2
   \   000002B4   0xE7EA             B.N      ??my_vsprintf_31
   \                     ??my_vsprintf_22: (+1)
   \   000002B6   0x3508             ADDS     R5,R5,#+8
   \   000002B8   0xF048 0x0102      ORR      R1,R8,#0x2
   \   000002BC   0x9103             STR      R1,[SP, #+12]
   \   000002BE   0x9002             STR      R0,[SP, #+8]
   \   000002C0   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   000002C4   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \   000002C8   0xE955 0x2302      LDRD     R2,R3,[R5, #-8]
   \   000002CC   0x4630             MOV      R0,R6
   \   000002CE   0x.... 0x....      BL       flt
   \   000002D2   0x4606             MOV      R6,R0
   \   000002D4   0xE6A8             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_33: (+1)
   \   000002D6   0x2825             CMP      R0,#+37
   \   000002D8   0xD002             BEQ.N    ??my_vsprintf_50
   \   000002DA   0x2025             MOVS     R0,#+37
   \   000002DC   0xF806 0x0B01      STRB     R0,[R6], #+1
   \                     ??my_vsprintf_50: (+1)
   \   000002E0   0x9804             LDR      R0,[SP, #+16]
   \   000002E2   0x7800             LDRB     R0,[R0, #+0]
   \   000002E4   0x2800             CMP      R0,#+0
   \   000002E6   0xD004             BEQ.N    ??my_vsprintf_51
   \                     ??my_vsprintf_5: (+1)
   \   000002E8   0x9804             LDR      R0,[SP, #+16]
   \   000002EA   0x7800             LDRB     R0,[R0, #+0]
   \   000002EC   0xF806 0x0B01      STRB     R0,[R6], #+1
   \   000002F0   0xE69A             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_51: (+1)
   \   000002F2   0x9804             LDR      R0,[SP, #+16]
   \   000002F4   0x1E40             SUBS     R0,R0,#+1
   \   000002F6   0x9004             STR      R0,[SP, #+16]
   \   000002F8   0xE696             B.N      ??my_vsprintf_3
   \                     ??my_vsprintf_49: (+1)
   \   000002FA   0x1D2D             ADDS     R5,R5,#+4
   \   000002FC   0xF835 0x1C04      LDRH     R1,[R5, #-4]
   \   00000300   0xE688             B.N      ??my_vsprintf_2
   \                     ??my_vsprintf_48: (+1)
   \   00000302   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   00000306   0xF57F 0xAE82      BPL.W    ??my_vsprintf_1
   \   0000030A   0x1D2D             ADDS     R5,R5,#+4
   \   0000030C   0xF855 0x1C04      LDR      R1,[R5, #-4]
   \   00000310   0xE680             B.N      ??my_vsprintf_2
   1078              } /* end of for (str = buf; *fmt; fmt++) */
   1079          
   1080              *str = '\0';
   \                     ??my_vsprintf_4: (+1)
   \   00000312   0x2000             MOVS     R0,#+0
   \   00000314   0x7030             STRB     R0,[R6, #+0]
   1081              return str - buf;
   \   00000316   0x1B30             SUBS     R0,R6,R4
   \   00000318   0xB005             ADD      SP,SP,#+20
   \   0000031A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1082          }
   1083          

   \                                 In section .text, align 2, keep-with-next
   1084          int usprintf(char *buf, const char *fmt, ...)
   1085          {
   \                     usprintf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   1086              va_list args;
   1087              int n;
   1088          
   1089              va_start(args, fmt);
   1090              n = vsprintf(buf, fmt, args);
   1091              va_end(args);
   1092          
   1093              return n;
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x.... 0x....      BL       my_vsprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   1094          }
   1095          
   1096          extern void WIN_DispMsg     (const char *msg);
   1097          extern void UARTPutString   (MODBUS_CH  *pch, const char *printfbuf);
   1098          

   \                                 In section .text, align 2, keep-with-next
   1099          void uprintf(const char *fmt, ...)
   1100          {
   \                     uprintf: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xB099             SUB      SP,SP,#+100
   1101              char printfbuf[100];
   1102              
   1103              va_list args;
   1104              va_start(args, fmt);
   1105              vsprintf(printfbuf, fmt, args);
   \   00000006   0xAA1B             ADD      R2,SP,#+108
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       my_vsprintf
   1106              va_end(args);
   1107              printfbuf[99] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0063      STRB     R0,[SP, #+99]
   1108              WIN_DispMsg((const char *)printfbuf);
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       WIN_DispMsg
   1109          }
   \   0000001C   0xB019             ADD      SP,SP,#+100
   \   0000001E   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
   1110          

   \                                 In section .text, align 2, keep-with-next
   1111          void uartprintf(MODBUS_CH  *pch,const char *fmt, ...)
   1112          {
   \                     uartprintf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0xB0B3             SUB      SP,SP,#+204
   \   00000006   0x4604             MOV      R4,R0
   1113              char printfbuf[200];
   1114              
   1115              va_list args;
   1116              va_start(args, fmt);
   1117              vsprintf(printfbuf, fmt, args);
   \   00000008   0xAA36             ADD      R2,SP,#+216
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       my_vsprintf
   1118              va_end(args);
   1119              printfbuf[199] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x00C7      STRB     R0,[SP, #+199]
   1120              UARTPutString(pch, (const char *)printfbuf);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       UARTPutString
   1121          }
   \   0000001E   0xB033             ADD      SP,SP,#+204
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x49 0x6E          DC8      "Inf"
   \              0x66 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x4E 0x61          DC8      "NaN"
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     digits

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x2C40C60E         DC32     0x2c40c60e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x0031FA18         DC32     0x31fa18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x2C40C60D         DC32     0x2c40c60d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x8031FA18         DC32     0x8031fa18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x40240000         DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x3FB99999         DC32     0x3fb99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x40140000         DC32     0x40140000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x........         DC32     ??INFINITY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x........         DC32     ??INFINITY_1

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x30 0x31          DC8 "0123456789abcdefghijklmnopqrstuvwxyz"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x67 0x68    
   \              0x69 0x6A    
   \              0x6B 0x6C    
   \              0x6D 0x6E    
   \              0x6F 0x70    
   \              0x71 0x72    
   \              0x73 0x74    
   \              0x75 0x76    
   \              0x77 0x78    
   \              0x79 0x7A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x30 0x31          DC8 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x47 0x48    
   \              0x49 0x4A    
   \              0x4B 0x4C    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \              0x51 0x52    
   \              0x53 0x54    
   \              0x55 0x56    
   \              0x57 0x58    
   \              0x59 0x5A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x3C 0x4E          DC8 "<NULL>"
   \              0x55 0x4C    
   \              0x4C 0x3E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x49 0x6E          DC8 "Inf"
   \              0x66 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x4E 0x61          DC8 "NaN"
   \              0x4E 0x00    
   1122          /* ///////////////////////////////////////////////////////////////////////////// */
   1123          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   __ecvround
     128   cfltcvt
       128   -> __aeabi_memcpy
       128   -> ecvtbuf
       128   -> fcvtbuf
       128 __aeabi_cdcmple
       128 __aeabi_cdrcmple
       0   cropzeros
      44   eaddr
      56   ecvtbuf
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset4
        56   -> __ecvround
        56   -> ftoaE
        56   -> my_atoi
        56   -> strcmp
        56   -> strncmp
      56   fcvtbuf
        56   -> __aeabi_memcpy
        56   -> __ecvround
        56   -> ecvtbuf
        56   -> my_ftoa
        56   -> strchr
        56   -> strlen
        56   -> strncmp
        56 __aeabi_cdcmple
        56 __aeabi_cdrcmple
     120   flt
       120   -> cfltcvt
       120   -> cropzeros
       120   -> forcdecpt
       120   -> strlen
       120 __aeabi_cdcmple
       8   forcdecpt
         8   -> strlen
      40   ftoaE
        40   -> __aeabi_d2iz
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_dsub
        40   -> __aeabi_i2d
        40   -> itoa
        40 __aeabi_cdcmple
        40 __aeabi_cdrcmple
      44   iaddr
       0   is_space
       8   itoa
       8   my_atoi
         8   -> is_space
      40   my_ftoa
        40   -> __aeabi_d2iz
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_dsub
        40   -> __aeabi_i2d
        40   -> itoa
        40   -> strlen
        40 __aeabi_cdcmple
        40 __aeabi_cdrcmple
       0   my_strnlen
      56   my_vsprintf
        56   -> eaddr
        56   -> flt
        56   -> iaddr
        56   -> my_strnlen
        56   -> number
        56   -> skip_atoi
      96   number
       0   skip_atoi
       0   strchr
         0   -> __iar_Strchr
     224   uartprintf
       224   -> UARTPutString
       224   -> my_vsprintf
     120   uprintf
       120   -> WIN_DispMsg
       120   -> my_vsprintf
      16   usprintf
        16   -> my_vsprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      40  ?_0
      40  ?_1
       4  ?_2
       4  ?_3
       8  ?_4
      12  INFINITY
      12  INFINITY
      68  __ecvround
     458  cfltcvt
      74  cropzeros
       8  digits
          upper_digits
     136  eaddr
     302  ecvtbuf
     268  fcvtbuf
     256  flt
      68  forcdecpt
     392  ftoaE
     220  iaddr
      20  is_space
      82  itoa
      72  my_atoi
     292  my_ftoa
      24  my_strnlen
     798  my_vsprintf
     312  number
      34  skip_atoi
       4  strchr
      38  uartprintf
      34  uprintf
      14  usprintf

 
    32 bytes in section .data
    88 bytes in section .rodata
 4 034 bytes in section .text
 
 4 030 bytes of CODE  memory (+ 4 bytes shared)
    88 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: none
