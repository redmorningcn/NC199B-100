###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  19:32:51
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Source\MBM_CORE.C
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Source\MBM_CORE.C -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\MBM_CORE.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\MBM_CORE.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Source\MBM_CORE.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                     uC/MODBUS SLAVE COMMAND PROCESSOR
     19          *
     20          * Filename      : mbm_core.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                             INCLUDE FILES
     31          *********************************************************************************************************
     32          */
     33          
     34          #define  MBM_MODULE
     35          #include <includes.h>
     36          #include <global.h>
     37          #include <aes.h>
     38          
     39          //#include <diagcounter.h>
     40          /*
     41          *********************************************************************************************************
     42          *                                                MACROS
     43          *********************************************************************************************************
     44          */
     45          #define  MBM_FCXX_ADDR          (pch->RxFrameData[0])
     46          #define  MBM_FCXX_CODE          (pch->RxFrameData[1])
     47          #define  MBM_TX_FCXX_ADDR       (pch->TxFrameData[0])
     48          #define  MBM_TX_FCXX_CODE       (pch->TxFrameData[1])
     49          #define  MBM_RX_FCXX_ADDR       (pch->RxFrameData[0])
     50          #define  MBM_RX_FCXX_CODE       (pch->RxFrameData[1])
     51          
     52          /***********************************************
     53          * 描述：接收帧数据格式，代码：MODBUS_FC01_COIL_RD
     54          */
     55          #define  MBM_RX_FC01_DATA_COIL      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     56          #define  MBM_RX_FC01_DATA_COIL_H     (pch->RxFrameData[4])
     57          #define  MBM_RX_FC01_DATA_COIL_L     (pch->RxFrameData[5])
     58          #define  MBM_TX_FC01_DATA_COIL      (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
     59          #define  MBM_TX_FC01_DATA_COIL_H     (pch->TxFrameData[4])
     60          #define  MBM_TX_FC01_DATA_COIL_L     (pch->TxFrameData[5])
     61          #define  MBM_RX_FC01_DATA(i)         (pch->RxFrameData[3 + i])
     62          #define  MBM_RX_FC01_NBYTE           (pch->RxFrameData[2])
     63          
     64          /***********************************************
     65          * 描述：接收帧数据格式，代码：MODBUS_FC02_DI_RD
     66          */
     67          /***********************************************
     68          * 描述：接收帧数据格式，代码：MODBUS_FC03_HOLDING_REG_RD
     69          */
     70          #define  MBM_TX_FC03_REG      (((CPU_INT16U)pch->TxFrameData[2] << 8) + (CPU_INT16U)pch->TxFrameData[3])
     71          #define  MBM_TX_FC03_REG_H      (pch->TxFrameData[2])
     72          #define  MBM_TX_FC03_REG_L      (pch->RxFrameData[3])
     73          #define  MBM_TX_FC03_NREG     (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
     74          #define  MBM_TX_FC03_NREG_H     (pch->TxFrameData[4])
     75          #define  MBM_TX_FC03_NREG_L     (pch->TxFrameData[5])
     76          #define  MBM_TX_FC03_CRC      (((CPU_INT16U)pch->TxFrameData[6] << 8) + (CPU_INT16U)pch->TxFrameData[7])
     77          #define  MBM_TX_FC03_CRC_H      (pch->TxFrameData[6])
     78          #define  MBM_TX_FC03_CRC_L      (pch->TxFrameData[7])
     79          
     80          
     81          #define  MBM_RX_FC03_NBYTE      (pch->RxFrameData[2])
     82          #define  MBM_RX_FC03_DATA(i)  (((CPU_INT16U)pch->RxFrameData[3 + i * 2] << 8) + (CPU_INT16U)pch->RxFrameData[4 + i * 2])
     83          #define  MBM_RX_FC03_DATA_H(i)  (pch->RxFrameData[3 + i * 2])
     84          #define  MBM_RX_FC03_DATA_L(i)  (pch->RxFrameData[4 + i * 2])
     85          
     86          #define  MBM_RX_FC03_IDX_NBYTE  2
     87          #define  MBM_RX_FC03_IDX_DATA   3
     88          #define  MBM_RX_FC03_IDX_DATA_H 3
     89          #define  MBM_RX_FC03_IDX_DATA_L 4
     90          
     91          /***********************************************
     92          * 描述：接收帧数据格式，代码：MODBUS_FC04_IN_REG_RD
     93          */
     94          /***********************************************
     95          * 描述：接收帧数据格式，代码：MODBUS_FC05_COIL_WR
     96          */
     97          #define  MBM_RX_FC05_COIL         (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
     98          #define  MBM_RX_FC05_COIL_H         (pch->RxFrameData[2])
     99          #define  MBM_RX_FC05_COIL_L         (pch->RxFrameData[3])
    100          #define  MBM_RX_FC05_COIL_DATA    (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    101          #define  MBM_RX_FC05_COIL_DATA_H    (pch->RxFrameData[4])
    102          #define  MBM_RX_FC05_COIL_DATA_L    (pch->RxFrameData[5])
    103          #define  MBM_RX_FC05_COIL_CRC     (((CPU_INT16U)pch->RxFrameData[6] << 8) + (CPU_INT16U)pch->RxFrameData[7])
    104          #define  MBM_RX_FC05_COIL_CRC_H     (pch->RxFrameData[6])
    105          #define  MBM_RX_FC05_COIL_CRC_L     (pch->RxFrameData[7])
    106          /***********************************************
    107          * 描述：接收帧数据格式，代码：MODBUS_FC06_HOLDING_REG_WR
    108          */
    109          #define  MBM_TX_FC06_REG      (((CPU_INT16U)pch->TxFrameData[2] << 8) + (CPU_INT16U)pch->TxFrameData[3])
    110          #define  MBM_TX_FC06_REG_H      (pch->TxFrameData[2])
    111          #define  MBM_TX_FC06_REG_L      (pch->RxFrameData[3])
    112          #define  MBM_TX_FC06_DATA     (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
    113          #define  MBM_TX_FC06_DATA_H     (pch->TxFrameData[4])
    114          #define  MBM_TX_FC06_DATA_L     (pch->TxFrameData[5])
    115          #define  MBM_TX_FC06_CRC      (((CPU_INT16U)pch->TxFrameData[6] << 8) + (CPU_INT16U)pch->TxFrameData[7])
    116          #define  MBM_TX_FC06_CRC_H      (pch->TxFrameData[6])
    117          #define  MBM_TX_FC06_CRC_L      (pch->TxFrameData[7])
    118          
    119          #define  MBM_RX_FC06_REG      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    120          #define  MBM_RX_FC06_REG_H      (pch->RxFrameData[2])
    121          #define  MBM_RX_FC06_REG_L      (pch->RxFrameData[3])
    122          #define  MBM_RX_FC06_DATA     (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    123          #define  MBM_RX_FC06_DATA_H     (pch->RxFrameData[4])
    124          #define  MBM_RX_FC06_DATA_L     (pch->RxFrameData[5])
    125          #define  MBM_RX_FC06_CRC      (((CPU_INT16U)pch->RxFrameData[6] << 8) + (CPU_INT16U)pch->RxFrameData[7])
    126          #define  MBM_RX_FC06_CRC_H      (pch->RxFrameData[6])
    127          #define  MBM_RX_FC06_CRC_L      (pch->RxFrameData[7])
    128          
    129          /***********************************************
    130          * 描述：接收帧数据格式，代码：MODBUS_FC08_LOOPBACK
    131          */
    132          /***********************************************
    133          * 描述：接收帧数据格式，代码：MODBUS_FC15_COIL_WR_MULTIPLE
    134          */
    135          #define  MBM_RX_FC15_COIL      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    136          #define  MBM_RX_FC15_COIL_H      (pch->RxFrameData[2])
    137          #define  MBM_RX_FC15_COIL_L      (pch->RxFrameData[3])
    138          #define  MBM_RX_FC15_COIL_DATA (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    139          #define  MBM_RX_FC15_COIL_DATA_H (pch->RxFrameData[4])
    140          #define  MBM_RX_FC15_COIL_DATA_L (pch->RxFrameData[5])
    141          #define  MBM_RX_FC15_COIL_BYTES  (pch->RxFrameData[6])
    142          
    143          /***********************************************
    144          * 描述：接收帧数据格式，代码：MODBUS_FC16_HOLDING_REG_WR_MULTIPLE
    145          */
    146          #define  MBM_TX_FC16_REG      (((CPU_INT16U)pch->TxFrameData[2] << 8) + (CPU_INT16U)pch->TxFrameData[3])
    147          #define  MBM_TX_FC16_REG_H      (pch->TxFrameData[2])
    148          #define  MBM_TX_FC16_REG_L      (pch->RxFrameData[3])
    149          #define  MBM_TX_FC16_NREG     (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
    150          #define  MBM_TX_FC16_NREG_H     (pch->TxFrameData[4])
    151          #define  MBM_TX_FC16_NREG_L     (pch->TxFrameData[5])
    152          #define  MBM_TX_FC16_NBYTE      (pch->TxFrameData[6])
    153          #define  MBM_TX_FC16_DATA_IDX   7
    154          
    155          #define  MBM_TX_FC16_DATA(i)  (((CPU_INT16U)pch->TxFrameData[7 + i * 2] << 8) + (CPU_INT16U)pch->TxFrameData[8 + i * 2])
    156          #define  MBM_TX_FC16_DATA_H(i)  (pch->TxFrameData[7 + i * 2])
    157          #define  MBM_TX_FC16_DATA_L(i)  (pch->TxFrameData[8 + i * 2])
    158          
    159          #define  MBM_RX_FC16_REG      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    160          #define  MBM_RX_FC16_REG_H      (pch->RxFrameData[2])
    161          #define  MBM_RX_FC16_REG_L      (pch->RxFrameData[3])
    162          #define  MBM_RX_FC16_NREG     (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    163          #define  MBM_RX_FC16_NREG_H     (pch->RxFrameData[4])
    164          #define  MBM_RX_FC16_NREG_L     (pch->RxFrameData[5])
    165          #define  MBM_RX_FC16_CRC      (((CPU_INT16U)pch->RxFrameData[6] << 8) + (CPU_INT16U)pch->RxFrameData[7])
    166          #define  MBM_RX_FC16_CRC_H      (pch->RxFrameData[6])
    167          #define  MBM_RX_FC16_CRC_L      (pch->RxFrameData[7])
    168          
    169          /***********************************************
    170          * 描述：接收帧数据格式，代码：MODBUS_FC20_FILE_RD
    171          */
    172          /***********************************************
    173          * 描述：接收帧数据格式，代码：MODBUS_FC21_FILE_WR
    174          */
    175          
    176          
    177          #define  MBM_TX_FRAME_DATA      (pch->TxFrameData[2])
    178          
    179          #define  MBM_RX_DATA_START     (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    180          #define  MBM_RX_DATA_START_H    (pch->RxFrameData[2])
    181          #define  MBM_RX_DATA_START_L    (pch->RxFrameData[3])
    182          
    183          #define  MBM_RX_DATA_POINTS    (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    184          #define  MBM_RX_DATA_POINTS_H   (pch->RxFrameData[4])
    185          #define  MBM_RX_DATA_POINTS_L   (pch->RxFrameData[5])
    186          
    187          #define  MBM_RX_DATA_COIL      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    188          #define  MBM_RX_DATA_COIL_H     (pch->RxFrameData[4])
    189          #define  MBM_RX_DATA_COIL_L     (pch->RxFrameData[5])
    190          
    191          #define  MBM_RX_DATA_REG       (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    192          #define  MBM_RX_DATA_REG_H      (pch->RxFrameData[4])
    193          #define  MBM_RX_DATA_REG_L      (pch->RxFrameData[5])
    194          
    195          #define  MBM_RX_DIAG_CODE      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    196          #define  MBM_RX_DIAG_CODE_H     (pch->RxFrameData[2])
    197          #define  MBM_RX_DIAG_CODE_L     (pch->RxFrameData[3])
    198          #define  MBM_RX_DIAG_DATA      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    199          #define  MBM_RX_DIAG_DATA_H     (pch->RxFrameData[4])
    200          #define  MBM_RX_DIAG_DATA_L     (pch->RxFrameData[5])
    201          
    202          #define  MBM_RX_FRAME          (&pch->RxFrame)
    203          #define  MBM_RX_FRAME_ADDR      (pch->RxFrameData[0])
    204          #define  MBM_RX_FRAME_FC        (pch->RxFrameData[1])
    205          #define  MBM_RX_FRAME_DATA      (pch->RxFrameData[2])
    206          #define  MBM_RX_FRAME_NBYTES    (pch->RxFrameNDataBytes)
    207          
    208          
    209          #define  MBM_TX_DATA_START_H    (pch->TxFrameData[2])
    210          #define  MBM_TX_DATA_START_L    (pch->TxFrameData[3])
    211          
    212          #define  MBM_TX_DATA_POINTS_H   (pch->TxFrameData[4])
    213          #define  MBM_TX_DATA_POINTS_L   (pch->TxFrameData[5])
    214          
    215          #define  MBM_TX_DATA_COIL_H     (pch->TxFrameData[4])
    216          #define  MBM_TX_DATA_COIL_L     (pch->TxFrameData[5])
    217          
    218          #define  MBM_TX_DATA_REG_H      (pch->TxFrameData[4])
    219          #define  MBM_TX_DATA_REG_L      (pch->TxFrameData[5])
    220          
    221          #define  MBM_TX_DIAG_CODE_H     (pch->TxFrameData[2])
    222          #define  MBM_TX_DIAG_CODE_L     (pch->TxFrameData[3])
    223          #define  MBM_TX_DIAG_DATA_H     (pch->TxFrameData[4])
    224          #define  MBM_TX_DIAG_DATA_L     (pch->TxFrameData[5])
    225          
    226          
    227          #define  MBM_TX_FRAME          (&pch->TxFrame)
    228          #define  MBM_TX_FRAME_ADDR      (pch->TxFrameData[0])
    229          #define  MBM_TX_FRAME_FC        (pch->TxFrameData[1])
    230          #define  MBM_TX_FRAME_DATA      (pch->TxFrameData[2])
    231          #define  MBM_TX_FRAME_NBYTES    (pch->TxFrameNDataBytes)
    232          
    233          //SE Added defines from this point forward
    234          #define  MBM_FC100_DATA_BYTES    (5u)
    235          
    236          /*$PAGE*/
    237          /*
    238          *********************************************************************************************************
    239          *                                    LOCAL FUNCTION PROTOTYPES
    240          *********************************************************************************************************
    241          */
    242          
    243          /*$PAGE*/
    244          /*
    245          *********************************************************************************************************
    246          *                                           MBM_FCxx_Handler()
    247          *
    248          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    249          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    250          *               will generate an Illegal Function Exception Response code (01).
    251          *
    252          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    253          *
    254          * Return(s)   : none.
    255          *
    256          * Caller(s)   : MBM_ASCII_Task()
    257          *               MBM_RTU_Task
    258          *
    259          * Note(s)     : none.
    260          *********************************************************************************************************
    261          */
    262          
    263          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    264          CPU_BOOLEAN  MBM_FCxx_Handler (MODBUS_CH  *pch)
    265          {
   \                     MBM_FCxx_Handler: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    266              CPU_BOOLEAN   send_reply;
    267          
    268              if (MBM_RX_FRAME_ADDR == pch->NodeAddr) {
   \   00000002   0x1C42             ADDS     R2,R0,#+1
   \   00000004   0xF500 0x7311      ADD      R3,R0,#+580
   \   00000008   0x781C             LDRB     R4,[R3, #+0]
   \   0000000A   0x79D5             LDRB     R5,[R2, #+7]
   \   0000000C   0x42AC             CMP      R4,R5
   \   0000000E   0xD12E             BNE.N    ??MBM_FCxx_Handler_0
    269          
    270                  switch (MBM_RX_FRAME_FC) {
   \   00000010   0x785B             LDRB     R3,[R3, #+1]
   \   00000012   0x2B01             CMP      R3,#+1
   \   00000014   0xD02B             BEQ.N    ??MBM_FCxx_Handler_0
   \   00000016   0x2B03             CMP      R3,#+3
   \   00000018   0xD029             BEQ.N    ??MBM_FCxx_Handler_0
   \   0000001A   0x2B05             CMP      R3,#+5
   \   0000001C   0xD00C             BEQ.N    ??MBM_FCxx_Handler_1
   \   0000001E   0x2B06             CMP      R3,#+6
   \   00000020   0xD00F             BEQ.N    ??MBM_FCxx_Handler_2
   \   00000022   0x2B08             CMP      R3,#+8
   \   00000024   0xD023             BEQ.N    ??MBM_FCxx_Handler_0
   \   00000026   0x2B0F             CMP      R3,#+15
   \   00000028   0xD010             BEQ.N    ??MBM_FCxx_Handler_3
   \   0000002A   0x2B10             CMP      R3,#+16
   \   0000002C   0xD013             BEQ.N    ??MBM_FCxx_Handler_4
   \   0000002E   0x2B14             CMP      R3,#+20
   \   00000030   0xD01D             BEQ.N    ??MBM_FCxx_Handler_0
   \   00000032   0x2B15             CMP      R3,#+21
   \   00000034   0xD014             BEQ.N    ??MBM_FCxx_Handler_5
   \   00000036   0xE018             B.N      ??MBM_FCxx_Handler_6
    271          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)
    272                      case MODBUS_FC01_COIL_RD:
    273                           break;
    274          #endif
    275          
    276          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    277                      case MODBUS_FC02_DI_RD:
    278                           break;
    279          #endif
    280          
    281          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    282                      case MODBUS_FC03_HOLDING_REG_RD:
    283                           break;
    284          #endif
    285          
    286          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    287                      case MODBUS_FC04_IN_REG_RD:
    288                           break;
    289          #endif
    290          
    291          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED)
    292                      case MODBUS_FC05_COIL_WR:
    293                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_1: (+1)
   \   00000038   0x7810             LDRB     R0,[R2, #+0]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD017             BEQ.N    ??MBM_FCxx_Handler_0
    294                           } else {
    295                               send_reply  = DEF_FALSE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xE015             B.N      ??MBM_FCxx_Handler_0
    296                           }
    297                           break;
    298          #endif
    299          
    300          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED)
    301                      case MODBUS_FC06_HOLDING_REG_WR:
    302                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_2: (+1)
   \   00000042   0x7810             LDRB     R0,[R2, #+0]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD012             BEQ.N    ??MBM_FCxx_Handler_0
    303                           } else {
    304                               send_reply  = DEF_FALSE;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xE010             B.N      ??MBM_FCxx_Handler_0
    305                           }
    306                           break;
    307          #endif
    308          
    309          #if (MODBUS_CFG_FC08_EN == DEF_ENABLED)
    310                      case MODBUS_FC08_LOOPBACK:
    311                           break;
    312          #endif
    313          
    314          #if (MODBUS_CFG_FC15_EN == DEF_ENABLED)
    315                      case MODBUS_FC15_COIL_WR_MULTIPLE:
    316                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_3: (+1)
   \   0000004C   0x7810             LDRB     R0,[R2, #+0]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD00D             BEQ.N    ??MBM_FCxx_Handler_0
    317                           } else {
    318                               send_reply  = DEF_FALSE;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xE00B             B.N      ??MBM_FCxx_Handler_0
    319                           }
    320                           break;
    321          #endif
    322          
    323          #if (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    324                      case MODBUS_FC16_HOLDING_REG_WR_MULTIPLE:
    325                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_4: (+1)
   \   00000056   0x7810             LDRB     R0,[R2, #+0]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD008             BEQ.N    ??MBM_FCxx_Handler_0
    326                           } else {
    327                               send_reply  = DEF_FALSE;
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0xE006             B.N      ??MBM_FCxx_Handler_0
    328                           }
    329                           break;
    330          #endif
    331          
    332          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)
    333                      case MODBUS_FC20_FILE_RD:
    334                           break;
    335          #endif
    336          
    337          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)
    338                      case MODBUS_FC21_FILE_WR:
    339                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_5: (+1)
   \   00000060   0x7810             LDRB     R0,[R2, #+0]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD003             BEQ.N    ??MBM_FCxx_Handler_0
    340                           } else {
    341                               send_reply = DEF_FALSE;
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0xE001             B.N      ??MBM_FCxx_Handler_0
    342                           }
    343                           break;
    344          #endif
    345          
    346          #if MODBUS_FC43_EN > 0 // Read Device ID
    347                     case MODBUS_FC43_READ_DEV_ID:
    348                      break;
    349          #endif
    350          
    351          #if MODBUS_FC100_EN > 0 // Scattered Read
    352                      case MODBUS_FC100_SCATTERED_READ:
    353                      break;
    354          #endif
    355          
    356                      default:
    357                           pch->Err   = MODBUS_ERR_ILLEGAL_FC;
   \                     ??MBM_FCxx_Handler_6: (+1)
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x82C1             STRH     R1,[R0, #+22]
    358                           send_reply = DEF_TRUE;
    359                           break;
    360                  }
    361              } else {
    362              }
    363          
    364              return (send_reply);
   \                     ??MBM_FCxx_Handler_0: (+1)
   \   0000006E   0x4608             MOV      R0,R1
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0xBC30             POP      {R4,R5}
   \   00000074   0x4770             BX       LR               ;; return
    365          }
    366          #endif
    367          /*$PAGE*/
    368          /*
    369          *********************************************************************************************************
    370          *                                           MBM_TxCmd()
    371          *
    372          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    373          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    374          *               will generate an Illegal Function Exception Response code (01).
    375          *
    376          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    377          *
    378          * Return(s)   : none.
    379          *
    380          * Caller(s)   : MBM_FCxx_xx()
    381          *
    382          * Note(s)     : none.
    383          *********************************************************************************************************
    384          */
    385          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    386          void MBM_TxCmd(MODBUS_CH *pch)
    387          {
    388          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    389              MB_RTU_Tx (pch);
   \                     MBM_TxCmd: (+1)
   \   00000000   0x.... 0x....      B.W      MB_RTU_Tx
    390          #endif
    391          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    392              MB_ASCII_Tx(pch);
    393          #endif
    394          }
    395          #endif
    396          
    397          /*$PAGE*/
    398          /*
    399          *********************************************************************************************************
    400          *                                           MBM_RxReply()
    401          *
    402          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    403          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    404          *               will generate an Illegal Function Exception Response code (01).
    405          *
    406          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    407          *
    408          * Return(s)   : none.
    409          *
    410          * Caller(s)   : MBM_FCxx_xx
    411          *
    412          * Note(s)     : none.
    413          *********************************************************************************************************
    414          */
    415          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    416          CPU_BOOLEAN MBM_RxReply(MODBUS_CH *pch )
    417          {
    418          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    419              return MB_RTU_Rx(pch);
   \                     MBM_RxReply: (+1)
   \   00000000   0x.... 0x....      B.W      MB_RTU_Rx
    420          
    421          #endif
    422          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    423              return MB_ASCII_Rx(pch);
    424          #endif
    425          }
    426          #endif
    427          
    428          
    429          /*$PAGE*/
    430          /*
    431          *********************************************************************************************************
    432          *                                           MBS_FC01_CoilRd()
    433          *
    434          * Description : Responds to a request to read the status of any number of coils.
    435          *
    436          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    437          *
    438          * Return(s)   : DEF_TRUE      If a response needs to be sent
    439          *               DEF_FALSE     If not
    440          *
    441          * Caller(s)   : MBS_FCxx_Handler()
    442          *
    443          * Note(s)     : none
    444          *********************************************************************************************************
    445          */
    446          
    447          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    448          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    449          CPU_INT16U  MBM_FC01_CoilRd          (MODBUS_CH   *pch,
    450                                                CPU_INT08U   slave_node,
    451                                                CPU_INT16U   slave_addr,
    452                                                CPU_INT08U  *p_coil_tbl,
    453                                                CPU_INT16U   nbr_coils)
    454          {
   \                     MBM_FC01_CoilRd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461D             MOV      R5,R3
    455              CPU_INT16U      nbr_bytes;
    456              CPU_INT08U     *ptx_data;
    457              CPU_INT16U      err;
    458              CPU_BOOLEAN     ok;
    459              CPU_INT16U      calc_crc;
    460          
    461              MB_OS_TxWait(pch,&err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x.... 0x....      BL       MB_OS_TxWait
    462              if ( err != MODBUS_ERR_NONE )
   \   00000010   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??MBM_FC01_CoilRd_0
    463                  return 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
    464              ptx_data    = &(pch->TxFrameData[0]);
   \                     ??MBM_FC01_CoilRd_0: (+1)
   \   0000001C   0xF204 0x324E      ADDW     R2,R4,#+846
    465              pch->TxFrameNDataBytes  = 4;
   \   00000020   0xF204 0x434E      ADDW     R3,R4,#+1102
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x8018             STRH     R0,[R3, #+0]
    466          
    467             *ptx_data++ = slave_node;
   \   00000028   0x7017             STRB     R7,[R2, #+0]
    468             *ptx_data++ = MODBUS_FC01_COIL_RD;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7050             STRB     R0,[R2, #+1]
    469             *ptx_data++ = HI_INT16U(slave_addr);
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x0A00             LSRS     R0,R0,#+8
   \   00000032   0x7090             STRB     R0,[R2, #+2]
    470             *ptx_data++ = LO_INT16U(slave_addr);
   \   00000034   0x70D6             STRB     R6,[R2, #+3]
   \   00000036   0x9906             LDR      R1,[SP, #+24]
    471             *ptx_data++ = HI_INT16U(nbr_coils);
   \   00000038   0x4608             MOV      R0,R1
   \   0000003A   0x0A00             LSRS     R0,R0,#+8
   \   0000003C   0x7110             STRB     R0,[R2, #+4]
    472             *ptx_data++ = LO_INT16U(nbr_coils);
   \   0000003E   0x7151             STRB     R1,[R2, #+5]
    473              nbr_bytes  = 0;
   \   00000040   0x2600             MOVS     R6,#+0
    474          
    475              /***********************************************
    476              * 描述： 发送
    477              */
    478              INT08S  retrys  = pch->Retrys;
   \   00000042   0x7918             LDRB     R0,[R3, #+4]
   \   00000044   0x08C7             LSRS     R7,R0,#+3
    479              do {
    480                MBM_TxCmd(pch);
   \                     ??MBM_FC01_CoilRd_1: (+1)
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       MBM_TxCmd
    481                MB_OS_RxWait(pch,&err);
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       MB_OS_RxWait
    482              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000054   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000058   0xF640 0x31B8      MOVW     R1,#+3000
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD103             BNE.N    ??MBM_FC01_CoilRd_2
   \   00000060   0x1E7F             SUBS     R7,R7,#+1
   \   00000062   0xB2FF             UXTB     R7,R7
   \   00000064   0x2F00             CMP      R7,#+0
   \   00000066   0xD1EE             BNE.N    ??MBM_FC01_CoilRd_1
    483          
    484              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC01_CoilRd_2: (+1)
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD12C             BNE.N    ??MBM_FC01_CoilRd_3
    485                  ok = MBM_RxReply(pch);
    486                  if ( DEF_TRUE == ok ) {
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       MBM_RxReply
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD12C             BNE.N    ??MBM_FC01_CoilRd_4
    487                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    488                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   0000007C   0xF104 0x011E      ADD      R1,R4,#+30
   \   00000080   0xF8B4 0x2346      LDRH     R2,[R4, #+838]
   \   00000084   0x4290             CMP      R0,R2
   \   00000086   0xD003             BEQ.N    ??MBM_FC01_CoilRd_5
    489                        /***********************************************
    490                        * 描述： 校验错误
    491                        */
    492                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   00000088   0x8848             LDRH     R0,[R1, #+2]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x8048             STRH     R0,[R1, #+2]
   \   0000008E   0xE01F             B.N      ??MBM_FC01_CoilRd_4
    493                      } else if (MBM_RX_FCXX_CODE == 0X81) {
   \                     ??MBM_FC01_CoilRd_5: (+1)
   \   00000090   0xF204 0x2045      ADDW     R0,R4,#+581
   \   00000094   0x7802             LDRB     R2,[R0, #+0]
   \   00000096   0x2A81             CMP      R2,#+129
   \   00000098   0xD103             BNE.N    ??MBM_FC01_CoilRd_6
    494                        pch->StatExceptCtr++;
   \   0000009A   0x8888             LDRH     R0,[R1, #+4]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x8088             STRH     R0,[R1, #+4]
    495                        /***********************************************
    496                        * 描述： 其他错误
    497                        //功能码03H： 读寄存器值错误响应
    498                        //第1字节	    ADR      	：	从机地址码（=001～254）
    499                        //第2字节　   83H			：	读寄存器值出错
    500                        //第3字节　   信息码		：	见信息码表
    501                        //第4、5字节	CRC			：	从字节1到3的CRC16校验和
    502                        //数息码	    表示意义
    503                        //01H	        非法的功能号
    504                        //02H	        非法的数据地址
    505                        //03H	        非法的数据值
    506                        //04H	        CRC16校验错
    507                        //05H	        接收正确
    508                        //06H	        接收错误
    509                        //07	        参数错误
    510                        */
    511                        nbr_bytes  = 0;
   \   000000A0   0xE016             B.N      ??MBM_FC01_CoilRd_4
    512                      } else {
    513                        pch->StatMsgCtr++;
   \                     ??MBM_FC01_CoilRd_6: (+1)
   \   000000A2   0x880A             LDRH     R2,[R1, #+0]
   \   000000A4   0x1C52             ADDS     R2,R2,#+1
   \   000000A6   0x800A             STRH     R2,[R1, #+0]
    514          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    515                        pch->StatNoRespCtr    = 0;
   \   000000A8   0x4632             MOV      R2,R6
   \   000000AA   0x810A             STRH     R2,[R1, #+8]
    516                        pch->StatCRCErrCtr    = 0;
   \   000000AC   0x804A             STRH     R2,[R1, #+2]
    517                        pch->StatExceptCtr    = 0;
   \   000000AE   0x808A             STRH     R2,[R1, #+4]
    518          #endif
    519                        /***********************************************
    520                        * 描述： 接收正确,且输入指针与数据指针不相等
    521                        */
    522                        nbr_bytes        = MBM_RX_FC01_NBYTE;
   \   000000B0   0x7846             LDRB     R6,[R0, #+1]
    523                        INT08U    idx    = 0;
   \   000000B2   0x4610             MOV      R0,R2
    524                        while(idx < nbr_bytes) {
   \                     ??MBM_FC01_CoilRd_7: (+1)
   \   000000B4   0x42B0             CMP      R0,R6
   \   000000B6   0xDA0B             BGE.N    ??MBM_FC01_CoilRd_4
    525                          p_coil_tbl[idx]    = MBM_RX_FC01_DATA(idx);
   \   000000B8   0x1901             ADDS     R1,R0,R4
   \   000000BA   0xF891 0x1247      LDRB     R1,[R1, #+583]
   \   000000BE   0x5541             STRB     R1,[R0, R5]
    526                          idx++;
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0xE7F6             B.N      ??MBM_FC01_CoilRd_7
    527                        }
    528                      }
    529                  }
    530              } else {
    531                  pch->StatNoRespCtr++;
   \                     ??MBM_FC01_CoilRd_3: (+1)
   \   000000C6   0xF104 0x011E      ADD      R1,R4,#+30
   \   000000CA   0x8908             LDRH     R0,[R1, #+8]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x8108             STRH     R0,[R1, #+8]
    532              }
    533          
    534              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC01_CoilRd_4: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF104 0x011E      ADD      R1,R4,#+30
   \   000000D6   0x8248             STRH     R0,[R1, #+18]
    535              pch->RxBufPtr     = &pch->RxBuf[0];
   \   000000D8   0xF104 0x0038      ADD      R0,R4,#+56
   \   000000DC   0x6360             STR      R0,[R4, #+52]
    536          
    537              MB_OS_TxOver(pch);
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       MB_OS_TxOver
    538          
    539              return nbr_bytes;
   \   000000E4   0x4630             MOV      R0,R6
   \   000000E6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    540          }
    541          #endif
    542          #endif
    543          
    544          /*$PAGE*/
    545          /*
    546          *********************************************************************************************************
    547          *                                           MBS_FC05_CoilWr()
    548          *
    549          * Description : Responds to a request to force a coil to a specified state.
    550          *
    551          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    552          *
    553          * Return(s)   : DEF_TRUE      If a response needs to be sent
    554          *               DEF_FALSE     If not
    555          *
    556          * Caller(s)   : MBS_FCxx_Handler()
    557          *
    558          * Note(s)     : none
    559          *********************************************************************************************************
    560          */
    561          
    562          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    563          #if (MODBUS_CFG_FC05_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    564          CPU_INT16U  MBM_FC05_CoilWr          (MODBUS_CH   *pch,
    565                                                CPU_INT08U   slave_node,
    566                                                CPU_INT16U   slave_addr,
    567                                                CPU_BOOLEAN  coil_val)
    568          {
   \                     MBM_FC05_CoilWr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461D             MOV      R5,R3
    569          
    570              CPU_INT08U     *ptx_data;
    571              CPU_INT16U      err;
    572              CPU_BOOLEAN     ok;
    573              CPU_INT16U      calc_crc;
    574              CPU_INT32U      timeout;
    575          
    576          
    577              MB_OS_TxWait(pch,&err);
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x.... 0x....      BL       MB_OS_TxWait
    578              if ( err != MODBUS_ERR_NONE )
   \   00000014   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??MBM_FC05_CoilWr_0
    579                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE079             B.N      ??MBM_FC05_CoilWr_1
    580              ptx_data  = &(pch->TxFrameData[0]);
   \                     ??MBM_FC05_CoilWr_0: (+1)
   \   00000020   0xF204 0x314E      ADDW     R1,R4,#+846
    581          
    582             *ptx_data++ = slave_node;
   \   00000024   0x700F             STRB     R7,[R1, #+0]
    583             *ptx_data++ = MODBUS_FC05_COIL_WR;
   \   00000026   0x2005             MOVS     R0,#+5
   \   00000028   0x7048             STRB     R0,[R1, #+1]
    584             *ptx_data++ = HI_INT16U(slave_addr);
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x0A00             LSRS     R0,R0,#+8
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
    585             *ptx_data++ = LO_INT16U(slave_addr);
   \   00000030   0x70CE             STRB     R6,[R1, #+3]
    586             *ptx_data++ = (coil_val) ? 0xff : 0x00;
   \   00000032   0x1D08             ADDS     R0,R1,#+4
   \   00000034   0x1C41             ADDS     R1,R0,#+1
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD001             BEQ.N    ??MBM_FC05_CoilWr_2
   \   0000003A   0x22FF             MOVS     R2,#+255
   \   0000003C   0xE000             B.N      ??MBM_FC05_CoilWr_3
   \                     ??MBM_FC05_CoilWr_2: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \                     ??MBM_FC05_CoilWr_3: (+1)
   \   00000040   0x7002             STRB     R2,[R0, #+0]
    587             *ptx_data++ = 0x00;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    588              pch->TxFrameNDataBytes  = 4;
   \   00000046   0xF204 0x484E      ADDW     R8,R4,#+1102
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    589          
    590              coil_val   = 0;
   \   00000050   0x2500             MOVS     R5,#+0
    591          
    592              timeout = pch->RxTimeout;
   \   00000052   0xF104 0x0628      ADD      R6,R4,#+40
   \   00000056   0x6837             LDR      R7,[R6, #+0]
    593              MB_MasterTimeoutSet(pch, 300u);                    // 设置MODBUS主机超时为500ms
   \   00000058   0xF44F 0x7196      MOV      R1,#+300
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       MB_MasterTimeoutSet
    594              /***********************************************
    595              * 描述： 发送
    596              */
    597              INT08S  retrys  = pch->Retrys;
   \   00000062   0xF898 0x0004      LDRB     R0,[R8, #+4]
   \   00000066   0xEA4F 0x08D0      LSR      R8,R0,#+3
    598              do {
    599                MBM_TxCmd(pch);
   \                     ??MBM_FC05_CoilWr_4: (+1)
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       MBM_TxCmd
    600                MB_OS_RxWait(pch,&err);
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       MB_OS_RxWait
    601              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000078   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000007C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD106             BNE.N    ??MBM_FC05_CoilWr_5
   \   00000084   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   00000088   0xFA5F 0xF888      UXTB     R8,R8
   \   0000008C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000090   0xD1EB             BNE.N    ??MBM_FC05_CoilWr_4
    602          
    603              MB_MasterTimeoutSet(pch, timeout);                // 设置MODBUS主机超时为500ms
   \                     ??MBM_FC05_CoilWr_5: (+1)
   \   00000092   0x4639             MOV      R1,R7
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       MB_MasterTimeoutSet
    604          
    605              if ( err == MODBUS_ERR_NONE ) {
   \   0000009A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD12A             BNE.N    ??MBM_FC05_CoilWr_6
    606                  ok = MBM_RxReply(pch);
    607                  if ( DEF_TRUE == ok ) {
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       MBM_RxReply
   \   000000A8   0x2801             CMP      R0,#+1
   \   000000AA   0xD12A             BNE.N    ??MBM_FC05_CoilWr_7
    608                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    609                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000B2   0xF104 0x011E      ADD      R1,R4,#+30
   \   000000B6   0xF8B4 0x2346      LDRH     R2,[R4, #+838]
   \   000000BA   0x4290             CMP      R0,R2
   \   000000BC   0xD003             BEQ.N    ??MBM_FC05_CoilWr_8
    610                        /***********************************************
    611                        * 描述： 校验错误
    612                        */
    613                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   000000BE   0x8848             LDRH     R0,[R1, #+2]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0x8048             STRH     R0,[R1, #+2]
   \   000000C4   0xE01D             B.N      ??MBM_FC05_CoilWr_7
    614                      } else if (MBM_RX_FCXX_CODE == 0X85) {
   \                     ??MBM_FC05_CoilWr_8: (+1)
   \   000000C6   0xF204 0x2045      ADDW     R0,R4,#+581
   \   000000CA   0x7802             LDRB     R2,[R0, #+0]
   \   000000CC   0x2A85             CMP      R2,#+133
   \   000000CE   0xD107             BNE.N    ??MBM_FC05_CoilWr_9
    615                        pch->StatExceptCtr++;
   \   000000D0   0x888A             LDRH     R2,[R1, #+4]
   \   000000D2   0x1C52             ADDS     R2,R2,#+1
   \   000000D4   0x808A             STRH     R2,[R1, #+4]
    616                        /***********************************************
    617                        * 描述： 其他错误
    618                        //功能码06H： 写单个寄存器值
    619                        //第1字节	    ADR      		：从机地址码（=001～254）
    620                        //第2字节　   86H			    ：写寄存器值出错功能码
    621                        //第3字节　   错误数息码		：	见信息码表
    622                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
    623                        //数息码	    表示意义
    624                        //01H	        非法的功能号
    625                        //02H	        非法的数据地址
    626                        //03H	        非法的数据值
    627                        //04H	        CRC16校验错
    628                        //05H	        接收正确
    629                        //06H	        接收错误
    630                        //07	        参数错误
    631                        */
    632                        coil_val   = (MBM_RX_FC05_COIL_DATA_H) ? 1 : 0;
   \   000000D6   0x78C0             LDRB     R0,[R0, #+3]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD012             BEQ.N    ??MBM_FC05_CoilWr_7
   \   000000DC   0x2501             MOVS     R5,#+1
   \   000000DE   0xE010             B.N      ??MBM_FC05_CoilWr_7
    633                      } else {
    634                        pch->StatMsgCtr++;
   \                     ??MBM_FC05_CoilWr_9: (+1)
   \   000000E0   0x880A             LDRH     R2,[R1, #+0]
   \   000000E2   0x1C52             ADDS     R2,R2,#+1
   \   000000E4   0x800A             STRH     R2,[R1, #+0]
    635          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    636                        pch->StatNoRespCtr    = 0;
   \   000000E6   0x462A             MOV      R2,R5
   \   000000E8   0x810A             STRH     R2,[R1, #+8]
    637                        pch->StatCRCErrCtr    = 0;
   \   000000EA   0x804A             STRH     R2,[R1, #+2]
    638                        pch->StatExceptCtr    = 0;
   \   000000EC   0x808A             STRH     R2,[R1, #+4]
    639          #endif
    640                        /***********************************************
    641                        * 描述： 接收正确
    642                        */
    643                        coil_val = (MBM_RX_FC05_COIL_DATA_H) ? 1 : 0;
   \   000000EE   0x78C0             LDRB     R0,[R0, #+3]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD006             BEQ.N    ??MBM_FC05_CoilWr_7
   \   000000F4   0x2501             MOVS     R5,#+1
   \   000000F6   0xE004             B.N      ??MBM_FC05_CoilWr_7
    644                      }
    645                  }
    646              } else {
    647                  pch->StatNoRespCtr++;
   \                     ??MBM_FC05_CoilWr_6: (+1)
   \   000000F8   0xF104 0x011E      ADD      R1,R4,#+30
   \   000000FC   0x8908             LDRH     R0,[R1, #+8]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x8108             STRH     R0,[R1, #+8]
    648              }
    649          
    650              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC05_CoilWr_7: (+1)
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x8130             STRH     R0,[R6, #+8]
    651              pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000106   0xF104 0x0038      ADD      R0,R4,#+56
   \   0000010A   0x60F0             STR      R0,[R6, #+12]
    652          
    653              MB_OS_TxOver(pch);
   \   0000010C   0x4620             MOV      R0,R4
   \   0000010E   0x.... 0x....      BL       MB_OS_TxOver
    654          
    655              return coil_val;
   \   00000112   0x4628             MOV      R0,R5
   \                     ??MBM_FC05_CoilWr_1: (+1)
   \   00000114   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    656          }
    657          #endif
    658          #endif
    659          
    660          
    661          /*$PAGE*/
    662          /*
    663          *********************************************************************************************************
    664          *                                           MBM_FC03_HoldingRegRd()
    665          *
    666          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    667          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    668          *               will generate an Illegal Function Exception Response code (01).
    669          *
    670          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    671          *
    672          * Return(s)   : none.
    673          *
    674          * Caller(s)   : Application
    675          *
    676          * Note(s)     : none.
    677          *********************************************************************************************************
    678          */
    679          
    680          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
    681              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
    682              (MODBUS_CFG_FC03_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    683          CPU_INT16U  MBM_FC03_HoldingRegRd    (MODBUS_CH   *pch,
    684                                                CPU_INT08U   slave_node,
    685                                                CPU_INT16U   slave_addr,
    686                                                CPU_INT16U  *p_reg_tbl,
    687                                                CPU_INT16U   nbr_regs)
    688          {
   \                     MBM_FC03_HoldingRegRd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461E             MOV      R6,R3
    689              CPU_INT08U     *ptx_data;
    690              CPU_INT16U      err;
    691              CPU_BOOLEAN     ok;
    692              CPU_INT16U      calc_crc;
    693          
    694              MB_OS_TxWait(pch,&err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x.... 0x....      BL       MB_OS_TxWait
    695              if ( err != MODBUS_ERR_NONE )
   \   00000010   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??MBM_FC03_HoldingRegRd_0
    696                  return 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
    697              ptx_data    = &(pch->TxFrameData[0]);
   \                     ??MBM_FC03_HoldingRegRd_0: (+1)
   \   0000001C   0xF205 0x314E      ADDW     R1,R5,#+846
    698              pch->TxFrameNDataBytes  = 4;
   \   00000020   0xF205 0x424E      ADDW     R2,R5,#+1102
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x8010             STRH     R0,[R2, #+0]
    699          
    700             *ptx_data++ = slave_node;
   \   00000028   0x700F             STRB     R7,[R1, #+0]
    701             *ptx_data++ = MODBUS_FC03_HOLDING_REG_RD;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x7048             STRB     R0,[R1, #+1]
    702             *ptx_data++ = HI_INT16U(slave_addr);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x0A00             LSRS     R0,R0,#+8
   \   00000032   0x7088             STRB     R0,[R1, #+2]
    703             *ptx_data++ = LO_INT16U(slave_addr);
   \   00000034   0x70CC             STRB     R4,[R1, #+3]
   \   00000036   0x9C06             LDR      R4,[SP, #+24]
    704             *ptx_data++ = HI_INT16U(nbr_regs);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x0A00             LSRS     R0,R0,#+8
   \   0000003C   0x7108             STRB     R0,[R1, #+4]
    705             *ptx_data++ = LO_INT16U(nbr_regs);
   \   0000003E   0x714C             STRB     R4,[R1, #+5]
    706              nbr_regs    = 0;
   \   00000040   0x2400             MOVS     R4,#+0
    707          
    708              /***********************************************
    709              * 描述： 发送
    710              */
    711              INT08S  retrys  = pch->Retrys;
   \   00000042   0x7910             LDRB     R0,[R2, #+4]
   \   00000044   0x08C7             LSRS     R7,R0,#+3
    712              do {
    713                MBM_TxCmd(pch);
   \                     ??MBM_FC03_HoldingRegRd_1: (+1)
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       MBM_TxCmd
    714                //redmorningcn    新增，防信号量冲突20171226
    715          //      uint16    delaytime; 
    716          //      delaytime  = (10 *(pch->TxFrameNDataBytes + 4) *1000)/pch->BaudRate ;
    717          //      
    718          //      if( delaytime  < 1 || delaytime > 100)
    719          //          delaytime = 5;
    720          //      
    721          //      BSP_OS_TimeDly(delaytime );
    722          //
    723                MB_OS_RxWait(pch,&err);
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x.... 0x....      BL       MB_OS_RxWait
    724              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000054   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000058   0xF640 0x31B8      MOVW     R1,#+3000
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD103             BNE.N    ??MBM_FC03_HoldingRegRd_2
   \   00000060   0x1E7F             SUBS     R7,R7,#+1
   \   00000062   0xB2FF             UXTB     R7,R7
   \   00000064   0x2F00             CMP      R7,#+0
   \   00000066   0xD1EE             BNE.N    ??MBM_FC03_HoldingRegRd_1
    725          
    726              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC03_HoldingRegRd_2: (+1)
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD133             BNE.N    ??MBM_FC03_HoldingRegRd_3
    727                  ok = MBM_RxReply(pch);
    728                  if ( DEF_TRUE == ok ) {
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       MBM_RxReply
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD133             BNE.N    ??MBM_FC03_HoldingRegRd_4
    729                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    730                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   0000007C   0xF105 0x011E      ADD      R1,R5,#+30
   \   00000080   0xF8B5 0x2346      LDRH     R2,[R5, #+838]
   \   00000084   0x4290             CMP      R0,R2
   \   00000086   0xD003             BEQ.N    ??MBM_FC03_HoldingRegRd_5
    731                        /***********************************************
    732                        * 描述： 校验错误
    733                        */
    734                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   00000088   0x8848             LDRH     R0,[R1, #+2]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x8048             STRH     R0,[R1, #+2]
   \   0000008E   0xE026             B.N      ??MBM_FC03_HoldingRegRd_4
    735                      } else if (MBM_RX_FCXX_CODE == 0X83) {
   \                     ??MBM_FC03_HoldingRegRd_5: (+1)
   \   00000090   0xF205 0x2045      ADDW     R0,R5,#+581
   \   00000094   0x7802             LDRB     R2,[R0, #+0]
   \   00000096   0x2A83             CMP      R2,#+131
   \   00000098   0xD103             BNE.N    ??MBM_FC03_HoldingRegRd_6
    736                        pch->StatExceptCtr++;
   \   0000009A   0x8888             LDRH     R0,[R1, #+4]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x8088             STRH     R0,[R1, #+4]
    737                        /***********************************************
    738                        * 描述： 其他错误
    739                        //功能码03H： 读寄存器值错误响应
    740                        //第1字节	    ADR      	：	从机地址码（=001～254）
    741                        //第2字节　   83H			：	读寄存器值出错
    742                        //第3字节　   信息码		：	见信息码表
    743                        //第4、5字节	CRC			：	从字节1到3的CRC16校验和
    744                        //数息码	    表示意义
    745                        //01H	        非法的功能号
    746                        //02H	        非法的数据地址
    747                        //03H	        非法的数据值
    748                        //04H	        CRC16校验错
    749                        //05H	        接收正确
    750                        //06H	        接收错误
    751                        //07	        参数错误
    752                        */
    753                        nbr_regs  = 0;
   \   000000A0   0xE01D             B.N      ??MBM_FC03_HoldingRegRd_4
    754                      } else {
    755                        pch->StatMsgCtr++;
   \                     ??MBM_FC03_HoldingRegRd_6: (+1)
   \   000000A2   0x880A             LDRH     R2,[R1, #+0]
   \   000000A4   0x1C52             ADDS     R2,R2,#+1
   \   000000A6   0x800A             STRH     R2,[R1, #+0]
    756          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    757                        pch->StatNoRespCtr    = 0;
   \   000000A8   0x4622             MOV      R2,R4
   \   000000AA   0x810A             STRH     R2,[R1, #+8]
    758                        pch->StatCRCErrCtr    = 0;
   \   000000AC   0x804A             STRH     R2,[R1, #+2]
    759                        pch->StatExceptCtr    = 0;
   \   000000AE   0x808A             STRH     R2,[R1, #+4]
    760          #endif
    761                        /***********************************************
    762                        * 描述： 接收正确,且输入指针与数据指针不相等
    763                        */
    764                        nbr_regs        = MBM_RX_FC03_NBYTE / 2;
   \   000000B0   0x7840             LDRB     R0,[R0, #+1]
   \   000000B2   0x0844             LSRS     R4,R0,#+1
    765                        INT08U    idx    = 0;
   \   000000B4   0x4610             MOV      R0,R2
    766                        while(idx < nbr_regs) {
   \                     ??MBM_FC03_HoldingRegRd_7: (+1)
   \   000000B6   0x42A0             CMP      R0,R4
   \   000000B8   0xDA11             BGE.N    ??MBM_FC03_HoldingRegRd_4
    767                          p_reg_tbl[idx]    = MBM_RX_FC03_DATA(idx);
   \   000000BA   0xEB05 0x0140      ADD      R1,R5,R0, LSL #+1
   \   000000BE   0xF201 0x2147      ADDW     R1,R1,#+583
   \   000000C2   0x780A             LDRB     R2,[R1, #+0]
   \   000000C4   0x7849             LDRB     R1,[R1, #+1]
   \   000000C6   0xEB01 0x2102      ADD      R1,R1,R2, LSL #+8
   \   000000CA   0xF826 0x1010      STRH     R1,[R6, R0, LSL #+1]
    768                          idx++;
   \   000000CE   0x1C40             ADDS     R0,R0,#+1
   \   000000D0   0xB2C0             UXTB     R0,R0
   \   000000D2   0xE7F0             B.N      ??MBM_FC03_HoldingRegRd_7
    769                        }
    770                      }
    771                  }
    772              } else {
    773                  pch->StatNoRespCtr++;
   \                     ??MBM_FC03_HoldingRegRd_3: (+1)
   \   000000D4   0xF105 0x011E      ADD      R1,R5,#+30
   \   000000D8   0x8908             LDRH     R0,[R1, #+8]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x8108             STRH     R0,[R1, #+8]
    774              }
    775          
    776              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC03_HoldingRegRd_4: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF105 0x011E      ADD      R1,R5,#+30
   \   000000E4   0x8248             STRH     R0,[R1, #+18]
    777              pch->RxBufPtr     = &pch->RxBuf[0];
   \   000000E6   0xF105 0x0038      ADD      R0,R5,#+56
   \   000000EA   0x6368             STR      R0,[R5, #+52]
    778          
    779              MB_OS_TxOver(pch);
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x.... 0x....      BL       MB_OS_TxOver
    780          
    781              return nbr_regs;
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    782          }
    783          #endif
    784          
    785          /*$PAGE*/
    786          /*
    787          *********************************************************************************************************
    788          *                                           MBM_FC06_HoldingRegWr()
    789          *
    790          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    791          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    792          *               will generate an Illegal Function Exception Response code (01).
    793          *
    794          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    795          *
    796          * Return(s)   : none.
    797          *
    798          * Caller(s)   : Application
    799          *
    800          * Note(s)     : none.
    801          *********************************************************************************************************
    802          */
    803          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
    804              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
    805              (MODBUS_CFG_FC06_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    806          CPU_INT16U  MBM_FC06_HoldingRegWr (  MODBUS_CH   *pch,
    807                                               CPU_INT08U   slave_node,
    808                                               CPU_INT16U   slave_addr,
    809                                               CPU_INT16U   reg_val)
    810          {
   \                     MBM_FC06_HoldingRegWr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461D             MOV      R5,R3
    811              CPU_INT08U     *ptx_data;
    812              CPU_INT16U      err;
    813              CPU_BOOLEAN     ok;
    814              CPU_INT16U      calc_crc;
    815              CPU_INT32U      timeout;
    816          
    817          
    818              MB_OS_TxWait(pch,&err);
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x.... 0x....      BL       MB_OS_TxWait
    819              if ( err != MODBUS_ERR_NONE )
   \   00000014   0x43E8             MVNS     R0,R5
   \   00000016   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD001             BEQ.N    ??MBM_FC06_HoldingRegWr_0
    820                  return (reg_val    = ~reg_val);                 // 取反，防止数据为0时相等
   \   0000001E   0xB280             UXTH     R0,R0
   \   00000020   0xE071             B.N      ??MBM_FC06_HoldingRegWr_1
    821              ptx_data  = &(pch->TxFrameData[0]);
   \                     ??MBM_FC06_HoldingRegWr_0: (+1)
   \   00000022   0xF204 0x324E      ADDW     R2,R4,#+846
    822          
    823             *ptx_data++ = slave_node;
   \   00000026   0x7017             STRB     R7,[R2, #+0]
    824             *ptx_data++ = MODBUS_FC06_HOLDING_REG_WR;
   \   00000028   0x2106             MOVS     R1,#+6
   \   0000002A   0x7051             STRB     R1,[R2, #+1]
    825             *ptx_data++ = HI_INT16U(slave_addr);
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0x0A09             LSRS     R1,R1,#+8
   \   00000030   0x7091             STRB     R1,[R2, #+2]
    826             *ptx_data++ = LO_INT16U(slave_addr);
   \   00000032   0x70D6             STRB     R6,[R2, #+3]
    827             *ptx_data++ = HI_INT16U(reg_val);
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x0A09             LSRS     R1,R1,#+8
   \   00000038   0x7111             STRB     R1,[R2, #+4]
    828             *ptx_data++ = LO_INT16U(reg_val);
   \   0000003A   0x7155             STRB     R5,[R2, #+5]
    829              reg_val    = ~reg_val;                              // 取反，防止数据为0时相等
   \   0000003C   0x4605             MOV      R5,R0
    830              pch->TxFrameNDataBytes  = 4;
   \   0000003E   0xF204 0x484E      ADDW     R8,R4,#+1102
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    831          
    832              timeout = pch->RxTimeout;
   \   00000048   0xF104 0x0628      ADD      R6,R4,#+40
   \   0000004C   0x6837             LDR      R7,[R6, #+0]
    833              MB_MasterTimeoutSet(pch, 300u);                     // 设置MODBUS主机超时为500ms
   \   0000004E   0xF44F 0x7196      MOV      R1,#+300
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       MB_MasterTimeoutSet
    834          
    835              /***********************************************
    836              * 描述： 发送
    837              */
    838              INT08S  retrys  = pch->Retrys;
   \   00000058   0xF898 0x0004      LDRB     R0,[R8, #+4]
   \   0000005C   0xEA4F 0x08D0      LSR      R8,R0,#+3
    839              do {
    840                MBM_TxCmd(pch);
   \                     ??MBM_FC06_HoldingRegWr_2: (+1)
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       MBM_TxCmd
    841                MB_OS_RxWait(pch,&err);
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       MB_OS_RxWait
    842              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   0000006E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000072   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD106             BNE.N    ??MBM_FC06_HoldingRegWr_3
   \   0000007A   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   0000007E   0xFA5F 0xF888      UXTB     R8,R8
   \   00000082   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000086   0xD1EB             BNE.N    ??MBM_FC06_HoldingRegWr_2
    843          
    844              MB_MasterTimeoutSet(pch, timeout);                // 设置MODBUS主机超时为500ms
   \                     ??MBM_FC06_HoldingRegWr_3: (+1)
   \   00000088   0x4639             MOV      R1,R7
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       MB_MasterTimeoutSet
    845          
    846              if ( err == MODBUS_ERR_NONE ) {
   \   00000090   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD127             BNE.N    ??MBM_FC06_HoldingRegWr_4
    847                  ok = MBM_RxReply(pch);
    848                  if ( DEF_TRUE == ok ) {
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       MBM_RxReply
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD127             BNE.N    ??MBM_FC06_HoldingRegWr_5
    849                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    850                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000A8   0xF104 0x011E      ADD      R1,R4,#+30
   \   000000AC   0xF8B4 0x2346      LDRH     R2,[R4, #+838]
   \   000000B0   0x4290             CMP      R0,R2
   \   000000B2   0xD003             BEQ.N    ??MBM_FC06_HoldingRegWr_6
    851                        /***********************************************
    852                        * 描述： 校验错误
    853                        */
    854                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   000000B4   0x8848             LDRH     R0,[R1, #+2]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x8048             STRH     R0,[R1, #+2]
   \   000000BA   0xE01A             B.N      ??MBM_FC06_HoldingRegWr_5
    855                      } else if (MBM_RX_FCXX_CODE == 0X86) {
   \                     ??MBM_FC06_HoldingRegWr_6: (+1)
   \   000000BC   0xF204 0x2045      ADDW     R0,R4,#+581
   \   000000C0   0x7802             LDRB     R2,[R0, #+0]
   \   000000C2   0x2A86             CMP      R2,#+134
   \   000000C4   0xD104             BNE.N    ??MBM_FC06_HoldingRegWr_7
    856                        pch->StatExceptCtr++;
   \   000000C6   0x8888             LDRH     R0,[R1, #+4]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0x8088             STRH     R0,[R1, #+4]
    857                        /***********************************************
    858                        * 描述： 其他错误
    859                        //功能码06H： 写单个寄存器值
    860                        //第1字节	    ADR      		：从机地址码（=001～254）
    861                        //第2字节　   86H			    ：写寄存器值出错功能码
    862                        //第3字节　   错误数息码		：	见信息码表
    863                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
    864                        //数息码	    表示意义
    865                        //01H	        非法的功能号
    866                        //02H	        非法的数据地址
    867                        //03H	        非法的数据值
    868                        //04H	        CRC16校验错
    869                        //05H	        接收正确
    870                        //06H	        接收错误
    871                        //07	        参数错误
    872                        */
    873                        reg_val   = 0;
   \   000000CC   0x2500             MOVS     R5,#+0
   \   000000CE   0xE010             B.N      ??MBM_FC06_HoldingRegWr_5
    874                      } else {
    875                        pch->StatMsgCtr++;
   \                     ??MBM_FC06_HoldingRegWr_7: (+1)
   \   000000D0   0x880A             LDRH     R2,[R1, #+0]
   \   000000D2   0x1C52             ADDS     R2,R2,#+1
   \   000000D4   0x800A             STRH     R2,[R1, #+0]
    876          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    877                        pch->StatNoRespCtr    = 0;
   \   000000D6   0x2200             MOVS     R2,#+0
   \   000000D8   0x810A             STRH     R2,[R1, #+8]
    878                        pch->StatCRCErrCtr    = 0;
   \   000000DA   0x804A             STRH     R2,[R1, #+2]
    879                        pch->StatExceptCtr    = 0;
   \   000000DC   0x808A             STRH     R2,[R1, #+4]
    880          #endif
    881                        /***********************************************
    882                        * 描述： 接收正确
    883                        */
    884                        reg_val = MBM_RX_FC06_DATA;
   \   000000DE   0x78C1             LDRB     R1,[R0, #+3]
   \   000000E0   0x7900             LDRB     R0,[R0, #+4]
   \   000000E2   0xEB00 0x2501      ADD      R5,R0,R1, LSL #+8
   \   000000E6   0xE004             B.N      ??MBM_FC06_HoldingRegWr_5
    885                      }
    886                  }
    887              } else {
    888                  pch->StatNoRespCtr++;
   \                     ??MBM_FC06_HoldingRegWr_4: (+1)
   \   000000E8   0xF104 0x011E      ADD      R1,R4,#+30
   \   000000EC   0x8908             LDRH     R0,[R1, #+8]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x8108             STRH     R0,[R1, #+8]
    889              }
    890          
    891              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC06_HoldingRegWr_5: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x8130             STRH     R0,[R6, #+8]
    892              pch->RxBufPtr     = &pch->RxBuf[0];
   \   000000F6   0xF104 0x0038      ADD      R0,R4,#+56
   \   000000FA   0x60F0             STR      R0,[R6, #+12]
    893          
    894              MB_OS_TxOver(pch);
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       MB_OS_TxOver
    895          
    896              return reg_val;
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0xB280             UXTH     R0,R0
   \                     ??MBM_FC06_HoldingRegWr_1: (+1)
   \   00000106   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    897          }
    898          #endif
    899          /*$PAGE*/
    900          /*
    901          *********************************************************************************************************
    902          *                                       MBS_FC15_CoilWrMultiple()
    903          *
    904          * Description : Processes the MODBUS "Force Multiple COILS" command and writes the COIL states.
    905          *
    906          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    907          *
    908          * Return(s)   : DEF_TRUE      If a response needs to be sent
    909          *               DEF_FALSE     If not
    910          *
    911          * Caller(s)   : MBS_FCxx_Handler()
    912          *
    913          * Note(s)     : none
    914          *********************************************************************************************************
    915          */
    916          
    917          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    918          #if (MODBUS_CFG_FC15_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    919          CPU_INT16U  MBM_FC15_CoilWr          (MODBUS_CH   *pch,
    920                                                CPU_INT08U   slave_node,
    921                                                CPU_INT16U   slave_addr,
    922                                                CPU_INT08U  *p_coil_tbl,
    923                                                CPU_INT16U   nbr_coils)
    924          {
   \                     MBM_FC15_CoilWr: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C0A             LDR      R4,[SP, #+40]
    925              CPU_INT16U      nbr_bytes       = (nbr_coils - 1) / 8 + 1;    /* Get the byte count for the data.                         */
   \   00000010   0x1E60             SUBS     R0,R4,#+1
   \   00000012   0x1081             ASRS     R1,R0,#+2
   \   00000014   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   00000018   0x10C0             ASRS     R0,R0,#+3
   \   0000001A   0x1C45             ADDS     R5,R0,#+1
    926              CPU_INT08U     *ptx_data;
    927              CPU_INT16U      err;
    928              CPU_BOOLEAN     ok;
    929              CPU_INT16U      calc_crc;
    930              CPU_INT16U      ctr             = nbr_bytes;
   \   0000001C   0x46AA             MOV      R10,R5
    931          
    932              if ( nbr_coils == 0 )
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD007             BEQ.N    ??MBM_FC15_CoilWr_0
    933                return 0;
    934              /***************************************************
    935              * 描述：
    936              */
    937              MB_OS_TxWait(pch,&err);
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       MB_OS_TxWait
    938              if ( err != MODBUS_ERR_NONE )
   \   0000002A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??MBM_FC15_CoilWr_1
    939                  return 0;
   \                     ??MBM_FC15_CoilWr_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE08B             B.N      ??MBM_FC15_CoilWr_2
    940          
    941              ptx_data    = &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]);
   \                     ??MBM_FC15_CoilWr_1: (+1)
   \   00000036   0xF206 0x3255      ADDW     R2,R6,#+853
   \   0000003A   0x4610             MOV      R0,R2
    942              /***************************************************
    943              * 描述： 如果输入数组与数据数组是同一数组，且是从第0个数据开始
    944              */
    945              if ( (CPU_INT08U *)p_coil_tbl == &(pch->TxFrameData[0]) ) {
   \   0000003C   0xF206 0x314E      ADDW     R1,R6,#+846
   \   00000040   0x4589             CMP      R9,R1
   \   00000042   0xD111             BNE.N    ??MBM_FC15_CoilWr_3
    946                ptx_data  += nbr_bytes + MBM_TX_FC16_DATA_IDX-1;                          // 指向数据的最后一个元素
   \   00000044   0xB2AD             UXTH     R5,R5
   \   00000046   0x1828             ADDS     R0,R5,R0
   \   00000048   0x1D80             ADDS     R0,R0,#+6
    947                p_coil_tbl += nbr_bytes-1;                              // 指向最后一个寄存器
   \   0000004A   0xEB05 0x0209      ADD      R2,R5,R9
   \   0000004E   0xF1A2 0x0901      SUB      R9,R2,#+1
    948          
    949                while(ctr--) {
   \                     ??MBM_FC15_CoilWr_4: (+1)
   \   00000052   0x4652             MOV      R2,R10
   \   00000054   0xF1A2 0x0A01      SUB      R10,R2,#+1
   \   00000058   0xB292             UXTH     R2,R2
   \   0000005A   0x2A00             CMP      R2,#+0
   \   0000005C   0xD01B             BEQ.N    ??MBM_FC15_CoilWr_5
    950                 *ptx_data--      = *p_coil_tbl--;
   \   0000005E   0xF819 0x2901      LDRB     R2,[R9], #-1
   \   00000062   0xF800 0x2901      STRB     R2,[R0], #-1
   \   00000066   0xE7F4             B.N      ??MBM_FC15_CoilWr_4
    951                }
    952              /***************************************************
    953              * 描述： 如果输入指针不是当前通道的数据帧的第7个元素，则拷贝元素到数据帧数组
    954              */
    955              } else if ( (CPU_INT08U *)p_coil_tbl == &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]) ) {
   \                     ??MBM_FC15_CoilWr_3: (+1)
   \   00000068   0x4591             CMP      R9,R2
   \   0000006A   0xD10E             BNE.N    ??MBM_FC15_CoilWr_6
    956                while(ctr--) {
   \                     ??MBM_FC15_CoilWr_7: (+1)
   \   0000006C   0x4652             MOV      R2,R10
   \   0000006E   0xF1A2 0x0A01      SUB      R10,R2,#+1
   \   00000072   0xB292             UXTH     R2,R2
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xD00E             BEQ.N    ??MBM_FC15_CoilWr_5
    957                 *ptx_data++      = *p_coil_tbl++;
   \   00000078   0xF819 0x2B01      LDRB     R2,[R9], #+1
   \   0000007C   0xF800 0x2B01      STRB     R2,[R0], #+1
   \   00000080   0xE7F4             B.N      ??MBM_FC15_CoilWr_7
    958                }
    959              } else {
    960                while(ctr--) {
    961                 *ptx_data++      = *p_coil_tbl++;
   \                     ??MBM_FC15_CoilWr_8: (+1)
   \   00000082   0xF819 0x2B01      LDRB     R2,[R9], #+1
   \   00000086   0xF800 0x2B01      STRB     R2,[R0], #+1
    962                }
   \                     ??MBM_FC15_CoilWr_6: (+1)
   \   0000008A   0x4652             MOV      R2,R10
   \   0000008C   0xF1A2 0x0A01      SUB      R10,R2,#+1
   \   00000090   0xB292             UXTH     R2,R2
   \   00000092   0x2A00             CMP      R2,#+0
   \   00000094   0xD1F5             BNE.N    ??MBM_FC15_CoilWr_8
    963              }
    964          
    965              ptx_data    = &(pch->TxFrameData[0]);
    966              /***************************************************
    967              * 描述：
    968              */
    969             *ptx_data++ = slave_node;
   \                     ??MBM_FC15_CoilWr_5: (+1)
   \   00000096   0xF881 0x8000      STRB     R8,[R1, #+0]
    970             *ptx_data++ = MODBUS_FC15_COIL_WR_MULTIPLE;
   \   0000009A   0x200F             MOVS     R0,#+15
   \   0000009C   0x7048             STRB     R0,[R1, #+1]
    971             *ptx_data++ = HI_INT16U(slave_addr);
   \   0000009E   0x4638             MOV      R0,R7
   \   000000A0   0x0A00             LSRS     R0,R0,#+8
   \   000000A2   0x7088             STRB     R0,[R1, #+2]
    972             *ptx_data++ = LO_INT16U(slave_addr);
   \   000000A4   0x70CF             STRB     R7,[R1, #+3]
    973             *ptx_data++ = HI_INT16U(nbr_coils);
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x0A00             LSRS     R0,R0,#+8
   \   000000AA   0x7108             STRB     R0,[R1, #+4]
    974             *ptx_data++ = LO_INT16U(nbr_coils);
   \   000000AC   0x714C             STRB     R4,[R1, #+5]
    975              pch->TxFrameNDataBytes  = 5 + nbr_bytes;
   \   000000AE   0x1D68             ADDS     R0,R5,#+5
   \   000000B0   0xF206 0x424E      ADDW     R2,R6,#+1102
   \   000000B4   0x8010             STRH     R0,[R2, #+0]
    976             *ptx_data++ = pch->TxFrameNDataBytes - 5;
   \   000000B6   0x1F40             SUBS     R0,R0,#+5
   \   000000B8   0x7188             STRB     R0,[R1, #+6]
    977          
    978              nbr_bytes    = 0;
   \   000000BA   0x2500             MOVS     R5,#+0
    979          
    980              /***********************************************
    981              * 描述： 发送
    982              */
    983              INT08S  retrys  = pch->Retrys;
   \   000000BC   0x7910             LDRB     R0,[R2, #+4]
   \   000000BE   0x08C4             LSRS     R4,R0,#+3
    984              do {
    985                MBM_TxCmd(pch);
   \                     ??MBM_FC15_CoilWr_9: (+1)
   \   000000C0   0x4630             MOV      R0,R6
   \   000000C2   0x.... 0x....      BL       MBM_TxCmd
    986                MB_OS_RxWait(pch,&err);
   \   000000C6   0x4669             MOV      R1,SP
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       MB_OS_RxWait
    987              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   000000CE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000D2   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000D6   0x4288             CMP      R0,R1
   \   000000D8   0xD103             BNE.N    ??MBM_FC15_CoilWr_10
   \   000000DA   0x1E64             SUBS     R4,R4,#+1
   \   000000DC   0xB2E4             UXTB     R4,R4
   \   000000DE   0x2C00             CMP      R4,#+0
   \   000000E0   0xD1EE             BNE.N    ??MBM_FC15_CoilWr_9
    988          
    989              /***************************************************
    990              * 描述：
    991              */
    992              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC15_CoilWr_10: (+1)
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD123             BNE.N    ??MBM_FC15_CoilWr_11
    993                  ok = MBM_RxReply(pch);
    994                  if ( DEF_TRUE == ok ) {
   \   000000E6   0x4630             MOV      R0,R6
   \   000000E8   0x.... 0x....      BL       MBM_RxReply
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD123             BNE.N    ??MBM_FC15_CoilWr_12
    995                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   000000F0   0x4630             MOV      R0,R6
   \   000000F2   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    996                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000F6   0xF106 0x011E      ADD      R1,R6,#+30
   \   000000FA   0xF8B6 0x2346      LDRH     R2,[R6, #+838]
   \   000000FE   0x4290             CMP      R0,R2
   \   00000100   0xD003             BEQ.N    ??MBM_FC15_CoilWr_13
    997                        /***********************************************
    998                        * 描述： 校验错误
    999                        */
   1000                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   00000102   0x8848             LDRH     R0,[R1, #+2]
   \   00000104   0x1C40             ADDS     R0,R0,#+1
   \   00000106   0x8048             STRH     R0,[R1, #+2]
   \   00000108   0xE016             B.N      ??MBM_FC15_CoilWr_12
   1001                      } else if (MBM_RX_FCXX_CODE == 0X8F) {
   \                     ??MBM_FC15_CoilWr_13: (+1)
   \   0000010A   0xF206 0x2045      ADDW     R0,R6,#+581
   \   0000010E   0x7802             LDRB     R2,[R0, #+0]
   \   00000110   0x2A8F             CMP      R2,#+143
   \   00000112   0xD103             BNE.N    ??MBM_FC15_CoilWr_14
   1002                          pch->StatExceptCtr++;
   \   00000114   0x8888             LDRH     R0,[R1, #+4]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   \   00000118   0x8088             STRH     R0,[R1, #+4]
   1003                        /***********************************************
   1004                        * 描述： 其他错误
   1005                        //功能码10H： 连续写多个寄存器值
   1006                        //第1字节	    ADR      		：	从机地址码（=001～254）
   1007                        //第2字节　   90H			    ：　写寄存器值出错
   1008                        //第3字节　   错误信息码		：	见信息码表
   1009                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
   1010                        //数息码	    表示意义
   1011                        //01H	        非法的功能号
   1012                        //02H	        非法的数据地址
   1013                        //03H	        非法的数据值
   1014                        //04H	        CRC16校验错
   1015                        //05H	        接收正确
   1016                        //06H	        接收错误
   1017                        //07	        参数错误
   1018                        */
   1019                        nbr_bytes = 0;
   \   0000011A   0xE00D             B.N      ??MBM_FC15_CoilWr_12
   1020                      } else {
   1021                        pch->StatMsgCtr++;
   \                     ??MBM_FC15_CoilWr_14: (+1)
   \   0000011C   0x880A             LDRH     R2,[R1, #+0]
   \   0000011E   0x1C52             ADDS     R2,R2,#+1
   \   00000120   0x800A             STRH     R2,[R1, #+0]
   1022          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
   1023                        pch->StatNoRespCtr    = 0;
   \   00000122   0x462A             MOV      R2,R5
   \   00000124   0x810A             STRH     R2,[R1, #+8]
   1024                        pch->StatCRCErrCtr    = 0;
   \   00000126   0x804A             STRH     R2,[R1, #+2]
   1025                        pch->StatExceptCtr    = 0;
   \   00000128   0x808A             STRH     R2,[R1, #+4]
   1026          #endif
   1027                        /***********************************************
   1028                        * 描述： 接收正确
   1029                        */
   1030                        nbr_bytes = MBM_RX_FC15_COIL_BYTES;
   \   0000012A   0x7945             LDRB     R5,[R0, #+5]
   \   0000012C   0xE004             B.N      ??MBM_FC15_CoilWr_12
   1031                      }
   1032                  }
   1033              } else {
   1034                  pch->StatNoRespCtr++;
   \                     ??MBM_FC15_CoilWr_11: (+1)
   \   0000012E   0xF106 0x011E      ADD      R1,R6,#+30
   \   00000132   0x8908             LDRH     R0,[R1, #+8]
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \   00000136   0x8108             STRH     R0,[R1, #+8]
   1035              }
   1036          
   1037              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC15_CoilWr_12: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF106 0x011E      ADD      R1,R6,#+30
   \   0000013E   0x8248             STRH     R0,[R1, #+18]
   1038              pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000140   0xF106 0x0038      ADD      R0,R6,#+56
   \   00000144   0x6370             STR      R0,[R6, #+52]
   1039          
   1040              MB_OS_TxOver(pch);
   \   00000146   0x4630             MOV      R0,R6
   \   00000148   0x.... 0x....      BL       MB_OS_TxOver
   1041          
   1042              return nbr_bytes;
   \   0000014C   0x4628             MOV      R0,R5
   \                     ??MBM_FC15_CoilWr_2: (+1)
   \   0000014E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1043          }
   1044          #endif
   1045          #endif
   1046          
   1047          /*$PAGE*/
   1048          /*
   1049          *********************************************************************************************************
   1050          *                                           MBM_FC16_HoldingRegWrN()
   1051          *
   1052          * Description : This is the main processing function for MODBUS commands.  The message integrity is
   1053          *               verified, and if valid, the function requested is processed.  Unimplemented functions
   1054          *               will generate an Illegal Function Exception Response code (01).
   1055          *
   1056          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1057          *
   1058          * Return(s)   : none.
   1059          *
   1060          * Caller(s)   : Application
   1061          *
   1062          * Note(s)     : none.
   1063          *********************************************************************************************************
   1064          */
   1065          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
   1066              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
   1067              (MODBUS_CFG_FC16_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1068          CPU_INT16U  MBM_FC16_HoldingRegWrN   (MODBUS_CH   *pch,
   1069                                                CPU_INT08U   slave_node,
   1070                                                CPU_INT16U   slave_addr,
   1071                                                CPU_INT16U  *p_reg_tbl,
   1072                                                CPU_INT16U   nbr_regs)
   1073          {
   \                     MBM_FC16_HoldingRegWrN: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
   1074              CPU_INT08U     *ptx_data;
   1075              CPU_INT16U      err;
   1076              CPU_BOOLEAN     ok;
   1077              CPU_INT16U      calc_crc;
   1078              CPU_INT16U      temp;
   1079              CPU_INT16U      ctr         = nbr_regs;
   \   0000000E   0x46A1             MOV      R9,R4
   1080          
   1081              if ( nbr_regs == 0 )
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD006             BEQ.N    ??MBM_FC16_HoldingRegWrN_0
   1082                return 0;
   1083              /***************************************************
   1084              * 描述：
   1085              */
   1086              MB_OS_TxWait(pch,&err);
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x.... 0x....      BL       MB_OS_TxWait
   1087              if ( err != MODBUS_ERR_NONE )
   \   0000001A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??MBM_FC16_HoldingRegWrN_1
   1088                  return 0;
   \                     ??MBM_FC16_HoldingRegWrN_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE09B             B.N      ??MBM_FC16_HoldingRegWrN_2
   1089          
   1090              ptx_data    = &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]);
   \                     ??MBM_FC16_HoldingRegWrN_1: (+1)
   \   00000026   0xF205 0x3255      ADDW     R2,R5,#+853
   \   0000002A   0x4610             MOV      R0,R2
   1091              /***************************************************
   1092              * 描述： 如果输入数组与数据数组是同一数组，且是从第0个数据开始
   1093              */
   1094              if ( (CPU_INT08U *)p_reg_tbl == &(pch->TxFrameData[0]) ) {
   \   0000002C   0xF205 0x314E      ADDW     R1,R5,#+846
   \   00000030   0x4588             CMP      R8,R1
   \   00000032   0xD116             BNE.N    ??MBM_FC16_HoldingRegWrN_3
   1095                ptx_data  += nbr_regs * 2 + MBM_TX_FC16_DATA_IDX-1;   // 指向数据的最后一个元素
   \   00000034   0xEB00 0x0044      ADD      R0,R0,R4, LSL #+1
   \   00000038   0x1D80             ADDS     R0,R0,#+6
   1096                p_reg_tbl += nbr_regs-1;                              // 指向最后一个寄存器
   \   0000003A   0xEB08 0x0244      ADD      R2,R8,R4, LSL #+1
   \   0000003E   0xF1A2 0x0802      SUB      R8,R2,#+2
   1097          
   1098                while(ctr--) {
   \                     ??MBM_FC16_HoldingRegWrN_4: (+1)
   \   00000042   0x464A             MOV      R2,R9
   \   00000044   0xF1A2 0x0901      SUB      R9,R2,#+1
   \   00000048   0xB292             UXTH     R2,R2
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD026             BEQ.N    ??MBM_FC16_HoldingRegWrN_5
   1099                 *ptx_data--      = LO_INT16U(*p_reg_tbl);
   \   0000004E   0xF8B8 0x2000      LDRH     R2,[R8, #+0]
   \   00000052   0xF800 0x2901      STRB     R2,[R0], #-1
   1100                 *ptx_data--      = HI_INT16U(*p_reg_tbl);
   \   00000056   0xF838 0x2902      LDRH     R2,[R8], #-2
   \   0000005A   0x0A12             LSRS     R2,R2,#+8
   \   0000005C   0xF800 0x2901      STRB     R2,[R0], #-1
   1101                  p_reg_tbl--;
   \   00000060   0xE7EF             B.N      ??MBM_FC16_HoldingRegWrN_4
   1102                }
   1103              /***************************************************
   1104              * 描述： 如果输入指针不是当前通道的数据帧的第7个元素，则拷贝元素到数据帧数组
   1105              */
   1106              } else if ( (CPU_INT08U *)p_reg_tbl == &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]) ) {
   \                     ??MBM_FC16_HoldingRegWrN_3: (+1)
   \   00000062   0x4590             CMP      R8,R2
   \   00000064   0xD114             BNE.N    ??MBM_FC16_HoldingRegWrN_6
   1107                while(ctr--) {
   \                     ??MBM_FC16_HoldingRegWrN_7: (+1)
   \   00000066   0x464A             MOV      R2,R9
   \   00000068   0xF1A2 0x0901      SUB      R9,R2,#+1
   \   0000006C   0xB292             UXTH     R2,R2
   \   0000006E   0x2A00             CMP      R2,#+0
   \   00000070   0xD014             BEQ.N    ??MBM_FC16_HoldingRegWrN_5
   1108                  temp            = *p_reg_tbl;
   \   00000072   0xF838 0x2B02      LDRH     R2,[R8], #+2
   1109                 *ptx_data++      = HI_INT16U(temp);
   \   00000076   0x1213             ASRS     R3,R2,#+8
   \   00000078   0xF800 0x3B01      STRB     R3,[R0], #+1
   1110                 *ptx_data++      = LO_INT16U(temp);
   \   0000007C   0xF800 0x2B01      STRB     R2,[R0], #+1
   1111                  p_reg_tbl++;
   \   00000080   0xE7F1             B.N      ??MBM_FC16_HoldingRegWrN_7
   1112                }
   1113              } else {
   1114                while(ctr--) {
   1115                  temp            = *p_reg_tbl;
   \                     ??MBM_FC16_HoldingRegWrN_8: (+1)
   \   00000082   0xF838 0x2B02      LDRH     R2,[R8], #+2
   1116                 *ptx_data++      = LO_INT16U(temp);
   \   00000086   0xF800 0x2B01      STRB     R2,[R0], #+1
   1117                 *ptx_data++      = HI_INT16U(temp);
   \   0000008A   0x1212             ASRS     R2,R2,#+8
   \   0000008C   0xF800 0x2B01      STRB     R2,[R0], #+1
   1118                  p_reg_tbl++;
   1119                }
   \                     ??MBM_FC16_HoldingRegWrN_6: (+1)
   \   00000090   0x464A             MOV      R2,R9
   \   00000092   0xF1A2 0x0901      SUB      R9,R2,#+1
   \   00000096   0xB292             UXTH     R2,R2
   \   00000098   0x2A00             CMP      R2,#+0
   \   0000009A   0xD1F2             BNE.N    ??MBM_FC16_HoldingRegWrN_8
   1120              }
   1121          
   1122              ptx_data    = &(pch->TxFrameData[0]);
   1123              /***************************************************
   1124              * 描述：
   1125              */
   1126             *ptx_data++ = slave_node;
   \                     ??MBM_FC16_HoldingRegWrN_5: (+1)
   \   0000009C   0x700F             STRB     R7,[R1, #+0]
   1127             *ptx_data++ = MODBUS_FC16_HOLDING_REG_WR_MULTIPLE;
   \   0000009E   0x2010             MOVS     R0,#+16
   \   000000A0   0x7048             STRB     R0,[R1, #+1]
   1128             *ptx_data++ = HI_INT16U(slave_addr);
   \   000000A2   0x4630             MOV      R0,R6
   \   000000A4   0x0A00             LSRS     R0,R0,#+8
   \   000000A6   0x7088             STRB     R0,[R1, #+2]
   1129             *ptx_data++ = LO_INT16U(slave_addr);
   \   000000A8   0x70CE             STRB     R6,[R1, #+3]
   1130             *ptx_data++ = HI_INT16U(nbr_regs);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x0A00             LSRS     R0,R0,#+8
   \   000000AE   0x7108             STRB     R0,[R1, #+4]
   1131             *ptx_data++ = LO_INT16U(nbr_regs);
   \   000000B0   0x714C             STRB     R4,[R1, #+5]
   1132              pch->TxFrameNDataBytes  = 5 + nbr_regs * 2;
   \   000000B2   0xF205 0x404E      ADDW     R0,R5,#+1102
   \   000000B6   0x0062             LSLS     R2,R4,#+1
   \   000000B8   0x1D52             ADDS     R2,R2,#+5
   \   000000BA   0x8002             STRH     R2,[R0, #+0]
   1133             *ptx_data++ = pch->TxFrameNDataBytes - 5;
   \   000000BC   0x8802             LDRH     R2,[R0, #+0]
   \   000000BE   0x1F52             SUBS     R2,R2,#+5
   \   000000C0   0x718A             STRB     R2,[R1, #+6]
   1134          
   1135              nbr_regs    = 0;
   \   000000C2   0x2400             MOVS     R4,#+0
   1136          
   1137              /***********************************************
   1138              * 描述： 发送
   1139              */
   1140              INT08S  retrys  = pch->Retrys;
   \   000000C4   0x7900             LDRB     R0,[R0, #+4]
   \   000000C6   0x08C6             LSRS     R6,R0,#+3
   1141              do {
   1142                MBM_TxCmd(pch);
   \                     ??MBM_FC16_HoldingRegWrN_9: (+1)
   \   000000C8   0x4628             MOV      R0,R5
   \   000000CA   0x.... 0x....      BL       MBM_TxCmd
   1143                MB_OS_RxWait(pch,&err);
   \   000000CE   0x4669             MOV      R1,SP
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0x.... 0x....      BL       MB_OS_RxWait
   1144              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   000000D6   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000DA   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD103             BNE.N    ??MBM_FC16_HoldingRegWrN_10
   \   000000E2   0x1E76             SUBS     R6,R6,#+1
   \   000000E4   0xB2F6             UXTB     R6,R6
   \   000000E6   0x2E00             CMP      R6,#+0
   \   000000E8   0xD1EE             BNE.N    ??MBM_FC16_HoldingRegWrN_9
   1145          
   1146              /***************************************************
   1147              * 描述：
   1148              */
   1149              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC16_HoldingRegWrN_10: (+1)
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD126             BNE.N    ??MBM_FC16_HoldingRegWrN_11
   1150                  ok = MBM_RxReply(pch);
   1151                  if ( DEF_TRUE == ok ) {
   \   000000EE   0x4628             MOV      R0,R5
   \   000000F0   0x.... 0x....      BL       MBM_RxReply
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xD126             BNE.N    ??MBM_FC16_HoldingRegWrN_12
   1152                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       MB_RTU_RxCalcCRC
   1153                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000FE   0xF105 0x011E      ADD      R1,R5,#+30
   \   00000102   0xF8B5 0x2346      LDRH     R2,[R5, #+838]
   \   00000106   0x4290             CMP      R0,R2
   \   00000108   0xD003             BEQ.N    ??MBM_FC16_HoldingRegWrN_13
   1154                        /***********************************************
   1155                        * 描述： 校验错误
   1156                        */
   1157                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   0000010A   0x8848             LDRH     R0,[R1, #+2]
   \   0000010C   0x1C40             ADDS     R0,R0,#+1
   \   0000010E   0x8048             STRH     R0,[R1, #+2]
   \   00000110   0xE019             B.N      ??MBM_FC16_HoldingRegWrN_12
   1158                      } else if (MBM_RX_FCXX_CODE == 0X90) {
   \                     ??MBM_FC16_HoldingRegWrN_13: (+1)
   \   00000112   0xF205 0x2045      ADDW     R0,R5,#+581
   \   00000116   0x7802             LDRB     R2,[R0, #+0]
   \   00000118   0x2A90             CMP      R2,#+144
   \   0000011A   0xD103             BNE.N    ??MBM_FC16_HoldingRegWrN_14
   1159                          pch->StatExceptCtr++;
   \   0000011C   0x8888             LDRH     R0,[R1, #+4]
   \   0000011E   0x1C40             ADDS     R0,R0,#+1
   \   00000120   0x8088             STRH     R0,[R1, #+4]
   1160                        /***********************************************
   1161                        * 描述： 其他错误
   1162                        //功能码10H： 连续写多个寄存器值
   1163                        //第1字节	    ADR      		：	从机地址码（=001～254）
   1164                        //第2字节　   90H			    ：　写寄存器值出错
   1165                        //第3字节　   错误信息码		：	见信息码表
   1166                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
   1167                        //数息码	    表示意义
   1168                        //01H	        非法的功能号
   1169                        //02H	        非法的数据地址
   1170                        //03H	        非法的数据值
   1171                        //04H	        CRC16校验错
   1172                        //05H	        接收正确
   1173                        //06H	        接收错误
   1174                        //07	        参数错误
   1175                        */
   1176                        nbr_regs = 0;
   \   00000122   0xE010             B.N      ??MBM_FC16_HoldingRegWrN_12
   1177                      } else {
   1178                        pch->StatMsgCtr++;
   \                     ??MBM_FC16_HoldingRegWrN_14: (+1)
   \   00000124   0x880A             LDRH     R2,[R1, #+0]
   \   00000126   0x1C52             ADDS     R2,R2,#+1
   \   00000128   0x800A             STRH     R2,[R1, #+0]
   1179          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
   1180                        pch->StatNoRespCtr    = 0;
   \   0000012A   0x4622             MOV      R2,R4
   \   0000012C   0x810A             STRH     R2,[R1, #+8]
   1181                        pch->StatCRCErrCtr    = 0;
   \   0000012E   0x804A             STRH     R2,[R1, #+2]
   1182                        pch->StatExceptCtr    = 0;
   \   00000130   0x808A             STRH     R2,[R1, #+4]
   1183          #endif
   1184                        /***********************************************
   1185                        * 描述： 接收正确
   1186                        */
   1187                        nbr_regs = MBM_RX_FC16_NREG;
   \   00000132   0x78C1             LDRB     R1,[R0, #+3]
   \   00000134   0x7900             LDRB     R0,[R0, #+4]
   \   00000136   0xEB00 0x2401      ADD      R4,R0,R1, LSL #+8
   \   0000013A   0xE004             B.N      ??MBM_FC16_HoldingRegWrN_12
   1188                      }
   1189                  }
   1190              } else {
   1191                  pch->StatNoRespCtr++;
   \                     ??MBM_FC16_HoldingRegWrN_11: (+1)
   \   0000013C   0xF105 0x011E      ADD      R1,R5,#+30
   \   00000140   0x8908             LDRH     R0,[R1, #+8]
   \   00000142   0x1C40             ADDS     R0,R0,#+1
   \   00000144   0x8108             STRH     R0,[R1, #+8]
   1192              }
   1193          
   1194              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC16_HoldingRegWrN_12: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xF105 0x011E      ADD      R1,R5,#+30
   \   0000014C   0x8248             STRH     R0,[R1, #+18]
   1195              pch->RxBufPtr     = &pch->RxBuf[0];
   \   0000014E   0xF105 0x0038      ADD      R0,R5,#+56
   \   00000152   0x6368             STR      R0,[R5, #+52]
   1196          
   1197              MB_OS_TxOver(pch);
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       MB_OS_TxOver
   1198          
   1199              return nbr_regs;
   \   0000015A   0x4620             MOV      R0,R4
   \   0000015C   0xB280             UXTH     R0,R0
   \                     ??MBM_FC16_HoldingRegWrN_2: (+1)
   \   0000015E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1200          }
   1201          #endif
   1202          
   1203          /*$PAGE*/
   1204          /*
   1205          *********************************************************************************************************
   1206          *                                           MBM_FCU_HoldingRegWrN()
   1207          *
   1208          * Description : This is the main processing function for MODBUS commands.  The message integrity is
   1209          *               verified, and if valid, the function requested is processed.  Unimplemented functions
   1210          *               will generate an Illegal Function Exception Response code (01).
   1211          *
   1212          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1213          *
   1214          * Return(s)   : none.
   1215          *
   1216          * Caller(s)   : Application
   1217          *
   1218          * Note(s)     : none.
   1219          *********************************************************************************************************
   1220          */
   1221          
   1222          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
   1223              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
   1224              (MODBUS_CFG_FCU_EN == DEF_ENABLED)
   1225          CPU_INT16U  MBM_FCU_HoldingRegWrN(  MODBUS_CH   *pch,
   1226                                              CPU_INT08U   slave_node,
   1227                                              CPU_INT08U   fc,
   1228                                              CPU_INT16U   block,
   1229                                              CPU_INT16U   blocks,
   1230                                              CPU_INT16U  *p_reg_tbl,
   1231                                              CPU_INT16U   nbr_regs)
   1232          {
   1233              CPU_INT08U     *ptx_data;
   1234              CPU_INT16U      err;
   1235              CPU_BOOLEAN     ok;
   1236              CPU_INT16U      calc_crc;
   1237          
   1238          
   1239              MB_OS_TxWait(pch,&err);
   1240              if ( err != MODBUS_ERR_NONE )
   1241                  return 0;
   1242              ptx_data    = &(pch->TxFrameData[0]);
   1243          
   1244             *ptx_data++ = slave_node;                        // 地址
   1245             *ptx_data++ = fc;                                // 写文件
   1246          
   1247             *ptx_data++ = HI_INT16U(block);                  // 当前块
   1248             *ptx_data++ = LO_INT16U(block);
   1249          
   1250             *ptx_data++ = HI_INT16U(blocks);                 // 总块数
   1251             *ptx_data++ = LO_INT16U(blocks);
   1252             *ptx_data++ = HI_INT16U(nbr_regs);
   1253             *ptx_data++ = LO_INT16U(nbr_regs);
   1254          
   1255              pch->TxFrameNDataBytes  = 7 + nbr_regs * 2;
   1256          
   1257              while(nbr_regs--) {
   1258               *ptx_data++   = HI_INT16U(*p_reg_tbl);
   1259               *ptx_data++   = LO_INT16U(*p_reg_tbl);
   1260                p_reg_tbl++;
   1261              }
   1262              nbr_regs    = 0;
   1263          
   1264              /***********************************************
   1265              * 描述： 发送
   1266              */
   1267              INT08S  retrys  = pch->Retrys;
   1268              do {
   1269                MBM_TxCmd(pch);
   1270                MB_OS_RxWait(pch,&err);
   1271              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   1272          
   1273              if ( err == MODBUS_ERR_NONE ) {
   1274                  ok = MBM_RxReply(pch);
   1275                  if ( DEF_TRUE == ok ) {
   1276                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   1277                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   1278                        /***********************************************
   1279                        * 描述： 校验错误
   1280                        */
   1281                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   1282                      } else if (MBM_RX_FCXX_CODE == (fc | 0x80)) {
   1283                          pch->StatExceptCtr++;
   1284                        /***********************************************
   1285                        * 描述： 其他错误
   1286                        //功能码10H： 连续写多个寄存器值
   1287                        //第1字节	    ADR      		：	从机地址码（=001～254）
   1288                        //第2字节　   90H			    ：　写寄存器值出错
   1289                        //第3字节　   错误信息码		：	见信息码表
   1290                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
   1291                        //数息码	    表示意义
   1292                        //01H	        非法的功能号
   1293                        //02H	        非法的数据地址
   1294                        //03H	        非法的数据值
   1295                        //04H	        CRC16校验错
   1296                        //05H	        接收正确
   1297                        //06H	        接收错误
   1298                        //07	        参数错误
   1299                        */
   1300                        nbr_regs = 0;
   1301                      } else {
   1302                        pch->StatMsgCtr++;
   1303          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
   1304                        pch->StatNoRespCtr    = 0;
   1305                        pch->StatCRCErrCtr    = 0;
   1306                        pch->StatExceptCtr    = 0;
   1307          #endif
   1308                        /***********************************************
   1309                        * 描述： 接收正确
   1310                        */
   1311                        nbr_regs = MBM_RX_FC16_NREG;
   1312                      }
   1313                  }
   1314              } else {
   1315                  pch->StatNoRespCtr++;
   1316              }
   1317          
   1318              pch->RxBufByteCtr = 0;
   1319              pch->RxBufPtr     = &pch->RxBuf[0];
   1320          
   1321              MB_OS_TxOver(pch);
   1322          
   1323              return nbr_regs;
   1324          }
   1325          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   MBM_FC01_CoilRd
        24   -> MBM_RxReply
        24   -> MBM_TxCmd
        24   -> MB_OS_RxWait
        24   -> MB_OS_TxOver
        24   -> MB_OS_TxWait
        24   -> MB_RTU_RxCalcCRC
      24   MBM_FC03_HoldingRegRd
        24   -> MBM_RxReply
        24   -> MBM_TxCmd
        24   -> MB_OS_RxWait
        24   -> MB_OS_TxOver
        24   -> MB_OS_TxWait
        24   -> MB_RTU_RxCalcCRC
      32   MBM_FC05_CoilWr
        32   -> MBM_RxReply
        32   -> MBM_TxCmd
        32   -> MB_MasterTimeoutSet
        32   -> MB_OS_RxWait
        32   -> MB_OS_TxOver
        32   -> MB_OS_TxWait
        32   -> MB_RTU_RxCalcCRC
      32   MBM_FC06_HoldingRegWr
        32   -> MBM_RxReply
        32   -> MBM_TxCmd
        32   -> MB_MasterTimeoutSet
        32   -> MB_OS_RxWait
        32   -> MB_OS_TxOver
        32   -> MB_OS_TxWait
        32   -> MB_RTU_RxCalcCRC
      40   MBM_FC15_CoilWr
        40   -> MBM_RxReply
        40   -> MBM_TxCmd
        40   -> MB_OS_RxWait
        40   -> MB_OS_TxOver
        40   -> MB_OS_TxWait
        40   -> MB_RTU_RxCalcCRC
      32   MBM_FC16_HoldingRegWrN
        32   -> MBM_RxReply
        32   -> MBM_TxCmd
        32   -> MB_OS_RxWait
        32   -> MB_OS_TxOver
        32   -> MB_OS_TxWait
        32   -> MB_RTU_RxCalcCRC
       8   MBM_FCxx_Handler
       0   MBM_RxReply
         0   -> MB_RTU_Rx
       0   MBM_TxCmd
         0   -> MB_RTU_Tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     232  MBM_FC01_CoilRd
     246  MBM_FC03_HoldingRegRd
     280  MBM_FC05_CoilWr
     266  MBM_FC06_HoldingRegWr
     338  MBM_FC15_CoilWr
     354  MBM_FC16_HoldingRegWrN
     118  MBM_FCxx_Handler
       4  MBM_RxReply
       4  MBM_TxCmd

 
 1 842 bytes in section .text
 
 1 842 bytes of CODE memory

Errors: none
Warnings: none
