###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:47:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_cbc.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_cbc.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\aes_cbc.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\aes_cbc.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_cbc.c
      1          /** crypto/aes/aes_cbc.c -*- mode:C; c-file-style: "eay" -*- */
      2          /** ====================================================================
      3           * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          
     52          #ifndef AES_DEBUG
     53          # ifndef NDEBUG
     54          #  define NDEBUG
     55          # endif
     56          #endif
     57          #include <assert.h>
     58          
     59          #include <aes.h>
     60          
     61          #if !defined(OPENSSL_FIPS_AES_ASM)

   \                                 In section .text, align 2, keep-with-next
     62          void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
     63          		     const unsigned long length, const AES_KEY *key,
     64          		     unsigned char *ivec, const int enc) {
   \                     AES_cbc_encrypt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
     65          
     66          	unsigned long n;
     67          	unsigned long len = length;
   \   00000008   0x0016             MOVS     R6,R2
     68          	unsigned char tmp[AES_BLOCK_SIZE];
     69          	const unsigned char *iv = ivec;
   \   0000000A   0x9F0C             LDR      R7,[SP, #+48]
     70          
     71          	assert(in && out && key && ivec);
     72          	assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));
     73          
     74          	if (AES_ENCRYPT == enc) {
   \   0000000C   0x980D             LDR      R0,[SP, #+52]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD14F             BNE      ??AES_cbc_encrypt_0
   \   00000012   0x2A10             CMP      R2,#+16
   \   00000014   0xD328             BCC      ??AES_cbc_encrypt_1
     75          		while (len >= AES_BLOCK_SIZE) {
     76          			for(n=0; n < AES_BLOCK_SIZE; ++n)
   \                     ??AES_cbc_encrypt_2: (+1)
   \   00000016   0x9400             STR      R4,[SP, #+0]
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x2104             MOVS     R1,#+4
     77          				out[n] = in[n] ^ iv[n];
   \                     ??AES_cbc_encrypt_3: (+1)
   \   0000001C   0x7803             LDRB     R3,[R0, #+0]
   \   0000001E   0x783A             LDRB     R2,[R7, #+0]
   \   00000020   0x405A             EORS     R2,R2,R3
   \   00000022   0x9B00             LDR      R3,[SP, #+0]
   \   00000024   0x701A             STRB     R2,[R3, #+0]
   \   00000026   0x7843             LDRB     R3,[R0, #+1]
   \   00000028   0x787A             LDRB     R2,[R7, #+1]
   \   0000002A   0x405A             EORS     R2,R2,R3
   \   0000002C   0x9B00             LDR      R3,[SP, #+0]
   \   0000002E   0x705A             STRB     R2,[R3, #+1]
   \   00000030   0x7883             LDRB     R3,[R0, #+2]
   \   00000032   0x78BA             LDRB     R2,[R7, #+2]
   \   00000034   0x405A             EORS     R2,R2,R3
   \   00000036   0x9B00             LDR      R3,[SP, #+0]
   \   00000038   0x709A             STRB     R2,[R3, #+2]
   \   0000003A   0x78C3             LDRB     R3,[R0, #+3]
   \   0000003C   0x78FA             LDRB     R2,[R7, #+3]
   \   0000003E   0x405A             EORS     R2,R2,R3
   \   00000040   0x9B00             LDR      R3,[SP, #+0]
   \   00000042   0x70DA             STRB     R2,[R3, #+3]
   \   00000044   0x1D3F             ADDS     R7,R7,#+4
   \   00000046   0x1D00             ADDS     R0,R0,#+4
   \   00000048   0x9A00             LDR      R2,[SP, #+0]
   \   0000004A   0x1D12             ADDS     R2,R2,#+4
   \   0000004C   0x9200             STR      R2,[SP, #+0]
   \   0000004E   0x1E49             SUBS     R1,R1,#+1
   \   00000050   0xD1E4             BNE      ??AES_cbc_encrypt_3
     78          			AES_encrypt(out, out, key);
   \   00000052   0x9A06             LDR      R2,[SP, #+24]
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       AES_encrypt
     79          			iv = out;
   \   0000005C   0x0027             MOVS     R7,R4
     80          			len -= AES_BLOCK_SIZE;
   \   0000005E   0x3E10             SUBS     R6,R6,#+16
     81          			in += AES_BLOCK_SIZE;
   \   00000060   0x3510             ADDS     R5,R5,#+16
     82          			out += AES_BLOCK_SIZE;
   \   00000062   0x3410             ADDS     R4,R4,#+16
     83          		}
   \   00000064   0x2E10             CMP      R6,#+16
   \   00000066   0xD2D6             BCS      ??AES_cbc_encrypt_2
     84          		if (len) {
   \                     ??AES_cbc_encrypt_1: (+1)
   \   00000068   0x2E00             CMP      R6,#+0
   \   0000006A   0xD100             BNE      .+4
   \   0000006C   0xE0B0             B        ??AES_cbc_encrypt_4
     85          			for(n=0; n < len; ++n)
   \   0000006E   0x9400             STR      R4,[SP, #+0]
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x0031             MOVS     R1,R6
     86          				out[n] = in[n] ^ iv[n];
   \                     ??AES_cbc_encrypt_5: (+1)
   \   00000074   0x782B             LDRB     R3,[R5, #+0]
   \   00000076   0x7802             LDRB     R2,[R0, #+0]
   \   00000078   0x405A             EORS     R2,R2,R3
   \   0000007A   0x9B00             LDR      R3,[SP, #+0]
   \   0000007C   0x701A             STRB     R2,[R3, #+0]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x1C6D             ADDS     R5,R5,#+1
   \   00000082   0x9A00             LDR      R2,[SP, #+0]
   \   00000084   0x1C52             ADDS     R2,R2,#+1
   \   00000086   0x9200             STR      R2,[SP, #+0]
   \   00000088   0x1E49             SUBS     R1,R1,#+1
   \   0000008A   0xD1F3             BNE      ??AES_cbc_encrypt_5
     87          			for(n=len; n < AES_BLOCK_SIZE; ++n)
   \   0000008C   0x2E10             CMP      R6,#+16
   \   0000008E   0xD209             BCS      ??AES_cbc_encrypt_6
   \   00000090   0x19A0             ADDS     R0,R4,R6
   \   00000092   0x19B9             ADDS     R1,R7,R6
   \   00000094   0x2210             MOVS     R2,#+16
   \   00000096   0x1B92             SUBS     R2,R2,R6
     88          				out[n] = iv[n];
   \                     ??AES_cbc_encrypt_7: (+1)
   \   00000098   0x780B             LDRB     R3,[R1, #+0]
   \   0000009A   0x7003             STRB     R3,[R0, #+0]
   \   0000009C   0x1C49             ADDS     R1,R1,#+1
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0x1E52             SUBS     R2,R2,#+1
   \   000000A2   0xD1F9             BNE      ??AES_cbc_encrypt_7
     89          			AES_encrypt(out, out, key);
   \                     ??AES_cbc_encrypt_6: (+1)
   \   000000A4   0x9A06             LDR      R2,[SP, #+24]
   \   000000A6   0x0021             MOVS     R1,R4
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       AES_encrypt
     90          			iv = out;
   \   000000AE   0x0027             MOVS     R7,R4
     91          		}
     92          		memcpy(ivec,iv,AES_BLOCK_SIZE);
   \   000000B0   0xE08E             B.N      ??AES_cbc_encrypt_4
     93          	} else if (in != out) {
   \                     ??AES_cbc_encrypt_0: (+1)
   \   000000B2   0x42A5             CMP      R5,R4
   \   000000B4   0xD157             BNE      ??AES_cbc_encrypt_8
   \   000000B6   0x2A10             CMP      R2,#+16
   \   000000B8   0xD32A             BCC      ??AES_cbc_encrypt_9
     94          		while (len >= AES_BLOCK_SIZE) {
     95          			AES_decrypt(in, out, key);
     96          			for(n=0; n < AES_BLOCK_SIZE; ++n)
     97          				out[n] ^= iv[n];
     98          			iv = in;
     99          			len -= AES_BLOCK_SIZE;
    100          			in  += AES_BLOCK_SIZE;
    101          			out += AES_BLOCK_SIZE;
    102          		}
    103          		if (len) {
    104          			AES_decrypt(in,tmp,key);
    105          			for(n=0; n < len; ++n)
    106          				out[n] = tmp[n] ^ iv[n];
    107          			iv = in;
    108          		}
    109          		memcpy(ivec,iv,AES_BLOCK_SIZE);
    110          	} else {
    111          		while (len >= AES_BLOCK_SIZE) {
    112          			memcpy(tmp, in, AES_BLOCK_SIZE);
   \                     ??AES_cbc_encrypt_10: (+1)
   \   000000BA   0x2210             MOVS     R2,#+16
   \   000000BC   0x0029             MOVS     R1,R5
   \   000000BE   0xA801             ADD      R0,SP,#+4
   \   000000C0   0x.... 0x....      BL       __aeabi_memcpy
    113          			AES_decrypt(in, out, key);
   \   000000C4   0x9A06             LDR      R2,[SP, #+24]
   \   000000C6   0x0021             MOVS     R1,R4
   \   000000C8   0x0028             MOVS     R0,R5
   \   000000CA   0x.... 0x....      BL       AES_decrypt
    114          			for(n=0; n < AES_BLOCK_SIZE; ++n)
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x990C             LDR      R1,[SP, #+48]
   \   000000D2   0x2204             MOVS     R2,#+4
    115          				out[n] ^= ivec[n];
   \                     ??AES_cbc_encrypt_11: (+1)
   \   000000D4   0x7803             LDRB     R3,[R0, #+0]
   \   000000D6   0x780F             LDRB     R7,[R1, #+0]
   \   000000D8   0x405F             EORS     R7,R7,R3
   \   000000DA   0x7007             STRB     R7,[R0, #+0]
   \   000000DC   0x7843             LDRB     R3,[R0, #+1]
   \   000000DE   0x784F             LDRB     R7,[R1, #+1]
   \   000000E0   0x405F             EORS     R7,R7,R3
   \   000000E2   0x7047             STRB     R7,[R0, #+1]
   \   000000E4   0x7883             LDRB     R3,[R0, #+2]
   \   000000E6   0x788F             LDRB     R7,[R1, #+2]
   \   000000E8   0x405F             EORS     R7,R7,R3
   \   000000EA   0x7087             STRB     R7,[R0, #+2]
   \   000000EC   0x78C3             LDRB     R3,[R0, #+3]
   \   000000EE   0x78CF             LDRB     R7,[R1, #+3]
   \   000000F0   0x405F             EORS     R7,R7,R3
   \   000000F2   0x70C7             STRB     R7,[R0, #+3]
   \   000000F4   0x1D09             ADDS     R1,R1,#+4
   \   000000F6   0x1D00             ADDS     R0,R0,#+4
   \   000000F8   0x1E52             SUBS     R2,R2,#+1
   \   000000FA   0xD1EB             BNE      ??AES_cbc_encrypt_11
    116          			memcpy(ivec, tmp, AES_BLOCK_SIZE);
   \   000000FC   0x2210             MOVS     R2,#+16
   \   000000FE   0xA901             ADD      R1,SP,#+4
   \   00000100   0x980C             LDR      R0,[SP, #+48]
   \   00000102   0x.... 0x....      BL       __aeabi_memcpy
    117          			len -= AES_BLOCK_SIZE;
   \   00000106   0x3E10             SUBS     R6,R6,#+16
    118          			in += AES_BLOCK_SIZE;
   \   00000108   0x3510             ADDS     R5,R5,#+16
    119          			out += AES_BLOCK_SIZE;
   \   0000010A   0x3410             ADDS     R4,R4,#+16
    120          		}
   \   0000010C   0x2E10             CMP      R6,#+16
   \   0000010E   0xD2D4             BCS      ??AES_cbc_encrypt_10
    121          		if (len) {
   \                     ??AES_cbc_encrypt_9: (+1)
   \   00000110   0x2E00             CMP      R6,#+0
   \   00000112   0xD026             BEQ      ??AES_cbc_encrypt_12
    122          			memcpy(tmp, in, AES_BLOCK_SIZE);
   \   00000114   0x2210             MOVS     R2,#+16
   \   00000116   0x0029             MOVS     R1,R5
   \   00000118   0xA801             ADD      R0,SP,#+4
   \   0000011A   0x.... 0x....      BL       __aeabi_memcpy
    123          			AES_decrypt(tmp, out, key);
   \   0000011E   0x9A06             LDR      R2,[SP, #+24]
   \   00000120   0x0021             MOVS     R1,R4
   \   00000122   0xA801             ADD      R0,SP,#+4
   \   00000124   0x.... 0x....      BL       AES_decrypt
    124          			for(n=0; n < len; ++n)
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x990C             LDR      R1,[SP, #+48]
   \   0000012C   0x0032             MOVS     R2,R6
    125          				out[n] ^= ivec[n];
   \                     ??AES_cbc_encrypt_13: (+1)
   \   0000012E   0x7803             LDRB     R3,[R0, #+0]
   \   00000130   0x780D             LDRB     R5,[R1, #+0]
   \   00000132   0x405D             EORS     R5,R5,R3
   \   00000134   0x7005             STRB     R5,[R0, #+0]
   \   00000136   0x1C49             ADDS     R1,R1,#+1
   \   00000138   0x1C40             ADDS     R0,R0,#+1
   \   0000013A   0x1E52             SUBS     R2,R2,#+1
   \   0000013C   0xD1F7             BNE      ??AES_cbc_encrypt_13
    126          			for(n=len; n < AES_BLOCK_SIZE; ++n)
   \   0000013E   0x2E10             CMP      R6,#+16
   \   00000140   0xD20A             BCS      ??AES_cbc_encrypt_14
   \   00000142   0x19A0             ADDS     R0,R4,R6
   \   00000144   0xA901             ADD      R1,SP,#+4
   \   00000146   0x1989             ADDS     R1,R1,R6
   \   00000148   0x2210             MOVS     R2,#+16
   \   0000014A   0x1B92             SUBS     R2,R2,R6
    127          				out[n] = tmp[n];
   \                     ??AES_cbc_encrypt_15: (+1)
   \   0000014C   0x780B             LDRB     R3,[R1, #+0]
   \   0000014E   0x7003             STRB     R3,[R0, #+0]
   \   00000150   0x1C49             ADDS     R1,R1,#+1
   \   00000152   0x1C40             ADDS     R0,R0,#+1
   \   00000154   0x1E52             SUBS     R2,R2,#+1
   \   00000156   0xD1F9             BNE      ??AES_cbc_encrypt_15
    128          			memcpy(ivec, tmp, AES_BLOCK_SIZE);
   \                     ??AES_cbc_encrypt_14: (+1)
   \   00000158   0x2210             MOVS     R2,#+16
   \   0000015A   0xA901             ADD      R1,SP,#+4
   \   0000015C   0x980C             LDR      R0,[SP, #+48]
   \   0000015E   0x.... 0x....      BL       __aeabi_memcpy
    129          		}
    130          	}
    131          }
   \                     ??AES_cbc_encrypt_12: (+1)
   \   00000162   0xB007             ADD      SP,SP,#+28
   \   00000164   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??AES_cbc_encrypt_8: (+1)
   \   00000166   0x2A10             CMP      R2,#+16
   \   00000168   0xD320             BCC      ??AES_cbc_encrypt_16
   \                     ??AES_cbc_encrypt_17: (+1)
   \   0000016A   0x9A06             LDR      R2,[SP, #+24]
   \   0000016C   0x0021             MOVS     R1,R4
   \   0000016E   0x0028             MOVS     R0,R5
   \   00000170   0x.... 0x....      BL       AES_decrypt
   \   00000174   0x0020             MOVS     R0,R4
   \   00000176   0x2104             MOVS     R1,#+4
   \                     ??AES_cbc_encrypt_18: (+1)
   \   00000178   0x7802             LDRB     R2,[R0, #+0]
   \   0000017A   0x783B             LDRB     R3,[R7, #+0]
   \   0000017C   0x4053             EORS     R3,R3,R2
   \   0000017E   0x7003             STRB     R3,[R0, #+0]
   \   00000180   0x7842             LDRB     R2,[R0, #+1]
   \   00000182   0x787B             LDRB     R3,[R7, #+1]
   \   00000184   0x4053             EORS     R3,R3,R2
   \   00000186   0x7043             STRB     R3,[R0, #+1]
   \   00000188   0x7882             LDRB     R2,[R0, #+2]
   \   0000018A   0x78BB             LDRB     R3,[R7, #+2]
   \   0000018C   0x4053             EORS     R3,R3,R2
   \   0000018E   0x7083             STRB     R3,[R0, #+2]
   \   00000190   0x78C2             LDRB     R2,[R0, #+3]
   \   00000192   0x78FB             LDRB     R3,[R7, #+3]
   \   00000194   0x4053             EORS     R3,R3,R2
   \   00000196   0x70C3             STRB     R3,[R0, #+3]
   \   00000198   0x1D3F             ADDS     R7,R7,#+4
   \   0000019A   0x1D00             ADDS     R0,R0,#+4
   \   0000019C   0x1E49             SUBS     R1,R1,#+1
   \   0000019E   0xD1EB             BNE      ??AES_cbc_encrypt_18
   \   000001A0   0x002F             MOVS     R7,R5
   \   000001A2   0x3E10             SUBS     R6,R6,#+16
   \   000001A4   0x3510             ADDS     R5,R5,#+16
   \   000001A6   0x3410             ADDS     R4,R4,#+16
   \   000001A8   0x2E10             CMP      R6,#+16
   \   000001AA   0xD2DE             BCS      ??AES_cbc_encrypt_17
   \                     ??AES_cbc_encrypt_16: (+1)
   \   000001AC   0x2E00             CMP      R6,#+0
   \   000001AE   0xD00F             BEQ      ??AES_cbc_encrypt_4
   \   000001B0   0x9A06             LDR      R2,[SP, #+24]
   \   000001B2   0xA901             ADD      R1,SP,#+4
   \   000001B4   0x0028             MOVS     R0,R5
   \   000001B6   0x.... 0x....      BL       AES_decrypt
   \   000001BA   0xA801             ADD      R0,SP,#+4
   \                     ??AES_cbc_encrypt_19: (+1)
   \   000001BC   0x7801             LDRB     R1,[R0, #+0]
   \   000001BE   0x783A             LDRB     R2,[R7, #+0]
   \   000001C0   0x404A             EORS     R2,R2,R1
   \   000001C2   0x7022             STRB     R2,[R4, #+0]
   \   000001C4   0x1C7F             ADDS     R7,R7,#+1
   \   000001C6   0x1C40             ADDS     R0,R0,#+1
   \   000001C8   0x1C64             ADDS     R4,R4,#+1
   \   000001CA   0x1E76             SUBS     R6,R6,#+1
   \   000001CC   0xD1F6             BNE      ??AES_cbc_encrypt_19
   \   000001CE   0x002F             MOVS     R7,R5
   \                     ??AES_cbc_encrypt_4: (+1)
   \   000001D0   0x2210             MOVS     R2,#+16
   \   000001D2   0x0039             MOVS     R1,R7
   \   000001D4   0x980C             LDR      R0,[SP, #+48]
   \   000001D6   0x.... 0x....      BL       __aeabi_memcpy
   \   000001DA   0xE7C2             B        ??AES_cbc_encrypt_12
    132          #endif
    133          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   AES_cbc_encrypt
        48   -> AES_decrypt
        48   -> AES_encrypt
        48   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     476  AES_cbc_encrypt

 
 476 bytes in section .text
 
 476 bytes of CODE memory

Errors: none
Warnings: none
