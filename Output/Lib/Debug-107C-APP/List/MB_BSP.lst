###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  20:53:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Ports\STM32\STM32F103\IAR\MB_BSP.C
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Ports\STM32\STM32F103\IAR\MB_BSP.C
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -D DEBUG -D IMAGE_A -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\List\MB_BSP.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\Obj\MB_BSP.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Ports\STM32\STM32F103\IAR\MB_BSP.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                            uC/Modbus
     19          *
     20          *                                      MODBUS BOARD SUPPORT PACKAGE
     21          *                                         Philips LPC2000 (ARM7)
     22          *
     23          * Filename    : mb_bsp.c
     24          * Version     : V2.12
     25          * Programmers : JJL
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          #include  <global.h>
     35          #include <includes.h>
     36          
     37          /*
     38          *********************************************************************************************************
     39          *                                            LOCAL DEFINES 
     40          *********************************************************************************************************
     41          */
     42          
     43          #define  BIT0                       0x01
     44          #define  BIT1                       0x02
     45          #define  BIT2                       0x04
     46          #define  BIT3                       0x08
     47          #define  BIT4                       0x10
     48          #define  BIT5                       0x20
     49          #define  BIT6                       0x40
     50          #define  BIT7                       0x80
     51          
     52          #define UARAT_CFG_MAX_PORT          5           // 定义最大串口数量
     53          /***********************************************
     54          * 描述： 
     55          */
     56          #define  BSP_COM1_TXD               DEF_BIT_09
     57          #define  BSP_COM1_RXD               DEF_BIT_10
     58          
     59          #define  BSP_COM2_TXD               DEF_BIT_02
     60          #define  BSP_COM2_RXD               DEF_BIT_03
     61          
     62          #define  BSP_COM3_TXD               DEF_BIT_02
     63          #define  BSP_COM3_RXD               DEF_BIT_03
     64          
     65          /***********************************************
     66          * 描述： 
     67          */
     68          #define  BSP_COM1_REN               DEF_ENABLED
     69          #define  BSP_COM2_REN               DEF_ENABLED
     70          #define  BSP_COM3_REN               DEF_ENABLED
     71          #define  BSP_COM4_REN               DEF_ENABLED
     72          
     73          #define  BSP_COM1_SEN               DEF_ENABLED
     74          #define  BSP_COM2_SEN               DEF_ENABLED
     75          #define  BSP_COM3_SEN               DEF_ENABLED
     76          #define  BSP_COM4_SEN               DEF_DISABLED
     77          
     78          /***********************************************
     79          * 描述： 
     80          */
     81          #if (BSP_COM1_REN == DEF_ENABLED)
     82          #define MBREN1_GPIO_PIN        GPIO_Pin_15//8             /* PA.08 */
     83          #define MBREN1_GPIO_PORT       GPIOA
     84          #define MBREN1_GPIO_RCC        RCC_APB2Periph_GPIOA
     85          #endif
     86          
     87          #if (BSP_COM2_REN == DEF_ENABLED)
     88          #define MBREN2_GPIO_PIN        GPIO_Pin_0             /* PA.00 */
     89          #define MBREN2_GPIO_PORT       GPIOA
     90          #define MBREN2_GPIO_RCC        RCC_APB2Periph_GPIOA
     91          #endif
     92          
     93          #if (BSP_COM3_REN == DEF_ENABLED)
     94          #define MBREN3_GPIO_PIN        GPIO_Pin_15             /* PE.15 */
     95          #define MBREN3_GPIO_PORT       GPIOE
     96          #define MBREN3_GPIO_RCC        RCC_APB2Periph_GPIOE     
     97          #endif
     98          
     99          #if (BSP_COM4_REN == DEF_ENABLED)
    100          #define MBREN4_GPIO_PIN        GPIO_Pin_0//15             /* PE.15 */
    101          #define MBREN4_GPIO_PORT       GPIOD//A
    102          #define MBREN4_GPIO_RCC        RCC_APB2Periph_GPIOD//A
    103          #endif
    104          /*
    105          *********************************************************************************************************
    106          *                                             LOCAL VARIABLES
    107          *********************************************************************************************************
    108          */
    109          

   \                                 In section .bss, align 4
    110          static  CPU_INT32U  MB_Tmr_ReloadCnts;
   \                     MB_Tmr_ReloadCnts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    111          static  MODBUS_CH  *MB_ChPortMap[UARAT_CFG_MAX_PORT] = {NULL,NULL,NULL,NULL,NULL};
   \                     MB_ChPortMap:
   \   00000000                      DS8 20
    112          
    113          void            USART1_RxTxISRHandler   (void);
    114          void            USART2_RxTxISRHandler   (void);
    115          void            USART3_RxTxISRHandler   (void);
    116          void            USART4_RxTxISRHandler   (void);
    117          void            USARTx_RxTxISRHandler   (MODBUS_CH *pch);
    118          
    119          /*$PAGE*/
    120          /*
    121          *********************************************************************************************************
    122          *                                             MB_CommExit()
    123          *
    124          * Description : This function is called to terminate Modbus communications.  All Modbus channels are close.
    125          *
    126          * Argument(s) : none
    127          *
    128          * Return(s)   : none.
    129          *
    130          * Caller(s)   : MB_Exit()
    131          *
    132          * Note(s)     : none.
    133          *********************************************************************************************************
    134          */

   \                                 In section .text, align 2, keep-with-next
    135          void  MB_CommExit (void)
    136          {
   \                     MB_CommExit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    137              CPU_INT08U   ch;
    138              MODBUS_CH   *pch;
    139          
    140          
    141              pch = &MB_ChTbl[0];
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable10
    142              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0xE008             B.N      ??MB_CommExit_0
    143                  MB_CommTxIntDis(pch);
   \                     ??MB_CommExit_1: (+1)
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       MB_CommTxIntDis
    144                  MB_CommRxIntDis(pch);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       MB_CommRxIntDis
    145                  pch++;
   \   00000016   0xF504 0x648D      ADD      R4,R4,#+1128
    146              }
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MB_CommExit_0: (+1)
   \   0000001C   0x2D04             CMP      R5,#+4
   \   0000001E   0xDBF4             BLT.N    ??MB_CommExit_1
    147          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    148          
    149          /*$PAGE*/
    150          /*
    151          *********************************************************************************************************
    152          *                                           MB_CommPortCfg()
    153          *
    154          * Description : This function initializes the serial port to the desired baud rate and the UART will be
    155          *               configured for N, 8, 1 (No parity, 8 bits, 1 stop).
    156          *
    157          * Argument(s) : pch        is a pointer to the Modbus channel
    158          *               port_nbr   is the desired serial port number.  This argument allows you to assign a
    159          *                          specific serial port to a sepcific Modbus channel.
    160          *               baud       is the desired baud rate for the serial port.
    161          *               parity     is the desired parity and can be either:
    162          *
    163          *                          MODBUS_PARITY_NONE
    164          *                          MODBUS_PARITY_ODD
    165          *                          MODBUS_PARITY_EVEN
    166          *
    167          *               bits       specifies the number of bit and can be either 7 or 8.
    168          *               stops      specifies the number of stop bits and can either be 1 or 2
    169          *
    170          * Return(s)   : none.
    171          *
    172          * Caller(s)   : MB_CfgCh()
    173          *
    174          * Note(s)     : none.
    175          *********************************************************************************************************
    176          */

   \                                 In section .text, align 4, keep-with-next
    177          void  MB_CommPortCfg (MODBUS_CH  *pch,
    178                                CPU_INT08U  port_nbr,
    179                                CPU_INT32U  baud,
    180                                CPU_INT16U  bits,
    181                                CPU_INT16U  parity,
    182                                CPU_INT16U  stops)
    183          {
   \                     MB_CommPortCfg: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   \   0000000E   0x2D05             CMP      R5,#+5
   \   00000010   0xF280 0x8093      BGE.W    ??MB_CommPortCfg_1
    184              USART_InitTypeDef USART_InitStructure;
    185              GPIO_InitTypeDef  GPIO_InitStructure;
    186              INT16U            BSP_INT_ID_USARTx;
    187              USART_TypeDef*    USARTx;
    188              CPU_FNCT_VOID     USARTx_RxTxISRHandler;
    189              
    190              /***********************************************
    191              * 描述： 串口3引脚接到地，不能使用
    192              */
    193              if ( port_nbr >= UARAT_CFG_MAX_PORT )
    194                return;
    195              
    196              /***********************************************
    197              * 描述： 
    198              */
    199              switch ( port_nbr ) {
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xF200 0x808F      BHI.W    ??MB_CommPortCfg_1
   \   0000001C   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??MB_CommPortCfg_0:
   \   00000020   0x0004 0x0090      DC16     0x4,0x90,0xCE,0x112
   \              0x00CE 0x0112
    200              case 0:
    201                  USARTx                    = USART1;
   \                     ??MB_CommPortCfg_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R8,??DataTable10_1  ;; 0x40013800
    202                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART1;
   \   0000002C   0xF04F 0x0925      MOV      R9,#+37
    203                  USARTx_RxTxISRHandler     = USART1_RxTxISRHandler;
   \   00000030   0x.... 0x....      ADR.W    R10,USART1_RxTxISRHandler
    204                  
    205                  /* Enable USART1 clock */
    206                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    207                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    208                  
    209                  /* Configure USART1 Rx (PA.10) as input floating */
    210                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000046   0xF44F 0x6080      MOV      R0,#+1024
   \   0000004A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    211                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0xF88D 0x0007      STRB     R0,[SP, #+7]
    212                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000054   0x.... 0x....      LDR.W    R11,??DataTable10_2  ;; 0x40010800
   \   00000058   0xA901             ADD      R1,SP,#+4
   \   0000005A   0x4658             MOV      R0,R11
   \   0000005C   0x.... 0x....      BL       GPIO_Init
    213                  
    214                  /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    215                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000060   0xF44F 0x7000      MOV      R0,#+512
   \   00000064   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    216                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000068   0x2003             MOVS     R0,#+3
   \   0000006A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    217                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000006E   0x2018             MOVS     R0,#+24
   \   00000070   0xF88D 0x0007      STRB     R0,[SP, #+7]
    218                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000074   0xA901             ADD      R1,SP,#+4
   \   00000076   0x4658             MOV      R0,R11
   \   00000078   0x.... 0x....      BL       GPIO_Init
    219                  
    220                  /***********************************************
    221                  * 描述： 接收发送使能信号
    222                  */
    223          #if (BSP_COM1_REN == DEF_ENABLED)
    224                  RCC_APB2PeriphClockCmd(MBREN1_GPIO_RCC, ENABLE);
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    225                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x4608             MOV      R0,R1
   \   00000088   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    226                  GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x300200
   \   00000092   0x.... 0x....      BL       GPIO_PinRemapConfig
    227                  GPIO_InitStructure.GPIO_Pin   = MBREN1_GPIO_PIN;
   \   00000096   0xF44F 0x4000      MOV      R0,#+32768
   \   0000009A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    228                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0xF88D 0x0006      STRB     R0,[SP, #+6]
    229                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   000000A4   0x2010             MOVS     R0,#+16
   \   000000A6   0xF88D 0x0007      STRB     R0,[SP, #+7]
    230                  GPIO_Init(MBREN1_GPIO_PORT, &GPIO_InitStructure);
   \   000000AA   0xA901             ADD      R1,SP,#+4
   \   000000AC   0x4658             MOV      R0,R11
   \   000000AE   0x.... 0x....      BL       GPIO_Init
    231                  GPIO_ResetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);  // 低电平接收使能 
   \   000000B2   0xF44F 0x4100      MOV      R1,#+32768
   \   000000B6   0x4658             MOV      R0,R11
   \   000000B8   0x.... 0x....      BL       GPIO_ResetBits
    232          #endif
    233                  
    234                  break;
    235              case 1:
    236                  USARTx                    = USART2;
    237                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART2;
    238                  USARTx_RxTxISRHandler     = USART2_RxTxISRHandler;
    239                  
    240                  /* Enable USART2 clock */
    241                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    242                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    243                  
    244                  /* Configure USART1 Rx (PA.3) as input floating */
    245                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    246                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    247                  GPIO_Init(GPIOA, &GPIO_InitStructure);
    248                  
    249                  /* Configure USART1 Tx (PA.2) as alternate function push-pull */
    250                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    251                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    252                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    253                  GPIO_Init(GPIOA, &GPIO_InitStructure);
    254                  
    255                  /***********************************************
    256                  * 描述： 接收发送使能信号
    257                  */
    258          #if (BSP_COM2_REN == DEF_ENABLED)
    259                  GPIO_InitTypeDef  GPIO_InitStructure;
    260                  RCC_APB2PeriphClockCmd(MBREN2_GPIO_RCC, ENABLE);
    261                  GPIO_InitStructure.GPIO_Pin   = MBREN2_GPIO_PIN;
    262                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    263                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    264                  GPIO_Init(MBREN2_GPIO_PORT, &GPIO_InitStructure);
    265                  
    266                  GPIO_ResetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);  // 低电平接收使能  
    267          #endif
    268                  break;
    269              case 2:
    270                  USARTx                    = USART3;
    271                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART3;
    272                  USARTx_RxTxISRHandler     = USART3_RxTxISRHandler;
    273                  
    274                  /* Enable USART3 clock */
    275                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    276                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    277                  
    278                  /* Configure USART1 Rx (PB.11) as input floating */
    279                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    280                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    281                  GPIO_Init(GPIOB, &GPIO_InitStructure);
    282                  
    283                  /* Configure USART1 Tx (PB.10) as alternate function push-pull */
    284                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    285                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    286                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    287                  GPIO_Init(GPIOB, &GPIO_InitStructure);
    288                  
    289                  /***********************************************
    290                  * 描述： 接收发送使能信号
    291                  */
    292          #if (BSP_COM3_REN == DEF_ENABLED)
    293                  RCC_APB2PeriphClockCmd(MBREN3_GPIO_RCC, ENABLE);
    294                  GPIO_InitStructure.GPIO_Pin   = MBREN3_GPIO_PIN;
    295                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    296                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    297                  GPIO_Init(MBREN3_GPIO_PORT, &GPIO_InitStructure);
    298                  
    299                  GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能  
    300          #endif
    301                  break;
    302              case 3:
    303                  USARTx                    = UART4;
    304                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART4;
    305                  USARTx_RxTxISRHandler     = USART4_RxTxISRHandler;
    306                  
    307                  /* Enable USART4 clock */
    308                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    309                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
    310                  
    311                  /* Configure USART4 Rx (PC.11) as input floating */
    312                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    313                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    314                  GPIO_Init(GPIOC, &GPIO_InitStructure);
    315                  
    316                  /* Configure USART4 Tx (PC.10) as alternate function push-pull */
    317                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    318                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    319                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    320                  GPIO_Init(GPIOC, &GPIO_InitStructure);
    321                  
    322                  /***********************************************
    323                  * 描述： 接收发送使能信号
    324                  */
    325          #if (BSP_COM4_REN == DEF_ENABLED)
    326                  RCC_APB2PeriphClockCmd(MBREN4_GPIO_RCC, ENABLE);
    327                  GPIO_InitStructure.GPIO_Pin   = MBREN4_GPIO_PIN;
    328                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    329                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    330                  GPIO_Init(MBREN4_GPIO_PORT, &GPIO_InitStructure);
    331          
    332                  GPIO_ResetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);  // 低电平接收使能  
    333          #endif
    334                  break;
    335              default:
    336                  return;
    337              }    
    338              
    339              if (pch != (MODBUS_CH *)0) {
   \                     ??MB_CommPortCfg_3: (+1)
   \   000000BC   0x2C00             CMP      R4,#+0
   \   000000BE   0xD00C             BEQ.N    ??MB_CommPortCfg_4
    340                  pch->PortNbr            = port_nbr;                                 /* Store configuration in channel             */
   \   000000C0   0x7265             STRB     R5,[R4, #+9]
    341                  pch->BaudRate           = baud;
   \   000000C2   0x60E6             STR      R6,[R4, #+12]
    342                  pch->Parity             = parity;
   \   000000C4   0x9810             LDR      R0,[SP, #+64]
   \   000000C6   0x7420             STRB     R0,[R4, #+16]
    343                  pch->Bits               = bits;
   \   000000C8   0x7467             STRB     R7,[R4, #+17]
    344                  pch->Stops              = stops;
   \   000000CA   0x9811             LDR      R0,[SP, #+68]
   \   000000CC   0x74A0             STRB     R0,[R4, #+18]
    345                  pch->USARTx             = USARTx;        
   \   000000CE   0xF8C4 0x8460      STR      R8,[R4, #+1120]
    346                  MB_ChPortMap[port_nbr]  = pch;
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   000000D6   0xF840 0x4025      STR      R4,[R0, R5, LSL #+2]
    347              }
    348              
    349              /***********************************************
    350              * 描述： configuration
    351              */
    352              USART_InitStructure.USART_BaudRate              = baud;
   \                     ??MB_CommPortCfg_4: (+1)
   \   000000DA   0x9602             STR      R6,[SP, #+8]
    353              USART_InitStructure.USART_WordLength            = USART_WordLength_8b;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x9003             STR      R0,[SP, #+12]
    354              USART_InitStructure.USART_StopBits              = USART_StopBits_1;
    355              USART_InitStructure.USART_Parity                = USART_Parity_No;
   \   000000E0   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    356              USART_InitStructure.USART_HardwareFlowControl   = USART_HardwareFlowControl_None;
   \   000000E4   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    357              USART_InitStructure.USART_Mode                  = USART_Mode_Rx | USART_Mode_Tx;
   \   000000E8   0x200C             MOVS     R0,#+12
   \   000000EA   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    358              
    359              /***********************************************
    360              * 描述： 
    361              */
    362              USART_DeInit(USARTx);
   \   000000EE   0x4640             MOV      R0,R8
   \   000000F0   0x.... 0x....      BL       USART_DeInit
    363              USART_Init(USARTx, &USART_InitStructure);
   \   000000F4   0xA902             ADD      R1,SP,#+8
   \   000000F6   0x4640             MOV      R0,R8
   \   000000F8   0x.... 0x....      BL       USART_Init
    364              
    365              /***********************************************
    366              * 描述： 
    367              */
    368              //if ( port_nbr != 3 )
    369                  USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
   \   000000FC   0x2201             MOVS     R2,#+1
   \   000000FE   0xF240 0x5125      MOVW     R1,#+1317
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0x.... 0x....      BL       USART_ITConfig
    370              USART_ITConfig(USARTx, USART_IT_TXE, DISABLE);
   \   00000108   0x2200             MOVS     R2,#+0
   \   0000010A   0xF240 0x7127      MOVW     R1,#+1831
   \   0000010E   0x4640             MOV      R0,R8
   \   00000110   0x.... 0x....      BL       USART_ITConfig
    371              //USART_ITConfig(USARTx, USART_IT_IDLE, ENABLE);
    372              
    373              /***********************************************
    374              * 描述： 
    375              */
    376              USART_ClearFlag(USARTx,USART_FLAG_TXE);
   \   00000114   0x2180             MOVS     R1,#+128
   \   00000116   0x4640             MOV      R0,R8
   \   00000118   0x.... 0x....      BL       USART_ClearFlag
    377              USART_ClearFlag(USARTx,USART_FLAG_RXNE);
   \   0000011C   0x2120             MOVS     R1,#+32
   \   0000011E   0x4640             MOV      R0,R8
   \   00000120   0x.... 0x....      BL       USART_ClearFlag
    378              //USART_ClearFlag(USARTx,USART_FLAG_IDLE);      
    379              
    380              /***********************************************
    381              * 描述： 
    382              */
    383              USART_Cmd(USARTx, ENABLE);
   \   00000124   0x2101             MOVS     R1,#+1
   \   00000126   0x4640             MOV      R0,R8
   \   00000128   0x.... 0x....      BL       USART_Cmd
    384              
    385              /***********************************************
    386              * 描述： 
    387              */
    388              BSP_IntVectSet(BSP_INT_ID_USARTx, USARTx_RxTxISRHandler);
   \   0000012C   0x4651             MOV      R1,R10
   \   0000012E   0x4648             MOV      R0,R9
   \   00000130   0x.... 0x....      BL       BSP_IntVectSet
    389              BSP_IntEn(BSP_INT_ID_USARTx);
   \   00000134   0x4648             MOV      R0,R9
   \   00000136   0x.... 0x....      BL       BSP_IntEn
    390          }
   \                     ??MB_CommPortCfg_1: (+1)
   \   0000013A   0xB007             ADD      SP,SP,#+28
   \   0000013C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??MB_CommPortCfg_5: (+1)
   \   00000140   0x.... 0x....      LDR.W    R8,??DataTable10_5  ;; 0x40004400
   \   00000144   0xF04F 0x0926      MOV      R9,#+38
   \   00000148   0x.... 0x....      ADR.W    R10,USART2_RxTxISRHandler
   \   0000014C   0x2101             MOVS     R1,#+1
   \   0000014E   0xF44F 0x3000      MOV      R0,#+131072
   \   00000152   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0x2004             MOVS     R0,#+4
   \   0000015A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   0000015E   0x2008             MOVS     R0,#+8
   \   00000160   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000164   0x2004             MOVS     R0,#+4
   \   00000166   0xF88D 0x0007      STRB     R0,[SP, #+7]
   \   0000016A   0x.... 0x....      LDR.W    R11,??DataTable10_2  ;; 0x40010800
   \   0000016E   0xA901             ADD      R1,SP,#+4
   \   00000170   0x4658             MOV      R0,R11
   \   00000172   0x.... 0x....      BL       GPIO_Init
   \   00000176   0x2004             MOVS     R0,#+4
   \   00000178   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000017C   0x2003             MOVS     R0,#+3
   \   0000017E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   \   00000182   0x2018             MOVS     R0,#+24
   \   00000184   0xF88D 0x0007      STRB     R0,[SP, #+7]
   \   00000188   0xA901             ADD      R1,SP,#+4
   \   0000018A   0x4658             MOV      R0,R11
   \   0000018C   0x.... 0x....      BL       GPIO_Init
   \   00000190   0x2101             MOVS     R1,#+1
   \   00000192   0x2004             MOVS     R0,#+4
   \   00000194   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000019E   0x2003             MOVS     R0,#+3
   \   000001A0   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   000001A4   0x2010             MOVS     R0,#+16
   \   000001A6   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   000001AA   0x4669             MOV      R1,SP
   \   000001AC   0x4658             MOV      R0,R11
   \   000001AE   0x.... 0x....      BL       GPIO_Init
   \   000001B2   0x2101             MOVS     R1,#+1
   \   000001B4   0x4658             MOV      R0,R11
   \   000001B6   0x.... 0x....      BL       GPIO_ResetBits
   \   000001BA   0xE77F             B.N      ??MB_CommPortCfg_3
   \                     ??MB_CommPortCfg_6: (+1)
   \   000001BC   0x.... 0x....      LDR.W    R8,??DataTable10_6  ;; 0x40004800
   \   000001C0   0xF04F 0x0927      MOV      R9,#+39
   \   000001C4   0x.... 0x....      ADR.W    R10,USART3_RxTxISRHandler
   \   000001C8   0x2101             MOVS     R1,#+1
   \   000001CA   0xF44F 0x2080      MOV      R0,#+262144
   \   000001CE   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   000001D2   0x2101             MOVS     R1,#+1
   \   000001D4   0x2008             MOVS     R0,#+8
   \   000001D6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   000001DA   0xF44F 0x6000      MOV      R0,#+2048
   \   000001DE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000001E2   0x2004             MOVS     R0,#+4
   \   000001E4   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   000001E8   0x.... 0x....      LDR.W    R11,??DataTable10_7  ;; 0x40010c00
   \   000001EC   0x4669             MOV      R1,SP
   \   000001EE   0x4658             MOV      R0,R11
   \   000001F0   0x.... 0x....      BL       GPIO_Init
   \   000001F4   0xF44F 0x6080      MOV      R0,#+1024
   \   000001F8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000001FC   0x2003             MOVS     R0,#+3
   \   000001FE   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000202   0x2018             MOVS     R0,#+24
   \   00000204   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000208   0x4669             MOV      R1,SP
   \   0000020A   0x4658             MOV      R0,R11
   \   0000020C   0x.... 0x....      BL       GPIO_Init
   \   00000210   0x2101             MOVS     R1,#+1
   \   00000212   0x2040             MOVS     R0,#+64
   \   00000214   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   00000218   0xF44F 0x4000      MOV      R0,#+32768
   \   0000021C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000220   0x2003             MOVS     R0,#+3
   \   00000222   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000226   0x2010             MOVS     R0,#+16
   \   00000228   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000022C   0x.... 0x....      LDR.W    R11,??DataTable10_8  ;; 0x40011800
   \   00000230   0x4669             MOV      R1,SP
   \   00000232   0x4658             MOV      R0,R11
   \   00000234   0x.... 0x....      BL       GPIO_Init
   \   00000238   0xF44F 0x4100      MOV      R1,#+32768
   \   0000023C   0x4658             MOV      R0,R11
   \   0000023E   0x.... 0x....      BL       GPIO_ResetBits
   \   00000242   0xE73B             B.N      ??MB_CommPortCfg_3
   \                     ??MB_CommPortCfg_7: (+1)
   \   00000244   0x.... 0x....      LDR.W    R8,??DataTable10_9  ;; 0x40004c00
   \   00000248   0xF04F 0x0934      MOV      R9,#+52
   \   0000024C   0x.... 0x....      ADR.W    R10,USART4_RxTxISRHandler
   \   00000250   0x2101             MOVS     R1,#+1
   \   00000252   0xF44F 0x2000      MOV      R0,#+524288
   \   00000256   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   0000025A   0x2101             MOVS     R1,#+1
   \   0000025C   0x2010             MOVS     R0,#+16
   \   0000025E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   00000262   0xF44F 0x6000      MOV      R0,#+2048
   \   00000266   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000026A   0x2004             MOVS     R0,#+4
   \   0000026C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000270   0x.... 0x....      LDR.W    R11,??DataTable10_10  ;; 0x40011000
   \   00000274   0x4669             MOV      R1,SP
   \   00000276   0x4658             MOV      R0,R11
   \   00000278   0x.... 0x....      BL       GPIO_Init
   \   0000027C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000280   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000284   0x2003             MOVS     R0,#+3
   \   00000286   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000028A   0x2018             MOVS     R0,#+24
   \   0000028C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000290   0x4669             MOV      R1,SP
   \   00000292   0x4658             MOV      R0,R11
   \   00000294   0x.... 0x....      BL       GPIO_Init
   \   00000298   0x2101             MOVS     R1,#+1
   \   0000029A   0x2020             MOVS     R0,#+32
   \   0000029C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   000002A0   0x2001             MOVS     R0,#+1
   \   000002A2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000002A6   0x2003             MOVS     R0,#+3
   \   000002A8   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   000002AC   0x2010             MOVS     R0,#+16
   \   000002AE   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   000002B2   0x.... 0x....      LDR.W    R11,??DataTable10_11  ;; 0x40011400
   \   000002B6   0x4669             MOV      R1,SP
   \   000002B8   0x4658             MOV      R0,R11
   \   000002BA   0x.... 0x....      BL       GPIO_Init
   \   000002BE   0x2101             MOVS     R1,#+1
   \   000002C0   0x4658             MOV      R0,R11
   \   000002C2   0x.... 0x....      BL       GPIO_ResetBits
   \   000002C6   0xE6F9             B.N      ??MB_CommPortCfg_3
    391          
    392          /*$PAGE*/
    393          /*
    394          *********************************************************************************************************
    395          *                                         MB_CommRxIntDis()
    396          *
    397          * Description : This function disables Rx interrupts.
    398          *
    399          * Argument(s) : pch        is a pointer to the Modbus channel
    400          *
    401          * Return(s)   : none.
    402          *
    403          * Caller(s)   : MB_CommExit()
    404          *
    405          * Note(s)     : none.
    406          *********************************************************************************************************
    407          */

   \                                 In section .text, align 4, keep-with-next
    408          void  MB_CommRxIntDis (MODBUS_CH  *pch)
    409          {
   \                     MB_CommRxIntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    410              CPU_SR  cpu_sr = 0;
    411          
    412              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    413              switch (pch->PortNbr) {
   \   0000000E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD82C             BHI.N    ??MB_CommRxIntDis_1
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??MB_CommRxIntDis_0:
   \   00000018   0x02 0x0E          DC8      0x2,0xE,0x19,0x25
   \              0x19 0x25    
    414              case 0:
    415                  /***********************************************
    416                  * 描述： 收发送使能控制信号
    417                  */
    418          #if (BSP_COM1_REN == DEF_ENABLED)
    419                  GPIO_SetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);        // 高电平发送使能 
   \                     ??MB_CommRxIntDis_2: (+1)
   \   0000001C   0xF44F 0x4100      MOV      R1,#+32768
   \   00000020   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40010800
   \   00000022   0x.... 0x....      BL       GPIO_SetBits
    420          #endif
    421                  USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002C   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40013800
   \   0000002E   0x.... 0x....      BL       USART_ITConfig
    422                  break;
   \   00000032   0xE01C             B.N      ??MB_CommRxIntDis_1
    423                  
    424              case 1:
    425                  /***********************************************
    426                  * 描述： 收发送使能控制信号
    427                  */
    428          #if (BSP_COM2_REN == DEF_ENABLED)
    429                  GPIO_SetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);        // 高电平发送使能 
   \                     ??MB_CommRxIntDis_3: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40010800
   \   00000038   0x.... 0x....      BL       GPIO_SetBits
    430          #endif
    431                  USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xF240 0x5125      MOVW     R1,#+1317
   \   00000042   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000044   0x.... 0x....      BL       USART_ITConfig
    432                  break;
   \   00000048   0xE011             B.N      ??MB_CommRxIntDis_1
    433                  
    434              case 2:
    435                  /***********************************************
    436                  * 描述： 收发送使能控制信号
    437                  */
    438          #if (BSP_COM3_REN == DEF_ENABLED)
    439                  GPIO_SetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);        // 高电平发送使能 
   \                     ??MB_CommRxIntDis_4: (+1)
   \   0000004A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000004E   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40011800
   \   00000050   0x.... 0x....      BL       GPIO_SetBits
    440          #endif
    441                  USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0xF240 0x5125      MOVW     R1,#+1317
   \   0000005A   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40004800
   \   0000005C   0x.... 0x....      BL       USART_ITConfig
    442                  break;
   \   00000060   0xE005             B.N      ??MB_CommRxIntDis_1
    443                  
    444              case 3:
    445                  /***********************************************
    446                  * 描述： 收发送使能控制信号
    447                  */
    448          #if (BSP_COM4_REN == DEF_ENABLED)
    449          #if BSP_COM4_SEN ==  DEF_ENABLED
    450                  GPIO_SetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);        // 高电平发送使能 
    451          #endif
    452          #endif
    453                  USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);
   \                     ??MB_CommRxIntDis_5: (+1)
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0xF240 0x5125      MOVW     R1,#+1317
   \   00000068   0x....             LDR.N    R0,??DataTable10_9  ;; 0x40004c00
   \   0000006A   0x.... 0x....      BL       USART_ITConfig
    454                  break;
    455              }
    456              CPU_CRITICAL_EXIT();
   \                     ??MB_CommRxIntDis_1: (+1)
   \   0000006E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000078   0x.... 0x....      B.W      CPU_SR_Restore
    457          }
    458          
    459          /*$PAGE*/
    460          /*
    461          *********************************************************************************************************
    462          *                                          MB_CommRxIntEn()
    463          *
    464          * Description : This function enables Rx interrupts.
    465          *
    466          * Argument(s) : pch        is a pointer to the Modbus channel
    467          *
    468          * Return(s)   : none.
    469          *
    470          * Caller(s)   : MB_TxByte()
    471          *
    472          * Note(s)     : none.
    473          *********************************************************************************************************
    474          */

   \                                 In section .text, align 4, keep-with-next
    475          void  MB_CommRxIntEn (MODBUS_CH  *pch)
    476          {
   \                     MB_CommRxIntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    477              CPU_SR  cpu_sr = 0;
    478          
    479              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    480              switch (pch->PortNbr) {
   \   0000000E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD830             BHI.N    ??MB_CommRxIntEn_1
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??MB_CommRxIntEn_0:
   \   00000018   0x02 0x0E          DC8      0x2,0xE,0x19,0x25
   \              0x19 0x25    
    481              case 0:
    482          #if (BSP_COM1_REN == DEF_ENABLED)
    483                  GPIO_ResetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_2: (+1)
   \   0000001C   0xF44F 0x4100      MOV      R1,#+32768
   \   00000020   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40010800
   \   00000022   0x.... 0x....      BL       GPIO_ResetBits
    484          #endif
    485                  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);        
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002C   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40013800
   \   0000002E   0x.... 0x....      BL       USART_ITConfig
    486                  break;
   \   00000032   0xE020             B.N      ??MB_CommRxIntEn_1
    487                  
    488              case 1:
    489          #if (BSP_COM2_REN == DEF_ENABLED)
    490                  GPIO_ResetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_3: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40010800
   \   00000038   0x.... 0x....      BL       GPIO_ResetBits
    491          #endif
    492                  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0xF240 0x5125      MOVW     R1,#+1317
   \   00000042   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000044   0x.... 0x....      BL       USART_ITConfig
    493                  break;
   \   00000048   0xE015             B.N      ??MB_CommRxIntEn_1
    494                  
    495              case 2:
    496          #if (BSP_COM3_REN == DEF_ENABLED)
    497                  GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_4: (+1)
   \   0000004A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000004E   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40011800
   \   00000050   0x.... 0x....      BL       GPIO_ResetBits
    498          #endif
    499                  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0xF240 0x5125      MOVW     R1,#+1317
   \   0000005A   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40004800
   \   0000005C   0x.... 0x....      BL       USART_ITConfig
    500                  break;
   \   00000060   0xE009             B.N      ??MB_CommRxIntEn_1
    501                  
    502              case 3:
    503          #if (BSP_COM4_REN == DEF_ENABLED)
    504                  GPIO_ResetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_5: (+1)
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x....             LDR.N    R0,??DataTable10_11  ;; 0x40011400
   \   00000066   0x.... 0x....      BL       GPIO_ResetBits
    505          #endif
    506                  USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000070   0x....             LDR.N    R0,??DataTable10_9  ;; 0x40004c00
   \   00000072   0x.... 0x....      BL       USART_ITConfig
    507                  break;
    508              }
    509              CPU_CRITICAL_EXIT();
   \                     ??MB_CommRxIntEn_1: (+1)
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000080   0x.... 0x....      B.W      CPU_SR_Restore
    510          }
    511          
    512          /*$PAGE*/
    513          /*
    514          *********************************************************************************************************
    515          *                                       MB_CommRxTxISR_Handler()
    516          *
    517          * Description : This function is the ISR for either a received or transmitted character.
    518          *
    519          * Argument(s) : none.
    520          *
    521          * Return(s)   : none.
    522          *
    523          * Caller(s)   : This is a ISR
    524          *
    525          * Note(s)     : (1) The pseudo-code for this function should be:  
    526          *
    527          *               if (Rx Byte has been received) {
    528          *                  c = get byte from serial port;
    529          *                  Clear receive interrupt;
    530          *                  pch->RxCtr++;                      Increment the number of bytes received
    531          *                  MB_RxByte(pch, c);                 Pass character to Modbus to process
    532          *              }
    533          *
    534          *              if (Byte has been transmitted) {
    535          *                  pch->TxCtr++;                      Increment the number of bytes transmitted
    536          *                  MB_TxByte(pch);                    Send next byte in response
    537          *                  Clear transmit interrupt           Clear Transmit Interrupt flag
    538          *              }
    539          *********************************************************************************************************
    540          */
    541          

   \                                 In section .text, align 2, keep-with-next
    542          void  USARTx_RxTxISRHandler (MODBUS_CH *pch)
    543          {
   \                     USARTx_RxTxISRHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    544              volatile  CPU_INT08U    rx_data;
    545              
    546              /***********************************************
    547              * 描述：接收中断
    548              */
    549              if (SET == USART_GetFlagStatus(pch->USARTx, USART_FLAG_RXNE)) {
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   0000000C   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD112             BNE.N    ??USARTx_RxTxISRHandler_0
    550                  rx_data = (uint16_t)(pch->USARTx->DR & (uint16_t)0x01FF);
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x8880             LDRH     R0,[R0, #+4]
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    551                  pch->RxCtr++;
   \   0000001E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x62E0             STR      R0,[R4, #+44]
    552                  MB_RxByte(pch, rx_data);                                        /* Pass character to Modbus to process                  */
   \   00000024   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       MB_RxByte
    553                  USART_ClearITPendingBit(pch->USARTx, USART_IT_RXNE);            /* Clear the USART2 receive interrupt.                  */
   \   0000002E   0xF240 0x5125      MOVW     R1,#+1317
   \   00000032   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000036   0x.... 0x....      BL       USART_ClearITPendingBit
    554              }
    555              /***********************************************
    556              * 描述：发送中断
    557              */
    558              if (SET == USART_GetFlagStatus(pch->USARTx, USART_FLAG_TC)) {
   \                     ??USARTx_RxTxISRHandler_0: (+1)
   \   0000003A   0x2140             MOVS     R1,#+64
   \   0000003C   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000040   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD10F             BNE.N    ??USARTx_RxTxISRHandler_1
    559                  USART_ClearITPendingBit(pch->USARTx, USART_IT_TC);              /* Clear the USART2 receive interrupt.                  */
   \   00000048   0xF240 0x6126      MOVW     R1,#+1574
   \   0000004C   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000050   0x.... 0x....      BL       USART_ClearITPendingBit
    560                  pch->TxCtr++;
   \   00000054   0xF8D4 0x0138      LDR      R0,[R4, #+312]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0xF8C4 0x0138      STR      R0,[R4, #+312]
    561                  MB_TxByte(pch);                                                 /* Send next byte                                       */
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xE8BD 0x4016      POP      {R1,R2,R4,LR}
   \   00000064   0x.... 0x....      B.W      MB_TxByte
    562              }
    563          }
   \                     ??USARTx_RxTxISRHandler_1: (+1)
   \   00000068   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    564          
    565          /*$PAGE*/
    566          /*
    567          *********************************************************************************************************
    568          *                                UART #0 Rx/Tx Communication handler for Modbus
    569          *********************************************************************************************************
    570          */
    571          
    572          /***********************************************
    573          * 描述： UART1中断服务程序
    574          */

   \                                 In section .text, align 4, keep-with-next
    575          void  USART1_RxTxISRHandler (void)
    576          {
    577              USARTx_RxTxISRHandler(MB_ChPortMap[0]);
   \                     USART1_RxTxISRHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             B.N      USARTx_RxTxISRHandler
    578          }
    579          
    580          /***********************************************
    581          * 描述： UART2中断服务程序
    582          */

   \                                 In section .text, align 4, keep-with-next
    583          void  USART2_RxTxISRHandler (void)
    584          {
    585              USARTx_RxTxISRHandler(MB_ChPortMap[1]);
   \                     USART2_RxTxISRHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x....             B.N      USARTx_RxTxISRHandler
    586          }
    587          
    588          /***********************************************
    589          * 描述： UART3中断服务程序
    590          */

   \                                 In section .text, align 4, keep-with-next
    591          void  USART3_RxTxISRHandler (void)
    592          {
    593              USARTx_RxTxISRHandler(MB_ChPortMap[2]);
   \                     USART3_RxTxISRHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x....             B.N      USARTx_RxTxISRHandler
    594          }
    595          
    596          /***********************************************
    597          * 描述： UART4中断服务程序
    598          */

   \                                 In section .text, align 4, keep-with-next
    599          void  USART4_RxTxISRHandler (void)
    600          {
    601              USARTx_RxTxISRHandler(MB_ChPortMap[3]);
   \                     USART4_RxTxISRHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x....             B.N      USARTx_RxTxISRHandler
    602          }
    603          
    604          /*$PAGE*/
    605          /*
    606          *********************************************************************************************************
    607          *                                             MB_CommTx1()
    608          *
    609          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    610          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    611          *               is enabled to accept the next Modbus request.
    612          *
    613          * Argument(s) : c     is the byte to send to the serial port
    614          *
    615          * Return(s)   : none.
    616          *
    617          * Caller(s)   : MB_TxByte()
    618          *
    619          * Note(s)     : none.
    620          *********************************************************************************************************
    621          */
    622          

   \                                 In section .text, align 2, keep-with-next
    623          void  MB_CommTx1 (MODBUS_CH  *pch,
    624                            CPU_INT08U  c)
    625          {
    626              pch->USARTx->DR = (c & (u16)0x01FF);
   \                     MB_CommTx1: (+1)
   \   00000000   0xF8D0 0x0460      LDR      R0,[R0, #+1120]
   \   00000004   0x8081             STRH     R1,[R0, #+4]
    627              return;
   \   00000006   0x4770             BX       LR               ;; return
    628              
    629          //    switch (pch->PortNbr) 
    630          //    {
    631          //    case 0:
    632          //        /* Transmit Data */
    633          //        USART1->DR = (c & (u16)0x01FF);
    634          //        break;
    635          //        
    636          //    case 1:
    637          //        /* Transmit Data */
    638          //        USART2->DR = (c & (u16)0x01FF);
    639          //        break;
    640          //        
    641          //    case 2:
    642          //        /* Transmit Data */
    643          //        USART3->DR = (c & (u16)0x01FF);
    644          //        break;
    645          //        
    646          //    case 3:
    647          //        /* Transmit Data */
    648          //        UART4->DR = (c & (u16)0x01FF);
    649          //        break;
    650          //    }
    651          }
    652          
    653          /*$PAGE*/
    654          /*
    655          *********************************************************************************************************
    656          *                                         MB_CommTxIntDis()
    657          *
    658          * Description : This function disables Tx interrupts.
    659          *
    660          * Argument(s) : pch        is a pointer to the Modbus channel
    661          *
    662          * Return(s)   : none.
    663          *
    664          * Caller(s)   : MB_CommExit()
    665          *               MB_TxByte()
    666          *
    667          * Note(s)     : none.
    668          *********************************************************************************************************
    669          */
    670          

   \                                 In section .text, align 2, keep-with-next
    671          void  MB_CommTxIntDis (MODBUS_CH  *pch)
    672          {
   \                     MB_CommTxIntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    673              CPU_SR  cpu_sr = 0;
    674          
    675              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    676              USART_ITConfig(pch->USARTx, USART_IT_TC, DISABLE);
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF240 0x6126      MOVW     R1,#+1574
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x.... 0x....      BL       USART_ITConfig
    677              USART_ITConfig(pch->USARTx, USART_IT_TXE, DISABLE);
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xF240 0x7127      MOVW     R1,#+1831
   \   00000022   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000026   0x.... 0x....      BL       USART_ITConfig
    678              CPU_CRITICAL_EXIT();
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000034   0x.... 0x....      B.W      CPU_SR_Restore
    679              
    680              return;
    681          //    
    682          //    switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
    683          //    case 0:
    684          //        USART_ITConfig(USART1, USART_IT_TC, DISABLE);
    685          //        USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
    686          //        break;
    687          //        
    688          //    case 1:
    689          //        USART_ITConfig(USART2, USART_IT_TC, DISABLE);
    690          //        USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    691          //        break;
    692          //        
    693          //    case 2:
    694          //        USART_ITConfig(USART3, USART_IT_TC, DISABLE);
    695          //        USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
    696          //        break;
    697          //        
    698          //    case 3:
    699          //        USART_ITConfig(UART4, USART_IT_TC, DISABLE);
    700          //        USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
    701          //        break;
    702          //    }
    703          //    CPU_CRITICAL_EXIT();
    704          }
    705          
    706          /*$PAGE*/
    707          /*
    708          *********************************************************************************************************
    709          *                                         MB_CommTxIntEn()
    710          *
    711          * Description : This function enables Tx interrupts.
    712          *
    713          * Argument(s) : pch        is a pointer to the Modbus channel
    714          *
    715          * Return(s)   : none.
    716          *
    717          * Caller(s)   : MB_Tx()
    718          *
    719          * Note(s)     : none.
    720          *********************************************************************************************************
    721          */

   \                                 In section .text, align 2, keep-with-next
    722          void  MB_CommTxIntEn (MODBUS_CH  *pch)
    723          {
   \                     MB_CommTxIntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    724              CPU_SR  cpu_sr = 0;
    725          
    726              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    727              USART_ITConfig(pch->USARTx, USART_IT_TC, ENABLE);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF240 0x6126      MOVW     R1,#+1574
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x.... 0x....      BL       USART_ITConfig
    728              USART_ITConfig(pch->USARTx, USART_IT_TXE, ENABLE);
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF240 0x7127      MOVW     R1,#+1831
   \   00000022   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000026   0x.... 0x....      BL       USART_ITConfig
    729              CPU_CRITICAL_EXIT();
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000034   0x.... 0x....      B.W      CPU_SR_Restore
    730              
    731              return;
    732              
    733          //    switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
    734          //    case 0:
    735          //        USART_ITConfig(USART1, USART_IT_TC, ENABLE);
    736          //        USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
    737          //        break;
    738          //        
    739          //    case 1:
    740          //        USART_ITConfig(USART2, USART_IT_TC, ENABLE);
    741          //        USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    742          //        break;
    743          //        
    744          //    case 2:
    745          //        USART_ITConfig(USART3, USART_IT_TC, ENABLE);
    746          //        USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
    747          //        break;
    748          //        
    749          //    case 3:
    750          //        USART_ITConfig(UART4, USART_IT_TC, ENABLE);
    751          //        USART_ITConfig(UART4, USART_IT_TXE, ENABLE);
    752          //        break;
    753          //    }
    754          //    CPU_CRITICAL_EXIT();
    755          }
    756          
    757          /*$PAGE*/
    758          /*
    759          *********************************************************************************************************
    760          *                                           MB_RTU_TmrInit()
    761          *
    762          * Description : This function is called to initialize the RTU timeout timer.
    763          *
    764          * Argument(s) : freq          Is the frequency of the modbus RTU timer interrupt.
    765          *
    766          * Return(s)   : none.
    767          *
    768          * Caller(s)   : MB_Init().
    769          *
    770          * Note(s)     : none.
    771          *********************************************************************************************************
    772          */
    773          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    774          void  MB_RTU_TmrInit (void)
    775          {
   \                     MB_RTU_TmrInit: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    776              CPU_INT32U  clk_freq;
    777              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; 
    778              
    779              clk_freq            = BSP_CPU_ClkFreq();
   \   00000002   0x.... 0x....      BL       BSP_CPU_ClkFreq
    780              MB_Tmr_ReloadCnts   = clk_freq / 36000/ MB_RTU_Freq - 1;
   \   00000006   0x....             LDR.N    R5,??DataTable10_12
   \   00000008   0xF648 0x41A0      MOVW     R1,#+36000
   \   0000000C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000010   0x....             LDR.N    R1,??DataTable10_13
   \   00000012   0x8809             LDRH     R1,[R1, #+0]
   \   00000014   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    781              
    782              //预分频系数（TIM_Prescaler）  = 36000-1，这样计数器时钟为72MHz/36000 = 2kHz 
    783              //中断计数器 （TIM_Period）    = MB_Tmr_ReloadCnts
    784              //定时器中断频率               = clk_freq / （TIM_Prescaler + 1） / （TIM_Period + 1）
    785              //定时器中断频率               = 72000000 / 36000 / 5 = 400Hz
    786              
    787              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);            // 使能定时器时钟
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    788              TIM_DeInit(TIM3);                                               // 复位TIM3定时器
   \   00000024   0x....             LDR.N    R4,??DataTable10_14  ;; 0x40000400
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       TIM_DeInit
    789              
    790              /* TIM3 configuration */
    791              TIM_TimeBaseStructure.TIM_Period        = MB_Tmr_ReloadCnts;    // 中断频率     
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    792              TIM_TimeBaseStructure.TIM_Prescaler     = 36000 - 1;            // 分频36000       
   \   00000032   0xF648 0x409F      MOVW     R0,#+35999
   \   00000036   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    793              TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;         // 时钟分频  
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    794              TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;   // 计数方向向上计数
   \   00000040   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    795              TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       TIM_TimeBaseInit
    796              
    797              TIM_ClearFlag(TIM3, TIM_FLAG_Update);           // 清除TIM3溢出中断标志
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       TIM_ClearFlag
    798              TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);      // TIM3溢出中断允许
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0x4611             MOV      R1,R2
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       TIM_ITConfig
    799              TIM_Cmd(TIM3, ENABLE);                          // 允许tim2计数
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       TIM_Cmd
    800              
    801              /***********************************************
    802              * 描述：设置中断入口函数及中断优先级
    803              */
    804              BSP_IntVectSet(BSP_INT_ID_TIM3, MB_RTU_TmrISR_Handler);
   \   00000066   0x.... 0x....      ADR.W    R1,MB_RTU_TmrISR_Handler
   \   0000006A   0x201D             MOVS     R0,#+29
   \   0000006C   0x.... 0x....      BL       BSP_IntVectSet
    805              BSP_IntEn(BSP_INT_ID_TIM3);
   \   00000070   0x201D             MOVS     R0,#+29
   \   00000072   0x.... 0x....      BL       BSP_IntEn
    806              
    807              MB_RTU_TmrResetAll();                                     /* Reset all the RTU timers, we changed freq. */
   \   00000076   0x.... 0x....      BL       MB_RTU_TmrResetAll
    808          }
   \   0000007A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    809          #endif
    810          
    811          /*$PAGE*/
    812          /*
    813          *********************************************************************************************************
    814          *                                           MB_RTU_TmrExit()
    815          *
    816          * Description : This function is called to disable the RTU timeout timer.
    817          *
    818          * Argument(s) : none.
    819          *
    820          * Return(s)   : none.
    821          *
    822          * Caller(s)   : MB_Exit()
    823          *
    824          * Note(s)     : none.
    825          *********************************************************************************************************
    826          */
    827          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    828          void  MB_RTU_TmrExit (void)
    829          {
   \                     MB_RTU_TmrExit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    830              TIM_Cmd(TIM3,DISABLE);              //禁止计数器 
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable10_14  ;; 0x40000400
   \   00000006   0x.... 0x....      BL       TIM_Cmd
    831              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE8BD 0x4004      POP      {R2,LR}
   \   00000012   0x.... 0x....      B.W      RCC_APB1PeriphClockCmd
    832          }
    833          #endif
    834          
    835          /*$PAGE*/
    836          /*
    837          *********************************************************************************************************
    838          *                                       MB_RTU_TmrISR_Handler()
    839          *
    840          * Description : This function handles the case when the RTU timeout timer expires.
    841          *
    842          * Arguments   : none.
    843          *
    844          * Returns     : none.
    845          *
    846          * Caller(s)   : This is a ISR.
    847          *
    848          * Note(s)     : none.
    849          *********************************************************************************************************
    850          */
    851          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    852          void  MB_RTU_TmrISR_Handler (void)
    853          {
   \                     MB_RTU_TmrISR_Handler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    854              if(TIM_GetITStatus(TIM3, TIM_IT_Update)== SET) {//检测是否发生溢出更新事件
   \   00000002   0x....             LDR.N    R4,??DataTable10_14  ;; 0x40000400
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD10B             BNE.N    ??MB_RTU_TmrISR_Handler_0
    855                TIM_ClearITPendingBit(TIM3 , TIM_FLAG_Update);/* Clear timer #1 interrupt                           */
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       TIM_ClearITPendingBit
    856                MB_RTU_TmrCtr++;                              /* Indicate that we had activities on this interrupt. */
   \   00000018   0x....             LDR.N    R0,??DataTable10_15
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    857                MB_RTU_TmrUpdate();                           /* Check for RTU timers that have expired             */
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      MB_RTU_TmrUpdate
    858              }
    859          }
   \                     ??MB_RTU_TmrISR_Handler_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    860          #endif
    861                                

   \                                 In section .text, align 2, keep-with-next
    862          void    UARTPutString(MODBUS_CH  *pch, const char *printfbuf)              
    863          {
   \                     UARTPutString: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    864              // USART_ITConfig(pch->USARTx, USART_IT_TC, DISABLE);
    865              // printf((const char *)printfbuf);
    866              // USART_ClearITPendingBit(pch->USARTx, USART_IT_TC); 
    867              // USART_ITConfig(pch->USARTx, USART_IT_TC, ENABLE);
    868              
    869              int nbr_bytes   = strlen(printfbuf);
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       strlen
    870              
    871              if ( (nbr_bytes > 0) && (nbr_bytes < MB_DATA_NBR_REGS * 2 ) ) {  
   \   0000000C   0x1E41             SUBS     R1,R0,#+1
   \   0000000E   0x29F9             CMP      R1,#+249
   \   00000010   0xD207             BCS.N    ??UARTPutString_0
    872                  NMB_Tx((MODBUS_CH   *)pch,
    873                         (CPU_INT08U  *)printfbuf,
    874                         (CPU_INT16U   )nbr_bytes);
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0xB292             UXTH     R2,R2
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000001E   0x.... 0x....      B.W      NMB_Tx
    875              }
    876          }
   \                     ??UARTPutString_0: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     MB_ChTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x00300200         DC32     0x300200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     MB_ChPortMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     MB_Tmr_ReloadCnts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     MB_RTU_Freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     MB_RTU_TmrCtr

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MB_CommExit
        16   -> MB_CommRxIntDis
        16   -> MB_CommTxIntDis
      64   MB_CommPortCfg
        64   -> BSP_IntEn
        64   -> BSP_IntVectSet
        64   -> GPIO_Init
        64   -> GPIO_PinRemapConfig
        64   -> GPIO_ResetBits
        64   -> RCC_APB1PeriphClockCmd
        64   -> RCC_APB2PeriphClockCmd
        64   -> USART_ClearFlag
        64   -> USART_Cmd
        64   -> USART_DeInit
        64   -> USART_ITConfig
        64   -> USART_Init
      16   MB_CommRxIntDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> GPIO_SetBits
        16   -> USART_ITConfig
      16   MB_CommRxIntEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> GPIO_ResetBits
        16   -> USART_ITConfig
       0   MB_CommTx1
      16   MB_CommTxIntDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> USART_ITConfig
      16   MB_CommTxIntEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> USART_ITConfig
       8   MB_RTU_TmrExit
         0   -> RCC_APB1PeriphClockCmd
         8   -> TIM_Cmd
       8   MB_RTU_TmrISR_Handler
         0   -> MB_RTU_TmrUpdate
         8   -> TIM_ClearITPendingBit
         8   -> TIM_GetITStatus
      24   MB_RTU_TmrInit
        24   -> BSP_CPU_ClkFreq
        24   -> BSP_IntEn
        24   -> BSP_IntVectSet
        24   -> MB_RTU_TmrResetAll
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_ClearFlag
        24   -> TIM_Cmd
        24   -> TIM_DeInit
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      16   UARTPutString
         0   -> NMB_Tx
        16   -> strlen
       0   USART1_RxTxISRHandler
         0   -> USARTx_RxTxISRHandler
       0   USART2_RxTxISRHandler
         0   -> USARTx_RxTxISRHandler
       0   USART3_RxTxISRHandler
         0   -> USARTx_RxTxISRHandler
       0   USART4_RxTxISRHandler
         0   -> USARTx_RxTxISRHandler
      16   USARTx_RxTxISRHandler
        16   -> MB_RxByte
         0   -> MB_TxByte
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      20  MB_ChPortMap
      34  MB_CommExit
     712  MB_CommPortCfg
     124  MB_CommRxIntDis
     132  MB_CommRxIntEn
       8  MB_CommTx1
      56  MB_CommTxIntDis
      56  MB_CommTxIntEn
      22  MB_RTU_TmrExit
      42  MB_RTU_TmrISR_Handler
     124  MB_RTU_TmrInit
       4  MB_Tmr_ReloadCnts
      36  UARTPutString
       6  USART1_RxTxISRHandler
       6  USART2_RxTxISRHandler
       6  USART3_RxTxISRHandler
       6  USART4_RxTxISRHandler
     106  USARTx_RxTxISRHandler

 
    24 bytes in section .bss
 1 540 bytes in section .text
 
 1 540 bytes of CODE memory
    24 bytes of DATA memory

Errors: none
Warnings: none
