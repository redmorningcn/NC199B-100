###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Nov/2017  10:06:12
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Source\MB.C
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Source\MB.C -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\MB.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\MB.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-MB\Source\MB.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                        uC/MODBUS Source Code
     19          *
     20          * Filename      : mb.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                            INCLUDE FILES
     31          *********************************************************************************************************
     32          */
     33          
     34          #define   MB_MODULE
     35          // modified by SE
     36          #include  <includes.h>

   \                                 In section .bss, align 4
   \   __absolute CPU_INT08U MB_ChCtr
   \                     MB_ChCtr:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   __absolute CPU_INT16U MB_RTU_Freq
   \                     MB_RTU_Freq:
   \   00000002                      DS8 2
   \   __absolute OS_SEM MB_OS_RxSemTbl[4]
   \                     MB_OS_RxSemTbl:
   \   00000004                      DS8 112
   \   __absolute OS_SEM MB_OS_TxSemTbl[4]
   \                     MB_OS_TxSemTbl:
   \   00000074                      DS8 112
   \   __absolute MODBUS_CH MB_ChTbl[4]
   \                     MB_ChTbl:
   \   000000E4                      DS8 4512

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U MB_RTU_TmrCtr
   \                     MB_RTU_TmrCtr:
   \   00000000                      DS8 4
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          #define MIN_INTER_CHAR_TIMEOUT      5            // 最小字符间超时
     45          /*
     46          *********************************************************************************************************
     47          *                                           LOCAL CONSTANTS
     48          *********************************************************************************************************
     49          */
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                          LOCAL DATA TYPES
     55          *********************************************************************************************************
     56          */
     57          
     58          
     59          /*
     60          *********************************************************************************************************
     61          *                                            LOCAL TABLES
     62          *********************************************************************************************************
     63          */
     64          
     65          /*
     66          *********************************************************************************************************
     67          *                                       LOCAL GLOBAL VARIABLES
     68          *********************************************************************************************************
     69          */
     70          /*
     71          *********************************************************************************************************
     72          *                                        RAM STORAGE REQUIREMENTS
     73          *********************************************************************************************************
     74          */
     75                                                                          /* RAM Storage Requiremets                            */
     76          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .rodata, align 4, keep-with-next
     77          CPU_INT32U  const  MB_TotalRAMSize = sizeof(MB_RTU_Freq)
   \                     MB_TotalRAMSize:
   \   00000000   0x000011A6         DC32 4518
     78                                             + sizeof(MB_RTU_TmrCtr)
     79                                             + sizeof(MB_ChTbl);
     80          #else
     81          CPU_INT32U  const  MB_TotalRAMSize = sizeof(MB_ChTbl);
     82          #endif
     83          

   \                                 In section .rodata, align 2, keep-with-next
     84          CPU_INT16U  const  MB_ChSize       = sizeof(MODBUS_CH);
   \                     MB_ChSize:
   \   00000000   0x0468             DC16 1128
     85          
     86          /*
     87          *********************************************************************************************************
     88          *                                      LOCAL FUNCTION PROTOTYPES
     89          *********************************************************************************************************
     90          */
     91          
     92          
     93          /*
     94          *********************************************************************************************************
     95          *                                     LOCAL CONFIGURATION ERRORS
     96          *********************************************************************************************************
     97          */
     98          
     99          
    100          /*
    101          *********************************************************************************************************
    102          *                                               MB_Init()
    103          *
    104          * Description : Handle either Modbus ASCII or Modbus RTU received packets.
    105          *
    106          * Argument(s) : freq       Specifies the Modbus RTU timer frequency (in Hz)
    107          *
    108          * Return(s)   : none.
    109          *
    110          * Caller(s)   : Application
    111          *
    112          * Note(s)     : none.
    113          *********************************************************************************************************
    114          */
    115          

   \                                 In section .text, align 2, keep-with-next
    116          void  MB_Init (CPU_INT32U freq)
    117          {
   \                     MB_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    118              CPU_INT08U   ch;
    119              MODBUS_CH   *pch;
    120          
    121          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    122              MB_RTU_Freq = freq;                              /* Save the RTU frequency                         */
   \   00000002   0x....             LDR.N    R4,??DataTable5
   \   00000004   0x8060             STRH     R0,[R4, #+2]
    123          #endif
    124          
    125              pch         = &MB_ChTbl[0];                      /* Save Modbus channel number in data structure   */
   \   00000006   0xF104 0x05E4      ADD      R5,R4,#+228
    126              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {     /* Initialize default values                          */
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0xE017             B.N      ??MB_Init_0
    127                  pch->Ch            = ch;
   \                     ??MB_Init_1: (+1)
   \   0000000E   0x702E             STRB     R6,[R5, #+0]
    128                  pch->NodeAddr      = 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7228             STRB     R0,[R5, #+8]
    129                  pch->MasterSlave   = MODBUS_SLAVE;           /* Channel defaults to MODBUS_SLAVE mode          */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7528             STRB     R0,[R5, #+20]
    130                  pch->Mode          = MODBUS_MODE_ASCII;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x74E8             STRB     R0,[R5, #+19]
    131                  pch->RxBufByteCtr  = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x8628             STRH     R0,[R5, #+48]
    132                  pch->RxBufPtr      = &pch->RxBuf[0];
   \   00000020   0xF105 0x0038      ADD      R0,R5,#+56
   \   00000024   0x6368             STR      R0,[R5, #+52]
    133                  pch->WrEn          = MODBUS_WR_EN;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7068             STRB     R0,[R5, #+1]
    134                  pch->WrCtr         = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6068             STR      R0,[R5, #+4]
    135          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    136                  pch->RTU_TimeoutEn = DEF_TRUE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x7728             STRB     R0,[R5, #+28]
    137          #endif
    138          
    139          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)  && \
    140              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)
    141                  MBS_StatInit(pch);
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       MBS_StatInit
    142          #endif
    143                  pch++;
   \   00000038   0xF505 0x658D      ADD      R5,R5,#+1128
    144              }
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \                     ??MB_Init_0: (+1)
   \   0000003E   0x2E04             CMP      R6,#+4
   \   00000040   0xDBE5             BLT.N    ??MB_Init_1
    145          
    146              MB_ChCtr = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7020             STRB     R0,[R4, #+0]
    147          
    148              MB_OS_Init();                                       /* Initialize OS interface functions              */
   \   00000046   0x.... 0x....      BL       MB_OS_Init
    149          
    150          
    151          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)                  /* MODBUS 'RTU' Initialization                         */
    152              MB_RTU_TmrInit();
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x.... 0x....      B.W      MB_RTU_TmrInit
    153          #else
    154              (void)&freq;
    155          #endif
    156          }
    157          
    158          /*
    159          *********************************************************************************************************
    160          *                                               MB_Exit()
    161          *
    162          * Description : This function is called to terminate all Modbus communications
    163          *
    164          * Argument(s) : none.
    165          *
    166          * Return(s)   : none.
    167          *
    168          * Caller(s)   : Application.
    169          *
    170          * Note(s)     : none.
    171          *********************************************************************************************************
    172          */

   \                                 In section .text, align 2, keep-with-next
    173          void  MB_Exit (void)
    174          {
   \                     MB_Exit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    175          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    176              MB_RTU_TmrExit();                                /* Stop the RTU timer interrupts                  */
   \   00000002   0x.... 0x....      BL       MB_RTU_TmrExit
    177          #endif
    178          
    179              MB_CommExit();                                   /* Disable all communications                     */
   \   00000006   0x.... 0x....      BL       MB_CommExit
    180          
    181              MB_OS_Exit();                                    /* Stop RTOS services                             */
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      MB_OS_Exit
    182          }
    183          
    184          /*
    185          *********************************************************************************************************
    186          *                                              MB_CfgCh()
    187          *
    188          * Description : This function must be called after calling MB_Init() to initialize each of the Modbus
    189          *               channels in your system.
    190          *
    191          * Argument(s) : node_addr     is the Modbus node address that the channel is assigned to.
    192          *
    193          *               master_slave  specifies whether the channel is a MODBUS_MASTER or a MODBUS_SLAVE
    194          *
    195          *               rx_timeout    amount of time Master will wait for a response from the slave.
    196          *
    197          *               modbus_mode   specifies the type of modbus channel.  The choices are:
    198          *                             MODBUS_MODE_ASCII
    199          *                             MODBUS_MODE_RTU
    200          *
    201          *               port_nbr      is the UART port number associated with the channel, 0 <= port_nbr < MODBUS_CFG_MAX_CH
    202          *
    203          *               baud          is the desired baud rate
    204          *
    205          *               parity        is the UART's parity setting:
    206          *                             MODBUS_PARITY_NONE
    207          *                             MODBUS_PARITY_ODD
    208          *                             MODBUS_PARITY_EVEN
    209          *
    210          *               bits          UART's number of bits (7 or 8)
    211          *
    212          *               stops         Number of stops bits (1 or 2)
    213          *
    214          *               wr_en         This argument determines whether a Modbus WRITE request will be accepted.
    215          *                             The choices are:
    216          *                             MODBUS_WR_EN
    217          *                             MODBUS_WR_DIS
    218          *
    219          * Return(s)   : none.
    220          *
    221          * Caller(s)   : Application.
    222          *
    223          * Note(s)     : none.
    224          *********************************************************************************************************
    225          */

   \                                 In section .text, align 2, keep-with-next
    226          MODBUS_CH  *MB_CfgCh (CPU_INT08U  node_addr,
    227                                CPU_INT08U  master_slave,
    228                                CPU_INT32U  rx_timeout,
    229                                CPU_INT08U  modbus_mode,
    230                                CPU_INT08U  port_nbr,
    231                                CPU_INT32U  baud,
    232                                CPU_INT16U  bits,
    233                                CPU_INT16U  parity,
    234                                CPU_INT16U  stops,
    235                                CPU_INT08U  wr_en)
    236          {
   \                     MB_CfgCh: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4611             MOV      R1,R2
   \   0000000A   0x4698             MOV      R8,R3
    237              MODBUS_CH   *pch;
    238          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    239              CPU_INT16U   cnts;
    240          #endif
    241          
    242              if (MB_ChCtr < MODBUS_CFG_MAX_CH) {
   \   0000000C   0x....             LDR.N    R5,??DataTable5
   \   0000000E   0x7828             LDRB     R0,[R5, #+0]
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xDA46             BGE.N    ??MB_CfgCh_0
    243                  pch = &MB_ChTbl[MB_ChCtr];
   \   00000014   0xF44F 0x628D      MOV      R2,#+1128
   \   00000018   0xFB02 0x5000      MLA      R0,R2,R0,R5
   \   0000001C   0xF100 0x06E4      ADD      R6,R0,#+228
    244                  MB_MasterTimeoutSet(pch, rx_timeout);
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       MB_MasterTimeoutSet
    245                  MB_NodeAddrSet(pch, node_addr);
   \   00000026   0x4621             MOV      R1,R4
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       MB_NodeAddrSet
    246                  MB_ModeSet(pch, master_slave, modbus_mode);
   \   0000002E   0x4642             MOV      R2,R8
   \   00000030   0x4639             MOV      R1,R7
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       MB_ModeSet
    247                  MB_WrEnSet(pch, wr_en);
   \   00000038   0x990D             LDR      R1,[SP, #+52]
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       MB_WrEnSet
   \   00000040   0x9C08             LDR      R4,[SP, #+32]
    248                  MB_ChToPortMap(pch, port_nbr);
   \   00000042   0x4621             MOV      R1,R4
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       MB_ChToPortMap
   \   0000004A   0x9F09             LDR      R7,[SP, #+36]
    249                  MB_CommPortCfg(pch, port_nbr, baud, bits, parity, stops);
   \   0000004C   0x980C             LDR      R0,[SP, #+48]
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x980B             LDR      R0,[SP, #+44]
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x9B0A             LDR      R3,[SP, #+40]
   \   00000056   0x463A             MOV      R2,R7
   \   00000058   0x4621             MOV      R1,R4
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       MB_CommPortCfg
    250          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    251                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000060   0xF106 0x0014      ADD      R0,R6,#+20
   \   00000064   0x7801             LDRB     R1,[R0, #+0]
   \   00000066   0x2901             CMP      R1,#+1
   \   00000068   0xD101             BNE.N    ??MB_CfgCh_1
    252                      pch->RTU_TimeoutEn = DEF_FALSE;
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x7201             STRB     R1,[R0, #+8]
    253                  }
    254          
    255                  cnts = ((CPU_INT32U)MB_RTU_Freq * 5L * 10L) / baud;           /* Freq * 5 char * 10 bits/char * 1/BaudRate  */
   \                     ??MB_CfgCh_1: (+1)
   \   0000006E   0x8869             LDRH     R1,[R5, #+2]
   \   00000070   0x2232             MOVS     R2,#+50
   \   00000072   0x4351             MULS     R1,R2,R1
   \   00000074   0xFBB1 0xF1F7      UDIV     R1,R1,R7
    256                  if (cnts <= MIN_INTER_CHAR_TIMEOUT) {
   \   00000078   0xB289             UXTH     R1,R1
   \   0000007A   0x2906             CMP      R1,#+6
   \   0000007C   0xDA00             BGE.N    ??MB_CfgCh_2
    257                      cnts = MIN_INTER_CHAR_TIMEOUT;
   \   0000007E   0x2105             MOVS     R1,#+5
    258                  }
    259                  pch->RTU_TimeoutCnts = cnts;
   \                     ??MB_CfgCh_2: (+1)
   \   00000080   0x8081             STRH     R1,[R0, #+4]
    260                  pch->RTU_TimeoutCtr  = cnts;
   \   00000082   0x80C1             STRH     R1,[R0, #+6]
    261          #endif
    262                  pch->RxSem  = &MB_OS_RxSemTbl[port_nbr];                      // port_nbr < MODBUS_CFG_MAX_CH
   \   00000084   0xEBC4 0x00C4      RSB      R0,R4,R4, LSL #+3
   \   00000088   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   0000008C   0xF206 0x4154      ADDW     R1,R6,#+1108
   \   00000090   0x1D02             ADDS     R2,R0,#+4
   \   00000092   0x600A             STR      R2,[R1, #+0]
    263                  pch->TxSem  = &MB_OS_TxSemTbl[port_nbr];                      // port_nbr < MODBUS_CFG_MAX_CH 
   \   00000094   0x3074             ADDS     R0,R0,#+116
   \   00000096   0x6048             STR      R0,[R1, #+4]
    264                  
    265                  MB_ChCtr++;
   \   00000098   0x7828             LDRB     R0,[R5, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x7028             STRB     R0,[R5, #+0]
    266                  return (pch);
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0xE000             B.N      ??MB_CfgCh_3
    267              } else {
    268                  return ((MODBUS_CH *)0);
   \                     ??MB_CfgCh_0: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \                     ??MB_CfgCh_3: (+1)
   \   000000A4   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    269              }
    270          }
    271          
    272          /*
    273          *********************************************************************************************************
    274          *                                         MB_MasterTimeoutSet()
    275          *
    276          * Description : This function is called to change the operating mode of a Modbus channel.
    277          *
    278          * Argument(s) : pch          is a pointer to the Modbus channel to change
    279          *
    280          *               modbus_mode  specifies the type of modbus channel.  The choices are:
    281          *                            MODBUS_MODE_ASCII
    282          *                            MODBUS_MODE_RTU
    283          *
    284          * Return(s)   : none.
    285          *
    286          * Caller(s)   : Application.
    287          *
    288          * Note(s)     : none.
    289          *********************************************************************************************************
    290          */

   \                                 In section .text, align 2, keep-with-next
    291          void  MB_MasterTimeoutSet (MODBUS_CH  *pch,
    292                                     CPU_INT32U  timeout)
    293          {
    294              if (pch != (MODBUS_CH *)0) {
   \                     MB_MasterTimeoutSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_MasterTimeoutSet_0
    295                  pch->RxTimeout = timeout;
   \   00000004   0x6281             STR      R1,[R0, #+40]
    296              }
    297          }
   \                     ??MB_MasterTimeoutSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    298          
    299          /*
    300          *********************************************************************************************************
    301          *                                             MB_ModeSet()
    302          *
    303          * Description : This function is called to change the operating mode of a Modbus channel.
    304          *
    305          * Argument(s) : pch          is a pointer to the Modbus channel to change
    306          *
    307          *               modbus_mode  specifies the type of modbus channel.  The choices are:
    308          *                            MODBUS_MODE_ASCII
    309          *                            MODBUS_MODE_RTU
    310          *
    311          * Return(s)   : none.
    312          *
    313          * Caller(s)   : Application.
    314          *
    315          * Note(s)     : none.
    316          *********************************************************************************************************
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          void  MB_ModeSet (MODBUS_CH  *pch,
    319                            CPU_INT08U  master_slave,
    320                            CPU_INT08U  mode)
    321          {
    322              if (pch != (MODBUS_CH *)0) {
   \                     MB_ModeSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD00D             BEQ.N    ??MB_ModeSet_0
    323          
    324                  switch (master_slave) {
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD102             BNE.N    ??MB_ModeSet_1
    325                      case MODBUS_MASTER:
    326                           pch->MasterSlave = MODBUS_MASTER;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7501             STRB     R1,[R0, #+20]
    327                           break;
   \   0000000C   0xE001             B.N      ??MB_ModeSet_2
    328          
    329                      case MODBUS_SLAVE:
    330                      default:
    331                           pch->MasterSlave = MODBUS_SLAVE;
   \                     ??MB_ModeSet_1: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7501             STRB     R1,[R0, #+20]
    332                           break;
    333                  }
    334          
    335                  switch (mode) {
   \                     ??MB_ModeSet_2: (+1)
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD102             BNE.N    ??MB_ModeSet_3
    336          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    337                      case MODBUS_MODE_ASCII:
    338                           pch->Mode = MODBUS_MODE_ASCII;
    339                           break;
    340          #endif
    341          
    342          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    343                      case MODBUS_MODE_RTU:
    344                           pch->Mode = MODBUS_MODE_RTU;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x74C1             STRB     R1,[R0, #+19]
    345                           break;
   \   0000001A   0x4770             BX       LR
    346          #endif
    347          
    348                      default:
    349          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    350                           pch->Mode = MODBUS_MODE_RTU;
   \                     ??MB_ModeSet_3: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x74C1             STRB     R1,[R0, #+19]
    351          #else
    352                           pch->Mode = MODBUS_MODE_ASCII;
    353          #endif
    354                           break;
    355                  }
    356              }
    357          }
   \                     ??MB_ModeSet_0: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    358          
    359          /*
    360          *********************************************************************************************************
    361          *                                           MB_NodeAddrSet()
    362          *
    363          * Description : This function is called to change the Modbus node address that the channel will respond to.
    364          *
    365          * Argument(s) : pch          is a pointer to the Modbus channel to change
    366          *
    367          *               node_addr    is the Modbus node address that the channel is assigned to.
    368          *
    369          * Return(s)   : none.
    370          *
    371          * Caller(s)   : Application.
    372          *
    373          * Note(s)     : none.
    374          *********************************************************************************************************
    375          */

   \                                 In section .text, align 2, keep-with-next
    376          void  MB_NodeAddrSet (MODBUS_CH  *pch,
    377                                CPU_INT08U  node_addr)
    378          {
    379              if (pch != (MODBUS_CH *)0) {
   \                     MB_NodeAddrSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_NodeAddrSet_0
    380                  pch->NodeAddr = node_addr;
   \   00000004   0x7201             STRB     R1,[R0, #+8]
    381              }
    382          }
   \                     ??MB_NodeAddrSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    383          
    384          /*
    385          *********************************************************************************************************
    386          *                                             MB_WrEnSet()
    387          *
    388          * Description : This function is called to enable or disable write accesses to the data.
    389          *
    390          * Argument(s) : ch           is the Modbus channel to change
    391          *
    392          *               wr_en        This argument determines whether a Modbus WRITE request will be accepted.
    393          *                            The choices are:
    394          *                            MODBUS_WR_EN
    395          *                            MODBUS_WR_DIS
    396          *
    397          * Return(s)   : none.
    398          *
    399          * Caller(s)   : Application.
    400          *
    401          * Note(s)     : none.
    402          *********************************************************************************************************
    403          */

   \                                 In section .text, align 2, keep-with-next
    404          void  MB_WrEnSet (MODBUS_CH  *pch,
    405                            CPU_INT08U  wr_en)
    406          {
    407              if (pch != (MODBUS_CH *)0) {
   \                     MB_WrEnSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_WrEnSet_0
    408                  pch->WrEn = wr_en;
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    409              }
    410          }
   \                     ??MB_WrEnSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    411          
    412          /*
    413          *********************************************************************************************************
    414          *                                           MB_ChToPortMap()
    415          *
    416          * Description : This function is called to change the physical port number of the Modbus channel.
    417          *
    418          * Argument(s) : pch          is a pointer to the Modbus channel to change
    419          *
    420          *               port_nbr     This argument determines the physical port number of the Modbus channel
    421          *
    422          * Return(s)   : none.
    423          *
    424          * Caller(s)   : Application.
    425          *
    426          * Note(s)     : none.
    427          *********************************************************************************************************
    428          */

   \                                 In section .text, align 2, keep-with-next
    429          void  MB_ChToPortMap (MODBUS_CH  *pch,
    430                                CPU_INT08U  port_nbr)
    431          {
    432              if (pch != (MODBUS_CH *)0) {
   \                     MB_ChToPortMap: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_ChToPortMap_0
    433                  pch->PortNbr = port_nbr;
   \   00000004   0x7241             STRB     R1,[R0, #+9]
    434              }
    435          }
   \                     ??MB_ChToPortMap_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    436          
    437          /*$PAGE*/
    438          /*
    439          *********************************************************************************************************
    440          *                                              MB_RxByte()
    441          *
    442          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    443          *               when a complete packet has been received.
    444          *
    445          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    446          *
    447          *               rx_byte     Is the byte received.
    448          *
    449          * Return(s)   : none.
    450          *
    451          * Caller(s)   : MB_CommRxTxISR_Handler()
    452          *
    453          * Note(s)     : none.
    454          *********************************************************************************************************
    455          */

   \                                 In section .text, align 2, keep-with-next
    456          void  MB_RxByte (MODBUS_CH  *pch,
    457                           CPU_INT08U  rx_byte)
    458          {
    459              switch (pch->Mode) {
   \                     MB_RxByte: (+1)
   \   00000000   0x7CC2             LDRB     R2,[R0, #+19]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD100             BNE.N    ??MB_RxByte_0
    460          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    461                  case MODBUS_MODE_ASCII:
    462                       MB_ASCII_RxByte(pch, rx_byte & 0x7F);
    463                       break;
    464          #endif
    465          
    466          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    467                  case MODBUS_MODE_RTU:
    468                       MB_RTU_RxByte(pch, rx_byte);
   \   00000006   0x....             B.N      MB_RTU_RxByte
    469                       break;
    470          #endif
    471          
    472                  default:
    473                       break;
    474              }
    475          }
   \                     ??MB_RxByte_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return
    476          
    477          /*$PAGE*/
    478          /*
    479          *********************************************************************************************************
    480          *                                              MB_RxTask() 
    481          *
    482          * Description : This function is called when a packet needs to be processed. 
    483          *
    484          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    485          *
    486          * Return(s)   : none.
    487          *
    488          * Caller(s)   : MB_OS_RxTask()
    489          *
    490          * Note(s)     : none.
    491          *********************************************************************************************************
    492          */

   \                                 In section .text, align 2, keep-with-next
    493          void  MB_RxTask (MODBUS_CH *pch)
    494          {
    495          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    496              if (pch != (MODBUS_CH *)0) {
   \                     MB_RxTask: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD004             BEQ.N    ??MB_RxTask_0
    497                  if (pch->MasterSlave == MODBUS_SLAVE) {
   \   00000004   0x7D01             LDRB     R1,[R0, #+20]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE.N    ??MB_RxTask_0
    498                      MBS_RxTask(pch);
   \   0000000A   0x.... 0x....      B.W      MBS_RxTask
    499                  }
    500              }
    501          #endif
    502          }
   \                     ??MB_RxTask_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    503          /*
    504          *********************************************************************************************************
    505          *                                                MB_Tx()
    506          *
    507          * Description : This function is called to start transmitting a packet to a modbus channel.
    508          *
    509          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    510          *
    511          * Return(s)   : none.
    512          *
    513          * Caller(s)   : MB_ASCII_Tx()
    514          *               MB_RTU_Tx()
    515          *
    516          * Note(s)     : none.
    517          *********************************************************************************************************
    518          */

   \                                 In section .text, align 2, keep-with-next
    519          void  MB_Tx (MODBUS_CH  *pch)
    520          {
   \                     MB_Tx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    521              pch->TxBufPtr = &pch->TxBuf[0];
   \   00000004   0xF504 0x70A2      ADD      R0,R4,#+324
   \   00000008   0xF8C4 0x0140      STR      R0,[R4, #+320]
    522              MB_TxByte(pch);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       MB_TxByte
    523              MB_CommRxIntDis(pch);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       MB_CommRxIntDis
    524              MB_CommTxIntEn(pch); 
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      MB_CommTxIntEn
    525          }
    526          
    527          /*$PAGE*/
    528          /*
    529          *********************************************************************************************************
    530          *                                              MB_TxByte()
    531          *
    532          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    533          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    534          *               is enabled to accept the next Modbus request.
    535          *
    536          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    537          *
    538          * Return(s)   : none.
    539          *
    540          * Caller(s)   : MB_CommRxTxISR_Handler()
    541          *               MB_Tx()
    542          *
    543          * Note(s)     : none.
    544          *********************************************************************************************************
    545          */

   \                                 In section .text, align 2, keep-with-next
    546          void  MB_TxByte (MODBUS_CH  *pch)
    547          {
   \                     MB_TxByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    548              CPU_INT08U  c;
    549          
    550              if (pch->TxBufByteCtr > 0) {
   \   00000004   0xF504 0x709C      ADD      R0,R4,#+312
   \   00000008   0x8881             LDRH     R1,[R0, #+4]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD014             BEQ.N    ??MB_TxByte_0
    551                  pch->TxBufByteCtr--;
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x8081             STRH     R1,[R0, #+4]
    552                  pch->TxCtr++;
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    553                  c = *pch->TxBufPtr++;
   \   00000018   0x6881             LDR      R1,[R0, #+8]
   \   0000001A   0x1C4A             ADDS     R2,R1,#+1
   \   0000001C   0x6082             STR      R2,[R0, #+8]
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
    554                  MB_CommTx1(pch,c);                         /* Write one byte to the serial port                  */
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       MB_CommTx1
    555                                                                  
    556          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    557                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000026   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000002A   0x7801             LDRB     R1,[R0, #+0]
   \   0000002C   0x2901             CMP      R1,#+1
   \   0000002E   0xD10E             BNE.N    ??MB_TxByte_1
    558          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    559                      pch->RTU_TimeoutEn = MODBUS_FALSE;     /* Disable RTU timeout timer until we start receiving */
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x7201             STRB     R1,[R0, #+8]
    560          #endif            
    561                      pch->RxBufByteCtr  = 0;                /* Flush Rx buffer                                           */
   \   00000034   0x8381             STRH     R1,[R0, #+28]
   \   00000036   0xBD10             POP      {R4,PC}
    562                  }
    563          #endif
    564              } else {                                       /* If there is nothing to do end transmission                */
    565                  pch->TxBufPtr = &pch->TxBuf[0];            /* Reset at beginning of buffer                              */
   \                     ??MB_TxByte_0: (+1)
   \   00000038   0xF504 0x71A2      ADD      R1,R4,#+324
   \   0000003C   0x6081             STR      R1,[R0, #+8]
    566                  MB_CommTxIntDis(pch);                      /* No more data to send, disable Tx interrupts               */
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       MB_CommTxIntDis
    567                  MB_CommRxIntEn(pch);                       /* Re-enable the receiver for the next packet                */
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x.... 0x....      B.W      MB_CommRxIntEn
    568              }
    569          }
   \                     ??MB_TxByte_1: (+1)
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    570          
    571          /*$PAGE*/
    572          /*
    573          *********************************************************************************************************
    574          *                                           MB_ASCII_RxByte()
    575          *
    576          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    577          *               when a complete packet has been received.
    578          *
    579          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    580          *
    581          *               rx_byte     Is the byte received.
    582          *
    583          * Return(s)   : none.
    584          *
    585          * Caller(s)   : MB_RxByte().
    586          *
    587          * Return(s)   : none.
    588          *********************************************************************************************************
    589          */
    590          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    591          void  MB_ASCII_RxByte (MODBUS_CH  *pch,
    592                                 CPU_INT08U  rx_byte)
    593          {
    594              CPU_INT08U    node_addr;
    595              CPU_INT08U   *phex;
    596          
    597          
    598              pch->RxCtr++;                                   /* Increment the number of bytes received                   */
    599              if (rx_byte == ':') {                           /* Is it the start of frame character?                      */
    600                  pch->RxBufPtr     = &pch->RxBuf[0];         /* Yes, Restart a new frame                                 */
    601                  pch->RxBufByteCtr = 0;
    602              }
    603              if (pch->RxBufByteCtr < MODBUS_CFG_BUF_SIZE) {              /* No, add received byte to buffer                    */
    604                  *pch->RxBufPtr++  = rx_byte;
    605                  pch->RxBufByteCtr++;                                    /* Increment byte counter to see if we have Rx ...    */
    606                                                                          /* ... activity                                       */
    607              }
    608              if (rx_byte == MODBUS_ASCII_END_FRAME_CHAR2) {  /* See if we received a complete ASCII frame                */
    609                  phex      = &pch->RxBuf[1];
    610                  node_addr = MB_ASCII_HexToBin(phex);
    611                  if ((node_addr == pch->NodeAddr) ||                     /* Is the address for us?                             */
    612                      (node_addr == 0)) {                                 /* ... or a 'broadcast'?                              */
    613                      MB_OS_RxSignal(pch);                    /* Yes, Let task handle reply                               */
    614                  } else {
    615                      pch->RxBufPtr     = &pch->RxBuf[0];     /* No,  Wipe out anything, we have to re-synchronize.       */
    616                      pch->RxBufByteCtr = 0;
    617                  }
    618              }
    619          }
    620          #endif
    621          
    622          /*$PAGE*/
    623          /*
    624          *********************************************************************************************************
    625          *                                             MB_ASCII_Rx()
    626          *
    627          * Description : Parses and converts an ASCII style message into a Modbus frame.  A check is performed
    628          *               to verify that the Modbus packet is valid.
    629          *
    630          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    631          *
    632          * Return(s)   : DEF_TRUE        If all checks pass.
    633          *               DEF_FALSE       If any checks fail.
    634          *
    635          * Caller(s)   : MBM_RxReply().
    636          *
    637          * Note(s)     : none.
    638          *********************************************************************************************************
    639          */
    640          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    641          CPU_BOOLEAN  MB_ASCII_Rx (MODBUS_CH  *pch)
    642          {
    643              CPU_INT08U    *pmsg;
    644              CPU_INT08U    *prx_data;
    645              CPU_INT16U     rx_size;
    646          
    647          
    648              pmsg      = &pch->RxBuf[0];
    649              rx_size   =  pch->RxBufByteCtr;
    650              prx_data  = &pch->RxFrameData[0];
    651              if ((rx_size & 0x01)                                     &&        /* Message should have an ODD nbr of bytes.        */
    652                  (rx_size           >  MODBUS_ASCII_MIN_MSG_SIZE)     &&        /* Check if message is long enough                 */
    653                  (pmsg[0]           == MODBUS_ASCII_START_FRAME_CHAR) &&        /* Check the first char.                           */
    654                  (pmsg[rx_size - 2] == MODBUS_ASCII_END_FRAME_CHAR1)  &&        /* Check the last two.                             */
    655                  (pmsg[rx_size - 1] == MODBUS_ASCII_END_FRAME_CHAR2)) {
    656                  rx_size               -= 3;                                    /* Take away for the ':', CR, and LF               */
    657                  pmsg++;                                                        /* Point past the ':' to the address.              */
    658                  pch->RxFrameNDataBytes = 0;                                    /* Get the data from the message                   */
    659                  while (rx_size > 2) {
    660                      *prx_data++  = MB_ASCII_HexToBin(pmsg);
    661                      pmsg        += 2;
    662                      rx_size     -= 2;
    663                      pch->RxFrameNDataBytes++;                                  /* Increment the number of Modbus packets received */
    664                  }
    665                  pch->RxFrameNDataBytes -= 2;                                   /* Subtract the Address and function code          */
    666                  pch->RxFrameCRC         = (CPU_INT16U)MB_ASCII_HexToBin(pmsg); /* Extract the message's LRC                       */
    667                  return (DEF_TRUE);
    668              } else {
    669                  return (DEF_FALSE);
    670              }
    671          }
    672          #endif
    673          
    674          /*$PAGE*/
    675          /*
    676          *********************************************************************************************************
    677          *                                             MB_ASCII_Tx()
    678          *
    679          * Description : The format of the message is ASCII.  The actual information is taken from the given
    680          *               MODBUS frame.
    681          *
    682          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    683          *
    684          * Return(s)   : none.
    685          *
    686          * Caller(s)   : MBM_TxCmd()
    687          *               MBS_ASCII_Task()
    688          *
    689          * Note(s)     : none.   
    690          *********************************************************************************************************
    691          */
    692          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    693          void  MB_ASCII_Tx (MODBUS_CH  *pch)
    694          {
    695              CPU_INT08U    *ptx_data;
    696              CPU_INT08U    *pbuf;
    697              CPU_INT16U     i;
    698              CPU_INT16U     tx_bytes;
    699              CPU_INT08U     lrc;
    700          
    701          
    702              ptx_data = &pch->TxFrameData[0];
    703              pbuf     = &pch->TxBuf[0];
    704              *pbuf++  = MODBUS_ASCII_START_FRAME_CHAR;                   /* Place the start-of-frame character into output buffer  */
    705              pbuf     = MB_ASCII_BinToHex(*ptx_data++, 
    706                                           pbuf);
    707              pbuf     = MB_ASCII_BinToHex(*ptx_data++, 
    708                                           pbuf);
    709              tx_bytes = 5;
    710              i        = (CPU_INT08U)pch->TxFrameNDataBytes;             /* Transmit the actual data                                 */
    711              while (i > 0) {
    712                  pbuf      = MB_ASCII_BinToHex(*ptx_data++, 
    713                                                pbuf);
    714                  tx_bytes += 2;
    715                  i--;
    716              }
    717              lrc               = MB_ASCII_TxCalcLRC(pch,                 /* Compute outbound packet LRC                            */
    718                                                     tx_bytes);      
    719              pbuf              = MB_ASCII_BinToHex(lrc,                  /* Add the LRC checksum in the packet                     */
    720                                                    pbuf);           
    721              *pbuf++           = MODBUS_ASCII_END_FRAME_CHAR1;           /* Add 1st end-of-frame character (0x0D) to output buffer */
    722              *pbuf++           = MODBUS_ASCII_END_FRAME_CHAR2;           /* Add 2nd end-of-frame character (0x0A) to output buffer */
    723              tx_bytes         += 4;
    724              pch->TxFrameCRC   = (CPU_INT16U)lrc;                       /* Save the computed LRC into the channel                   */
    725              pch->TxBufByteCtr = tx_bytes;                              /* Update the total number of bytes to send                 */
    726              MB_Tx(pch);                                                /* Send it out the communication driver.                    */
    727          }
    728          #endif
    729          
    730          /*$PAGE*/
    731          /*
    732          *********************************************************************************************************
    733          *                                            MB_RTU_RxByte()
    734          *
    735          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    736          *               when a complete packet has been received.
    737          *
    738          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    739          *
    740          *               rx_byte     Is the byte received.
    741          *
    742          * Return(s)   : none.
    743          *
    744          * Caller(s)   : MB_RxByte()
    745          *
    746          * Note(s)     : none.
    747          *********************************************************************************************************
    748          */
    749          
    750          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    751          void  MB_RTU_RxByte (MODBUS_CH  *pch,
    752                               CPU_INT08U  rx_byte)
    753          {
   \                     MB_RTU_RxByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    754             MB_RTU_TmrReset(pch);                                       /* Reset the timeout timer on a new character               */
   \   00000006   0x.... 0x....      BL       MB_RTU_TmrReset
    755          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    756              if (pch->MasterSlave == MODBUS_MASTER) {                  // 无名沈注释掉
   \   0000000A   0x7D20             LDRB     R0,[R4, #+20]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD103             BNE.N    ??MB_RTU_RxByte_0
    757                  pch->RTU_TimeoutEn = MODBUS_TRUE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7720             STRB     R0,[R4, #+28]
    758                  pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \   00000014   0x8B20             LDRH     R0,[R4, #+24]
   \   00000016   0x8360             STRH     R0,[R4, #+26]
    759              }                                                         // 无名沈注释掉
    760          #endif
    761                  pch->RTU_TimeoutEn = MODBUS_TRUE;                       //redmorningcn 增加 170526    
   \                     ??MB_RTU_RxByte_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x7720             STRB     R0,[R4, #+28]
    762                  pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;             //redmorningcn 增加 170526  接收到数据，超时定时器重启。
   \   0000001C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000001E   0x8360             STRH     R0,[R4, #+26]
    763              
    764              if (pch->RxBufByteCtr < MODBUS_CFG_BUF_SIZE) {              /* No, add received byte to buffer                        */
   \   00000020   0x8E20             LDRH     R0,[R4, #+48]
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xDC09             BGT.N    ??MB_RTU_RxByte_1
    765                  pch->RxCtr++;                                           /* Increment the number of bytes received                   */
   \   00000026   0x6AE0             LDR      R0,[R4, #+44]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x62E0             STR      R0,[R4, #+44]
    766                  *pch->RxBufPtr++ = rx_byte;
   \   0000002C   0x6B60             LDR      R0,[R4, #+52]
   \   0000002E   0x1C41             ADDS     R1,R0,#+1
   \   00000030   0x6361             STR      R1,[R4, #+52]
   \   00000032   0x7005             STRB     R5,[R0, #+0]
    767                  pch->RxBufByteCtr++;                                    /* Increment byte counter to see if we have Rx activity     */
   \   00000034   0x8E20             LDRH     R0,[R4, #+48]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0x8620             STRH     R0,[R4, #+48]
    768              }
    769          }
   \                     ??MB_RTU_RxByte_1: (+1)
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    770          #endif
    771          
    772          /*$PAGE*/
    773          /*
    774          *********************************************************************************************************
    775          *                                              MB_RTU_Rx()
    776          *
    777          * Description : Parses a Modbus RTU packet and processes the request if the packet is valid.
    778          *
    779          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    780          *
    781          * Return(s)   : DEF_TRUE    If all checks pass.
    782          *               DEF_FALSE   If any checks fail.
    783          *
    784          * Caller(s)   : MBM_RxReply()
    785          *               MBS_RTU_Task()
    786          *
    787          * Note(s)     : none.
    788          *********************************************************************************************************
    789          */
    790          
    791          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    792          CPU_BOOLEAN  MB_RTU_Rx (MODBUS_CH  *pch)
    793          {
   \                     MB_RTU_Rx: (+1)
   \   00000000   0xB410             PUSH     {R4}
    794              CPU_INT08U    *prx_data;
    795              CPU_INT08U    *pmsg;
    796              CPU_INT16U     rx_size;
    797              CPU_INT16U     crc;
    798          
    799          
    800              pmsg    = &pch->RxBuf[0];
   \   00000002   0xF100 0x0138      ADD      R1,R0,#+56
    801              
    802          #if MB_AES_EN == DEF_ENABLED  
    803              if ( pch->AesEn )
    804                pch->RxBufByteCtr = MB_AESCbcDecrypt(pch->RxBuf,pch->RxBufByteCtr);
    805          #endif
    806              
    807              rx_size =  pch->RxBufByteCtr;
   \   00000006   0x8E02             LDRH     R2,[R0, #+48]
    808              
    809              if (rx_size >= MODBUS_RTU_MIN_MSG_SIZE) {         /* Is the message long enough?                        */
   \   00000008   0x1F13             SUBS     R3,R2,#+4
   \   0000000A   0x2BFD             CMP      R3,#+253
   \   0000000C   0xD221             BCS.N    ??MB_RTU_Rx_0
    810                  if (rx_size <= MODBUS_CFG_BUF_SIZE) {
    811                      prx_data    = &pch->RxFrameData[0];
   \   0000000E   0xF500 0x7311      ADD      R3,R0,#+580
    812                      *prx_data++ = *pmsg++;                    /* Transfer the node address                          */
   \   00000012   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   00000016   0xF803 0x4B01      STRB     R4,[R3], #+1
    813                      rx_size--;
    814          
    815                      *prx_data++ = *pmsg++;                    /* Transfer the function code                         */
   \   0000001A   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   0000001E   0xF803 0x4B01      STRB     R4,[R3], #+1
    816                      rx_size--;
   \   00000022   0x1E92             SUBS     R2,R2,#+2
    817          
    818                      pch->RxFrameNDataBytes = 0;               /* Transfer the data                                  */
   \   00000024   0xF500 0x7051      ADD      R0,R0,#+836
   \   00000028   0x2400             MOVS     R4,#+0
   \   0000002A   0x8004             STRH     R4,[R0, #+0]
   \   0000002C   0xE007             B.N      ??MB_RTU_Rx_1
    819                      while (rx_size > 2) {
    820                          *prx_data++ = *pmsg++;
   \                     ??MB_RTU_Rx_2: (+1)
   \   0000002E   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   00000032   0xF803 0x4B01      STRB     R4,[R3], #+1
    821                          pch->RxFrameNDataBytes++;
   \   00000036   0x8804             LDRH     R4,[R0, #+0]
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0x8004             STRH     R4,[R0, #+0]
    822                          rx_size--;
   \   0000003C   0x1E52             SUBS     R2,R2,#+1
    823                      }
   \                     ??MB_RTU_Rx_1: (+1)
   \   0000003E   0xB292             UXTH     R2,R2
   \   00000040   0x2A03             CMP      R2,#+3
   \   00000042   0xDAF4             BGE.N    ??MB_RTU_Rx_2
    824          
    825                      crc              = (CPU_INT16U)*pmsg++;   /* Transfer the CRC over.  It's LSB first, then MSB.  */
    826                      crc             += (CPU_INT16U)*pmsg << 8;
    827                      pch->RxFrameCRC  = crc;
   \   00000044   0x780A             LDRB     R2,[R1, #+0]
   \   00000046   0x7849             LDRB     R1,[R1, #+1]
   \   00000048   0xEB02 0x2101      ADD      R1,R2,R1, LSL #+8
   \   0000004C   0x8041             STRH     R1,[R0, #+2]
    828                      return (DEF_TRUE);
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??MB_RTU_Rx_3
    829                  } else {
    830                      return (DEF_FALSE);
    831                  }
    832              } else {
    833                  return (DEF_FALSE);
   \                     ??MB_RTU_Rx_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??MB_RTU_Rx_3: (+1)
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
    834              }
    835          }
    836          #endif
    837          
    838          /*$PAGE*/
    839          /*
    840          *********************************************************************************************************
    841          *                                              MB_RTU_Tx()
    842          *
    843          * Description : A MODBUS message is formed into a buffer and sent to the appropriate communication port.
    844          *               The actual reply is taken from the given MODBUS Frame.
    845          *
    846          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    847          *
    848          * Return(s)   : none.
    849          *
    850          * Caller(s)   : MBM_TxCmd()
    851          *               MBS_RTU_Task()
    852          * 
    853          * Note(s)     : none.
    854          *********************************************************************************************************
    855          */
    856          
    857          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    858          void  MB_RTU_Tx (MODBUS_CH  *pch)
    859          {
   \                     MB_RTU_Tx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    860              CPU_INT08U  *ptx_data;
    861              CPU_INT08U  *pbuf;
    862              CPU_INT08U   i;
    863              CPU_INT16U   tx_bytes;
    864              CPU_INT16U   crc;
    865          
    866          
    867              tx_bytes  = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    868              pbuf      = &pch->TxBuf[0];                                    /* Point to the beginning of the output buffer.             */
   \   00000006   0xF504 0x76A2      ADD      R6,R4,#+324
    869              ptx_data  = &(pch->TxFrameData[0]);
   \   0000000A   0xF204 0x304E      ADDW     R0,R4,#+846
    870              i         = (CPU_INT08U)pch->TxFrameNDataBytes + 2;            /* Include the actual data in the buffer                    */
   \   0000000E   0xF204 0x474E      ADDW     R7,R4,#+1102
   \   00000012   0x8839             LDRH     R1,[R7, #+0]
   \   00000014   0x1C89             ADDS     R1,R1,#+2
   \   00000016   0xE005             B.N      ??MB_RTU_Tx_0
    871              while (i > 0) {
    872                  *pbuf++ = *ptx_data++;
   \                     ??MB_RTU_Tx_1: (+1)
   \   00000018   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \   0000001C   0xF806 0x2B01      STRB     R2,[R6], #+1
    873                  tx_bytes++;
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
    874                  i--;
   \   00000022   0x1E49             SUBS     R1,R1,#+1
    875              }
   \                     ??MB_RTU_Tx_0: (+1)
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD1F6             BNE.N    ??MB_RTU_Tx_1
    876              crc               = MB_RTU_TxCalcCRC(pch);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       MB_RTU_TxCalcCRC
    877              *pbuf++           = (CPU_INT08U)(crc & 0x00FF);                /* Add in the CRC checksum.  Low byte first!                */
   \   00000030   0x7030             STRB     R0,[R6, #+0]
    878              *pbuf             = (CPU_INT08U)(crc >> 8);
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x0A09             LSRS     R1,R1,#+8
   \   00000036   0x7071             STRB     R1,[R6, #+1]
    879              tx_bytes         += 2;
    880              pch->TxFrameCRC   = crc;                                       /* Save the calculated CRC in the channel                   */
   \   00000038   0x8078             STRH     R0,[R7, #+2]
    881              
    882              pch->TxBufByteCtr = tx_bytes;
   \   0000003A   0x1CA8             ADDS     R0,R5,#+2
   \   0000003C   0xF8A4 0x013C      STRH     R0,[R4, #+316]
    883              
    884          #if MB_AES_EN == DEF_ENABLED  
    885              if ( pch->AesEn )
    886                pch->TxBufByteCtr = MB_AESCbcEncrypt(pch->TxBuf,pch->TxBufByteCtr);
    887          #endif
    888              
    889              MB_Tx(pch);                                                    /* Send it out the communication driver.                    */
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000046   0x....             B.N      MB_Tx
    890          }
    891          #endif
    892          
    893          /*$PAGE*/
    894          /*
    895          *********************************************************************************************************
    896          *                                           MB_RTU_TmrReset()
    897          *
    898          * Description : This function is called when a byte a received and thus, we reset the RTU timeout timer value
    899          *               indicating that we are not done receiving a complete RTU packet.
    900          *
    901          * Argument(s) : none
    902          *
    903          * Return(s)   : none.
    904          *
    905          * Caller(s)   : MB_RTU_TmrResetAll()
    906          *
    907          * Note(s)     : none.
    908          *********************************************************************************************************
    909          */
    910          
    911          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    912          void  MB_RTU_TmrReset (MODBUS_CH  *pch)
    913          {
    914              pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \                     MB_RTU_TmrReset: (+1)
   \   00000000   0x8B01             LDRH     R1,[R0, #+24]
   \   00000002   0x8341             STRH     R1,[R0, #+26]
    915          }
   \   00000004   0x4770             BX       LR               ;; return
    916          #endif
    917          
    918          /*$PAGE*/
    919          /*
    920          *********************************************************************************************************
    921          *                                           MB_RTU_TmrResetAll()
    922          *
    923          * Description : This function is used to reset all the RTU timers for all Modbus channels.
    924          *
    925          * Argument(s) : none
    926          *
    927          * Return(s)   : none.
    928          *
    929          * Caller(s)   : MB_RTU_TmrInit()
    930          *
    931          * Note(s)     : none.
    932          *********************************************************************************************************
    933          */
    934          
    935          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    936          void  MB_RTU_TmrResetAll (void)
    937          {
   \                     MB_RTU_TmrResetAll: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    938              CPU_INT08U   ch;
    939              MODBUS_CH   *pch;
    940          
    941          
    942              pch = &MB_ChTbl[0];
   \   00000002   0x....             LDR.N    R4,??DataTable5_1
    943              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE008             B.N      ??MB_RTU_TmrResetAll_0
    944                  if (pch->Mode == MODBUS_MODE_RTU) {
   \                     ??MB_RTU_TmrResetAll_1: (+1)
   \   00000008   0x7CE0             LDRB     R0,[R4, #+19]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??MB_RTU_TmrResetAll_2
    945                      MB_RTU_TmrReset(pch);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       MB_RTU_TmrReset
    946                  }
    947                  pch++;
   \                     ??MB_RTU_TmrResetAll_2: (+1)
   \   00000014   0xF504 0x648D      ADD      R4,R4,#+1128
    948              }
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MB_RTU_TmrResetAll_0: (+1)
   \   0000001A   0x2D04             CMP      R5,#+4
   \   0000001C   0xDBF4             BLT.N    ??MB_RTU_TmrResetAll_1
    949          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    950          #endif
    951          
    952          /*$PAGE*/
    953          /*
    954          *********************************************************************************************************
    955          *                                           MB_RTU_TmrUpdate()
    956          *
    957          * Description : This function is called when the application supplied RTU framing timer expires.
    958          *
    959          * Argument(s) : none
    960          *
    961          * Return(s)   : none.
    962          *
    963          * Caller(s)   : MB_RTU_TmrISR_Handler()
    964          *
    965          * Note(s)     : none.
    966          *********************************************************************************************************
    967          */
    968          
    969          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    970          void  MB_RTU_TmrUpdate (void)
    971          {
   \                     MB_RTU_TmrUpdate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    972              CPU_INT08U   ch;
    973              MODBUS_CH   *pch;
    974          
    975              pch = &MB_ChTbl[0];
   \   00000002   0x....             LDR.N    R4,??DataTable5_1
    976              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE004             B.N      ??MB_RTU_TmrUpdate_0
    977                  if (pch->Mode == MODBUS_MODE_RTU) {
    978                      if (pch->RTU_TimeoutEn == DEF_TRUE) {
    979                          if (pch->RTU_TimeoutCtr > 0) {
    980                              pch->RTU_TimeoutCtr--;
    981                              if (
    982                                          pch->RTU_TimeoutCtr == 0                        //redmorningcn 超时
    983                                    ||    pch->RxBufByteCtr >= MODBUS_CFG_BUF_SIZE -1     //redmorningcn 20170919接收区已满   
    984                                  ) {
    985          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    986                                  //if (pch->MasterSlave == MODBUS_MASTER) {  // 无名沈注释掉
    987                                      pch->RTU_TimeoutEn = DEF_FALSE;
    988                                  //}                                         // 无名沈注释掉
    989          #endif
    990                                  //redmorningcn 在信号超时发送信号量的基础上，增加接收缓冲区满也发送信号量 20170919
    991                                  MB_OS_RxSignal(pch);          /* RTU Timer expired for this Modbus channel         */
    992                              }
    993                          }
    994                      } else {
    995                          pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \                     ??MB_RTU_TmrUpdate_1: (+1)
   \   00000008   0x8B20             LDRH     R0,[R4, #+24]
   \   0000000A   0x8360             STRH     R0,[R4, #+26]
    996                      }
    997                  }
    998                  pch++;
   \                     ??MB_RTU_TmrUpdate_2: (+1)
   \   0000000C   0xF504 0x648D      ADD      R4,R4,#+1128
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MB_RTU_TmrUpdate_0: (+1)
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xDA16             BGE.N    ??MB_RTU_TmrUpdate_3
   \   00000016   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F7             BNE.N    ??MB_RTU_TmrUpdate_2
   \   0000001C   0x7F20             LDRB     R0,[R4, #+28]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD1F2             BNE.N    ??MB_RTU_TmrUpdate_1
   \   00000022   0x8B60             LDRH     R0,[R4, #+26]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD0F1             BEQ.N    ??MB_RTU_TmrUpdate_2
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x8360             STRH     R0,[R4, #+26]
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ.N    ??MB_RTU_TmrUpdate_4
   \   00000032   0x8E20             LDRH     R0,[R4, #+48]
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xDBE9             BLT.N    ??MB_RTU_TmrUpdate_2
   \                     ??MB_RTU_TmrUpdate_4: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7720             STRB     R0,[R4, #+28]
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       MB_OS_RxSignal
   \   00000042   0xE7E3             B.N      ??MB_RTU_TmrUpdate_2
    999              }
   1000          }
   \                     ??MB_RTU_TmrUpdate_3: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1001          #endif
   1002          /*******************************************************************************
   1003           * 名    称： NMB_Tx
   1004           * 功    能： 非MODBUS通信协议发送
   1005           * 入口参数： 无
   1006           * 出口参数： 无
   1007           * 作  　者： 无名沈
   1008           * 创建日期： 2015-03-28
   1009           * 修    改：
   1010           * 修改日期：
   1011           * 备    注： 该初始化会创建Modbus任务。
   1012           *******************************************************************************/
   1013          
   1014          #if (MB_NONMODBUS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1015          void NMB_Tx(MODBUS_CH   *pch,
   1016                      CPU_INT08U  *p_reg_tbl,
   1017                      CPU_INT16U   nbr_bytes)
   1018          {
   \                     NMB_Tx: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1019              CPU_INT08U  *ptx_data;
   1020              CPU_INT08U  *pbuf;
   1021              CPU_INT08U   i;
   1022          
   1023              if ( p_reg_tbl != &pch->TxBuf[0] ) {
   \   00000004   0xF504 0x70A2      ADD      R0,R4,#+324
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xD009             BEQ.N    ??NMB_Tx_0
   1024                  pbuf      = &pch->TxBuf[0];                                     /* Point to the beginning of the output buffer.             */
   1025                  ptx_data  = p_reg_tbl;
   1026                  i         = nbr_bytes;                                          /* Include the actual data in the buffer                    */
   \   0000000C   0x4613             MOV      R3,R2
   \   0000000E   0xE004             B.N      ??NMB_Tx_1
   1027                  
   1028                  while (i > 0) {
   1029                      *pbuf++ = *ptx_data++;
   \                     ??NMB_Tx_2: (+1)
   \   00000010   0xF811 0x5B01      LDRB     R5,[R1], #+1
   \   00000014   0xF800 0x5B01      STRB     R5,[R0], #+1
   1030                      i--;
   \   00000018   0x1E5B             SUBS     R3,R3,#+1
   1031                  }
   \                     ??NMB_Tx_1: (+1)
   \   0000001A   0xB2DB             UXTB     R3,R3
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD1F7             BNE.N    ??NMB_Tx_2
   1032              }
   1033              pch->TxBufByteCtr = nbr_bytes;
   \                     ??NMB_Tx_0: (+1)
   \   00000020   0xF8A4 0x213C      STRH     R2,[R4, #+316]
   1034              
   1035          #if MB_AES_EN == DEF_ENABLED  
   1036              if ( pch->AesEn )
   1037                pch->TxBufByteCtr = MB_AESCbcEncrypt(pch->TxBuf,pch->TxBufByteCtr);
   1038          #endif
   1039              if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000024   0x7D20             LDRB     R0,[R4, #+20]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD107             BNE.N    ??NMB_Tx_3
   1040                  CPU_INT16U      err;
   1041                  MB_OS_TxWait(pch,&err);
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       MB_OS_TxWait
   1042                  if ( err != MODBUS_ERR_NONE )
   \   00000032   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD102             BNE.N    ??NMB_Tx_4
   1043                      return;
   1044              }
   1045              MB_Tx(pch);                                                    /* Send it out the communication driver.                    */
   \                     ??NMB_Tx_3: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       MB_Tx
   1046          }
   \                     ??NMB_Tx_4: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     MB_ChCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     MB_ChCtr+0xE4
   1047          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   MB_CfgCh
        32   -> MB_ChToPortMap
        32   -> MB_CommPortCfg
        32   -> MB_MasterTimeoutSet
        32   -> MB_ModeSet
        32   -> MB_NodeAddrSet
        32   -> MB_WrEnSet
       0   MB_ChToPortMap
       8   MB_Exit
         8   -> MB_CommExit
         0   -> MB_OS_Exit
         8   -> MB_RTU_TmrExit
      16   MB_Init
        16   -> MBS_StatInit
        16   -> MB_OS_Init
         0   -> MB_RTU_TmrInit
       0   MB_MasterTimeoutSet
       0   MB_ModeSet
       0   MB_NodeAddrSet
       4   MB_RTU_Rx
      16   MB_RTU_RxByte
        16   -> MB_RTU_TmrReset
       0   MB_RTU_TmrReset
      16   MB_RTU_TmrResetAll
        16   -> MB_RTU_TmrReset
      16   MB_RTU_TmrUpdate
        16   -> MB_OS_RxSignal
      24   MB_RTU_Tx
        24   -> MB_RTU_TxCalcCRC
         0   -> MB_Tx
       0   MB_RxByte
         0   -> MB_RTU_RxByte
       0   MB_RxTask
         0   -> MBS_RxTask
       8   MB_Tx
         8   -> MB_CommRxIntDis
         0   -> MB_CommTxIntEn
         8   -> MB_TxByte
       8   MB_TxByte
         0   -> MB_CommRxIntEn
         8   -> MB_CommTx1
         8   -> MB_CommTxIntDis
       0   MB_WrEnSet
      16   NMB_Tx
        16   -> MB_OS_TxWait
        16   -> MB_Tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
     168  MB_CfgCh
    4740  MB_ChCtr
          MB_RTU_Freq
          MB_OS_RxSemTbl
          MB_OS_TxSemTbl
          MB_ChTbl
       2  MB_ChSize
       8  MB_ChToPortMap
      18  MB_Exit
      82  MB_Init
       8  MB_MasterTimeoutSet
      34  MB_ModeSet
       8  MB_NodeAddrSet
      88  MB_RTU_Rx
      60  MB_RTU_RxByte
       4  MB_RTU_TmrCtr
       6  MB_RTU_TmrReset
      32  MB_RTU_TmrResetAll
      70  MB_RTU_TmrUpdate
      72  MB_RTU_Tx
      10  MB_RxByte
      16  MB_RxTask
       4  MB_TotalRAMSize
      34  MB_Tx
      80  MB_TxByte
       8  MB_WrEnSet
      66  NMB_Tx

 
 4 744 bytes in section .bss
     6 bytes in section .rodata
   876 bytes in section .text
 
   876 bytes of CODE  memory
     6 bytes of CONST memory
 4 744 bytes of DATA  memory

Errors: none
Warnings: none
