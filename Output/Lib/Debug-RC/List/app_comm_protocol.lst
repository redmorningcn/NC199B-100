###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       23/Nov/2017  13:36:18
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\APP\Protocol\app_comm_protocol.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\Protocol\app_comm_protocol.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\app_comm_protocol.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\app_comm_protocol.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\Protocol\app_comm_protocol.c
      1          /*******************************************************************************
      2           *   Filename:       app_lib.c
      3           *   Revised:        All copyrights reserved to Wuming Shen.
      4           *   Date:           2014-07-05
      5           *   Revision:       v1.0
      6           *   Writer:	     Wuming Shen.
      7           *
      8           *   Description:    双击选中 wdt 按 Ctrl + H, 钩选 Match the case, Replace with
      9           *                   输入您要的名字，点击 Replace All
     10           *                   双击选中 Wdt 按 Ctrl + H, 钩选 Match the case, Replace with
     11           *                   输入您要的名字，点击 Replace All
     12           *                   双击选中 WDT 按 Ctrl + H, 钩选 Match the case, Replace with
     13           *                   输入您要的名字，点击 Replace All
     14           *                   在 app_cfg.h 中指定任务的优先级 和 任务堆栈大小
     15           *
     16           *   Notes:
     17           *					QQ:276193028
     18           *     				E-mail:shenchangwei945@163.com
     19           *
     20           *******************************************************************************/
     21          
     22          /*******************************************************************************
     23           * INCLUDES
     24           */
     25          #define  SNL_APP_SOURCE
     26          #include <app.h>
     27          #include <app_chk.h>
     28          #include <bsp_usart.h>
     29          
     30          #define BSP_COMM_PROTOCOL_MODULE_EN 1
     31          #if BSP_COMM_PROTOCOL_MODULE_EN > 0
     32          
     33          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     34          const  CPU_CHAR  *app_comm_protocol__c = "$Id: $";
     35          #endif
     36          
     37          /*******************************************************************************
     38           * CONSTANTS
     39           */
     40          
     41          /*******************************************************************************
     42           * MACROS
     43           */
     44          
     45          /*******************************************************************************
     46           * TYPEDEFS
     47           */
     48               
     49          /*******************************************************************************
     50           * LOCAL VARIABLES
     51           */
     52          
     53          /*******************************************************************************
     54           * GLOBAL VARIABLES
     55           */
     56          
     57          /*******************************************************************************
     58           * LOCAL FUNCTIONS
     59           */
     60          
     61          /*******************************************************************************
     62           * GLOBAL FUNCTIONS
     63           */
     64          
     65          /*******************************************************************************
     66           * EXTERN VARIABLES
     67           */
     68          
     69          /*******************************************************************************
     70           * EXTERN FUNCTIONS
     71           */
     72           

   \                                 In section .bss, align 1
     73          unsigned char   l_recslaveaddr = 0;
   \                     l_recslaveaddr:
   \   00000000                      DS8 1
     74          
     75          /***********************************************
     76          * 描述： 
     77          */

   \                                 In section .text, align 2, keep-with-next
     78          unsigned char GetRecSlaveAddr(void)
     79          {
     80          	return	l_recslaveaddr;
   \                     GetRecSlaveAddr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     81          }
     82          

   \                                 In section .bss, align 1
     83          static INT08U	RecvFrameNbr = 0;
   \                     RecvFrameNbr:
   \   00000000                      DS8 1
     84          /***********************************************
     85          * 描述： 
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          INT08U	GetRecvFrameNbr(void)
     88          {
     89          	return 	RecvFrameNbr;
   \                     GetRecvFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     90          }
     91          
     92          
     93          /***********************************************
     94          * 描述： 
     95          */

   \                                 In section .text, align 2, keep-with-next
     96          void	SetRecvFrameNbr(void)
     97          {
     98          	RecvFrameNbr++;		
   \                     SetRecvFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_1
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
     99          }
   \   00000008   0x4770             BX       LR               ;; return
    100          
    101          /*******************************************************************************
    102          * 名    称： GetCheckSumNR
    103          * 功    能： 
    104          * 入口参数： 无
    105          * 出口参数： 无
    106          * 作　 　者： wumingshen.
    107          * 创建日期： 2015-12-07
    108          * 修    改：
    109          * 修改日期：
    110          * 备    注：
    111          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    112          INT08U GetCheckSumNR(INT08U  Buf[], INT32U Len)
    113          {
   \                     GetCheckSumNR: (+1)
   \   00000000   0xB410             PUSH     {R4}
    114              INT32S  i;
    115              INT08U   CheckSum = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    116              
    117              for(i = 0;i < Len; i++) {
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xE003             B.N      ??GetCheckSumNR_0
    118                  CheckSum += Buf[i];                         //求和
   \                     ??GetCheckSumNR_1: (+1)
   \   00000008   0x5C1C             LDRB     R4,[R3, R0]
   \   0000000A   0x18A2             ADDS     R2,R4,R2
   \   0000000C   0xB2D2             UXTB     R2,R2
    119              }
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??GetCheckSumNR_0: (+1)
   \   00000010   0x428B             CMP      R3,R1
   \   00000012   0xD3F9             BCC.N    ??GetCheckSumNR_1
    120              
    121              if((unsigned char)CheckSum >= 0x80) {
   \   00000014   0x4610             MOV      R0,R2
   \   00000016   0x2880             CMP      R0,#+128
   \   00000018   0xDB03             BLT.N    ??GetCheckSumNR_2
    122              	CheckSum = ~CheckSum + 1 +0x80;             //取反+1
   \   0000001A   0x43D0             MVNS     R0,R2
   \   0000001C   0xF1A0 0x027F      SUB      R2,R0,#+127
   \   00000020   0xB2D2             UXTB     R2,R2
    123              } else {
    124              	CheckSum = CheckSum;                       	//取反+1
    125              }
    126              return  CheckSum;
   \                     ??GetCheckSumNR_2: (+1)
   \   00000022   0x4610             MOV      R0,R2
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
    127          }
    128          
    129          /*******************************************************************************
    130          * 名    称： CSNC_GetData
    131          * 功    能： 
    132          * 入口参数： 无
    133          * 出口参数： 无
    134          * 作　 　者： wumingshen.
    135          * 创建日期： 2015-12-07
    136          * 修    改：
    137          * 修改日期：
    138          * 备    注：
    139          *******************************************************************************/
    140          //unsigned char  CSNC_GetData(	INT08U *RecvBuf,
    141          //								INT16U	RecLen,
    142          //								INT08U *DataBuf,
    143          //								INT16U *InfoLen)

   \                                 In section .text, align 2, keep-with-next
    144          unsigned char  CSNC_GetData(	INT08U *RecvBuf,
    145          								INT16U	RecvLen,
    146                                          StrNcProtocol   *pack)
    147          {
   \                     CSNC_GetData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
    148              unsigned short		j,k;
    149              unsigned char		SumCheck8;
    150              unsigned char		Tmp;
    151              unsigned short		RecCRC16,Check16;
    152          		
    153          	unsigned short		DataLen          = pack->Len;
    154              unsigned char     *pDat             = RecvBuf;    
    155              unsigned short    MaxDataLen        = RecvLen - 2;
   \   00000008   0x1E88             SUBS     R0,R1,#+2
    156              
    157              //pack->Len            = 0;
    158              /***********************************************
    159              * 描述： 识别帧头
    160              */
    161          //    for(i = 0; i < MaxDataLen; i++)	{		        //循环遍历
    162          //		if(	( (pack->Data[i + 0] ) == FRAM_HERD0 ) && 
    163          //            ( (pack->Data[i + 1] ) == FRAM_HERD1 ) ) {
    164          //            pDat    = &pack->Data[i];
    165          //            goto next;
    166          //        }
    167          //    }
    168          //    return 0;
    169              /***********************************************
    170              * 描述： 接收数据去掉帧头识别字0X10的重复部分
    171              */
    172          	for(j = 0;j < RecvLen ;j++ )	{				    //去重复通讯首字节
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xE007             B.N      ??CSNC_GetData_0
    173                  if( ( pDat[j]   == FRAM_HERD0 ) &&
    174                      ( pDat[j+1] == FRAM_HERD0 ) ) {
    175                      for(k = j; k < RecvLen; k++) {
    176                         Tmp	        = pDat[k+1];
    177                         pDat[k]      = Tmp;
   \                     ??CSNC_GetData_1: (+1)
   \   0000000E   0x191F             ADDS     R7,R3,R4
   \   00000010   0x787F             LDRB     R7,[R7, #+1]
   \   00000012   0x551F             STRB     R7,[R3, R4]
    178                      }
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0xB29B             UXTH     R3,R3
   \                     ??CSNC_GetData_2: (+1)
   \   00000018   0x428B             CMP      R3,R1
   \   0000001A   0xDBF8             BLT.N    ??CSNC_GetData_1
   \                     ??CSNC_GetData_3: (+1)
   \   0000001C   0x1C52             ADDS     R2,R2,#+1
   \                     ??CSNC_GetData_0: (+1)
   \   0000001E   0xB292             UXTH     R2,R2
   \   00000020   0x428A             CMP      R2,R1
   \   00000022   0xD209             BCS.N    ??CSNC_GetData_4
   \   00000024   0x4613             MOV      R3,R2
   \   00000026   0x5D1F             LDRB     R7,[R3, R4]
   \   00000028   0x2F10             CMP      R7,#+16
   \   0000002A   0xD1F7             BNE.N    ??CSNC_GetData_3
   \   0000002C   0x191B             ADDS     R3,R3,R4
   \   0000002E   0x785B             LDRB     R3,[R3, #+1]
   \   00000030   0x2B10             CMP      R3,#+16
   \   00000032   0xD1F3             BNE.N    ??CSNC_GetData_3
   \   00000034   0x4613             MOV      R3,R2
   \   00000036   0xE7EF             B.N      ??CSNC_GetData_2
    179                  }
    180          	}
    181              pDat    += 6;
    182              DataLen  = *pDat;
   \                     ??CSNC_GetData_4: (+1)
   \   00000038   0x79A7             LDRB     R7,[R4, #+6]
    183              // 长度超范围
    184              if ( DataLen > MaxDataLen )
   \   0000003A   0xB280             UXTH     R0,R0
   \   0000003C   0x42B8             CMP      R0,R7
   \   0000003E   0xDB2C             BLT.N    ??CSNC_GetData_5
    185                  return 0;
    186              
    187              pDat    += DataLen + 4;
    188              /***********************************************
    189              * 描述： 检查帧尾
    190              */
    191          //    if( ( pDat[0] 	!= FRAM_END0)	||
    192          //        ( pDat[1] 	!= FRAM_END1) ) {
    193          //        return 0;
    194          //    }
    195              pDat            = RecvBuf;
    196              SumCheck8 		= GetCheckSumNR((unsigned char *)&pDat[2],5);	//索引区校验
   \   00000040   0x2105             MOVS     R1,#+5
   \   00000042   0x1CA0             ADDS     R0,R4,#+2
   \   00000044   0x.... 0x....      BL       GetCheckSumNR
   \   00000048   0x4680             MOV      R8,R0
    197              RecCRC16 		= ((unsigned short)pDat[8+DataLen])
    198                              * 256 + pDat[9+DataLen];	        //校验	
   \   0000004A   0x1938             ADDS     R0,R7,R4
   \   0000004C   0x7A01             LDRB     R1,[R0, #+8]
   \   0000004E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000050   0xEB00 0x2901      ADD      R9,R0,R1, LSL #+8
    199                         
    200              switch((pDat[5]>>4) & 0x03) {							    //校验和算法判断
   \   00000054   0x7960             LDRB     R0,[R4, #+5]
   \   00000056   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD105             BNE.N    ??CSNC_GetData_6
    201              case	RS485_CHK_SUM:
    202                  break;
    203              case	RS485_CHK_CRC:
    204                 Check16 = GetCrc16Chk1(&pDat[2],6+DataLen);
   \   0000005E   0x1DB9             ADDS     R1,R7,#+6
   \   00000060   0xB289             UXTH     R1,R1
   \   00000062   0x1CA0             ADDS     R0,R4,#+2
   \   00000064   0x.... 0x....      BL       GetCrc16Chk1
   \   00000068   0x4606             MOV      R6,R0
    205                  break;
    206              case	RS485_CHK_RESUM:
    207                  break;
    208              }
    209              
    210              if(	(SumCheck8 == 	pDat[7] ) && 
    211                  (RecCRC16  ==	Check16 ) ) {
   \                     ??CSNC_GetData_6: (+1)
   \   0000006A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000006C   0x4580             CMP      R8,R0
   \   0000006E   0xD114             BNE.N    ??CSNC_GetData_5
   \   00000070   0xFA1F 0xF989      UXTH     R9,R9
   \   00000074   0xB2B6             UXTH     R6,R6
   \   00000076   0x45B1             CMP      R9,R6
   \   00000078   0xD10F             BNE.N    ??CSNC_GetData_5
    212                  /***********************************************
    213                  * 描述： 获取帧头
    214                  */
    215                  pack->SrcAddr 	= pDat[2];
   \   0000007A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000007C   0x7028             STRB     R0,[R5, #+0]
    216                  pack->DstAddr   = pDat[3];
   \   0000007E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000080   0x7068             STRB     R0,[R5, #+1]
    217                  pack->RecvSn   	= pDat[4];
   \   00000082   0x7920             LDRB     R0,[R4, #+4]
   \   00000084   0x70E8             STRB     R0,[R5, #+3]
    218                  pack->Pack.Dat 	= pDat[5];
   \   00000086   0x7960             LDRB     R0,[R4, #+5]
   \   00000088   0x7128             STRB     R0,[R5, #+4]
    219                  pack->Len 		= pDat[6]; 
   \   0000008A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000008C   0x7168             STRB     R0,[R5, #+5]
    220                  pack->Data      =&pDat[8];
   \   0000008E   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000092   0xF8C5 0x0006      STR      R0,[R5, #+6]
    221                  return		pack->DstAddr;
   \   00000096   0x7868             LDRB     R0,[R5, #+1]
   \   00000098   0xE000             B.N      ??CSNC_GetData_7
    222              }
    223                         
    224              return	0;
   \                     ??CSNC_GetData_5: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \                     ??CSNC_GetData_7: (+1)
   \   0000009C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    225          }
    226          

   \                                 In section .bss, align 1
    227          static INT08U	SendFrameNbr = 0;
   \                     SendFrameNbr:
   \   00000000                      DS8 1
    228          
    229          /***********************************************
    230          * 描述： 
    231          */

   \                                 In section .text, align 2, keep-with-next
    232          INT08U	GetSendFrameNbr(void)
    233          {
    234          	return SendFrameNbr;		
   \                     GetSendFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    235          }
    236          
    237          /***********************************************
    238          * 描述： 
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          void	SetSendFrameNbr(void)
    241          {
    242          	SendFrameNbr++;		
   \                     SetSendFrameNbr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_2
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    243          }
   \   00000008   0x4770             BX       LR               ;; return
    244          
    245          /*******************************************************************************
    246          * 名    称： CSNC_SendData
    247          * 功    能： 
    248          * 入口参数： 无
    249          * 出口参数： 无
    250          * 作  　者： wumingshen.
    251          * 创建日期： 2015-12-07
    252          * 修    改：
    253          * 修改日期：
    254          * 备    注：
    255          *******************************************************************************/
    256          //void	CSNC_SendData(	MODBUS_CH *pch,
    257          //                        INT08U  SourceAddr,
    258          //						INT08U  DistAddr,
    259          //						INT08U *DataBuf,
    260          //						INT16U  DataLen)
    261          //void	CSNC_SendData(	MODBUS_CH       *pch,
    262          //                        StrNcProtocol   *pack)
    263          //{
    264          //	unsigned char	SndBuf[250] = {0};
    265          //	unsigned char	SndBufTmp[250] = {0};
    266          //	unsigned char	SumCheck8;
    267          //	unsigned short	Crc16;
    268          //	unsigned short	AddHeadNum;
    269          //	unsigned short	i;
    270          //	unsigned char	ByteStation;
    271          //    
    272          //	ByteStation = 0;
    273          //	SndBuf[ByteStation++] = FRAM_HERD0;
    274          //	SndBuf[ByteStation++] = FRAM_HERD1;
    275          //	SndBuf[ByteStation++] = pack->SrcAddr;  //SourceAddr;	 
    276          //	SndBuf[ByteStation++] = pack->DstAddr;  //DistAddr;				    // 地址
    277          //	SndBuf[ByteStation++] = pack->SendSn;       //SendFrameNbr;               // SendFrameNbr++;
    278          //	SndBuf[ByteStation++] = pack->Pack.Dat;//(RS485_CHK_CRC<<4) | (PROTOCOL_VER_HIG << 6) | (PROTOCOL_VER_LOW << 0);
    279          //	SndBuf[ByteStation++] = pack->Len;      //DataLen;
    280          //	
    281          //	SumCheck8 = GetCheckSumNR(&SndBuf[2],5);		   	// 索引区校验
    282          //
    283          //	SndBuf[ByteStation++] = SumCheck8;
    284          //
    285          //	//memcpy(&SndBuf[8],DataBuf,DataLen);
    286          //	memcpy(&SndBuf[8],pack->Data,pack->Len);
    287          //
    288          //	Crc16 = GetCrc16Chk1(&SndBuf[2],6+ pack->Len);
    289          //
    290          //	SndBuf[2+6+pack->Len+1] = Crc16;
    291          //	SndBuf[2+6+pack->Len]   = Crc16>>8;
    292          //
    293          //	SndBufTmp[0] = SndBuf[0];						    // 准备数据发送
    294          //	SndBufTmp[1] = SndBuf[1];
    295          //	
    296          //	AddHeadNum = 0;
    297          //	for(i = 2; i< 2+6+pack->Len + 2;i++ )	{				// 数据，补移位 FRAM_HERD0
    298          //		SndBufTmp[i+AddHeadNum] = SndBuf[i];
    299          //		
    300          //		if(SndBuf[i] == FRAM_HERD0) {
    301          //			SndBufTmp[i+AddHeadNum+1] = FRAM_HERD0;
    302          //			AddHeadNum++;
    303          //		}
    304          //	}
    305          //
    306          //	SndBufTmp[2+6+pack->Len + 2 +AddHeadNum] = FRAM_END0;
    307          //	SndBufTmp[2+6+pack->Len + 2 +AddHeadNum+1] = FRAM_END1;      
    308          //    
    309          //    CPU_INT16U nbr_bytes= (2+6+pack->Len + 2 +AddHeadNum +2);
    310          //    if ( nbr_bytes < MB_DATA_NBR_REGS * 2 ) {  
    311          //        NMB_Tx(pch,
    312          //               (CPU_INT08U  *)SndBufTmp,
    313          //               (CPU_INT16U   )nbr_bytes);
    314          //    }
    315          //}
    316          
    317          

   \                                 In section .bss, align 4
    318          static  unsigned char	SndBuf[250] = {0};
    319          static  unsigned char	SndBufTmp[250] = {0};
   \                     SndBufTmp:
   \   00000000                      DS8 252
   \   000000FC                      DS8 252
    320          /*******************************************************************************
    321          * 名    称： CSNC_SendData
    322          * 功    能： 
    323          * 入口参数： 无
    324          * 出口参数： 无
    325          * 作  　者： wumingshen.
    326          * 创建日期： 2015-12-07
    327          * 修    改：
    328          * 修改日期：
    329          * 备    注：
    330          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    331          void	CSNC_SendData(	MODBUS_CH *pch,
    332                                  INT08U  SourceAddr,
    333          						INT08U  DistAddr,
    334                                  INT08U  SendFrameNum,
    335          						INT08U  SendCode,                       
    336          						INT08U *DataBuf,
    337          						INT16U  DataLen)
    338          {
   \                     CSNC_SendData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
    339          	unsigned char	    SumCheck8;
    340          	unsigned short	Crc16;
    341          	unsigned short	AddHeadNum;
    342          	unsigned short	i;
    343          	unsigned char	    ByteStation;	
    344              
    345          	ByteStation = 0;
    346          	SndBuf[ByteStation++] = FRAM_HERD0;
   \   00000006   0x....             LDR.N    R6,??DataTable5_3
   \   00000008   0xF106 0x08FC      ADD      R8,R6,#+252
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0xF888 0x0000      STRB     R0,[R8, #+0]
    347          	SndBuf[ByteStation++] = FRAM_HERD1;
   \   00000012   0x2028             MOVS     R0,#+40
   \   00000014   0xF888 0x0001      STRB     R0,[R8, #+1]
    348          	SndBuf[ByteStation++] = SourceAddr;	 
   \   00000018   0xF888 0x1002      STRB     R1,[R8, #+2]
    349          	SndBuf[ByteStation++] = DistAddr;				    // 地址
   \   0000001C   0xF888 0x2003      STRB     R2,[R8, #+3]
    350          	SndBuf[ByteStation++] = SendFrameNum;               // 发送帧序号
   \   00000020   0xF888 0x3004      STRB     R3,[R8, #+4]
    351          
    352          	SndBuf[ByteStation++] =  ( RS485_CHK_CRC<<4 )+ SendCode;// 发送控制字	
   \   00000024   0x9808             LDR      R0,[SP, #+32]
   \   00000026   0x3010             ADDS     R0,R0,#+16
   \   00000028   0xF888 0x0005      STRB     R0,[R8, #+5]
   \   0000002C   0x9C0A             LDR      R4,[SP, #+40]
    353          	SndBuf[ByteStation++] = DataLen;
   \   0000002E   0xF888 0x4006      STRB     R4,[R8, #+6]
    354          	
    355          	SumCheck8 = GetCheckSumNR(&SndBuf[2],5);		   	// 索引区校验
    356          
    357          	SndBuf[ByteStation++] = SumCheck8;
   \   00000032   0xF106 0x09FE      ADD      R9,R6,#+254
   \   00000036   0x2105             MOVS     R1,#+5
   \   00000038   0x4648             MOV      R0,R9
   \   0000003A   0x.... 0x....      BL       GetCheckSumNR
   \   0000003E   0xF888 0x0007      STRB     R0,[R8, #+7]
    358          
    359          	memcpy(&SndBuf[8],DataBuf,DataLen);
   \   00000042   0x4622             MOV      R2,R4
   \   00000044   0x9909             LDR      R1,[SP, #+36]
   \   00000046   0xF506 0x7082      ADD      R0,R6,#+260
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy
    360          
    361          	Crc16 = GetCrc16Check(&SndBuf[2],6+DataLen);
   \   0000004E   0x4627             MOV      R7,R4
   \   00000050   0x1DB9             ADDS     R1,R7,#+6
   \   00000052   0x4648             MOV      R0,R9
   \   00000054   0x.... 0x....      BL       GetCrc16Check
   \   00000058   0xB280             UXTH     R0,R0
    362          
    363          	SndBuf[2+6+DataLen+1] = Crc16;
   \   0000005A   0x19B9             ADDS     R1,R7,R6
   \   0000005C   0xF501 0x7182      ADD      R1,R1,#+260
   \   00000060   0x7048             STRB     R0,[R1, #+1]
    364          	SndBuf[2+6+DataLen]   = Crc16>>8;
   \   00000062   0x0A00             LSRS     R0,R0,#+8
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    365          
    366          	SndBufTmp[0] = SndBuf[0];						    // 准备数据发送
   \   00000066   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000006A   0x7030             STRB     R0,[R6, #+0]
    367          	SndBufTmp[1] = SndBuf[1];
   \   0000006C   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   00000070   0x7070             STRB     R0,[R6, #+1]
    368          	
    369          	AddHeadNum = 0;
   \   00000072   0x2000             MOVS     R0,#+0
    370          	for(i = 2; i< 2+6+DataLen + 2 + AddHeadNum;i++ )	{				// 数据，补移位 FRAM_HERD0
   \   00000074   0x2102             MOVS     R1,#+2
   \   00000076   0xE00D             B.N      ??CSNC_SendData_0
   \                     ??CSNC_SendData_1: (+1)
   \   00000078   0x198A             ADDS     R2,R1,R6
   \   0000007A   0xF892 0x20FC      LDRB     R2,[R2, #+252]
   \   0000007E   0x1843             ADDS     R3,R0,R1
   \   00000080   0x559A             STRB     R2,[R3, R6]
    371          	
    372          		SndBufTmp[i+AddHeadNum] = SndBuf[i];
    373          		
    374          		if(SndBuf[i] == FRAM_HERD0) {
   \   00000082   0x2A10             CMP      R2,#+16
   \   00000084   0xD104             BNE.N    ??CSNC_SendData_2
    375          			SndBufTmp[i+AddHeadNum+1] = FRAM_HERD0;
   \   00000086   0x2210             MOVS     R2,#+16
   \   00000088   0x199B             ADDS     R3,R3,R6
   \   0000008A   0x705A             STRB     R2,[R3, #+1]
    376          			AddHeadNum++;
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0xB280             UXTH     R0,R0
    377          		}
    378          	}
   \                     ??CSNC_SendData_2: (+1)
   \   00000090   0x1C49             ADDS     R1,R1,#+1
   \   00000092   0xB289             UXTH     R1,R1
   \                     ??CSNC_SendData_0: (+1)
   \   00000094   0x19C2             ADDS     R2,R0,R7
   \   00000096   0xF102 0x030A      ADD      R3,R2,#+10
   \   0000009A   0x4299             CMP      R1,R3
   \   0000009C   0xDBEC             BLT.N    ??CSNC_SendData_1
    379          
    380          	SndBufTmp[2+6+DataLen + 2 +AddHeadNum] = FRAM_END0;
   \   0000009E   0x1991             ADDS     R1,R2,R6
   \   000000A0   0x2210             MOVS     R2,#+16
   \   000000A2   0x728A             STRB     R2,[R1, #+10]
    381          	SndBufTmp[2+6+DataLen + 2 +AddHeadNum+1] = FRAM_END1;      
   \   000000A4   0x222C             MOVS     R2,#+44
   \   000000A6   0x72CA             STRB     R2,[R1, #+11]
    382              
    383              CPU_INT16U nbr_bytes= (2+6+DataLen + 2 +AddHeadNum +2);
   \   000000A8   0x1900             ADDS     R0,R0,R4
   \   000000AA   0xF100 0x020C      ADD      R2,R0,#+12
    384              if ( nbr_bytes < MB_DATA_NBR_REGS * 2 ) {  
   \   000000AE   0xB292             UXTH     R2,R2
   \   000000B0   0x2AFA             CMP      R2,#+250
   \   000000B2   0xDA08             BGE.N    ??CSNC_SendData_3
    385                  //串口在非接收状态，发送数据。
    386                  if (pch->RxBufByteCtr == 0) 
   \   000000B4   0x8E28             LDRH     R0,[R5, #+48]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD105             BNE.N    ??CSNC_SendData_3
    387                  {                
    388                      NMB_Tx(pch,
    389                             (CPU_INT08U  *)SndBufTmp,
    390                             (CPU_INT16U   )nbr_bytes);
   \   000000BA   0x4631             MOV      R1,R6
   \   000000BC   0x4628             MOV      R0,R5
   \   000000BE   0xE8BD 0x43F8      POP      {R3-R9,LR}
   \   000000C2   0x.... 0x....      B.W      NMB_Tx
    391                  }
    392                  else
    393                  {
    394                      return;
    395                  }
    396              }
    397          }
   \                     ??CSNC_SendData_3: (+1)
   \   000000C6   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     l_recslaveaddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     RecvFrameNbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     SendFrameNbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     SndBufTmp
    398          
    399          
    400          /*******************************************************************************
    401           * 				                    end of file                                *
    402           *******************************************************************************/
    403          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   CSNC_GetData
        32   -> GetCheckSumNR
        32   -> GetCrc16Chk1
      32   CSNC_SendData
        32   -> GetCheckSumNR
        32   -> GetCrc16Check
         0   -> NMB_Tx
        32   -> __aeabi_memcpy
       4   GetCheckSumNR
       0   GetRecSlaveAddr
       0   GetRecvFrameNbr
       0   GetSendFrameNbr
       0   SetRecvFrameNbr
       0   SetSendFrameNbr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
     160  CSNC_GetData
     202  CSNC_SendData
      40  GetCheckSumNR
       6  GetRecSlaveAddr
       6  GetRecvFrameNbr
       6  GetSendFrameNbr
       1  RecvFrameNbr
       1  SendFrameNbr
      10  SetRecvFrameNbr
      10  SetSendFrameNbr
     504  SndBufTmp
          SndBuf
       1  l_recslaveaddr

 
 507 bytes in section .bss
 456 bytes in section .text
 
 456 bytes of CODE memory
 507 bytes of DATA memory

Errors: none
Warnings: 1
