###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_msg.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_msg.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\os_msg.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\os_msg.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\Micrium\uC-OS-III\Source\os_msg.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                              MESSAGE HANDLING SERVICES
     10          *
     11          * File    : OS_MSG.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_msg__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_MSG_EN > 0u
     42          /*$PAGE*/
     43          /*
     44          ************************************************************************************************************************
     45          *                                            INITIALIZE THE POOL OF 'OS_MSG'
     46          *
     47          * Description: This function is called by OSInit() to initialize the free list of OS_MSGs.
     48          *
     49          * Argument(s): p_err     is a pointer to a variable that will contain an error code returned by this function.
     50          *
     51          *                            OS_ERR_MSG_POOL_NULL_PTR
     52          *                            OS_ERR_MSG_POOL_EMPTY
     53          *                            OS_ERR_NONE
     54          *
     55          * Returns    : none
     56          *
     57          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
     58          ************************************************************************************************************************
     59          */
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void  OS_MsgPoolInit (OS_ERR  *p_err)
     62          {
   \                     OS_MsgPoolInit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     63              OS_MSG      *p_msg1;
     64              OS_MSG      *p_msg2;
     65              OS_MSG_QTY   i;
     66              OS_MSG_QTY   loops;
     67          
     68          
     69          
     70          #ifdef OS_SAFETY_CRITICAL
     71              if (p_err == (OS_ERR *)0) {
     72                  OS_SAFETY_CRITICAL_EXCEPTION();
     73                  return;
     74              }
     75          #endif
     76          
     77          #if OS_CFG_ARG_CHK_EN > 0u
     78              if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
   \   00000002   0x....             LDR      R1,??DataTable3
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE      ??OS_MsgPoolInit_0
     79                 *p_err = OS_ERR_MSG_POOL_NULL_PTR;
   \   0000000A   0x....             LDR      R1,??DataTable3_1  ;; 0x571e
   \   0000000C   0xE004             B.N      ??OS_MsgPoolInit_1
     80                  return;
     81              }
     82              if (OSCfg_MsgPoolSize == (OS_MSG_QTY)0) {
   \                     ??OS_MsgPoolInit_0: (+1)
   \   0000000E   0x....             LDR      R2,??DataTable3_2
   \   00000010   0x8812             LDRH     R2,[R2, #+0]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD102             BNE      ??OS_MsgPoolInit_2
     83                 *p_err = OS_ERR_MSG_POOL_EMPTY;
   \   00000016   0x....             LDR      R1,??DataTable3_3  ;; 0x571d
   \                     ??OS_MsgPoolInit_1: (+1)
   \   00000018   0x8001             STRH     R1,[R0, #+0]
     84                  return;
   \   0000001A   0xE01A             B        ??OS_MsgPoolInit_3
     85              }
     86          #endif
     87          
     88              p_msg1 = OSCfg_MsgPoolBasePtr;
   \                     ??OS_MsgPoolInit_2: (+1)
   \   0000001C   0x000C             MOVS     R4,R1
     89              p_msg2 = OSCfg_MsgPoolBasePtr;
     90              p_msg2++;
   \   0000001E   0x000D             MOVS     R5,R1
   \   00000020   0x3510             ADDS     R5,R5,#+16
     91              loops  = OSCfg_MsgPoolSize - 1u;
   \   00000022   0x1E56             SUBS     R6,R2,#+1
   \   00000024   0x0436             LSLS     R6,R6,#+16
   \   00000026   0x0C36             LSRS     R6,R6,#+16
     92              for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x2E01             CMP      R6,#+1
   \   0000002C   0xDB07             BLT      ??OS_MsgPoolInit_4
     93                  p_msg1->NextPtr = p_msg2;
   \                     ??OS_MsgPoolInit_5: (+1)
   \   0000002E   0x6025             STR      R5,[R4, #+0]
     94                  p_msg1->MsgPtr  = (void      *)0;
   \   00000030   0x6063             STR      R3,[R4, #+4]
     95                  p_msg1->MsgSize = (OS_MSG_SIZE)0u;
   \   00000032   0x8123             STRH     R3,[R4, #+8]
     96                  p_msg1->MsgTS   = (CPU_TS     )0u;
   \   00000034   0x60E3             STR      R3,[R4, #+12]
     97                  p_msg1++;
   \   00000036   0x3410             ADDS     R4,R4,#+16
     98                  p_msg2++;
   \   00000038   0x3510             ADDS     R5,R5,#+16
     99              }
   \   0000003A   0x1E76             SUBS     R6,R6,#+1
   \   0000003C   0xD1F7             BNE      ??OS_MsgPoolInit_5
    100              p_msg1->NextPtr = (OS_MSG    *)0;                       /* Last OS_MSG                                            */
   \                     ??OS_MsgPoolInit_4: (+1)
   \   0000003E   0x6023             STR      R3,[R4, #+0]
    101              p_msg1->MsgPtr  = (void      *)0;
   \   00000040   0x6063             STR      R3,[R4, #+4]
    102              p_msg1->MsgSize = (OS_MSG_SIZE)0u;
   \   00000042   0x8123             STRH     R3,[R4, #+8]
    103              p_msg1->MsgTS   = (CPU_TS     )0u;
   \   00000044   0x60E3             STR      R3,[R4, #+12]
    104          
    105              OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
   \   00000046   0x....             LDR      R4,??DataTable3_4
   \   00000048   0x6021             STR      R1,[R4, #+0]
    106              OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
   \   0000004A   0x80A2             STRH     R2,[R4, #+4]
    107              OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
   \   0000004C   0x80E3             STRH     R3,[R4, #+6]
    108              OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   \   0000004E   0x8123             STRH     R3,[R4, #+8]
    109             *p_err                =  OS_ERR_NONE;
   \   00000050   0x8003             STRH     R3,[R0, #+0]
    110          }
   \                     ??OS_MsgPoolInit_3: (+1)
   \   00000052   0xBC70             POP      {R4-R6}
   \   00000054   0x4770             BX       LR               ;; return
    111          
    112          /*$PAGE*/
    113          /*
    114          ************************************************************************************************************************
    115          *                                        RELEASE ALL MESSAGE IN MESSAGE QUEUE
    116          *
    117          * Description: This function returns all the messages in a message queue to the free list.
    118          *
    119          * Arguments  : p_msg_q       is a pointer to the OS_MSG_Q structure containing messages to free.
    120          *              -------
    121          *
    122          * Returns    : the number of OS_MSGs returned to the free list
    123          *
    124          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    125          ************************************************************************************************************************
    126          */
    127          

   \                                 In section .text, align 2, keep-with-next
    128          OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
    129          {
   \                     OS_MsgQFreeAll: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    130              OS_MSG      *p_msg;
    131              OS_MSG_QTY   qty;
    132          
    133          
    134          
    135              qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
   \   00000002   0x894B             LDRH     R3,[R1, #+10]
   \   00000004   0x0018             MOVS     R0,R3
    136              if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
   \   00000006   0xD100             BNE      ??OS_MsgQFreeAll_0
   \   00000008   0x4770             BX       LR
    137                  p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
    138                  p_msg->NextPtr          = OSMsgPool.NextPtr;
   \                     ??OS_MsgQFreeAll_0: (+1)
   \   0000000A   0xB430             PUSH     {R4,R5}
   \   0000000C   0x....             LDR      R2,??DataTable3_4
   \   0000000E   0x6814             LDR      R4,[R2, #+0]
   \   00000010   0x680D             LDR      R5,[R1, #+0]
   \   00000012   0x602C             STR      R4,[R5, #+0]
    139                  OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
   \   00000014   0x684C             LDR      R4,[R1, #+4]
   \   00000016   0x6014             STR      R4,[R2, #+0]
    140                  OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
   \   00000018   0x88D4             LDRH     R4,[R2, #+6]
   \   0000001A   0x1AE3             SUBS     R3,R4,R3
   \   0000001C   0x80D3             STRH     R3,[R2, #+6]
    141                  OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
   \   0000001E   0x8893             LDRH     R3,[R2, #+4]
   \   00000020   0x894C             LDRH     R4,[R1, #+10]
   \   00000022   0x191B             ADDS     R3,R3,R4
   \   00000024   0x8093             STRH     R3,[R2, #+4]
    142                  p_msg_q->NbrEntries     = (OS_MSG_QTY)0;            /* Flush the message queue                                */
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x814A             STRH     R2,[R1, #+10]
    143                  p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
   \   0000002A   0x818A             STRH     R2,[R1, #+12]
    144                  p_msg_q->InPtr          = (OS_MSG   *)0;
   \   0000002C   0x600A             STR      R2,[R1, #+0]
    145                  p_msg_q->OutPtr         = (OS_MSG   *)0;
   \   0000002E   0x604A             STR      R2,[R1, #+4]
    146              }
    147              return (qty);
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
    148          }
    149          
    150          /*$PAGE*/
    151          /*
    152          ************************************************************************************************************************
    153          *                                               INITIALIZE A MESSAGE QUEUE
    154          *
    155          * Description: This function is called to initialize a message queue
    156          *
    157          * Arguments  : p_msg_q      is a pointer to the message queue to initialize
    158          *              -------
    159          *
    160          *              max          is the maximum number of entries that a message queue can have.
    161          *
    162          * Returns    : none
    163          *
    164          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    165          ************************************************************************************************************************
    166          */
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void  OS_MsgQInit (OS_MSG_Q    *p_msg_q,
    169                             OS_MSG_QTY   size)
    170          {
    171              p_msg_q->NbrEntriesSize = (OS_MSG_QTY)size;
   \                     OS_MsgQInit: (+1)
   \   00000000   0x8101             STRH     R1,[R0, #+8]
    172              p_msg_q->NbrEntries     = (OS_MSG_QTY)0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8141             STRH     R1,[R0, #+10]
    173              p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
   \   00000006   0x8181             STRH     R1,[R0, #+12]
    174              p_msg_q->InPtr          = (OS_MSG   *)0;
   \   00000008   0x6001             STR      R1,[R0, #+0]
    175              p_msg_q->OutPtr         = (OS_MSG   *)0;
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    176          }
   \   0000000C   0x4770             BX       LR               ;; return
    177          
    178          /*$PAGE*/
    179          /*
    180          ************************************************************************************************************************
    181          *                                           RETRIEVE MESSAGE FROM MESSAGE QUEUE
    182          *
    183          * Description: This function retrieves a message from a message queue
    184          *
    185          * Arguments  : p_msg_q     is a pointer to the message queue where we want to extract the message from
    186          *              -------
    187          *
    188          *              p_msg_size  is a pointer to where the size (in bytes) of the message will be placed
    189          *
    190          *              p_ts        is a pointer to where the time stamp will be placed
    191          *
    192          *              p_err       is a pointer to an error code that will be returned from this call.
    193          *
    194          *                              OS_ERR_Q_EMPTY
    195          *                              OS_ERR_NONE
    196          *
    197          * Returns    : The message (a pointer)
    198          *
    199          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    200          ************************************************************************************************************************
    201          */
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void  *OS_MsgQGet (OS_MSG_Q     *p_msg_q,
    204                             OS_MSG_SIZE  *p_msg_size,
    205                             CPU_TS       *p_ts,
    206                             OS_ERR       *p_err)
    207          {
   \                     OS_MsgQGet: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0014             MOVS     R4,R2
    208              OS_MSG  *p_msg;
    209              void    *p_void;
    210          
    211          
    212          
    213          #ifdef OS_SAFETY_CRITICAL
    214              if (p_err == (OS_ERR *)0) {
    215                  OS_SAFETY_CRITICAL_EXCEPTION();
    216                  return ((void *)0);
    217              }
    218          #endif
    219          
    220              if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is the queue empty?                                    */
   \   00000004   0x8942             LDRH     R2,[R0, #+10]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD108             BNE      ??OS_MsgQGet_0
    221                 *p_msg_size = (OS_MSG_SIZE)0;                        /* Yes                                                    */
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x800E             STRH     R6,[R1, #+0]
    222                  if (p_ts != (CPU_TS *)0) {
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD000             BEQ      ??OS_MsgQGet_1
    223                     *p_ts  = (CPU_TS  )0;
   \   00000012   0x6026             STR      R6,[R4, #+0]
    224                  }
    225                 *p_err = OS_ERR_Q_EMPTY;
   \                     ??OS_MsgQGet_1: (+1)
   \   00000014   0x....             LDR      R0,??DataTable3_5  ;; 0x6592
   \   00000016   0x8018             STRH     R0,[R3, #+0]
    226                  return ((void *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE01E             B        ??OS_MsgQGet_2
    227              }
    228          
    229              p_msg           = p_msg_q->OutPtr;                      /* No, get the next message to extract from the queue     */
   \                     ??OS_MsgQGet_0: (+1)
   \   0000001C   0x6845             LDR      R5,[R0, #+4]
    230              p_void          = p_msg->MsgPtr;
   \   0000001E   0x686A             LDR      R2,[R5, #+4]
    231             *p_msg_size      = p_msg->MsgSize;
   \   00000020   0x892E             LDRH     R6,[R5, #+8]
   \   00000022   0x800E             STRH     R6,[R1, #+0]
    232              if (p_ts != (CPU_TS *)0) {
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD001             BEQ      ??OS_MsgQGet_3
    233                 *p_ts  = p_msg->MsgTS;
   \   00000028   0x68E9             LDR      R1,[R5, #+12]
   \   0000002A   0x6021             STR      R1,[R4, #+0]
    234              }
    235          
    236              p_msg_q->OutPtr = p_msg->NextPtr;                       /* Point to next message to extract                       */
   \                     ??OS_MsgQGet_3: (+1)
   \   0000002C   0x682C             LDR      R4,[R5, #+0]
   \   0000002E   0x6044             STR      R4,[R0, #+4]
    237          
    238              if (p_msg_q->OutPtr == (OS_MSG *)0) {                   /* Are there any more messages in the queue?              */
   \   00000030   0x....             LDR      R1,??DataTable3_6  ;; 0xffff
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD101             BNE      ??OS_MsgQGet_4
    239                  p_msg_q->InPtr      = (OS_MSG   *)0;                /* No                                                     */
   \   00000038   0x6006             STR      R6,[R0, #+0]
    240                  p_msg_q->NbrEntries = (OS_MSG_QTY)0;
   \   0000003A   0xE001             B        ??OS_MsgQGet_5
    241              } else {
    242                  p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
   \                     ??OS_MsgQGet_4: (+1)
   \   0000003C   0x8944             LDRH     R4,[R0, #+10]
   \   0000003E   0x1864             ADDS     R4,R4,R1
   \                     ??OS_MsgQGet_5: (+1)
   \   00000040   0x8144             STRH     R4,[R0, #+10]
    243              }
    244          
    245              p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
   \   00000042   0x....             LDR      R0,??DataTable3_4
   \   00000044   0x6804             LDR      R4,[R0, #+0]
   \   00000046   0x602C             STR      R4,[R5, #+0]
    246              OSMsgPool.NextPtr = p_msg;
   \   00000048   0x6005             STR      R5,[R0, #+0]
    247              OSMsgPool.NbrFree++;
   \   0000004A   0x8884             LDRH     R4,[R0, #+4]
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0x8084             STRH     R4,[R0, #+4]
    248              OSMsgPool.NbrUsed--;
   \   00000050   0x88C4             LDRH     R4,[R0, #+6]
   \   00000052   0x1861             ADDS     R1,R4,R1
   \   00000054   0x80C1             STRH     R1,[R0, #+6]
    249          
    250             *p_err             = OS_ERR_NONE;
   \   00000056   0x801E             STRH     R6,[R3, #+0]
    251              return (p_void);
   \   00000058   0x0010             MOVS     R0,R2
   \                     ??OS_MsgQGet_2: (+1)
   \   0000005A   0xBC70             POP      {R4-R6}
   \   0000005C   0x4770             BX       LR               ;; return
    252          }
    253          
    254          /*$PAGE*/
    255          /*
    256          ************************************************************************************************************************
    257          *                                           DEPOSIT MESSAGE IN MESSAGE QUEUE
    258          *
    259          * Description: This function places a message in a message queue
    260          *
    261          * Arguments  : p_msg_q     is a pointer to the OS_TCB of the task to post the message to
    262          *              -------
    263          *
    264          *              p_void      is a pointer to the message to send.
    265          *
    266          *              msg_size    is the size of the message (in bytes)
    267          *
    268          *              opt         specifies whether the message will be posted in FIFO or LIFO order
    269          *
    270          *                              OS_OPT_POST_FIFO
    271          *                              OS_OPT_POST_LIFO
    272          *
    273          *              ts          is a timestamp as to when the message was posted
    274          *
    275          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    276          *
    277          *                              OS_ERR_Q_MAX           if the queue is full
    278          *                              OS_ERR_MSG_POOL_EMPTY  if we no longer have any OS_MSG to use
    279          *                              OS_ERR_NONE            the message was deposited in the queue
    280          *
    281          * Returns    : none
    282          *
    283          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    284          ************************************************************************************************************************
    285          */
    286          

   \                                 In section .text, align 2, keep-with-next
    287          void  OS_MsgQPut (OS_MSG_Q     *p_msg_q,
    288                            void         *p_void,
    289                            OS_MSG_SIZE   msg_size,
    290                            OS_OPT        opt,
    291                            CPU_TS        ts,
    292                            OS_ERR       *p_err)
    293          {
   \                     OS_MsgQPut: (+1)
   \   00000000   0xB4FA             PUSH     {R1,R3-R7}
   \   00000002   0x9907             LDR      R1,[SP, #+28]
    294              OS_MSG  *p_msg;
    295              OS_MSG  *p_msg_in;
    296          
    297          
    298          
    299          #ifdef OS_SAFETY_CRITICAL
    300              if (p_err == (OS_ERR *)0) {
    301                  OS_SAFETY_CRITICAL_EXCEPTION();
    302                  return;
    303              }
    304          #endif
    305          
    306              if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) {
   \   00000004   0x8944             LDRH     R4,[R0, #+10]
   \   00000006   0x8905             LDRH     R5,[R0, #+8]
   \   00000008   0x42AC             CMP      R4,R5
   \   0000000A   0xD301             BCC      ??OS_MsgQPut_0
    307                 *p_err = OS_ERR_Q_MAX;                               /* Message queue cannot accept any more messages          */
   \   0000000C   0x....             LDR      R0,??DataTable3_7  ;; 0x6593
   \   0000000E   0xE035             B        ??OS_MsgQPut_1
    308                  return;
    309              }
    310          
    311              if (OSMsgPool.NbrFree == (OS_MSG_QTY)0) {
   \                     ??OS_MsgQPut_0: (+1)
   \   00000010   0x....             LDR      R5,??DataTable3_4
   \   00000012   0x88AE             LDRH     R6,[R5, #+4]
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE      ??OS_MsgQPut_2
    312                 *p_err = OS_ERR_MSG_POOL_EMPTY;                      /* No more OS_MSG to use                                  */
   \   00000018   0x....             LDR      R0,??DataTable3_3  ;; 0x571d
   \   0000001A   0xE02F             B        ??OS_MsgQPut_1
    313                  return;
    314              }
    315          
    316              p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
   \                     ??OS_MsgQPut_2: (+1)
   \   0000001C   0x682C             LDR      R4,[R5, #+0]
    317              OSMsgPool.NextPtr = p_msg->NextPtr;
   \   0000001E   0x6827             LDR      R7,[R4, #+0]
   \   00000020   0x602F             STR      R7,[R5, #+0]
    318              OSMsgPool.NbrFree--;
   \   00000022   0x1E76             SUBS     R6,R6,#+1
   \   00000024   0x80AE             STRH     R6,[R5, #+4]
    319              OSMsgPool.NbrUsed++;
   \   00000026   0x88EE             LDRH     R6,[R5, #+6]
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \   0000002A   0x80EE             STRH     R6,[R5, #+6]
    320              if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
   \   0000002C   0x892F             LDRH     R7,[R5, #+8]
   \   0000002E   0x0436             LSLS     R6,R6,#+16
   \   00000030   0x0C36             LSRS     R6,R6,#+16
   \   00000032   0x42B7             CMP      R7,R6
   \   00000034   0xD200             BCS      ??OS_MsgQPut_3
    321                  OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
   \   00000036   0x812E             STRH     R6,[R5, #+8]
    322              }
    323          
    324              if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is this first message placed in the queue?             */
   \                     ??OS_MsgQPut_3: (+1)
   \   00000038   0x8946             LDRH     R6,[R0, #+10]
   \   0000003A   0x0035             MOVS     R5,R6
   \   0000003C   0xD105             BNE      ??OS_MsgQPut_4
    325                  p_msg_q->InPtr         = p_msg;                     /* Yes                                                    */
   \   0000003E   0x6004             STR      R4,[R0, #+0]
    326                  p_msg_q->OutPtr        = p_msg;
   \   00000040   0x6044             STR      R4,[R0, #+4]
    327                  p_msg_q->NbrEntries    = (OS_MSG_QTY)1;
   \   00000042   0x2501             MOVS     R5,#+1
    328                  p_msg->NextPtr         = (OS_MSG *)0;
   \   00000044   0x2300             MOVS     R3,#+0
   \   00000046   0x6023             STR      R3,[R4, #+0]
   \   00000048   0xE00B             B        ??OS_MsgQPut_5
    329              } else {                                                /* No                                                     */
    330                  if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) { /* Is it FIFO or LIFO?                                    */
   \                     ??OS_MsgQPut_4: (+1)
   \   0000004A   0x06DB             LSLS     R3,R3,#+27
   \   0000004C   0xD405             BMI      ??OS_MsgQPut_6
    331                      p_msg_in           = p_msg_q->InPtr;            /* FIFO, add to the head                                  */
    332                      p_msg_in->NextPtr  = p_msg;
   \   0000004E   0x6803             LDR      R3,[R0, #+0]
   \   00000050   0x601C             STR      R4,[R3, #+0]
    333                      p_msg_q->InPtr     = p_msg;
   \   00000052   0x6004             STR      R4,[R0, #+0]
    334                      p_msg->NextPtr     = (OS_MSG *)0;
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x6023             STR      R3,[R4, #+0]
   \   00000058   0xE002             B        ??OS_MsgQPut_7
    335                  } else {
    336                      p_msg->NextPtr     = p_msg_q->OutPtr;           /* LIFO, add to the tail                                  */
   \                     ??OS_MsgQPut_6: (+1)
   \   0000005A   0x6843             LDR      R3,[R0, #+4]
   \   0000005C   0x6023             STR      R3,[R4, #+0]
    337                      p_msg_q->OutPtr    = p_msg;
   \   0000005E   0x6044             STR      R4,[R0, #+4]
    338                  }
    339                  p_msg_q->NbrEntries++;
   \                     ??OS_MsgQPut_7: (+1)
   \   00000060   0x1C75             ADDS     R5,R6,#+1
   \                     ??OS_MsgQPut_5: (+1)
   \   00000062   0x8145             STRH     R5,[R0, #+10]
    340              }
    341              if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {
   \   00000064   0x8983             LDRH     R3,[R0, #+12]
   \   00000066   0x8945             LDRH     R5,[R0, #+10]
   \   00000068   0x42AB             CMP      R3,R5
   \   0000006A   0xD200             BCS      ??OS_MsgQPut_8
   \   0000006C   0x002B             MOVS     R3,R5
   \                     ??OS_MsgQPut_8: (+1)
   \   0000006E   0x8183             STRH     R3,[R0, #+12]
    342                  p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
    343              }
    344              p_msg->MsgPtr  = p_void;                                /* Deposit message in the message queue entry             */
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x6060             STR      R0,[R4, #+4]
    345              p_msg->MsgSize = msg_size;
   \   00000074   0x8122             STRH     R2,[R4, #+8]
    346              p_msg->MsgTS   = ts;
   \   00000076   0x9806             LDR      R0,[SP, #+24]
   \   00000078   0x60E0             STR      R0,[R4, #+12]
    347             *p_err          = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??OS_MsgQPut_1: (+1)
   \   0000007C   0x8008             STRH     R0,[R1, #+0]
    348          }
   \   0000007E   0xBCF3             POP      {R0,R1,R4-R7}
   \   00000080   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSCfg_MsgPoolBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x0000571E         DC32     0x571e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     OSCfg_MsgPoolSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x0000571D         DC32     0x571d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     OSMsgPool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x00006592         DC32     0x6592

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x00006593         DC32     0x6593
    349          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   OS_MsgPoolInit
       8   OS_MsgQFreeAll
      12   OS_MsgQGet
       0   OS_MsgQInit
      24   OS_MsgQPut


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
      86  OS_MsgPoolInit
      52  OS_MsgQFreeAll
      94  OS_MsgQGet
      14  OS_MsgQInit
     130  OS_MsgQPut

 
 408 bytes in section .text
 
 408 bytes of CODE memory

Errors: none
Warnings: none
