###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_pend_multi.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_pend_multi.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\os_pend_multi.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\os_pend_multi.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\Micrium\uC-OS-III\Source\os_pend_multi.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                               PEND ON MULTIPLE OBJECTS
     10          *
     11          * File    : OS_PEND_MULTI.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_pend_multi__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if (((OS_CFG_Q_EN > 0u) || (OS_CFG_SEM_EN > 0u)) && (OS_CFG_PEND_MULTI_EN > 0u))
     42          /*
     43          ************************************************************************************************************************
     44          *                                               PEND ON MULTIPLE OBJECTS
     45          *
     46          * Description: This function pends on multiple objects.  The objects pended on MUST be either semaphores or message
     47          *              queues.  If multiple objects are ready at the start of the pend call, then all available objects that
     48          *              are ready will be indicated to the caller.  If the task must pend on the multiple events then, as soon
     49          *              as one of the object is either posted, aborted or deleted, the task will be readied.
     50          *
     51          *              This function only allows you to pend on semaphores and/or message queues.
     52          *
     53          * Arguments  : p_pend_data_tbl   is a pointer to an array of type OS_PEND_DATA which contains a list of all the
     54          *                                objects we will be waiting on.  The caller must declare an array of OS_PEND_DATA
     55          *                                and initialize the .PendObjPtr (see below) with a pointer to the object (semaphore or
     56          *                                message queue) to pend on.
     57          *
     58          *                                    OS_PEND_DATA  MyPendArray[?];
     59          *
     60          *                                The OS_PEND_DATA field are as follows:
     61          *
     62          *                                    OS_PEND_DATA  *PrevPtr;      Used to link OS_PEND_DATA objects
     63          *                                    OS_PEND_DATA  *NextPtr;      Used to link OS_PEND_DATA objects
     64          *                                    OS_TCB        *TCBPtr;       Pointer to the TCB that is pending on multiple objects
     65          *                                    OS_PEND_OBJ   *PendObjPtr;   USER supplied field which is a pointer to the
     66          *                                                                 semaphore or message queue you want to pend on.  When
     67          *                                                                 you call OSPendMulti() you MUST fill this field for
     68          *                                                                 each of the objects you want to pend on.
     69          *                                    OS_PEND_OBJ   *RdyObjPtr;    OSPendMulti() will return the object that was posted,
     70          *                                                                 aborted or deleted in this field.
     71          *                                    void          *RdyMsgPtr;    OSPendMulti() will fill in this field if the object
     72          *                                                                 posted was a message queue.  This corresponds to the
     73          *                                                                 message posted.
     74          *                                    OS_MSG_SIZE    RdyMsgSize;   OSPendMulti() will fill in this field if the object
     75          *                                                                 posted was a message queue.  This corresponds to the
     76          *                                                                 size of the message posted.
     77          *                                    CPU_TS         RdyTS;        OSPendMulti() will fill in this field if the object
     78          *                                                                 was a message queue.  This corresponds to the time
     79          *                                                                 stamp when the message was posted.  However, if the
     80          *                                                                 object is a semaphore and the object is already ready
     81          *                                                                 the this field will be set to (CPU_TS)0 because it's
     82          *                                                                 not possible to know when the semaphore was posted.
     83          *
     84          *              tbl_size      is the size (in number of elements) of the OS_PEND_DATA array passed to this function.  In
     85          *                            other words, if the called needs to pend on 4 separate objects (semaphores and/or queues)
     86          *                            then you would pass 4 to this call.
     87          *
     88          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait any of
     89          *                            the objects up to the amount of time specified by this argument. If you specify 0, however,
     90          *                            your task will wait forever for the specified objects or, until an object is posted,
     91          *                            aborted or deleted.
     92          *
     93          *              opt           determines whether the user wants to block if none of the objects are available.
     94          *
     95          *                                OS_OPT_PEND_BLOCKING
     96          *                                OS_OPT_PEND_NON_BLOCKING
     97          *
     98          *              p_err         is a pointer to where an error message will be deposited.  Possible error messages are:
     99          *
    100          *                                OS_ERR_NONE              The call was successful and your task owns the resources or,
    101          *                                                         the objects you are waiting for occurred. Check the .RdyObjPtr
    102          *                                                         fields to know which objects have been posted.
    103          *                                OS_ERR_OBJ_TYPE          If any of the .PendPtr is NOT a semaphore or a message queue
    104          *                                OS_ERR_OPT_INVALID       If you specified an invalid option for 'opt'
    105          *                                OS_ERR_PEND_ABORT        The wait on the events was aborted; check the .RdyObjPtr fields
    106          *                                                         for which objects were aborted.
    107          *                                OS_ERR_PEND_DEL          The wait on the events was aborted; check the .RdyObjPtr fields
    108          *                                                         for which objects were aborted.
    109          *                                OS_ERR_PEND_ISR          If you called this function from an ISR
    110          *                                OS_ERR_PEND_LOCKED       If you called this function when the scheduler is locked.
    111          *                                OS_ERR_PEND_WOULD_BLOCK  If the caller didn't want to block and no object ready
    112          *                                OS_ERR_STATUS_INVALID    Invalid pend status
    113          *                                OS_ERR_PTR_INVALID       If you passes a NULL pointer of 'p_pend_data_tbl'
    114          *                                OS_ERR_TIMEOUT           The objects were not posted within the specified 'timeout'.
    115          *
    116          * Returns    : >  0          the number of objects returned as ready, aborted or deleted
    117          *              == 0          if no events are returned as ready because of timeout or upon error.
    118          ************************************************************************************************************************
    119          */
    120          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    121          OS_OBJ_QTY  OSPendMulti (OS_PEND_DATA  *p_pend_data_tbl,
    122                                   OS_OBJ_QTY     tbl_size,
    123                                   OS_TICK        timeout,
    124                                   OS_OPT         opt,
    125                                   OS_ERR        *p_err)
    126          {
   \                     OSPendMulti: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x001F             MOVS     R7,R3
   \   00000006   0x9E0A             LDR      R6,[SP, #+40]
    127              CPU_BOOLEAN   valid;
    128              OS_OBJ_QTY    nbr_obj_rdy;
    129              CPU_SR_ALLOC();
    130          
    131          
    132          
    133          #ifdef OS_SAFETY_CRITICAL
    134              if (p_err == (OS_ERR *)0) {
    135                  OS_SAFETY_CRITICAL_EXCEPTION();
    136                  return ((OS_OBJ_QTY)0);
    137              }
    138          #endif
    139          
    140          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    141              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't pend from an ISR                                 */
   \   00000008   0x....             LDR      R0,??DataTable3
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ      ??OSPendMulti_0
    142                 *p_err = OS_ERR_PEND_ISR;
   \   00000010   0x....             LDR      R0,??DataTable3_1  ;; 0x61ae
   \   00000012   0xE03E             B.N      ??OSPendMulti_1
    143                  return ((OS_OBJ_QTY)0);
    144              }
    145          #endif
    146          
    147          #if OS_CFG_ARG_CHK_EN > 0u
    148              if (p_pend_data_tbl == (OS_PEND_DATA *)0) {             /* Validate 'p_pend_data_tbl'                             */
   \                     ??OSPendMulti_0: (+1)
   \   00000014   0x9802             LDR      R0,[SP, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ      ??OSPendMulti_2
    149                 *p_err = OS_ERR_PTR_INVALID;
    150                  return ((OS_OBJ_QTY)0);
    151              }
    152              if (tbl_size == (OS_OBJ_QTY)0) {                        /* Array size must be > 0                                 */
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xD101             BNE      ??OSPendMulti_3
    153                 *p_err = OS_ERR_PTR_INVALID;
   \                     ??OSPendMulti_2: (+1)
   \   0000001E   0x....             LDR      R0,??DataTable3_2  ;; 0x62d5
   \   00000020   0xE037             B.N      ??OSPendMulti_1
    154                  return ((OS_OBJ_QTY)0);
    155              }
    156              switch (opt) {
   \                     ??OSPendMulti_3: (+1)
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0xD003             BEQ      ??OSPendMulti_4
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   0000002A   0x428F             CMP      R7,R1
   \   0000002C   0xD130             BNE      ??OSPendMulti_5
    157                  case OS_OPT_PEND_BLOCKING:
    158                  case OS_OPT_PEND_NON_BLOCKING:
    159                       break;
    160          
    161                  default:
    162                      *p_err = OS_ERR_OPT_INVALID;
    163                       return ((OS_OBJ_QTY)0);
    164              }
    165          #endif
    166          
    167              valid = OS_PendMultiValidate(p_pend_data_tbl,           /* -------- Validate objects to be OS_SEM or OS_Q ------- */
    168                                           tbl_size);
   \                     ??OSPendMulti_4: (+1)
   \   0000002E   0x9A02             LDR      R2,[SP, #+8]
   \   00000030   0x2400             MOVS     R4,#+0
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x....             LDR      R0,??DataTable3_3  ;; 0x55455551
   \   00000036   0x....             LDR      R1,??DataTable3_4  ;; 0x414d4553
   \   00000038   0xE001             B        ??OSPendMulti_6
   \                     ??OSPendMulti_7: (+1)
   \   0000003A   0x3220             ADDS     R2,R2,#+32
   \   0000003C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OSPendMulti_6: (+1)
   \   0000003E   0x466D             MOV      R5,SP
   \   00000040   0x89AD             LDRH     R5,[R5, #+12]
   \   00000042   0x041B             LSLS     R3,R3,#+16
   \   00000044   0x0C1B             LSRS     R3,R3,#+16
   \   00000046   0x42AB             CMP      R3,R5
   \   00000048   0xD209             BCS      ??OSPendMulti_8
   \   0000004A   0x68D5             LDR      R5,[R2, #+12]
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD004             BEQ      ??OSPendMulti_9
   \   00000050   0x682D             LDR      R5,[R5, #+0]
   \   00000052   0x428D             CMP      R5,R1
   \   00000054   0xD0F1             BEQ      ??OSPendMulti_7
   \   00000056   0x4285             CMP      R5,R0
   \   00000058   0xD0EF             BEQ      ??OSPendMulti_7
    169              if (valid == DEF_FALSE) {
    170                 *p_err = OS_ERR_OBJ_TYPE;                            /* Invalid, not OS_SEM or OS_Q                            */
   \                     ??OSPendMulti_9: (+1)
   \   0000005A   0x....             LDR      R0,??DataTable3_5  ;; 0x5dc4
   \   0000005C   0xE02F             B.N      ??OSPendMulti_10
    171                  return ((OS_OBJ_QTY)0);
    172              }
    173          
    174          /*$PAGE*/
    175              CPU_CRITICAL_ENTER();
   \                     ??OSPendMulti_8: (+1)
   \   0000005E   0x.... 0x....      BL       CPU_SR_Save
   \   00000062   0x0005             MOVS     R5,R0
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStart
    176              nbr_obj_rdy = OS_PendMultiGetRdy(p_pend_data_tbl,       /* --------- SEE IF OBJECT(s) HAVE BEEN POSTED ---------- */
    177                                               tbl_size);
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x8981             LDRH     R1,[R0, #+12]
   \   0000006C   0x9802             LDR      R0,[SP, #+8]
   \   0000006E   0x.... 0x....      BL       OS_PendMultiGetRdy
   \   00000072   0x4669             MOV      R1,SP
   \   00000074   0x8008             STRH     R0,[R1, #+0]
    178              if (nbr_obj_rdy > (OS_OBJ_QTY)0) {
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x8800             LDRH     R0,[R0, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD10C             BNE      ??OSPendMulti_11
    179                  CPU_CRITICAL_EXIT();
    180                 *p_err = OS_ERR_NONE;
    181                  return ((OS_OBJ_QTY)nbr_obj_rdy);
    182              }
    183          
    184              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \   0000007E   0x0438             LSLS     R0,R7,#+16
   \   00000080   0xD513             BPL      ??OSPendMulti_12
    185                  CPU_CRITICAL_EXIT();
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    186                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \   0000008C   0x....             LDR      R0,??DataTable3_6  ;; 0x61b0
   \   0000008E   0xE016             B.N      ??OSPendMulti_10
    187                  return ((OS_OBJ_QTY)0);
    188              } else {
   \                     ??OSPendMulti_5: (+1)
   \   00000090   0x....             LDR      R0,??DataTable3_7  ;; 0x5e25
   \                     ??OSPendMulti_1: (+1)
   \   00000092   0x8030             STRH     R0,[R6, #+0]
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE052             B        ??OSPendMulti_13
   \                     ??OSPendMulti_11: (+1)
   \   00000098   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
   \   000000A2   0x8034             STRH     R4,[R6, #+0]
   \   000000A4   0x4668             MOV      R0,SP
   \   000000A6   0x8800             LDRH     R0,[R0, #+0]
   \   000000A8   0xE049             B        ??OSPendMulti_13
    189                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSPendMulti_12: (+1)
   \   000000AA   0x....             LDR      R7,??DataTable3_8
   \   000000AC   0x7838             LDRB     R0,[R7, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD008             BEQ      ??OSPendMulti_14
    190                      CPU_CRITICAL_EXIT();
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B6   0x0028             MOVS     R0,R5
   \   000000B8   0x.... 0x....      BL       CPU_SR_Restore
    191                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000BC   0x....             LDR      R0,??DataTable3_9  ;; 0x6d63
   \                     ??OSPendMulti_10: (+1)
   \   000000BE   0x8030             STRH     R0,[R6, #+0]
    192                      return ((OS_OBJ_QTY)0);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE03C             B        ??OSPendMulti_13
    193                  }
    194              }
    195                                                                      /* Lock the scheduler/re-enable interrupts                */
    196              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSPendMulti_14: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x7038             STRB     R0,[R7, #+0]
   \   000000C8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       CPU_SR_Restore
    197                                                                      /* ------ NO OBJECT READY, PEND ON MULTIPLE OBJECTS ----- */
    198              OS_PendMultiWait(p_pend_data_tbl,                       /* Suspend task until object posted or timeout occurs     */
    199                               tbl_size,
    200                               timeout);
   \   000000D2   0x9A04             LDR      R2,[SP, #+16]
   \   000000D4   0x4668             MOV      R0,SP
   \   000000D6   0x8981             LDRH     R1,[R0, #+12]
   \   000000D8   0x9802             LDR      R0,[SP, #+8]
   \   000000DA   0x.... 0x....      BL       OS_PendMultiWait
    201          
    202              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000DE   0x.... 0x....      BL       CPU_SR_Save
   \   000000E2   0x0005             MOVS     R5,R0
   \   000000E4   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000E8   0x7838             LDRB     R0,[R7, #+0]
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   \   000000EC   0x7038             STRB     R0,[R7, #+0]
   \   000000EE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0x.... 0x....      BL       CPU_SR_Restore
    203          
    204              OSSched();                                              /* Find next highest priority task ready                  */
   \   000000F8   0x.... 0x....      BL       OSSched
    205          
    206              CPU_CRITICAL_ENTER();
   \   000000FC   0x.... 0x....      BL       CPU_SR_Save
   \   00000100   0x0005             MOVS     R5,R0
   \   00000102   0x.... 0x....      BL       CPU_IntDisMeasStart
    207              switch (OSTCBCurPtr->PendStatus) {
   \   00000106   0x....             LDR      R0,??DataTable3_10
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x2135             MOVS     R1,#+53
   \   0000010C   0x5C41             LDRB     R1,[R0, R1]
   \   0000010E   0x2900             CMP      R1,#+0
   \   00000110   0xD00C             BEQ      ??OSPendMulti_15
   \   00000112   0x2902             CMP      R1,#+2
   \   00000114   0xD007             BEQ      ??OSPendMulti_16
   \   00000116   0xD302             BCC      ??OSPendMulti_17
   \   00000118   0x2903             CMP      R1,#+3
   \   0000011A   0xD002             BEQ      ??OSPendMulti_18
   \   0000011C   0xE005             B        ??OSPendMulti_19
    208                  case OS_STATUS_PEND_OK:                             /* We got one of the objects posted to                    */
    209                      *p_err = OS_ERR_NONE;
    210                       break;
    211          
    212                  case OS_STATUS_PEND_ABORT:                          /* Indicate that the multi-pend was aborted               */
    213                      *p_err = OS_ERR_PEND_ABORT;
   \                     ??OSPendMulti_17: (+1)
   \   0000011E   0x....             LDR      R1,??DataTable3_11  ;; 0x61a9
    214                       break;
   \   00000120   0xE004             B        ??OSPendMulti_15
    215          
    216                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
    217                      *p_err = OS_ERR_TIMEOUT;
   \                     ??OSPendMulti_18: (+1)
   \   00000122   0x....             LDR      R1,??DataTable3_12  ;; 0x72d9
    218                       break;
   \   00000124   0xE002             B        ??OSPendMulti_15
    219          
    220                  case OS_STATUS_PEND_DEL:                            /* Indicate that an object pended on has been deleted     */
    221                      *p_err = OS_ERR_OBJ_DEL;
   \                     ??OSPendMulti_16: (+1)
   \   00000126   0x....             LDR      R1,??DataTable3_13  ;; 0x5dc2
    222                      break;
   \   00000128   0xE000             B        ??OSPendMulti_15
    223          
    224                  default:
    225                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSPendMulti_19: (+1)
   \   0000012A   0x....             LDR      R1,??DataTable3_14  ;; 0x6e2e
    226                       break;
   \                     ??OSPendMulti_15: (+1)
   \   0000012C   0x8031             STRH     R1,[R6, #+0]
    227              }
    228          
    229              OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
   \   0000012E   0x3035             ADDS     R0,R0,#+53
   \   00000130   0x7004             STRB     R4,[R0, #+0]
    230              CPU_CRITICAL_EXIT();
   \   00000132   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000136   0x0028             MOVS     R0,R5
   \   00000138   0x.... 0x....      BL       CPU_SR_Restore
    231          
    232              return ((OS_OBJ_QTY)1);
   \   0000013C   0x2001             MOVS     R0,#+1
   \                     ??OSPendMulti_13: (+1)
   \   0000013E   0xB005             ADD      SP,SP,#+20
   \   00000140   0xBDF0             POP      {R4-R7,PC}       ;; return
    233          }
    234          
    235          /*$PAGE*/
    236          /*
    237          ************************************************************************************************************************
    238          *                                              GET A LIST OF OBJECTS READY
    239          *
    240          * Description: This function is called by OSPendMulti() to obtain the list of object that are ready.
    241          *
    242          * Arguments  : p_pend_data_tbl   is a pointer to an array of OS_PEND_DATA
    243          *              ---------------
    244          *
    245          *              tbl_size          is the size of the array
    246          *
    247          * Returns    :  > 0              the number of objects ready
    248          *              == 0              if no object ready
    249          *
    250          * Note       : This function is INTERNAL to uC/OS-III and your application should not call it.
    251          ************************************************************************************************************************
    252          */
    253          

   \                                 In section .text, align 2, keep-with-next
    254          OS_OBJ_QTY  OS_PendMultiGetRdy (OS_PEND_DATA  *p_pend_data_tbl,
    255                                          OS_OBJ_QTY     tbl_size)
    256          {
   \                     OS_PendMultiGetRdy: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    257              OS_OBJ_QTY   i;
    258              OS_OBJ_QTY   nbr_obj_rdy;
    259          #if OS_CFG_Q_EN > 0u
    260              OS_ERR       err;
    261              OS_MSG_SIZE  msg_size;
    262              OS_Q        *p_q;
    263              void        *p_void;
    264              CPU_TS       ts;
    265          #endif
    266          #if OS_CFG_SEM_EN  > 0u
    267              OS_SEM      *p_sem;
    268          #endif
    269          
    270          
    271          
    272              nbr_obj_rdy = (OS_OBJ_QTY)0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2500             MOVS     R5,#+0
    273              for (i = 0u; i < tbl_size; i++) {
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD031             BEQ      ??OS_PendMultiGetRdy_0
   \   0000000E   0x000F             MOVS     R7,R1
    274                  p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;         /* Clear all fields                                  */
   \                     ??OS_PendMultiGetRdy_1: (+1)
   \   00000010   0x6126             STR      R6,[R4, #+16]
    275                  p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
   \   00000012   0x6166             STR      R6,[R4, #+20]
    276                  p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
   \   00000014   0x8326             STRH     R6,[R4, #+24]
    277                  p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
   \   00000016   0x61E6             STR      R6,[R4, #+28]
    278                  p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;
   \   00000018   0x6066             STR      R6,[R4, #+4]
    279                  p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
   \   0000001A   0x6026             STR      R6,[R4, #+0]
    280                  p_pend_data_tbl->TCBPtr     = (OS_TCB       *)0;
   \   0000001C   0x60A6             STR      R6,[R4, #+8]
    281          #if OS_CFG_Q_EN > 0u
    282                  p_q = (OS_Q *)((void *)p_pend_data_tbl->PendObjPtr);     /* Assume we are pointing to a message queue object  */
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
    283                  if (p_q->Type == OS_OBJ_TYPE_Q) {                        /* Is it a message queue?                            */
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x....             LDR      R2,??DataTable3_3  ;; 0x55455551
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD113             BNE      ??OS_PendMultiGetRdy_2
    284                      p_void = OS_MsgQGet(&p_q->MsgQ,                      /* Yes, Any message waiting in the message queue?    */
    285                                          &msg_size,
    286                                          &ts,
    287                                          &err);
   \   00000028   0xAB00             ADD      R3,SP,#+0
   \   0000002A   0x1C9B             ADDS     R3,R3,#+2
   \   0000002C   0xAA01             ADD      R2,SP,#+4
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x3014             ADDS     R0,R0,#+20
   \   00000032   0x.... 0x....      BL       OS_MsgQGet
    288                      if (err == OS_ERR_NONE) {
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x8849             LDRH     R1,[R1, #+2]
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD108             BNE      ??OS_PendMultiGetRdy_2
    289                          p_pend_data_tbl->RdyObjPtr  = p_pend_data_tbl->PendObjPtr;
   \   0000003E   0x68E1             LDR      R1,[R4, #+12]
   \   00000040   0x6121             STR      R1,[R4, #+16]
    290                          p_pend_data_tbl->RdyMsgPtr  = p_void;            /*      Yes, save the message received               */
   \   00000042   0x6160             STR      R0,[R4, #+20]
    291                          p_pend_data_tbl->RdyMsgSize = msg_size;
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x8800             LDRH     R0,[R0, #+0]
   \   00000048   0x8320             STRH     R0,[R4, #+24]
    292                          p_pend_data_tbl->RdyTS      = ts;
   \   0000004A   0x9801             LDR      R0,[SP, #+4]
   \   0000004C   0x61E0             STR      R0,[R4, #+28]
    293                          nbr_obj_rdy++;
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
    294                      }
    295                  }
    296          #endif
    297          
    298          #if OS_CFG_SEM_EN > 0u
    299                  p_sem = (OS_SEM *)((void *)p_pend_data_tbl->PendObjPtr); /* Assume we are pointing to a semaphore object      */
   \                     ??OS_PendMultiGetRdy_2: (+1)
   \   00000050   0x68E0             LDR      R0,[R4, #+12]
    300                  if (p_sem->Type == OS_OBJ_TYPE_SEM) {                    /* Is it a semaphore?                                */
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0x....             LDR      R3,??DataTable3_4  ;; 0x414d4553
   \   00000056   0x429A             CMP      R2,R3
   \   00000058   0xD108             BNE      ??OS_PendMultiGetRdy_3
    301                      if (p_sem->Ctr > 0u) {                               /* Yes, Semaphore has been signaled?                 */
   \   0000005A   0x6942             LDR      R2,[R0, #+20]
   \   0000005C   0x2A00             CMP      R2,#+0
   \   0000005E   0xD005             BEQ      ??OS_PendMultiGetRdy_3
    302                          p_sem->Ctr--;                                    /*      Yes, caller may proceed                      */
   \   00000060   0x1E52             SUBS     R2,R2,#+1
   \   00000062   0x6142             STR      R2,[R0, #+20]
    303                          p_pend_data_tbl->RdyObjPtr  = p_pend_data_tbl->PendObjPtr;
   \   00000064   0x6120             STR      R0,[R4, #+16]
    304                          p_pend_data_tbl->RdyTS      = p_sem->TS;
   \   00000066   0x6980             LDR      R0,[R0, #+24]
   \   00000068   0x61E0             STR      R0,[R4, #+28]
    305                          nbr_obj_rdy++;
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
    306                      }
    307                  }
    308          #endif
    309          
    310                  p_pend_data_tbl++;
   \                     ??OS_PendMultiGetRdy_3: (+1)
   \   0000006C   0x3420             ADDS     R4,R4,#+32
    311              }
   \   0000006E   0x1E7F             SUBS     R7,R7,#+1
   \   00000070   0xD1CE             BNE      ??OS_PendMultiGetRdy_1
    312              return (nbr_obj_rdy);
   \                     ??OS_PendMultiGetRdy_0: (+1)
   \   00000072   0x0428             LSLS     R0,R5,#+16
   \   00000074   0x0C00             LSRS     R0,R0,#+16
   \   00000076   0xB003             ADD      SP,SP,#+12
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
    313          }
    314          
    315          /*$PAGE*/
    316          /*
    317          ************************************************************************************************************************
    318          *                                 VERIFY THAT OBJECTS PENDED ON ARE EITHER SEMAPHORES or QUEUES
    319          *
    320          * Description: This function is called by OSPendMulti() to verify that we are multi-pending on either semaphores or
    321          *              message queues.
    322          *
    323          * Arguments  : p_pend_data_tbl    is a pointer to an array of OS_PEND_DATA
    324          *              ---------------
    325          *
    326          *              tbl_size           is the size of the array
    327          *
    328          * Returns    : TRUE               if all objects pended on are either semaphores of queues
    329          *              FALSE              if at least one object is not a semaphore or queue.
    330          *
    331          * Note       : This function is INTERNAL to uC/OS-III and your application should not call it.
    332          ************************************************************************************************************************
    333          */
    334          

   \                                 In section .text, align 2, keep-with-next
    335          CPU_BOOLEAN  OS_PendMultiValidate (OS_PEND_DATA  *p_pend_data_tbl,
    336                                             OS_OBJ_QTY     tbl_size)
    337          {
   \                     OS_PendMultiValidate: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    338              OS_OBJ_QTY  i;
    339              OS_OBJ_QTY  ctr;
    340          #if OS_CFG_SEM_EN  > 0u
    341              OS_SEM      *p_sem;
    342          #endif
    343          #if OS_CFG_Q_EN > 0u
    344              OS_Q        *p_q;
    345          #endif
    346          
    347          
    348              for (i = 0u; i < tbl_size; i++) {
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             LDR      R3,??DataTable3_3  ;; 0x55455551
   \   00000006   0x....             LDR      R4,??DataTable3_4  ;; 0x414d4553
   \   00000008   0xE001             B        ??OS_PendMultiValidate_0
    349                  if (p_pend_data_tbl->PendObjPtr == (OS_PEND_OBJ *)0) {   /* All .PendObjPtr in the table MUST be non NULL     */
    350                      return (DEF_FALSE);
    351                  }
    352          
    353                  ctr = 0u;
    354          #if OS_CFG_SEM_EN  > 0u
    355                  p_sem = (OS_SEM *)((void *)p_pend_data_tbl->PendObjPtr); /* All objects to pend on must be of type OS_SEM ... */
    356                  if (p_sem->Type == OS_OBJ_TYPE_SEM) {
    357                      ctr++;
    358                  }
    359          #endif
    360          
    361          #if OS_CFG_Q_EN > 0u
    362                  p_q = (OS_Q *)((void *)p_pend_data_tbl->PendObjPtr);     /* ... or of type OS_Q                               */
    363                  if (p_q->Type == OS_OBJ_TYPE_Q) {
    364                      ctr++;
    365                  }
    366          #endif
    367          
    368                  if (ctr == (OS_OBJ_QTY)0) {
    369                      return (DEF_FALSE);                                  /* Found at least one invalid object type            */
    370                  }
    371                  p_pend_data_tbl++;
   \                     ??OS_PendMultiValidate_1: (+1)
   \   0000000A   0x3020             ADDS     R0,R0,#+32
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \                     ??OS_PendMultiValidate_0: (+1)
   \   0000000E   0x0412             LSLS     R2,R2,#+16
   \   00000010   0x0C12             LSRS     R2,R2,#+16
   \   00000012   0x428A             CMP      R2,R1
   \   00000014   0xD209             BCS      ??OS_PendMultiValidate_2
   \   00000016   0x68C5             LDR      R5,[R0, #+12]
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD004             BEQ      ??OS_PendMultiValidate_3
   \   0000001C   0x682D             LDR      R5,[R5, #+0]
   \   0000001E   0x42A5             CMP      R5,R4
   \   00000020   0xD0F3             BEQ      ??OS_PendMultiValidate_1
   \   00000022   0x429D             CMP      R5,R3
   \   00000024   0xD0F1             BEQ      ??OS_PendMultiValidate_1
   \                     ??OS_PendMultiValidate_3: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B        ??OS_PendMultiValidate_4
    372              }
    373              return (DEF_TRUE);
   \                     ??OS_PendMultiValidate_2: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \                     ??OS_PendMultiValidate_4: (+1)
   \   0000002C   0xBC30             POP      {R4,R5}
   \   0000002E   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*$PAGE*/
    377          /*
    378          ************************************************************************************************************************
    379          *                                 MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
    380          *
    381          * Description: This function is called by OSPendMulti() to suspend a task because any one of multiple objects that have
    382          *              not been posted to.
    383          *
    384          * Arguments  : p_pend_data_tbl    is a pointer to an array of OS_PEND_DATA
    385          *              ---------------
    386          *
    387          *              tbl_size           is the size of the array
    388          *
    389          *              timeout            is the timeout to wait in case none of the objects become ready
    390          *
    391          * Returns    : none
    392          *
    393          * Note       : This function is INTERNAL to uC/OS-III and your application should not call it.
    394          ************************************************************************************************************************
    395          */
    396          

   \                                 In section .text, align 2, keep-with-next
    397          void  OS_PendMultiWait (OS_PEND_DATA  *p_pend_data_tbl,
    398                                  OS_OBJ_QTY     tbl_size,
    399                                  OS_TICK        timeout)
    400          {
   \                     OS_PendMultiWait: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0011             MOVS     R1,R2
    401              OS_OBJ_QTY      i;
    402              OS_PEND_LIST   *p_pend_list;
    403          
    404          #if OS_CFG_Q_EN > 0u
    405              OS_Q           *p_q;
    406          #endif
    407          
    408          #if OS_CFG_SEM_EN > 0u
    409              OS_SEM         *p_sem;
    410          #endif
    411          
    412          
    413          
    414              OSTCBCurPtr->PendOn             = OS_TASK_PEND_ON_MULTI;   /* Resource not available, wait until it is            */
   \   00000008   0x....             LDR      R6,??DataTable3_10
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x6832             LDR      R2,[R6, #+0]
   \   0000000E   0x3234             ADDS     R2,R2,#+52
   \   00000010   0x7010             STRB     R0,[R2, #+0]
    415              OSTCBCurPtr->PendStatus         = OS_STATUS_PEND_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6832             LDR      R2,[R6, #+0]
   \   00000016   0x3235             ADDS     R2,R2,#+53
   \   00000018   0x7010             STRB     R0,[R2, #+0]
    416              OSTCBCurPtr->PendDataTblEntries = tbl_size;
   \   0000001A   0x6830             LDR      R0,[R6, #+0]
   \   0000001C   0x87C5             STRH     R5,[R0, #+62]
    417              OSTCBCurPtr->PendDataTblPtr     = p_pend_data_tbl;
   \   0000001E   0x6304             STR      R4,[R0, #+48]
    418          
    419              OS_TaskBlock(OSTCBCurPtr,                                  /* Block the task waiting for object to be posted ...  */
    420                           timeout);                                     /* ... but with a timeout if not                       */
   \   00000020   0x.... 0x....      BL       OS_TaskBlock
    421          
    422              for (i = 0u; i < tbl_size; i++) {
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD016             BEQ      ??OS_PendMultiWait_0
   \   00000028   0x....             LDR      R7,??DataTable3_4  ;; 0x414d4553
    423                  p_pend_data_tbl->TCBPtr = OSTCBCurPtr;                 /* Every entry points back to the TCB of the task      */
   \                     ??OS_PendMultiWait_1: (+1)
   \   0000002A   0x6830             LDR      R0,[R6, #+0]
   \   0000002C   0x60A0             STR      R0,[R4, #+8]
    424          
    425          #if OS_CFG_SEM_EN > 0u
    426                  p_sem = (OS_SEM *)((void *)p_pend_data_tbl->PendObjPtr);
   \   0000002E   0x68E0             LDR      R0,[R4, #+12]
    427                  if (p_sem->Type == OS_OBJ_TYPE_SEM) {
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x42B9             CMP      R1,R7
   \   00000034   0xD103             BNE      ??OS_PendMultiWait_2
    428                      p_pend_list = &p_sem->PendList;
    429                      OS_PendListInsertPrio(p_pend_list,
    430                                            p_pend_data_tbl);
   \   00000036   0x0021             MOVS     R1,R4
   \   00000038   0x3008             ADDS     R0,R0,#+8
   \   0000003A   0x.... 0x....      BL       OS_PendListInsertPrio
    431                  }
    432          #endif
    433          
    434          #if OS_CFG_Q_EN > 0u
    435                  p_q = (OS_Q *)((void *)p_pend_data_tbl->PendObjPtr);
   \                     ??OS_PendMultiWait_2: (+1)
   \   0000003E   0x68E0             LDR      R0,[R4, #+12]
    436                  if (p_q->Type == OS_OBJ_TYPE_Q) {
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x....             LDR      R2,??DataTable3_3  ;; 0x55455551
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xD103             BNE      ??OS_PendMultiWait_3
    437                      p_pend_list = &p_q->PendList;
    438                      OS_PendListInsertPrio(p_pend_list,
    439                                            p_pend_data_tbl);
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0x3008             ADDS     R0,R0,#+8
   \   0000004C   0x.... 0x....      BL       OS_PendListInsertPrio
    440                  }
    441          #endif
    442          
    443                  p_pend_data_tbl++;
   \                     ??OS_PendMultiWait_3: (+1)
   \   00000050   0x3420             ADDS     R4,R4,#+32
    444              }
   \   00000052   0x1E6D             SUBS     R5,R5,#+1
   \   00000054   0xD1E9             BNE      ??OS_PendMultiWait_1
    445          }
   \                     ??OS_PendMultiWait_0: (+1)
   \   00000056   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x000061AE         DC32     0x61ae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x000062D5         DC32     0x62d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x55455551         DC32     0x55455551

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x00005DC4         DC32     0x5dc4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x000061B0         DC32     0x61b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x00005E25         DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x00006D63         DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x000061A9         DC32     0x61a9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x000072D9         DC32     0x72d9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x00005DC2         DC32     0x5dc2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x00006E2E         DC32     0x6e2e
    446          
    447          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSPendMulti
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_PendMultiGetRdy
        40   -> OS_PendMultiWait
      32   OS_PendMultiGetRdy
        32   -> OS_MsgQGet
       8   OS_PendMultiValidate
      24   OS_PendMultiWait
        24   -> OS_PendListInsertPrio
        24   -> OS_TaskBlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     322  OSPendMulti
     122  OS_PendMultiGetRdy
      48  OS_PendMultiValidate
      88  OS_PendMultiWait

 
 640 bytes in section .text
 
 640 bytes of CODE memory

Errors: none
Warnings: none
