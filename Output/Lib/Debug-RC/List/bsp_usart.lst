###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:21:31
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_usart.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_usart.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\bsp_usart.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\bsp_usart.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_usart.c
      1          /*******************************************************************************
      2           *   Filename:       bsp_usart.c
      3           *   Revised:        All copyrights reserved to wumingshen.
      4           *   Revision:       v1.0
      5           *   Writer:	     wumingshen.
      6           *
      7           *   Description:    串口驱动模块
      8           *   Notes:          中断程序未对发送缓冲区满做处理.也就是说调用ComSendBuf()函数时，
      9           *		             如果开辟的发送缓冲区不足，将导致最先放入FIFO的数据被冲掉。
     10           *		             不过对以一般的应用程序，将发送缓冲区开的足够大以保证一个最长的通信帧能够容纳下即可。
     11           *     				 E-mail:shenchangwei945@163.com
     12           *
     13           *******************************************************************************/
     14          #include "includes.h"
     15          #include "bsp_usart.h"
     16          
     17          #define    UCOS_EN        DEF_ENABLED
     18          
     19          
     20          /*******************************************************************************
     21           * 名    称： InitHardUart
     22           * 功    能： 配置USART硬件参数
     23           * 入口参数： 无
     24           * 出口参数： 无
     25           * 作　 　者： 无名沈.
     26           * 创建日期： 2015-06-25
     27           * 修    改：
     28           * 修改日期：
     29           * 备    注：
     30           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     31          void BSP_UartCfg(u8 port_nbr,u32  baud)
     32          {
   \                     BSP_UartCfg: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x460C             MOV      R4,R1
     33          	GPIO_InitTypeDef GPIO_InitStructure;
     34          	USART_InitTypeDef USART_InitStructure;
     35          
     36              /***********************************************
     37              * 描述： 串口3引脚接到地，不能使用
     38              */
     39              if ( port_nbr > 3 )
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xF280 0x80ED      BGE.W    ??BSP_UartCfg_0
     40                  return;
     41              
     42              switch ( port_nbr ) {
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD006             BEQ.N    ??BSP_UartCfg_1
   \   00000010   0xF0C0 0x80E9      BCC.W    ??BSP_UartCfg_0
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xF000 0x809A      BEQ.W    ??BSP_UartCfg_2
   \   0000001A   0xD34D             BCC.N    ??BSP_UartCfg_3
   \   0000001C   0xE0E3             B.N      ??BSP_UartCfg_0
     43          #if defined (Open_UART1)
     44              case 1:
     45          	/* 第1步：打开GPIO和USART部件的时钟 */
     46          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
   \                     ??BSP_UartCfg_1: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     47          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     48          
     49          	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
     50          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000030   0xF44F 0x7000      MOV      R0,#+512
   \   00000034   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     51          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000038   0x2018             MOVS     R0,#+24
   \   0000003A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     52          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xF88D 0x0002      STRB     R0,[SP, #+2]
     53          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000044   0x....             LDR.N    R5,??DataTable3  ;; 0x40010800
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       GPIO_Init
     54          
     55          	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
     56              由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
     57              但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
     58          	*/
     59          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000004E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000052   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     60          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000056   0x2004             MOVS     R0,#+4
   \   00000058   0xF88D 0x0003      STRB     R0,[SP, #+3]
     61          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       GPIO_Init
     62          	/*  第3步已经做了，因此这步可以不做
     63              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     64          	*/
     65          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       GPIO_Init
     66          
     67          	/* 第4步：设置串口硬件参数 */
     68          	USART_InitStructure.USART_BaudRate = baud;
   \   0000006C   0x9401             STR      R4,[SP, #+4]
     69          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9002             STR      R0,[SP, #+8]
     70          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
     71          	USART_InitStructure.USART_Parity = USART_Parity_No ;
   \   00000072   0xF8AD 0x000C      STRH     R0,[SP, #+12]
     72          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000076   0xF8AD 0x0010      STRH     R0,[SP, #+16]
     73          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   0000007A   0x200C             MOVS     R0,#+12
   \   0000007C   0xF8AD 0x000E      STRH     R0,[SP, #+14]
     74          	USART_Init(USART1, &USART_InitStructure);
   \   00000080   0x....             LDR.N    R4,??DataTable3_1  ;; 0x40013800
   \   00000082   0xA901             ADD      R1,SP,#+4
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       USART_Init
     75          	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
   \   0000008A   0x2201             MOVS     R2,#+1
   \   0000008C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       USART_ITConfig
     76          	
     77              //USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
     78              /*注意: 不要在此处打开发送中断
     79              发送中断使能在SendUart()函数打开
     80          	*/
     81          	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       USART_Cmd
     82          
     83          	/***********************************************
     84              * 描述： CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
     85          	*	     如下语句解决第1个字节无法正确发送出去的问题：
     86          	*	     清发送完成标志，Transmission Complete flag
     87              */
     88          	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送标志，Transmission Complete flag */
   \   0000009E   0x2140             MOVS     R1,#+64
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       USART_ClearFlag
     89          
     90          #if  (UCOS_EN == DEF_ENABLED)
     91              /***********************************************
     92              * 描述：中断函数映射处理，将USART1的中断服务函数入口地址映射到
     93              *       USARTx_RxTxISRHandler的函数入口地址上，并使能。
     94              */
     95              BSP_IntVectSet(BSP_INT_ID_USART1, USART1_IRQHandler);
   \   000000A6   0x.... 0x....      ADR.W    R1,USART1_IRQHandler
   \   000000AA   0x2025             MOVS     R0,#+37
   \   000000AC   0x.... 0x....      BL       BSP_IntVectSet
     96              BSP_IntEn(BSP_INT_ID_USART1);
   \   000000B0   0x2025             MOVS     R0,#+37
   \   000000B2   0x.... 0x....      BL       BSP_IntEn
     97          
     98          #else
     99              NVIC_InitTypeDef NVIC_InitStructure;
    100              /* Configure the NVIC Preemption Priority Bits */
    101              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    102              /* Enable the USART1 Interrupt */
    103              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    104              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    105              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    106              NVIC_Init(&NVIC_InitStructure);
    107          
    108              /*在不使用UCOS系统时，将USART1_IRQHandler函数放在stm32_it.c文件的串口中断函数中*/
    109          #endif
    110          
    111                  break;
   \   000000B6   0xE096             B.N      ??BSP_UartCfg_0
    112          #endif /*end of open_uart1*/
    113          
    114          #if defined (Open_UART2)
    115              case 2:
    116          	/* 第1步：打开GPIO和USART部件的时钟 */
    117          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
   \                     ??BSP_UartCfg_3: (+1)
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x2005             MOVS     R0,#+5
   \   000000BC   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    118          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0xF44F 0x3000      MOV      R0,#+131072
   \   000000C6   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    119          
    120          	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
    121          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;
   \   000000CA   0x2004             MOVS     R0,#+4
   \   000000CC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    122          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
   \   000000D0   0x2018             MOVS     R0,#+24
   \   000000D2   0xF88D 0x0003      STRB     R0,[SP, #+3]
    123          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    124          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000DC   0x....             LDR.N    R5,??DataTable3  ;; 0x40010800
   \   000000DE   0x4669             MOV      R1,SP
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x.... 0x....      BL       GPIO_Init
    125          
    126          	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
    127          		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
    128          		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
    129          	*/
    130          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   000000E6   0x2008             MOVS     R0,#+8
   \   000000E8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    131          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   000000EC   0x2004             MOVS     R0,#+4
   \   000000EE   0xF88D 0x0003      STRB     R0,[SP, #+3]
    132          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000F2   0x4669             MOV      R1,SP
   \   000000F4   0x4628             MOV      R0,R5
   \   000000F6   0x.... 0x....      BL       GPIO_Init
    133          	/*  第3步已经做了，因此这步可以不做
    134          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    135          	*/
    136          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000FA   0x4669             MOV      R1,SP
   \   000000FC   0x4628             MOV      R0,R5
   \   000000FE   0x.... 0x....      BL       GPIO_Init
    137          
    138          	/* 第4步：设置串口硬件参数 */
    139          	USART_InitStructure.USART_BaudRate = baud;
   \   00000102   0x9401             STR      R4,[SP, #+4]
    140          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x9002             STR      R0,[SP, #+8]
    141          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
    142          	USART_InitStructure.USART_Parity = USART_Parity_No ;
   \   00000108   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    143          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000010C   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    144          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000110   0x200C             MOVS     R0,#+12
   \   00000112   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    145          	USART_Init(USART2, &USART_InitStructure);
   \   00000116   0x....             LDR.N    R4,??DataTable3_2  ;; 0x40004400
   \   00000118   0xA901             ADD      R1,SP,#+4
   \   0000011A   0x4620             MOV      R0,R4
   \   0000011C   0x.... 0x....      BL       USART_Init
    146          	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
   \   00000120   0x2201             MOVS     R2,#+1
   \   00000122   0xF240 0x5125      MOVW     R1,#+1317
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0x.... 0x....      BL       USART_ITConfig
    147          	/*
    148              USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    149              注意: 不要在此处打开发送中断
    150              发送中断使能在SendUart()函数打开
    151          	*/
    152          	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
   \   0000012C   0x2101             MOVS     R1,#+1
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0x.... 0x....      BL       USART_Cmd
    153          
    154          	/***********************************************
    155              * 描述： CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
    156          	*	     如下语句解决第1个字节无法正确发送出去的问题：
    157          	*	     清发送完成标志，Transmission Complete flag
    158              */
    159          	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送标志，Transmission Complete flag */
   \   00000134   0x2140             MOVS     R1,#+64
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       USART_ClearFlag
    160          
    161          #if  (UCOS_EN == DEF_ENABLED)
    162              /***********************************************
    163              * 描述：中断函数映射处理，将USART1的中断服务函数入口地址映射到
    164              *       USARTx_RxTxISRHandler的函数入口地址上，并使能。
    165              */
    166              BSP_IntVectSet(BSP_INT_ID_USART2, USART2_IRQHandler);
   \   0000013C   0x.... 0x....      ADR.W    R1,USART2_IRQHandler
   \   00000140   0x2026             MOVS     R0,#+38
   \   00000142   0x.... 0x....      BL       BSP_IntVectSet
    167              BSP_IntEn(BSP_INT_ID_USART2);
   \   00000146   0x2026             MOVS     R0,#+38
   \   00000148   0x.... 0x....      BL       BSP_IntEn
    168          
    169          #else
    170              NVIC_InitTypeDef NVIC_InitStructure;
    171              /* Configure the NVIC Preemption Priority Bits */
    172              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    173              /* Enable the USART1 Interrupt */
    174              NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    175              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    176              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    177              NVIC_Init(&NVIC_InitStructure);
    178          
    179              /*在不使用UCOS系统时，将USART2_IRQHandler函数放在stm32_it.c文件的串口中断函数中*/
    180          #endif
    181          
    182                  break;
   \   0000014C   0xE04B             B.N      ??BSP_UartCfg_0
    183          #endif /*end of open_uart2*/
    184          #if defined (Open_UART3)
    185          
    186              case 3:
    187          	/* 第1步：打开GPIO和USART部件的时钟 */
    188          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
   \                     ??BSP_UartCfg_2: (+1)
   \   0000014E   0x2101             MOVS     R1,#+1
   \   00000150   0x2009             MOVS     R0,#+9
   \   00000152   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    189          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0xF44F 0x2080      MOV      R0,#+262144
   \   0000015C   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    190          
    191          	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
    192          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000160   0xF44F 0x6080      MOV      R0,#+1024
   \   00000164   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    193          	GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_AF_PP;//GPIO_Mode_AF_PP;
   \   00000168   0x2018             MOVS     R0,#+24
   \   0000016A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    194          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000016E   0x2003             MOVS     R0,#+3
   \   00000170   0xF88D 0x0002      STRB     R0,[SP, #+2]
    195          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000174   0x....             LDR.N    R5,??DataTable3_3  ;; 0x40010c00
   \   00000176   0x4669             MOV      R1,SP
   \   00000178   0x4628             MOV      R0,R5
   \   0000017A   0x.... 0x....      BL       GPIO_Init
    196          
    197          	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
    198          		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
    199          		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
    200          	*/
    201          	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_11;
   \   0000017E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000182   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    202          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000186   0x2004             MOVS     R0,#+4
   \   00000188   0xF88D 0x0003      STRB     R0,[SP, #+3]
    203          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000018C   0x4669             MOV      R1,SP
   \   0000018E   0x4628             MOV      R0,R5
   \   00000190   0x.... 0x....      BL       GPIO_Init
    204          	/*  第3步已经做了，因此这步可以不做
    205          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    206          	*/
    207          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000194   0x4669             MOV      R1,SP
   \   00000196   0x4628             MOV      R0,R5
   \   00000198   0x.... 0x....      BL       GPIO_Init
    208              //    return ;
    209          	/* 第4步：设置串口硬件参数 */
    210          	USART_InitStructure.USART_BaudRate = baud;
   \   0000019C   0x9401             STR      R4,[SP, #+4]
    211          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0x9002             STR      R0,[SP, #+8]
    212          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
    213          	USART_InitStructure.USART_Parity = USART_Parity_No ;
   \   000001A2   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    214          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   000001A6   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    215          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   000001AA   0x200C             MOVS     R0,#+12
   \   000001AC   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    216          	USART_Init(USART3, &USART_InitStructure);
   \   000001B0   0x....             LDR.N    R4,??DataTable3_4  ;; 0x40004800
   \   000001B2   0xA901             ADD      R1,SP,#+4
   \   000001B4   0x4620             MOV      R0,R4
   \   000001B6   0x.... 0x....      BL       USART_Init
    217          	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
   \   000001BA   0x2201             MOVS     R2,#+1
   \   000001BC   0xF240 0x5125      MOVW     R1,#+1317
   \   000001C0   0x4620             MOV      R0,R4
   \   000001C2   0x.... 0x....      BL       USART_ITConfig
    218          	/*
    219              USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
    220              注意: 不要在此处打开发送中断
    221              发送中断使能在SendUart()函数打开
    222          	*/
    223          	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
   \   000001C6   0x2101             MOVS     R1,#+1
   \   000001C8   0x4620             MOV      R0,R4
   \   000001CA   0x.... 0x....      BL       USART_Cmd
    224          
    225          	/***********************************************
    226              * 描述： CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
    227          	*	     如下语句解决第1个字节无法正确发送出去的问题：
    228          	*	     清发送完成标志，Transmission Complete flag
    229              */
    230          	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送标志，Transmission Complete flag */
   \   000001CE   0x2140             MOVS     R1,#+64
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0x.... 0x....      BL       USART_ClearFlag
    231          
    232          #if  (UCOS_EN == DEF_ENABLED)
    233              /***********************************************
    234              * 描述：中断函数映射处理，将USART1的中断服务函数入口地址映射到
    235              *       USARTx_RxTxISRHandler的函数入口地址上，并使能。
    236              */
    237              BSP_IntVectSet(BSP_INT_ID_USART3, USART3_IRQHandler);
   \   000001D6   0x.... 0x....      ADR.W    R1,USART3_IRQHandler
   \   000001DA   0x2027             MOVS     R0,#+39
   \   000001DC   0x.... 0x....      BL       BSP_IntVectSet
    238              BSP_IntEn(BSP_INT_ID_USART3);
   \   000001E0   0x2027             MOVS     R0,#+39
   \   000001E2   0x.... 0x....      BL       BSP_IntEn
    239          
    240          #else
    241              NVIC_InitTypeDef NVIC_InitStructure;
    242              /* Configure the NVIC Preemption Priority Bits */
    243              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    244              /* Enable the USART1 Interrupt */
    245              NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
    246              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    247              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    248              NVIC_Init(&NVIC_InitStructure);
    249          
    250              /*在不使用UCOS系统时，将USART3_IRQHandler函数放在stm32_it.c文件的串口中断函数中*/
    251          #endif
    252          
    253              break;
    254          #endif /*end of open_uart3*/
    255              }
    256          }
   \                     ??BSP_UartCfg_0: (+1)
   \   000001E6   0xB005             ADD      SP,SP,#+20
   \   000001E8   0xBD30             POP      {R4,R5,PC}       ;; return
    257          
    258          /*******************************************************************************
    259           * 名    称： UartIRQ
    260           * 功    能： 供中断服务程序调用，通用串口中断处理函数。
    261           * 入口参数： _pUart: 串口结构体指针
    262           * 出口参数： 无
    263           * 作　 　者： 无名沈.
    264           * 创建日期： 2015-06-25
    265           * 修    改：
    266           * 修改日期：
    267           * 备    注：
    268           *******************************************************************************/
    269          #if defined(PM2D5_UART_CHK)
    270          u8  Uart1RxBuf[11];
    271          u8  Uart1RxCtr  = 0;
    272          #endif

   \                                 In section .text, align 2, keep-with-next
    273          static void  USARTx_RxTxISRHandler (USART_TypeDef* USARTx)
    274          {
   \                     USARTx_RxTxISRHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    275              uint8_t t_receivedata = 0;
    276              /***********************************************
    277              * 描述：接收中断
    278              */
    279              if (SET == USART_GetFlagStatus(USARTx, USART_FLAG_RXNE)) {
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD107             BNE.N    ??USARTx_RxTxISRHandler_0
    280                  /***********************************************
    281                  * 描述：接收一个字节
    282                  */    
    283          #if defined(PM2D5_UART_CHK)
    284                  Uart1RxBuf[Uart1RxCtr++]   = USART_ReceiveData(USARTx);
    285                  if ( Uart1RxCtr > 10 )
    286                      Uart1RxCtr = 0;
    287                  
    288                  osal_start_timerEx( OS_TASK_ID_SENSOR,
    289                                     OS_EVT_SEN_UART_TIMEOUT,
    290                                      20);
    291          #else
    292                  t_receivedata   = USART_ReceiveData(USARTx);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       USART_ReceiveData
    293                  t_receivedata   = t_receivedata; 
    294          #endif
    295                  USART_ClearITPendingBit(USARTx, USART_IT_RXNE);         /* Clear the USARTx receive interrupt.                  */
   \   00000014   0xF240 0x5125      MOVW     R1,#+1317
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       USART_ClearITPendingBit
    296              }
    297          
    298              /***********************************************
    299              * 描述：发送中断
    300              */
    301              if (SET == USART_GetFlagStatus(USARTx, USART_FLAG_TC)) {
   \                     ??USARTx_RxTxISRHandler_0: (+1)
   \   0000001E   0x2140             MOVS     R1,#+64
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD10C             BNE.N    ??USARTx_RxTxISRHandler_1
    302          
    303          
    304                  USART_ClearITPendingBit(USARTx, USART_IT_TC);           /*清除串口发送中断标志位*/
   \   0000002A   0xF240 0x6526      MOVW     R5,#+1574
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       USART_ClearITPendingBit
    305                  USART_ITConfig(USARTx, USART_IT_TC, DISABLE);           /*关闭串口发送中断*/
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000040   0x.... 0x....      B.W      USART_ITConfig
    306              }
    307          }
   \                     ??USARTx_RxTxISRHandler_1: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    308          
    309          /*******************************************************************************
    310           * 名    称： USART1_IRQHandler
    311           * 功    能： USART1中断服务程序
    312           * 入口参数： 无
    313           * 出口参数： 无
    314           * 作　 　者： 无名沈.
    315           * 创建日期： 2015-06-25
    316           * 修    改：
    317           * 修改日期：
    318           * 备    注：
    319           *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    320          void USART1_IRQHandler(void)
    321          {
    322          	USARTx_RxTxISRHandler (USART1);
   \                     USART1_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40013800
   \   00000002   0x....             B.N      USARTx_RxTxISRHandler
    323          }
    324          
    325          /*******************************************************************************
    326           * 名    称： USART2_IRQHandler
    327           * 功    能： USART2中断服务程序
    328           * 入口参数： 无
    329           * 出口参数： 无
    330           * 作　 　者： 无名沈.
    331           * 创建日期： 2015-06-25
    332           * 修    改：
    333           * 修改日期：
    334           * 备    注：
    335           *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    336          void USART2_IRQHandler(void)
    337          {
    338          	USARTx_RxTxISRHandler (USART2);
   \                     USART2_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40004400
   \   00000002   0x....             B.N      USARTx_RxTxISRHandler
    339          //     static u16   recvcont = 0;
    340          
    341          //    /***********************************************
    342          //    * 描述：接收中断
    343          //    */
    344          //    if (SET == USART_GetFlagStatus(USART2, USART_FLAG_RXNE)) {
    345          //         extern u8 PM2D5_UartBuf[];
    346          //         PM2D5_UartBuf[recvcont] = USART_ReceiveData(USART2);
    347          //         if(++recvcont >= 14) {
    348          //            recvcont = 0;
    349          //            Ctrl.PM2D5.RxFaildCtr   = 0;
    350          //         }
    351          //         USART_ClearITPendingBit(USART2, USART_IT_RXNE);                /* Clear the USART2 receive interrupt.                  */
    352          //     }
    353          //
    354          //    /***********************************************
    355          //    * 描述：发送中断
    356          //    */
    357          //    if (SET == USART_GetFlagStatus(USART2, USART_FLAG_TC)) {
    358          //        USART_ITConfig(USART2, USART_IT_TC, DISABLE);
    359          //        USART_ClearITPendingBit(USART2, USART_IT_TC);                   /* Clear the USART2 receive interrupt.                */
    360          //    }
    361          }
    362          
    363          /*******************************************************************************
    364           * 名    称： USART3_IRQHandler
    365           * 功    能： USART3中断服务程序
    366           * 入口参数： 无
    367           * 出口参数： 无
    368           * 作　 　者： 无名沈.
    369           * 创建日期： 2015-06-25
    370           * 修    改：
    371           * 修改日期：
    372           * 备    注：
    373           *******************************************************************************/
    374          //extern UART_HandleTypeDef  				Ctrl.Wifi.UartHandle;
    375          //extern Device_ReadTypeDef               Device_ReadStruct;

   \                                 In section .text, align 4, keep-with-next
    376          void USART3_IRQHandler(void)
    377          {
    378          	USARTx_RxTxISRHandler (USART3);
   \                     USART3_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40004800
   \   00000002   0x....             B.N      USARTx_RxTxISRHandler
    379          //    uint8_t 	value;
    380          //    OS_ERR      err;
    381          //    
    382          //    if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) {
    383          //		USART_ClearITPendingBit(USART3,USART_IT_RXNE);
    384          //		value = USART_ReceiveData(USART3);
    385          //        /***********************************************
    386          //        * 描述： 发送WIFI串口接收超时标志位
    387          //        */
    388          //        //OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.WifiEvtFlagGrp,
    389          //        //            ( OS_FLAGS      )WIFI_EVT_FLAG_TIMEOUT,
    390          //        //            ( OS_OPT        )OS_OPT_POST_FLAG_SET,
    391          //        //            ( OS_ERR       *)&err); 
    392          //        Ctrl.Wifi.UartHandle.UART_RecvFlag         = 1;
    393          //        Ctrl.Wifi.UartHandle.UART_RecvTimeoutCtr   = 0;
    394          //        /***********************************************
    395          //        * 描述： 准备收取一包数据
    396          //        */
    397          //		if(Ctrl.Wifi.UartHandle.Package_Flag != 0 ) {
    398          //            if ( Ctrl.Wifi.UartHandle.UART_Count >= Max_UartBuf ){
    399          //                Ctrl.Wifi.UartHandle.UART_Count    = 0;
    400          //                Ctrl.Wifi.UartHandle.Package_Flag  = 0;
    401          //            }
    402          //		} else {
    403          //            /***********************************************
    404          //            * 描述： 判断第一个字节是不是数据帧头0XFF
    405          //            */
    406          //			if(Ctrl.Wifi.UartHandle.UART_Flag1 ==0) {
    407          //				if(value == 0xff) {
    408          //                    Ctrl.Wifi.UartHandle.UART_Count = 0;
    409          //                    Ctrl.Wifi.UartHandle.UART_Buf[Ctrl.Wifi.UartHandle.UART_Count]=value;
    410          //                    Ctrl.Wifi.UartHandle.UART_Count++;
    411          //                    Ctrl.Wifi.UartHandle.UART_Flag1 = 1;
    412          //				}
    413          //				return ;
    414          //                /***********************************************
    415          //                * 描述： 判断第二个字节是不是0XFF
    416          //                */
    417          //			} else if(Ctrl.Wifi.UartHandle.UART_Flag2 ==0) {
    418          //                Ctrl.Wifi.UartHandle.UART_Buf[Ctrl.Wifi.UartHandle.UART_Count]=value;
    419          //                Ctrl.Wifi.UartHandle.UART_Count++;
    420          //                /***********************************************
    421          //                * 描述： 第二个字节是0XFF，接受下一个数据
    422          //                */
    423          //                if(Ctrl.Wifi.UartHandle.UART_Buf[1] == 0xff) {
    424          //                    Ctrl.Wifi.UartHandle.UART_Flag2 = 1;
    425          //                    /***********************************************
    426          //                    * 描述： 第二个字节不是0XFF重新开始接受数据
    427          //                    */
    428          //                } else {
    429          //                    Ctrl.Wifi.UartHandle.UART_Flag1 = 0;
    430          //                }
    431          //                return ;
    432          //                /***********************************************
    433          //                * 描述： 当第一二个字节正确时，接受之后的字节
    434          //                */
    435          //			} else {
    436          //                /***********************************************
    437          //                * 描述：往串口接受缓冲区存放接受数据
    438          //                */
    439          //				Ctrl.Wifi.UartHandle.UART_Buf[Ctrl.Wifi.UartHandle.UART_Count] = value;
    440          //                /***********************************************
    441          //                * 描述：往串口接受缓冲区存放接受数据
    442          //                */
    443          //				if(Ctrl.Wifi.UartHandle.UART_Count >=4 && Ctrl.Wifi.UartHandle.UART_Buf[Ctrl.Wifi.UartHandle.UART_Count] == 0x55 && \
    444          //                    Ctrl.Wifi.UartHandle.UART_Buf[Ctrl.Wifi.UartHandle.UART_Count - 1] == 0xFF){
    445          //                        //待处理
    446          //                    } else {
    447          //                        Ctrl.Wifi.UartHandle.UART_Count++;
    448          //                    }
    449          //                
    450          //				if(Ctrl.Wifi.UartHandle.UART_Count == 0x04) {
    451          //					Ctrl.Wifi.UartHandle.UART_Cmd_len = Ctrl.Wifi.UartHandle.UART_Buf[2]*256+  Ctrl.Wifi.UartHandle.UART_Buf[3];
    452          //                    //============================================//
    453          //                    /***********************************************
    454          //                    * 描述：该段代码自行加入,收到的长度错误时，重新接受数据
    455          //                    */
    456          //                    if((Ctrl.Wifi.UartHandle.UART_Cmd_len >= 255) || (Ctrl.Wifi.UartHandle.UART_Cmd_len  == 0)) {
    457          //                        Ctrl.Wifi.UartHandle.UART_Cmd_len = 0;
    458          //                        Ctrl.Wifi.UartHandle.UART_Flag1 = 0;
    459          //                        Ctrl.Wifi.UartHandle.UART_Flag2 = 0;
    460          //                        return;
    461          //                    }
    462          //                    //============================================//
    463          //				}
    464          //				if(Ctrl.Wifi.UartHandle.UART_Count ==  (Ctrl.Wifi.UartHandle.UART_Cmd_len + 4)) {
    465          //					//OSSemPost ((OS_SEM  *)&SemUsartPackageFlag,
    466          //                    //           (OS_OPT   )OS_OPT_POST_1,
    467          //                    //           (OS_ERR  *)&err);
    468          //                    
    469          //                    /***********************************************
    470          //                    * 描述： 发送WIFI串口接收标志位
    471          //                    */
    472          //                    OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.WifiEvtFlagGrp,
    473          //                               ( OS_FLAGS      )WIFI_EVT_FLAG_RECV,
    474          //                               ( OS_OPT        )OS_OPT_POST_FLAG_SET,
    475          //                               ( OS_ERR       *)&err); 
    476          //                    /***********************************************
    477          //                    * 描述： 发送WIFI串口接收超时标志位
    478          //                    */
    479          //                    //OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.WifiEvtFlagGrp,
    480          //                    //            ( OS_FLAGS      )WIFI_EVT_FLAG_TIMEOUT,
    481          //                    //            ( OS_OPT        )OS_OPT_POST_FLAG_CLR,
    482          //                    //            ( OS_ERR       *)&err); 
    483          //                    
    484          //                    
    485          //                    Ctrl.Wifi.UartHandle.UART_RecvFlag = 0;
    486          //                    Ctrl.Wifi.UartHandle.Package_Flag  = 1;
    487          //					Ctrl.Wifi.UartHandle.UART_Flag1    = 0;
    488          //					Ctrl.Wifi.UartHandle.UART_Flag2    = 0;
    489          //                    //printf("Package_Flag =1 \r\n");
    490          //				}
    491          //			}
    492          //		}
    493          //    }
    494          }
    495          
    496          /*******************************************************************************
    497           * 名    称： USART_OPen_INT
    498           * 功    能： 打开某个串口的中断
    499           * 入口参数： USART_TypeDef* USARTx 串口号
    500           * 出口参数： 无
    501           * 作　 　者： 无名沈.
    502           * 创建日期： 2015-06-25
    503           * 修    改：
    504           * 修改日期：
    505           * 备    注：
    506           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    507          void USART_OPen_INT(USART_TypeDef* USARTx)
    508          {
   \                     USART_OPen_INT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    509              USART_ClearITPendingBit(USARTx,USART_IT_RXNE);
   \   00000004   0xF240 0x5525      MOVW     R5,#+1317
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x.... 0x....      BL       USART_ClearITPendingBit
    510              USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000018   0x.... 0x....      B.W      USART_ITConfig
    511          
    512          }
    513          
    514          /*******************************************************************************
    515           * 名    称： USART_Close_INT
    516           * 功    能： 关闭某个串口的中断
    517           * 入口参数： USART_TypeDef* USARTx 串口号
    518           * 出口参数： 无
    519           * 作　 　者： 无名沈.
    520           * 创建日期： 2015-06-25
    521           * 修    改：
    522           * 修改日期：
    523           * 备    注：
    524           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    525          void USART_Close_INT(USART_TypeDef* USARTx)
    526          {
    527              USART_ITConfig(USARTx, USART_IT_RXNE, DISABLE);
   \                     USART_Close_INT: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      B.W      USART_ITConfig
    528          
    529          }
    530          
    531          /*******************************************************************************
    532           * 名    称： USART_Send_Char
    533           * 功    能： 查询法发送一个字节
    534           * 入口参数： USART_TypeDef* USARTx 串口号 ；data ：需要发送的字节
    535           * 出口参数： 无
    536           * 作　 　者： 无名沈.
    537           * 创建日期： 2015-06-25
    538           * 修    改：
    539           * 修改日期：
    540           * 备    注：
    541           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    542          void USART_Send_Char(USART_TypeDef* USARTx,unsigned char data)
    543          {
   \                     USART_Send_Char: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    544              USART_ClearFlag(USARTx,USART_FLAG_TC);
   \   00000006   0x2140             MOVS     R1,#+64
   \   00000008   0x.... 0x....      BL       USART_ClearFlag
    545              USART_SendData(USARTx,data);
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       USART_SendData
    546              while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET);     //等待发送完毕
   \                     ??USART_Send_Char_0: (+1)
   \   00000014   0x2180             MOVS     R1,#+128
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD0F9             BEQ.N    ??USART_Send_Char_0
    547          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    548          
    549          /*******************************************************************************
    550           * 名    称： USART_Send_String
    551           * 功    能： 查询法发送一串字符串
    552           * 入口参数： USART_TypeDef* USARTx 串口号 ；unsigned char *buffer：需要发送的字符串
    553           *            unsigned int len ： 字符串长度
    554           * 出口参数： 无
    555           * 作　 　者： 无名沈.
    556           * 创建日期： 2015-06-25
    557           * 修    改：
    558           * 修改日期：
    559           * 备    注：
    560           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    561          void USART_WriteBytes(USART_TypeDef* USARTx,unsigned char *buffer,unsigned int len)
    562          {
   \                     USART_WriteBytes: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    563              if ( len ) {
   \   00000008   0xD00E             BEQ.N    ??USART_WriteBytes_0
    564                  while(len--) {
   \                     ??USART_WriteBytes_1: (+1)
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x1E46             SUBS     R6,R0,#+1
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00D             BEQ.N    ??USART_WriteBytes_2
    565                      USART_Send_Char(USARTx,*buffer);
   \   00000012   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       USART_Send_Char
    566                      buffer++;
   \   0000001C   0xE7F5             B.N      ??USART_WriteBytes_1
    567                  }
    568              } else {        
    569                  while(*buffer) {
    570                      USART_Send_Char(USARTx,*buffer);
   \                     ??USART_WriteBytes_3: (+1)
   \   0000001E   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       USART_Send_Char
    571                      buffer++;
    572                  }
   \                     ??USART_WriteBytes_0: (+1)
   \   00000028   0x7828             LDRB     R0,[R5, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1F7             BNE.N    ??USART_WriteBytes_3
    573              }
    574          }
   \                     ??USART_WriteBytes_2: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40004800         DC32     0x40004800
    575          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   BSP_UartCfg
        32   -> BSP_IntEn
        32   -> BSP_IntVectSet
        32   -> GPIO_Init
        32   -> RCC_APB1PeriphClockCmd
        32   -> RCC_APB2PeriphClockCmd
        32   -> USART_ClearFlag
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
       0   USART1_IRQHandler
         0   -> USARTx_RxTxISRHandler
       0   USART2_IRQHandler
         0   -> USARTx_RxTxISRHandler
       0   USART3_IRQHandler
         0   -> USARTx_RxTxISRHandler
       0   USART_Close_INT
         0   -> USART_ITConfig
      16   USART_OPen_INT
        16   -> USART_ClearITPendingBit
         0   -> USART_ITConfig
      16   USART_Send_Char
        16   -> USART_ClearFlag
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
      16   USART_WriteBytes
        16   -> USART_Send_Char
      16   USARTx_RxTxISRHandler
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
         0   -> USART_ITConfig
        16   -> USART_ReceiveData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
     490  BSP_UartCfg
       4  USART1_IRQHandler
       4  USART2_IRQHandler
       4  USART3_IRQHandler
      10  USART_Close_INT
      28  USART_OPen_INT
      34  USART_Send_Char
      48  USART_WriteBytes
      70  USARTx_RxTxISRHandler

 
 712 bytes in section .text
 
 712 bytes of CODE memory

Errors: none
Warnings: none
