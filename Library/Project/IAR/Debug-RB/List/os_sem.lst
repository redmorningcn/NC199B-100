###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:15
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_sem.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_sem.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\os_sem.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\os_sem.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\Micrium\uC-OS-III\Source\os_sem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                 SEMAPHORE MANAGEMENT
     10          *
     11          * File    : OS_SEM.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_sem__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_SEM_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                                  CREATE A SEMAPHORE
     45          *
     46          * Description: This function creates a semaphore.
     47          *
     48          * Arguments  : p_sem         is a pointer to the semaphore to initialize.  Your application is responsible for
     49          *                            allocating storage for the semaphore.
     50          *
     51          *              p_name        is a pointer to the name you would like to give the semaphore.
     52          *
     53          *              cnt           is the initial value for the semaphore.
     54          *                            If used to share resources, you should initialize to the number of resources available.
     55          *                            If used to signal the occurrence of event(s) then you should initialize to 0.
     56          *
     57          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     58          *
     59          *                                OS_ERR_NONE                    if the call was successful
     60          *                                OS_ERR_CREATE_ISR              if you called this function from an ISR
     61          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the semaphore after you
     62          *                                                                 called OSSafetyCriticalStart().
     63          *                                OS_ERR_NAME                    if 'p_name' is a NULL pointer
     64          *                                OS_ERR_OBJ_CREATED             if the semaphore has already been created
     65          *                                OS_ERR_OBJ_PTR_NULL            if 'p_sem'  is a NULL pointer
     66          *                                OS_ERR_OBJ_TYPE                if 'p_sem' has already been initialized to a different
     67          *                                                               object type
     68          *
     69          * Returns    : none
     70          ************************************************************************************************************************
     71          */
     72          
     73          
     74          /***********************************************
     75          * 描述： 传入的参数分别为： OS_SEM结构体地址、
     76          *                           信号量名、
     77          *                           初始信号量计数值、
     78          *                           错误代号。
     79          */

   \                                 In section .text, align 2, keep-with-next
     80          void  OSSemCreate (OS_SEM      *p_sem,
     81                             CPU_CHAR    *p_name,
     82                             OS_SEM_CTR   cnt,
     83                             OS_ERR      *p_err)
     84          {
   \                     OSSemCreate: (+1)
   \   00000000   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0017             MOVS     R7,R2
     85              CPU_SR_ALLOC();
     86          
     87          
     88          
     89          #ifdef OS_SAFETY_CRITICAL
     90              if (p_err == (OS_ERR *)0) {
     91                  OS_SAFETY_CRITICAL_EXCEPTION();
     92                  return;
     93              }
     94          #endif
     95          
     96          #ifdef OS_SAFETY_CRITICAL_IEC61508
     97              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     98                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     99                  return;
    100              }
    101          #endif
    102          
    103          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    104              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \   00000006   0x....             LDR      R0,??DataTable2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ      ??OSSemCreate_0
    105                 *p_err = OS_ERR_CREATE_ISR;
   \   0000000E   0x....             LDR      R0,??DataTable2_1  ;; 0x2ee1
   \   00000010   0xE002             B.N      ??OSSemCreate_1
    106                  return;
    107              }
    108          #endif
    109          
    110          #if OS_CFG_ARG_CHK_EN > 0u
    111              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemCreate_0: (+1)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD102             BNE      ??OSSemCreate_2
    112                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000016   0x....             LDR      R0,??DataTable2_2  ;; 0x5dc3
   \                     ??OSSemCreate_1: (+1)
   \   00000018   0x8018             STRH     R0,[R3, #+0]
    113                  return;
   \   0000001A   0xE02B             B        ??OSSemCreate_3
    114              }
    115          #endif
    116          
    117              OS_CRITICAL_ENTER();
   \                     ??OSSemCreate_2: (+1)
   \   0000001C   0x.... 0x....      BL       CPU_SR_Save
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000026   0x....             LDR      R6,??DataTable2_3
   \   00000028   0x7830             LDRB     R0,[R6, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x7030             STRB     R0,[R6, #+0]
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
    118              p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
   \   00000038   0x....             LDR      R0,??DataTable2_4  ;; 0x414d4553
   \   0000003A   0x6020             STR      R0,[R4, #+0]
    119              p_sem->Ctr     = cnt;                                   /* Set semaphore value                                    */
   \   0000003C   0x6167             STR      R7,[R4, #+20]
    120              p_sem->TS      = (CPU_TS)0;
   \   0000003E   0x2500             MOVS     R5,#+0
   \   00000040   0x61A5             STR      R5,[R4, #+24]
    121              p_sem->NamePtr = p_name;                                /* Save the name of the semaphore                         */
   \   00000042   0x9801             LDR      R0,[SP, #+4]
   \   00000044   0x6060             STR      R0,[R4, #+4]
    122              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \   00000046   0x3408             ADDS     R4,R4,#+8
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       OS_PendListInit
    123          
    124          #if OS_CFG_DBG_EN > 0u
    125              OS_SemDbgListAdd(p_sem);
    126          #endif
    127              OSSemQty++;
   \   0000004E   0x....             LDR      R0,??DataTable3
   \   00000050   0x8801             LDRH     R1,[R0, #+0]
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \   00000054   0x8001             STRH     R1,[R0, #+0]
    128          
    129              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000056   0x.... 0x....      BL       CPU_SR_Save
   \   0000005A   0x0004             MOVS     R4,R0
   \   0000005C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000060   0x7830             LDRB     R0,[R6, #+0]
   \   00000062   0x1E40             SUBS     R0,R0,#+1
   \   00000064   0x7030             STRB     R0,[R6, #+0]
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
    130             *p_err = OS_ERR_NONE;
   \   00000070   0x9802             LDR      R0,[SP, #+8]
   \   00000072   0x8005             STRH     R5,[R0, #+0]
    131          }
   \                     ??OSSemCreate_3: (+1)
   \   00000074   0xB003             ADD      SP,SP,#+12
   \   00000076   0xBDF0             POP      {R4-R7,PC}       ;; return
    132          
    133          /*$PAGE*/
    134          /*
    135          ************************************************************************************************************************
    136          *                                                  DELETE A SEMAPHORE
    137          *
    138          * Description: This function deletes a semaphore.
    139          *
    140          * Arguments  : p_sem         is a pointer to the semaphore to delete
    141          *
    142          *              opt           determines delete options as follows:
    143          *
    144          *                                OS_OPT_DEL_NO_PEND          Delete semaphore ONLY if no task pending
    145          *                                OS_OPT_DEL_ALWAYS           Deletes the semaphore even if tasks are waiting.
    146          *                                                            In this case, all the tasks pending will be readied.
    147          *
    148          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    149          *
    150          *                                OS_ERR_NONE                 The call was successful and the semaphore was deleted
    151          *                                OS_ERR_DEL_ISR              If you attempted to delete the semaphore from an ISR
    152          *                                OS_ERR_OBJ_PTR_NULL         If 'p_sem' is a NULL pointer.
    153          *                                OS_ERR_OBJ_TYPE             If 'p_sem' is not pointing at a semaphore
    154          *                                OS_ERR_OPT_INVALID          An invalid option was specified
    155          *                                OS_ERR_TASK_WAITING         One or more tasks were waiting on the semaphore
    156          *
    157          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    158          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    159          *
    160          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the semaphore
    161          *                 MUST check the return code of OSSemPend().
    162          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted.
    163          *              3) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in applications where
    164          *                 the semaphore is used for mutual exclusion because the resource(s) will no longer be guarded by the
    165          *                 semaphore.
    166          ************************************************************************************************************************
    167          */
    168          
    169          #if OS_CFG_SEM_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    170          OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
    171                                OS_OPT   opt,
    172                                OS_ERR  *p_err)
    173          {
   \                     OSSemDel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0017             MOVS     R7,R2
    174              OS_OBJ_QTY     cnt;
    175              OS_OBJ_QTY     nbr_tasks;
    176              OS_PEND_DATA  *p_pend_data;
    177              OS_PEND_LIST  *p_pend_list;
    178              OS_TCB        *p_tcb;
    179              CPU_TS         ts;
    180              CPU_SR_ALLOC();
    181          
    182          
    183          
    184          #ifdef OS_SAFETY_CRITICAL
    185              if (p_err == (OS_ERR *)0) {
    186                  OS_SAFETY_CRITICAL_EXCEPTION();
    187                  return ((OS_OBJ_QTY)0);
    188              }
    189          #endif
    190          
    191          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    192              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
   \   00000008   0x....             LDR      R0,??DataTable2
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ      ??OSSemDel_0
    193                 *p_err = OS_ERR_DEL_ISR;
   \   00000010   0x....             LDR      R0,??DataTable3_1  ;; 0x32c9
   \   00000012   0xE035             B.N      ??OSSemDel_1
    194                  return ((OS_OBJ_QTY)0);
    195              }
    196          #endif
    197          
    198          #if OS_CFG_ARG_CHK_EN > 0u
    199              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemDel_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD101             BNE      ??OSSemDel_2
    200                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000018   0x....             LDR      R0,??DataTable2_2  ;; 0x5dc3
   \   0000001A   0xE031             B.N      ??OSSemDel_1
    201                  return ((OS_OBJ_QTY)0);
    202              }
    203              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemDel_2: (+1)
   \   0000001C   0x000E             MOVS     R6,R1
   \   0000001E   0x2E01             CMP      R6,#+1
   \   00000020   0xD82B             BHI      ??OSSemDel_3
    204                  case OS_OPT_DEL_NO_PEND:
    205                  case OS_OPT_DEL_ALWAYS:
    206                       break;
    207          
    208                  default:
    209                      *p_err = OS_ERR_OPT_INVALID;
    210                       return ((OS_OBJ_QTY)0);
    211              }
    212          #endif
    213          
    214          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    215              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x....             LDR      R1,??DataTable2_4  ;; 0x414d4553
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD129             BNE      ??OSSemDel_4
    216                 *p_err = OS_ERR_OBJ_TYPE;
    217                  return ((OS_OBJ_QTY)0);
    218              }
    219          #endif
    220          
    221              CPU_CRITICAL_ENTER();
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   \   0000002E   0x0005             MOVS     R5,R0
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x3008             ADDS     R0,R0,#+8
   \   00000038   0x9001             STR      R0,[SP, #+4]
    222              p_pend_list = &p_sem->PendList;
    223              cnt         = p_pend_list->NbrEntries;
   \   0000003A   0x8900             LDRH     R0,[R0, #+8]
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x8008             STRH     R0,[R1, #+0]
    224              nbr_tasks   = cnt;
    225              switch (opt) {
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD002             BEQ      ??OSSemDel_5
   \   00000044   0x2E01             CMP      R6,#+1
   \   00000046   0xD025             BEQ      ??OSSemDel_6
   \   00000048   0xE05F             B        ??OSSemDel_7
    226                  case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
    227                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSSemDel_5: (+1)
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD119             BNE      ??OSSemDel_8
    228          #if OS_CFG_DBG_EN > 0u
    229                           OS_SemDbgListRemove(p_sem);
    230          #endif
    231                           OSSemQty--;
   \   00000052   0x....             LDR      R0,??DataTable3
   \   00000054   0x8801             LDRH     R1,[R0, #+0]
   \   00000056   0x1E49             SUBS     R1,R1,#+1
   \   00000058   0x8001             STRH     R1,[R0, #+0]
    232                           OS_SemClr(p_sem);
   \   0000005A   0x....             LDR      R0,??DataTable3_2  ;; 0x454e4f4e
   \   0000005C   0x6020             STR      R0,[R4, #+0]
   \   0000005E   0x6166             STR      R6,[R4, #+20]
   \   00000060   0x61A6             STR      R6,[R4, #+24]
   \   00000062   0x....             LDR      R0,??DataTable3_3
   \   00000064   0x6060             STR      R0,[R4, #+4]
   \   00000066   0x3408             ADDS     R4,R4,#+8
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       OS_PendListInit
    233                           CPU_CRITICAL_EXIT();
   \   0000006E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000072   0x0028             MOVS     R0,R5
   \   00000074   0x.... 0x....      BL       CPU_SR_Restore
    234                          *p_err = OS_ERR_NONE;
   \   00000078   0xE045             B.N      ??OSSemDel_9
    235                       } else {
   \                     ??OSSemDel_3: (+1)
   \   0000007A   0x....             LDR      R0,??DataTable3_4  ;; 0x5e25
   \   0000007C   0xE000             B.N      ??OSSemDel_1
   \                     ??OSSemDel_4: (+1)
   \   0000007E   0x....             LDR      R0,??DataTable3_5  ;; 0x5dc4
   \                     ??OSSemDel_1: (+1)
   \   00000080   0x8038             STRH     R0,[R7, #+0]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE04A             B        ??OSSemDel_10
    236                           CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_8: (+1)
   \   00000086   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
    237                          *p_err = OS_ERR_TASK_WAITING;
   \   00000090   0x....             LDR      R0,??DataTable3_6  ;; 0x715f
   \   00000092   0xE040             B        ??OSSemDel_11
    238                       }
   \                     ??OSSemDel_6: (+1)
   \   00000094   0x....             LDR      R0,??DataTable2_3
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x1C40             ADDS     R0,R0,#+1
   \   0000009A   0x....             LDR      R1,??DataTable2_3
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
    239                       break;
    240          
    241                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
    242                       OS_CRITICAL_ENTER_CPU_EXIT();
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
    243                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
   \   000000A8   0x4668             MOV      R0,SP
   \   000000AA   0x8800             LDRH     R0,[R0, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD00A             BEQ      ??OSSemDel_12
   \   000000B0   0x4668             MOV      R0,SP
   \   000000B2   0x8805             LDRH     R5,[R0, #+0]
    244                       while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
    245                           p_pend_data = p_pend_list->HeadPtr;
    246                           p_tcb       = p_pend_data->TCBPtr;
    247                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
    248                                         p_tcb,
    249                                         ts);
   \                     ??OSSemDel_13: (+1)
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x9801             LDR      R0,[SP, #+4]
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x6881             LDR      R1,[R0, #+8]
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       OS_PendObjDel
    250                           cnt--;
   \   000000C2   0x1E6D             SUBS     R5,R5,#+1
    251                       }
   \   000000C4   0xD1F6             BNE      ??OSSemDel_13
    252          #if OS_CFG_DBG_EN > 0u
    253                       OS_SemDbgListRemove(p_sem);
    254          #endif
    255                       OSSemQty--;
   \                     ??OSSemDel_12: (+1)
   \   000000C6   0x....             LDR      R0,??DataTable3
   \   000000C8   0x8801             LDRH     R1,[R0, #+0]
   \   000000CA   0x1E49             SUBS     R1,R1,#+1
   \   000000CC   0x8001             STRH     R1,[R0, #+0]
    256                       OS_SemClr(p_sem);
   \   000000CE   0x....             LDR      R0,??DataTable3_2  ;; 0x454e4f4e
   \   000000D0   0x6020             STR      R0,[R4, #+0]
   \   000000D2   0x2600             MOVS     R6,#+0
   \   000000D4   0x6166             STR      R6,[R4, #+20]
   \   000000D6   0x61A6             STR      R6,[R4, #+24]
   \   000000D8   0x....             LDR      R0,??DataTable3_3
   \   000000DA   0x6060             STR      R0,[R4, #+4]
   \   000000DC   0x3408             ADDS     R4,R4,#+8
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       OS_PendListInit
    257                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000E4   0x.... 0x....      BL       CPU_SR_Save
   \   000000E8   0x0005             MOVS     R5,R0
   \   000000EA   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000EE   0x....             LDR      R0,??DataTable2_3
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x1E40             SUBS     R0,R0,#+1
   \   000000F4   0x....             LDR      R1,??DataTable2_3
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x0028             MOVS     R0,R5
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
    258                       OSSched();                                     /* Find highest priority task ready to run                */
   \   00000102   0x.... 0x....      BL       OSSched
    259                      *p_err = OS_ERR_NONE;
   \                     ??OSSemDel_9: (+1)
   \   00000106   0x803E             STRH     R6,[R7, #+0]
    260                       break;
   \   00000108   0xE006             B        ??OSSemDel_14
    261          
    262                  default:
    263                       CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_7: (+1)
   \   0000010A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010E   0x0028             MOVS     R0,R5
   \   00000110   0x.... 0x....      BL       CPU_SR_Restore
    264                      *p_err = OS_ERR_OPT_INVALID;
   \   00000114   0x....             LDR      R0,??DataTable3_4  ;; 0x5e25
   \                     ??OSSemDel_11: (+1)
   \   00000116   0x8038             STRH     R0,[R7, #+0]
    265                       break;
    266              }
    267              return ((OS_OBJ_QTY)nbr_tasks);
   \                     ??OSSemDel_14: (+1)
   \   00000118   0x4668             MOV      R0,SP
   \   0000011A   0x8800             LDRH     R0,[R0, #+0]
   \                     ??OSSemDel_10: (+1)
   \   0000011C   0xB003             ADD      SP,SP,#+12
   \   0000011E   0xBDF0             POP      {R4-R7,PC}       ;; return
    268          }
    269          #endif
    270          
    271          /*$PAGE*/
    272          /*
    273          ************************************************************************************************************************
    274          *                                                  PEND ON SEMAPHORE
    275          *
    276          * Description: This function waits for a semaphore.
    277          *
    278          * Arguments  : p_sem         is a pointer to the semaphore
    279          *
    280          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    281          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    282          *                            0, however, your task will wait forever at the specified semaphore or, until the resource
    283          *                            becomes available (or the event occurs).
    284          *
    285          *              opt           determines whether the user wants to block if the semaphore is not available or not:
    286          *
    287          *                                OS_OPT_PEND_BLOCKING
    288          *                                OS_OPT_PEND_NON_BLOCKING
    289          *
    290          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
    291          *                            or pend aborted or the semaphore deleted.  If you pass a NULL pointer (i.e. (CPU_TS*)0)
    292          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid
    293          *                            and indicates that you don't need the timestamp.
    294          *
    295          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    296          *
    297          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    298          *                                                          or, the event you are waiting for occurred.
    299          *                                OS_ERR_OBJ_DEL            If 'p_sem' was deleted
    300          *                                OS_ERR_OBJ_PTR_NULL       If 'p_sem' is a NULL pointer.
    301          *                                OS_ERR_OBJ_TYPE           If 'p_sem' is not pointing at a semaphore
    302          *                                OS_ERR_OPT_INVALID        If you specified an invalid value for 'opt'
    303          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    304          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    305          *                                                          would lead to a suspension.
    306          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the semaphore was not
    307          *                                                          available.
    308          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    309          *                                OS_ERR_STATUS_INVALID     Pend status is invalid
    310          *                                OS_ERR_TIMEOUT            The semaphore was not received within the specified
    311          *                                                          timeout.
    312          *
    313          *
    314          * Returns    : The current value of the semaphore counter or 0 if not available.
    315          ************************************************************************************************************************
    316          */
    317          
    318          
    319          /***********************************************
    320          * 描述： 传入的参数分别为 OS_SEM结构体地址、
    321          *                   等待期满值、
    322          *                   信号量失效模式、
    323          *                   时间戳、
    324          *                   错误代号
    325          */

   \                                 In section .text, align 2, keep-with-next
    326          OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
    327                                 OS_TICK   timeout,
    328                                 OS_OPT    opt,
    329                                 CPU_TS   *p_ts,
    330                                 OS_ERR   *p_err)
    331          {
   \                     OSSemPend: (+1)
   \   00000000   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x001F             MOVS     R7,R3
   \   00000008   0x9D10             LDR      R5,[SP, #+64]
    332              OS_SEM_CTR    ctr;
    333              OS_PEND_DATA  pend_data;
    334              CPU_SR_ALLOC();
    335          
    336          
    337          
    338          #ifdef OS_SAFETY_CRITICAL
    339              if (p_err == (OS_ERR *)0) {
    340                  OS_SAFETY_CRITICAL_EXCEPTION();
    341                  return ((OS_SEM_CTR)0);
    342              }
    343          #endif
    344          
    345          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    346              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   0000000A   0x....             LDR      R0,??DataTable4
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ      ??OSSemPend_0
    347                 *p_err = OS_ERR_PEND_ISR;
   \   00000012   0x....             LDR      R0,??DataTable4_1  ;; 0x61ae
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    348                  return ((OS_SEM_CTR)0);
   \   00000016   0xE09F             B.N      ??OSSemPend_1
    349              }
    350          #endif
    351          
    352          #if OS_CFG_ARG_CHK_EN > 0u
    353              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemPend_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD102             BNE      ??OSSemPend_2
    354                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001C   0x....             LDR      R0,??DataTable4_2  ;; 0x5dc3
   \   0000001E   0x8028             STRH     R0,[R5, #+0]
    355                  return ((OS_SEM_CTR)0);
   \   00000020   0xE09A             B.N      ??OSSemPend_1
    356              }
    357              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPend_2: (+1)
   \   00000022   0x0010             MOVS     R0,R2
   \   00000024   0xD003             BEQ      ??OSSemPend_3
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   0000002A   0x428A             CMP      R2,R1
   \   0000002C   0xD11E             BNE      ??OSSemPend_4
    358                  case OS_OPT_PEND_BLOCKING:
    359                  case OS_OPT_PEND_NON_BLOCKING:
    360                       break;
    361          
    362                  default:
    363                      *p_err = OS_ERR_OPT_INVALID;
    364                       return ((OS_SEM_CTR)0);
    365              }
    366          #endif
    367          
    368          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    369              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPend_3: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x....             LDR      R1,??DataTable5  ;; 0x414d4553
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD11D             BNE      ??OSSemPend_5
    370                 *p_err = OS_ERR_OBJ_TYPE;
    371                  return ((OS_SEM_CTR)0);
    372              }
    373          #endif
    374          
    375              if (p_ts != (CPU_TS *)0) {
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD001             BEQ      ??OSSemPend_6
    376                 *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6038             STR      R0,[R7, #+0]
    377              }
    378              CPU_CRITICAL_ENTER();
   \                     ??OSSemPend_6: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0006             MOVS     R6,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
    379              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
   \   00000048   0x6960             LDR      R0,[R4, #+20]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD014             BEQ      ??OSSemPend_7
    380                  p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x6160             STR      R0,[R4, #+20]
    381                  if (p_ts != (CPU_TS *)0) {
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD001             BEQ      ??OSSemPend_8
    382                     *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
   \   00000056   0x69A0             LDR      R0,[R4, #+24]
   \   00000058   0x6038             STR      R0,[R7, #+0]
    383                  }
    384                  ctr   = p_sem->Ctr;
   \                     ??OSSemPend_8: (+1)
   \   0000005A   0x6964             LDR      R4,[R4, #+20]
    385                  CPU_CRITICAL_EXIT();
   \   0000005C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0x.... 0x....      BL       CPU_SR_Restore
    386                 *p_err = OS_ERR_NONE;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x8028             STRH     R0,[R5, #+0]
    387                  return (ctr);
   \   0000006A   0xE059             B        ??OSSemPend_9
    388              }
   \                     ??OSSemPend_4: (+1)
   \   0000006C   0x....             LDR      R0,??DataTable3_4  ;; 0x5e25
   \   0000006E   0x8028             STRH     R0,[R5, #+0]
   \   00000070   0xE072             B.N      ??OSSemPend_1
   \                     ??OSSemPend_5: (+1)
   \   00000072   0x....             LDR      R0,??DataTable3_5  ;; 0x5dc4
   \   00000074   0x8028             STRH     R0,[R5, #+0]
   \   00000076   0xE06F             B.N      ??OSSemPend_1
    389          
    390              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSSemPend_7: (+1)
   \   00000078   0x4668             MOV      R0,SP
   \   0000007A   0x8D00             LDRH     R0,[R0, #+40]
   \   0000007C   0x0400             LSLS     R0,R0,#+16
   \   0000007E   0xD507             BPL      ??OSSemPend_10
    391                  ctr   = p_sem->Ctr;                                 /* No                                                     */
    392                  CPU_CRITICAL_EXIT();
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x0030             MOVS     R0,R6
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    393                 *p_err = OS_ERR_PEND_WOULD_BLOCK;
   \   0000008A   0x....             LDR      R0,??DataTable5_1  ;; 0x61b0
   \   0000008C   0x8028             STRH     R0,[R5, #+0]
    394                  return (ctr);
   \   0000008E   0xE063             B.N      ??OSSemPend_1
    395              } else {                                                /* Yes                                                    */
   \                     ??OSSemPend_10: (+1)
   \   00000090   0x....             LDR      R0,??DataTable5_2
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD007             BEQ      ??OSSemPend_11
    396                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
    397                      CPU_CRITICAL_EXIT();
   \   00000098   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009C   0x0030             MOVS     R0,R6
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
    398                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000A2   0x....             LDR      R0,??DataTable6  ;; 0x6d63
   \   000000A4   0x8028             STRH     R0,[R5, #+0]
    399                      return ((OS_SEM_CTR)0);
   \   000000A6   0xE057             B.N      ??OSSemPend_1
    400                  }
    401              }
    402                                                                      /* Lock the scheduler/re-enable interrupts                */
    403              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPend_11: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x....             LDR      R1,??DataTable5_2
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
    404              OS_Pend(&pend_data,                                     /* Block task pending on Semaphore                        */
    405                      (OS_PEND_OBJ *)((void *)p_sem),
    406                      OS_TASK_PEND_ON_SEM,
    407                      timeout);
   \   000000B8   0x9B09             LDR      R3,[SP, #+36]
   \   000000BA   0x2206             MOVS     R2,#+6
   \   000000BC   0x0021             MOVS     R1,R4
   \   000000BE   0x4668             MOV      R0,SP
   \   000000C0   0x.... 0x....      BL       OS_Pend
    408          
    409              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000C4   0x.... 0x....      BL       CPU_SR_Save
   \   000000C8   0x0006             MOVS     R6,R0
   \   000000CA   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000CE   0x....             LDR      R0,??DataTable5_2
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   \   000000D4   0x....             LDR      R1,??DataTable5_2
   \   000000D6   0x7008             STRB     R0,[R1, #+0]
   \   000000D8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0x.... 0x....      BL       CPU_SR_Restore
    410          
    411              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   000000E2   0x.... 0x....      BL       OSSched
    412          
    413              CPU_CRITICAL_ENTER();
   \   000000E6   0x.... 0x....      BL       CPU_SR_Save
   \   000000EA   0x0006             MOVS     R6,R0
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStart
    414              switch (OSTCBCurPtr->PendStatus) {
   \   000000F0   0x....             LDR      R0,??DataTable8
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x2135             MOVS     R1,#+53
   \   000000F6   0x5C41             LDRB     R1,[R0, R1]
   \   000000F8   0x2900             CMP      R1,#+0
   \   000000FA   0xD005             BEQ      ??OSSemPend_12
   \   000000FC   0x2902             CMP      R1,#+2
   \   000000FE   0xD01E             BEQ      ??OSSemPend_13
   \   00000100   0xD311             BCC      ??OSSemPend_14
   \   00000102   0x2903             CMP      R1,#+3
   \   00000104   0xD015             BEQ      ??OSSemPend_15
   \   00000106   0xE020             B        ??OSSemPend_16
    415                  case OS_STATUS_PEND_OK:                             /* We got the semaphore                                   */
    416                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_12: (+1)
   \   00000108   0x2F00             CMP      R7,#+0
   \   0000010A   0xD001             BEQ      ??OSSemPend_17
    417                          *p_ts  =  OSTCBCurPtr->TS;
   \   0000010C   0x6C00             LDR      R0,[R0, #+64]
   \   0000010E   0x6038             STR      R0,[R7, #+0]
    418                       }
    419                      *p_err = OS_ERR_NONE;
   \                     ??OSSemPend_17: (+1)
   \   00000110   0x2000             MOVS     R0,#+0
    420                       break;
   \                     ??OSSemPend_18: (+1)
   \   00000112   0x8028             STRH     R0,[R5, #+0]
    421          
    422                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    423                       if (p_ts != (CPU_TS *)0) {
    424                          *p_ts  =  OSTCBCurPtr->TS;
    425                       }
    426                      *p_err = OS_ERR_PEND_ABORT;
    427                       break;
    428          
    429                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
    430                       if (p_ts != (CPU_TS *)0) {
    431                          *p_ts  = (CPU_TS  )0;
    432                       }
    433                      *p_err = OS_ERR_TIMEOUT;
    434                       break;
    435          
    436                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    437                       if (p_ts != (CPU_TS *)0) {
    438                          *p_ts  =  OSTCBCurPtr->TS;
    439                       }
    440                      *p_err = OS_ERR_OBJ_DEL;
    441                       break;
    442          
    443                  default:
    444                      *p_err = OS_ERR_STATUS_INVALID;
    445                       CPU_CRITICAL_EXIT();
    446                       return ((OS_SEM_CTR)0);
    447              }
    448              ctr = p_sem->Ctr;
   \   00000114   0x6964             LDR      R4,[R4, #+20]
    449              CPU_CRITICAL_EXIT();
   \   00000116   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011A   0x0030             MOVS     R0,R6
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
    450              return (ctr);
   \                     ??OSSemPend_9: (+1)
   \   00000120   0x0020             MOVS     R0,R4
   \                     ??OSSemPend_19: (+1)
   \   00000122   0xB00B             ADD      SP,SP,#+44
   \   00000124   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??OSSemPend_14: (+1)
   \   00000126   0x2F00             CMP      R7,#+0
   \   00000128   0xD001             BEQ      ??OSSemPend_20
   \   0000012A   0x6C00             LDR      R0,[R0, #+64]
   \   0000012C   0x6038             STR      R0,[R7, #+0]
   \                     ??OSSemPend_20: (+1)
   \   0000012E   0x....             LDR      R0,??DataTable8_1  ;; 0x61a9
   \   00000130   0xE7EF             B        ??OSSemPend_18
   \                     ??OSSemPend_15: (+1)
   \   00000132   0x2F00             CMP      R7,#+0
   \   00000134   0xD001             BEQ      ??OSSemPend_21
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x6038             STR      R0,[R7, #+0]
   \                     ??OSSemPend_21: (+1)
   \   0000013A   0x....             LDR      R0,??DataTable8_2  ;; 0x72d9
   \   0000013C   0xE7E9             B        ??OSSemPend_18
   \                     ??OSSemPend_13: (+1)
   \   0000013E   0x2F00             CMP      R7,#+0
   \   00000140   0xD001             BEQ      ??OSSemPend_22
   \   00000142   0x6C00             LDR      R0,[R0, #+64]
   \   00000144   0x6038             STR      R0,[R7, #+0]
   \                     ??OSSemPend_22: (+1)
   \   00000146   0x....             LDR      R0,??DataTable8_3  ;; 0x5dc2
   \   00000148   0xE7E3             B        ??OSSemPend_18
   \                     ??OSSemPend_16: (+1)
   \   0000014A   0x....             LDR      R0,??DataTable9  ;; 0x6e2e
   \   0000014C   0x8028             STRH     R0,[R5, #+0]
   \   0000014E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000152   0x0030             MOVS     R0,R6
   \   00000154   0x.... 0x....      BL       CPU_SR_Restore
   \                     ??OSSemPend_1: (+1)
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0xE7E2             B        ??OSSemPend_19
    451          }
    452          
    453          /*$PAGE*/
    454          /*
    455          ************************************************************************************************************************
    456          *                                             ABORT WAITING ON A SEMAPHORE
    457          *
    458          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function should be used
    459          *              to fault-abort the wait on the semaphore, rather than to normally signal the semaphore via OSSemPost().
    460          *
    461          * Arguments  : p_sem     is a pointer to the semaphore
    462          *
    463          *              opt       determines the type of ABORT performed:
    464          *
    465          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the semaphore
    466          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the semaphore
    467          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    468          *
    469          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    470          *
    471          *                            OS_ERR_NONE                  At least one task waiting on the semaphore was readied and
    472          *                                                         informed of the aborted wait; check return value for the
    473          *                                                         number of tasks whose wait on the semaphore was aborted.
    474          *                            OS_ERR_OBJ_PTR_NULL          If 'p_sem' is a NULL pointer.
    475          *                            OS_ERR_OBJ_TYPE              If 'p_sem' is not pointing at a semaphore
    476          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    477          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    478          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    479          *
    480          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    481          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    482          ************************************************************************************************************************
    483          */
    484          
    485          #if OS_CFG_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    486          OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
    487                                      OS_OPT   opt,
    488                                      OS_ERR  *p_err)
    489          {
   \                     OSSemPendAbort: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
    490              OS_PEND_LIST  *p_pend_list;
    491              OS_TCB        *p_tcb;
    492              CPU_TS         ts;
    493              OS_OBJ_QTY     nbr_tasks;
    494              CPU_SR_ALLOC();
    495          
    496          
    497          
    498          #ifdef OS_SAFETY_CRITICAL
    499              if (p_err == (OS_ERR *)0) {
    500                  OS_SAFETY_CRITICAL_EXCEPTION();
    501                  return ((OS_OBJ_QTY)0u);
    502              }
    503          #endif
    504          
    505          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    506              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ      ??OSSemPendAbort_0
    507                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000010   0x....             LDR      R0,??DataTable9_1  ;; 0x61aa
   \   00000012   0xE02B             B.N      ??OSSemPendAbort_1
    508                  return ((OS_OBJ_QTY)0u);
    509              }
    510          #endif
    511          
    512          #if OS_CFG_ARG_CHK_EN > 0u
    513              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemPendAbort_0: (+1)
   \   00000014   0x9802             LDR      R0,[SP, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE      ??OSSemPendAbort_2
    514                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   0000001A   0x....             LDR      R0,??DataTable4_2  ;; 0x5dc3
   \   0000001C   0xE026             B.N      ??OSSemPendAbort_1
    515                  return ((OS_OBJ_QTY)0u);
    516              }
    517              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPendAbort_2: (+1)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xD00A             BEQ      ??OSSemPendAbort_3
   \   00000022   0x2180             MOVS     R1,#+128
   \   00000024   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000026   0x428D             CMP      R5,R1
   \   00000028   0xD006             BEQ      ??OSSemPendAbort_3
   \   0000002A   0x01C9             LSLS     R1,R1,#+7
   \   0000002C   0x428D             CMP      R5,R1
   \   0000002E   0xD003             BEQ      ??OSSemPendAbort_3
   \   00000030   0x2181             MOVS     R1,#+129
   \   00000032   0x0209             LSLS     R1,R1,#+8        ;; #+33024
   \   00000034   0x428D             CMP      R5,R1
   \   00000036   0xD116             BNE      ??OSSemPendAbort_4
    518                  case OS_OPT_PEND_ABORT_1:
    519                  case OS_OPT_PEND_ABORT_ALL:
    520                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    521                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    522                       break;
    523          
    524                  default:
    525                      *p_err =  OS_ERR_OPT_INVALID;
    526                       return ((OS_OBJ_QTY)0u);
    527              }
    528          #endif
    529          
    530          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    531              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPendAbort_3: (+1)
   \   00000038   0x9802             LDR      R0,[SP, #+8]
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x....             LDR      R1,??DataTable5  ;; 0x414d4553
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD113             BNE      ??OSSemPendAbort_5
    532                 *p_err =  OS_ERR_OBJ_TYPE;
    533                  return ((OS_OBJ_QTY)0u);
    534              }
    535          #endif
    536          
    537              CPU_CRITICAL_ENTER();
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0006             MOVS     R6,R0
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStart
    538              p_pend_list = &p_sem->PendList;
   \   0000004C   0x9802             LDR      R0,[SP, #+8]
   \   0000004E   0x3008             ADDS     R0,R0,#+8
   \   00000050   0x9000             STR      R0,[SP, #+0]
    539              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
   \   00000052   0x8900             LDRH     R0,[R0, #+8]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD10C             BNE      ??OSSemPendAbort_6
    540                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   00000058   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0x.... 0x....      BL       CPU_SR_Restore
    541                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000062   0x....             LDR      R0,??DataTable9_2  ;; 0x61ab
   \   00000064   0xE002             B.N      ??OSSemPendAbort_1
    542                  return ((OS_OBJ_QTY)0u);
    543              }
   \                     ??OSSemPendAbort_4: (+1)
   \   00000066   0x....             LDR      R0,??DataTable5_3  ;; 0x5e25
   \   00000068   0xE000             B.N      ??OSSemPendAbort_1
   \                     ??OSSemPendAbort_5: (+1)
   \   0000006A   0x....             LDR      R0,??DataTable9_3  ;; 0x5dc4
   \                     ??OSSemPendAbort_1: (+1)
   \   0000006C   0x8038             STRH     R0,[R7, #+0]
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE031             B        ??OSSemPendAbort_7
   \                     ??OSSemPendAbort_6: (+1)
   \   00000072   0x....             LDR      R0,??DataTable5_2
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0x....             LDR      R1,??DataTable5_2
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    544          
    545              OS_CRITICAL_ENTER_CPU_EXIT();
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0x.... 0x....      BL       CPU_SR_Restore
   \   00000086   0x2400             MOVS     R4,#+0
   \   00000088   0x2680             MOVS     R6,#+128
   \   0000008A   0x0076             LSLS     R6,R6,#+1        ;; #+256
    546              nbr_tasks = 0u;
    547              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
    548              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSSemPendAbort_8: (+1)
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x8900             LDRH     R0,[R0, #+8]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD009             BEQ      ??OSSemPendAbort_9
    549                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
    550                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
    551                               p_tcb,
    552                               ts);
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0x9800             LDR      R0,[SP, #+0]
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x6881             LDR      R1,[R0, #+8]
   \   0000009C   0x9802             LDR      R0,[SP, #+8]
   \   0000009E   0x.... 0x....      BL       OS_PendAbort
    553                  nbr_tasks++;
   \   000000A2   0x1C64             ADDS     R4,R4,#+1
    554                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000A4   0x42B5             CMP      R5,R6
   \   000000A6   0xD0F1             BEQ      ??OSSemPendAbort_8
    555                      break;                                          /* No                                                     */
    556                  }
    557              }
    558              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSSemPendAbort_9: (+1)
   \   000000A8   0x.... 0x....      BL       CPU_SR_Save
   \   000000AC   0x0006             MOVS     R6,R0
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000B2   0x....             LDR      R0,??DataTable5_2
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x1E40             SUBS     R0,R0,#+1
   \   000000B8   0x....             LDR      R1,??DataTable5_2
   \   000000BA   0x7008             STRB     R0,[R1, #+0]
   \   000000BC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    559          
    560              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   000000C6   0x0428             LSLS     R0,R5,#+16
   \   000000C8   0xD401             BMI      ??OSSemPendAbort_10
    561                  OSSched();                                          /* Run the scheduler                                      */
   \   000000CA   0x.... 0x....      BL       OSSched
    562              }
    563          
    564             *p_err = OS_ERR_NONE;
   \                     ??OSSemPendAbort_10: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x8038             STRH     R0,[R7, #+0]
    565              return (nbr_tasks);
   \   000000D2   0x0420             LSLS     R0,R4,#+16
   \   000000D4   0x0C00             LSRS     R0,R0,#+16
   \                     ??OSSemPendAbort_7: (+1)
   \   000000D6   0xB003             ADD      SP,SP,#+12
   \   000000D8   0xBDF0             POP      {R4-R7,PC}       ;; return
    566          }
    567          #endif
    568          
    569          /*$PAGE*/
    570          /*
    571          ************************************************************************************************************************
    572          *                                                 POST TO A SEMAPHORE
    573          *
    574          * Description: This function signals a semaphore
    575          *
    576          * Arguments  : p_sem    is a pointer to the semaphore
    577          *
    578          *              opt      determines the type of POST performed:
    579          *
    580          *                           OS_OPT_POST_1            POST and ready only the highest priority task waiting on semaphore
    581          *                                                    (if tasks are waiting).
    582          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    583          *
    584          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    585          *
    586          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    587          *
    588          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    589          *
    590          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    591          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    592          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    593          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    594          *
    595          * Returns    : The current value of the semaphore counter or 0 upon error.
    596          ************************************************************************************************************************
    597          */
    598          

   \                                 In section .text, align 2, keep-with-next
    599          OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
    600                                 OS_OPT   opt,
    601                                 OS_ERR  *p_err)
    602          {
   \                     OSSemPost: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    603              OS_SEM_CTR  ctr;
    604              CPU_TS      ts;
    605          
    606          
    607          
    608          #ifdef OS_SAFETY_CRITICAL
    609              if (p_err == (OS_ERR *)0) {
    610                  OS_SAFETY_CRITICAL_EXCEPTION();
    611                  return ((OS_SEM_CTR)0);
    612              }
    613          #endif
    614          
    615          #if OS_CFG_ARG_CHK_EN > 0u
    616              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE      ??OSSemPost_0
    617                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000008   0x....             LDR      R0,??DataTable9_4  ;; 0x5dc3
   \   0000000A   0xE022             B.N      ??OSSemPost_1
    618                  return ((OS_SEM_CTR)0);
    619              }
    620              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPost_0: (+1)
   \   0000000C   0x000B             MOVS     R3,R1
   \   0000000E   0xD00A             BEQ      ??OSSemPost_2
   \   00000010   0x2480             MOVS     R4,#+128
   \   00000012   0x00A4             LSLS     R4,R4,#+2        ;; #+512
   \   00000014   0x42A1             CMP      R1,R4
   \   00000016   0xD006             BEQ      ??OSSemPost_2
   \   00000018   0x01A4             LSLS     R4,R4,#+6
   \   0000001A   0x42A1             CMP      R1,R4
   \   0000001C   0xD003             BEQ      ??OSSemPost_2
   \   0000001E   0x2482             MOVS     R4,#+130
   \   00000020   0x0224             LSLS     R4,R4,#+8        ;; #+33280
   \   00000022   0x42A1             CMP      R1,R4
   \   00000024   0xD112             BNE      ??OSSemPost_3
    621                  case OS_OPT_POST_1:
    622                  case OS_OPT_POST_ALL:
    623                  case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
    624                  case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    625                       break;
    626          
    627                  default:
    628                      *p_err =  OS_ERR_OPT_INVALID;
    629                       return ((OS_SEM_CTR)0u);
    630              }
    631          #endif
    632          
    633          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    634              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPost_2: (+1)
   \   00000026   0x....             LDR      R4,??DataTable5  ;; 0x414d4553
   \   00000028   0x6803             LDR      R3,[R0, #+0]
   \   0000002A   0x42A3             CMP      R3,R4
   \   0000002C   0xD110             BNE      ??OSSemPost_4
    635                 *p_err = OS_ERR_OBJ_TYPE;
    636                  return ((OS_SEM_CTR)0);
    637              }
    638          #endif
    639          
    640              ts = OS_TS_GET();                                       /* Get timestamp                                          */
    641          
    642          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    643              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \   0000002E   0x....             LDR      R3,??DataTable9_5
   \   00000030   0x781B             LDRB     R3,[R3, #+0]
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD010             BEQ      ??OSSemPost_5
    644                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_SEM,           /* Post to ISR queue                                      */
    645                              (void      *)p_sem,
    646                              (void      *)0,
    647                              (OS_MSG_SIZE)0,
    648                              (OS_FLAGS   )0,
    649                              (OS_OPT     )opt,
    650                              (CPU_TS     )ts,
    651                              (OS_ERR    *)p_err);
   \   00000036   0x9203             STR      R2,[SP, #+12]
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x9202             STR      R2,[SP, #+8]
   \   0000003C   0x9101             STR      R1,[SP, #+4]
   \   0000003E   0x9200             STR      R2,[SP, #+0]
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       OS_IntQPost
    652                  return ((OS_SEM_CTR)0);
   \   0000004A   0xE003             B.N      ??OSSemPost_6
    653              }
   \                     ??OSSemPost_3: (+1)
   \   0000004C   0x....             LDR      R0,??DataTable5_3  ;; 0x5e25
   \   0000004E   0xE000             B.N      ??OSSemPost_1
   \                     ??OSSemPost_4: (+1)
   \   00000050   0x....             LDR      R0,??DataTable9_3  ;; 0x5dc4
   \                     ??OSSemPost_1: (+1)
   \   00000052   0x8010             STRH     R0,[R2, #+0]
   \                     ??OSSemPost_6: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE003             B        ??OSSemPost_7
    654          #endif
    655          
    656              ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
    657                               opt,
    658                               ts,
    659                               p_err);
    660          
    661              return (ctr);
   \                     ??OSSemPost_5: (+1)
   \   00000058   0x0013             MOVS     R3,R2
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x.... 0x....      BL       OS_SemPost
   \                     ??OSSemPost_7: (+1)
   \   00000060   0xB004             ADD      SP,SP,#+16
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    662          }
    663          
    664          /*$PAGE*/
    665          /*
    666          ************************************************************************************************************************
    667          *                                                    SET SEMAPHORE
    668          *
    669          * Description: This function sets the semaphore count to the value specified as an argument.  Typically, this value
    670          *              would be 0 but of course, we can set the semaphore to any value.
    671          *
    672          *              You would typically use this function when a semaphore is used as a signaling mechanism
    673          *              and, you want to reset the count value.
    674          *
    675          * Arguments  : p_sem     is a pointer to the semaphore
    676          *
    677          *              cnt       is the new value for the semaphore count.  You would pass 0 to reset the semaphore count.
    678          *
    679          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    680          *
    681          *                            OS_ERR_NONE           The call was successful and the semaphore value was set.
    682          *                            OS_ERR_OBJ_PTR_NULL   If 'p_sem' is a NULL pointer.
    683          *                            OS_ERR_OBJ_TYPE       If 'p_sem' is not pointing to a semaphore.
    684          *                            OS_ERR_TASK_WAITING   If tasks are waiting on the semaphore.
    685          *
    686          * Returns    : None
    687          ************************************************************************************************************************
    688          */
    689          
    690          #if OS_CFG_SEM_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    691          void  OSSemSet (OS_SEM      *p_sem,
    692                          OS_SEM_CTR   cnt,
    693                          OS_ERR      *p_err)
    694          {
   \                     OSSemSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    695              OS_PEND_LIST  *p_pend_list;
    696              CPU_SR_ALLOC();
    697          
    698          
    699          
    700          #ifdef OS_SAFETY_CRITICAL
    701              if (p_err == (OS_ERR *)0) {
    702                  OS_SAFETY_CRITICAL_EXCEPTION();
    703                  return;
    704              }
    705          #endif
    706          
    707          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    708              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \   00000008   0x....             LDR      R0,??DataTable9_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ      ??OSSemSet_0
    709                 *p_err = OS_ERR_SET_ISR;
   \   00000010   0x....             LDR      R0,??DataTable9_6  ;; 0x6dc6
   \   00000012   0xE008             B.N      ??OSSemSet_1
    710                  return;
    711              }
    712          #endif
    713          
    714          #if OS_CFG_ARG_CHK_EN > 0u
    715              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemSet_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD101             BNE      ??OSSemSet_2
    716                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000018   0x....             LDR      R0,??DataTable9_4  ;; 0x5dc3
   \   0000001A   0xE004             B.N      ??OSSemSet_1
    717                  return;
    718              }
    719          #endif
    720          
    721          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    722              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemSet_2: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x....             LDR      R1,??DataTable9_7  ;; 0x414d4553
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD002             BEQ      ??OSSemSet_3
    723                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000024   0x....             LDR      R0,??DataTable9_3  ;; 0x5dc4
   \                     ??OSSemSet_1: (+1)
   \   00000026   0x8030             STRH     R0,[R6, #+0]
    724                  return;
   \   00000028   0xBDF1             POP      {R0,R4-R7,PC}
    725              }
    726          #endif
    727          
    728             *p_err = OS_ERR_NONE;
   \                     ??OSSemSet_3: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
    729              CPU_CRITICAL_ENTER();
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x0007             MOVS     R7,R0
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStart
    730              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
   \   00000038   0x6960             LDR      R0,[R4, #+20]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD102             BNE      ??OSSemSet_4
    731                  p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
    732              } else {
    733                  p_pend_list = &p_sem->PendList;                     /* No                                                     */
    734                  if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
   \   0000003E   0x8A20             LDRH     R0,[R4, #+16]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD101             BNE      ??OSSemSet_5
    735                      p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
   \                     ??OSSemSet_4: (+1)
   \   00000044   0x6165             STR      R5,[R4, #+20]
   \   00000046   0xE001             B        ??OSSemSet_6
    736                  } else {
    737                     *p_err      = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_5: (+1)
   \   00000048   0x....             LDR      R0,??DataTable9_8  ;; 0x715f
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
    738                  }
    739              }
    740              CPU_CRITICAL_EXIT();
   \                     ??OSSemSet_6: (+1)
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x0038             MOVS     R0,R7
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    741          }
   \   00000056   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    742          #endif
    743          
    744          /*$PAGE*/
    745          /*
    746          ************************************************************************************************************************
    747          *                                           CLEAR THE CONTENTS OF A SEMAPHORE
    748          *
    749          * Description: This function is called by OSSemDel() to clear the contents of a semaphore
    750          *
    751          
    752          * Argument(s): p_sem      is a pointer to the semaphore to clear
    753          *              -----
    754          *
    755          * Returns    : none
    756          *
    757          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    758          ************************************************************************************************************************
    759          */
    760          

   \                                 In section .text, align 4, keep-with-next
    761          void  OS_SemClr (OS_SEM  *p_sem)
    762          {
   \                     OS_SemClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    763              p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
   \   00000002   0x....             LDR      R1,??DataTable9_9  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
    764              p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6141             STR      R1,[R0, #+20]
    765              p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
   \   0000000A   0x6181             STR      R1,[R0, #+24]
    766              p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
   \   0000000C   0x....             ADR.N    R1,?_0
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    767              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \   00000010   0x3008             ADDS     R0,R0,#+8
   \   00000012   0x.... 0x....      BL       OS_PendListInit
    768          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    769          
    770          /*$PAGE*/
    771          /*
    772          ************************************************************************************************************************
    773          *                                        ADD/REMOVE SEMAPHORE TO/FROM DEBUG LIST
    774          *
    775          * Description: These functions are called by uC/OS-III to add or remove a semaphore to/from the debug list.
    776          *
    777          * Arguments  : p_sem     is a pointer to the semaphore to add/remove
    778          *
    779          * Returns    : none
    780          *
    781          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    782          ************************************************************************************************************************
    783          */
    784          
    785          
    786          #if OS_CFG_DBG_EN > 0u
    787          void  OS_SemDbgListAdd (OS_SEM  *p_sem)
    788          {
    789              p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    790              p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    791              if (OSSemDbgListPtr == (OS_SEM *)0) {
    792                  p_sem->DbgNextPtr           = (OS_SEM   *)0;
    793              } else {
    794                  p_sem->DbgNextPtr           =  OSSemDbgListPtr;
    795                  OSSemDbgListPtr->DbgPrevPtr =  p_sem;
    796              }
    797              OSSemDbgListPtr                 =  p_sem;
    798          }
    799          
    800          
    801          
    802          void  OS_SemDbgListRemove (OS_SEM  *p_sem)
    803          {
    804              OS_SEM  *p_sem_next;
    805              OS_SEM  *p_sem_prev;
    806          
    807          
    808              p_sem_prev = p_sem->DbgPrevPtr;
    809              p_sem_next = p_sem->DbgNextPtr;
    810          
    811              if (p_sem_prev == (OS_SEM *)0) {
    812                  OSSemDbgListPtr = p_sem_next;
    813                  if (p_sem_next != (OS_SEM *)0) {
    814                      p_sem_next->DbgPrevPtr = (OS_SEM *)0;
    815                  }
    816                  p_sem->DbgNextPtr = (OS_SEM *)0;
    817          
    818              } else if (p_sem_next == (OS_SEM *)0) {
    819                  p_sem_prev->DbgNextPtr = (OS_SEM *)0;
    820                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
    821          
    822              } else {
    823                  p_sem_prev->DbgNextPtr =  p_sem_next;
    824                  p_sem_next->DbgPrevPtr =  p_sem_prev;
    825                  p_sem->DbgNextPtr      = (OS_SEM *)0;
    826                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
    827              }
    828          }
    829          #endif
    830          
    831          /*$PAGE*/
    832          /*
    833          ************************************************************************************************************************
    834          *                                                SEMAPHORE INITIALIZATION
    835          *
    836          * Description: This function is called by OSInit() to initialize the semaphore management.
    837          *
    838          
    839          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
    840          *
    841          *                                OS_ERR_NONE     the call was successful
    842          *
    843          * Returns    : none
    844          *
    845          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    846          ************************************************************************************************************************
    847          */
    848          

   \                                 In section .text, align 2, keep-with-next
    849          void  OS_SemInit (OS_ERR  *p_err)
    850          {
    851          #ifdef OS_SAFETY_CRITICAL
    852              if (p_err == (OS_ERR *)0) {
    853                  OS_SAFETY_CRITICAL_EXCEPTION();
    854                  return;
    855              }
    856          #endif
    857          
    858          #if OS_CFG_DBG_EN > 0u
    859              OSSemDbgListPtr = (OS_SEM *)0;
    860          #endif
    861          
    862              OSSemQty        = (OS_OBJ_QTY)0;
   \                     OS_SemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR      R2,??DataTable9_10
   \   00000004   0x8011             STRH     R1,[R2, #+0]
    863             *p_err           = OS_ERR_NONE;
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    864          }
   \   00000008   0x4770             BX       LR               ;; return
    865          
    866          /*$PAGE*/
    867          /*
    868          ************************************************************************************************************************
    869          *                                                 POST TO A SEMAPHORE
    870          *
    871          * Description: This function signals a semaphore
    872          *
    873          * Arguments  : p_sem    is a pointer to the semaphore
    874          *
    875          *              opt      determines the type of POST performed:
    876          *
    877          *                           OS_OPT_POST_1            POST to a single waiting task
    878          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    879          *
    880          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    881          *
    882          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    883          *
    884          *              ts       is a timestamp indicating when the post occurred.
    885          *
    886          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    887          *
    888          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    889          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    890          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    891          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    892          *
    893          * Returns    : The current value of the semaphore counter or 0 upon error.
    894          *
    895          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    896          ************************************************************************************************************************
    897          */
    898          

   \                                 In section .text, align 2, keep-with-next
    899          OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
    900                                  OS_OPT   opt,
    901                                  CPU_TS   ts,
    902                                  OS_ERR  *p_err)
    903          {
   \                     OS_SemPost: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
    904              OS_OBJ_QTY     cnt;
    905              OS_SEM_CTR     ctr;
    906              OS_PEND_LIST  *p_pend_list;
    907              OS_PEND_DATA  *p_pend_data;
    908              OS_PEND_DATA  *p_pend_data_next;
    909              OS_TCB        *p_tcb;
    910              CPU_SR_ALLOC();
    911          
    912          
    913          
    914              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    915              p_pend_list = &p_sem->PendList;
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x3008             ADDS     R0,R0,#+8
   \   00000016   0x9000             STR      R0,[SP, #+0]
    916              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on semaphore?                         */
   \   00000018   0x8900             LDRH     R0,[R0, #+8]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD118             BNE      ??OS_SemPost_0
    917                  switch (sizeof(OS_SEM_CTR)) {
    918                      case 1u:
    919                           if (p_sem->Ctr == DEF_INT_08U_MAX_VAL) {
    920                               CPU_CRITICAL_EXIT();
    921                              *p_err = OS_ERR_SEM_OVF;
    922                               return ((OS_SEM_CTR)0);
    923                           }
    924                           break;
    925          
    926                      case 2u:
    927                           if (p_sem->Ctr == DEF_INT_16U_MAX_VAL) {
    928                               CPU_CRITICAL_EXIT();
    929                              *p_err = OS_ERR_SEM_OVF;
    930                               return ((OS_SEM_CTR)0);
    931                           }
    932                           break;
    933          
    934                      case 4u:
    935                           if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD109             BNE      ??OS_SemPost_1
    936                               CPU_CRITICAL_EXIT();
   \   00000028   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
    937                              *p_err = OS_ERR_SEM_OVF;
   \   00000032   0x....             LDR      R0,??DataTable9_11  ;; 0x6dc5
   \   00000034   0x9902             LDR      R1,[SP, #+8]
   \   00000036   0x8008             STRH     R0,[R1, #+0]
    938                               return ((OS_SEM_CTR)0);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE043             B        ??OS_SemPost_2
    939                           }
    940                           break;
    941          
    942                      default:
    943                           break;
    944                  }
    945                  p_sem->Ctr++;                                       /* No                                                     */
   \                     ??OS_SemPost_1: (+1)
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x6160             STR      R0,[R4, #+20]
    946                  ctr       = p_sem->Ctr;
   \   00000040   0x9000             STR      R0,[SP, #+0]
    947                  p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
   \   00000042   0x61A7             STR      R7,[R4, #+24]
    948                  CPU_CRITICAL_EXIT();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
    949                 *p_err     = OS_ERR_NONE;
   \   0000004E   0xE035             B        ??OS_SemPost_3
    950                  return (ctr);
    951              }
   \                     ??OS_SemPost_0: (+1)
   \   00000050   0x....             LDR      R0,??DataTable9_12
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x....             LDR      R1,??DataTable9_12
   \   00000058   0x7008             STRB     R0,[R1, #+0]
    952          
    953              OS_CRITICAL_ENTER_CPU_EXIT();
   \   0000005A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0x.... 0x....      BL       CPU_SR_Restore
    954              if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
   \   00000064   0x05A8             LSLS     R0,R5,#+22
   \   00000066   0xD505             BPL      ??OS_SemPost_4
    955                  cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x8906             LDRH     R6,[R0, #+8]
    956              } else {
    957                  cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    958              }
    959              p_pend_data = p_pend_list->HeadPtr;
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x2E00             CMP      R6,#+0
   \   00000070   0xD103             BNE      ??OS_SemPost_5
   \   00000072   0xE00E             B        ??OS_SemPost_6
   \                     ??OS_SemPost_4: (+1)
   \   00000074   0x2601             MOVS     R6,#+1
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
    960              while (cnt > 0u) {
    961                  p_tcb            = p_pend_data->TCBPtr;
    962                  p_pend_data_next = p_pend_data->NextPtr;
   \                     ??OS_SemPost_5: (+1)
   \   0000007A   0x6841             LDR      R1,[R0, #+4]
   \   0000007C   0x9101             STR      R1,[SP, #+4]
    963                  OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    964                          p_tcb,
    965                          (void      *)0,
    966                          (OS_MSG_SIZE)0,
    967                          ts);
   \   0000007E   0x9700             STR      R7,[SP, #+0]
   \   00000080   0x2300             MOVS     R3,#+0
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x6881             LDR      R1,[R0, #+8]
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       OS_Post
    968                  p_pend_data = p_pend_data_next;
   \   0000008C   0x9801             LDR      R0,[SP, #+4]
    969                  cnt--;
   \   0000008E   0x1E76             SUBS     R6,R6,#+1
    970              }
   \   00000090   0xD1F3             BNE      ??OS_SemPost_5
    971              ctr = p_sem->Ctr;
   \                     ??OS_SemPost_6: (+1)
   \   00000092   0x6960             LDR      R0,[R4, #+20]
   \   00000094   0x9000             STR      R0,[SP, #+0]
    972              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000096   0x.... 0x....      BL       CPU_SR_Save
   \   0000009A   0x0006             MOVS     R6,R0
   \   0000009C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000A0   0x....             LDR      R0,??DataTable9_12
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x....             LDR      R1,??DataTable9_12
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
   \   000000AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0x.... 0x....      BL       CPU_SR_Restore
    973              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   000000B4   0x0428             LSLS     R0,R5,#+16
   \   000000B6   0xD401             BMI      ??OS_SemPost_3
    974                  OSSched();                                          /* Run the scheduler                                      */
   \   000000B8   0x.... 0x....      BL       OSSched
    975              }
    976             *p_err = OS_ERR_NONE;
   \                     ??OS_SemPost_3: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x9902             LDR      R1,[SP, #+8]
   \   000000C0   0x8008             STRH     R0,[R1, #+0]
    977              return (ctr);
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \                     ??OS_SemPost_2: (+1)
   \   000000C4   0xB003             ADD      SP,SP,#+12
   \   000000C6   0xBDF0             POP      {R4-R7,PC}       ;; return
    978          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x00002EE1         DC32     0x2ee1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x00005DC3         DC32     0x5dc3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x000032C9         DC32     0x32c9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x00005E25         DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x00005DC4         DC32     0x5dc4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x0000715F         DC32     0x715f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x000061AE         DC32     0x61ae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x00005DC3         DC32     0x5dc3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x000061B0         DC32     0x61b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x00005E25         DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x00006D63         DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x000061A9         DC32     0x61a9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x000072D9         DC32     0x72d9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x00005DC2         DC32     0x5dc2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x00006E2E         DC32     0x6e2e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x000061AA         DC32     0x61aa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x000061AB         DC32     0x61ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x00005DC4         DC32     0x5dc4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x00005DC3         DC32     0x5dc3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x00006DC6         DC32     0x6dc6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x0000715F         DC32     0x715f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x00006DC5         DC32     0x6dc5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x3F 0x53          DC8 "?SEM"
   \              0x45 0x4D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    979          
    980          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSSemCreate
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_PendListInit
      32   OSSemDel
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendListInit
        32   -> OS_PendObjDel
      64   OSSemPend
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OS_Pend
      32   OSSemPendAbort
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      24   OSSemPost
        24   -> OS_IntQPost
        24   -> OS_SemPost
      24   OSSemSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       8   OS_SemClr
         8   -> OS_PendListInit
       0   OS_SemInit
      32   OS_SemPost
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Post


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable6
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?_0
     120  OSSemCreate
     288  OSSemDel
     348  OSSemPend
     218  OSSemPendAbort
     100  OSSemPost
      88  OSSemSet
      24  OS_SemClr
      10  OS_SemInit
     200  OS_SemPost

 
 1 552 bytes in section .text
 
 1 552 bytes of CODE memory

Errors: none
Warnings: none
