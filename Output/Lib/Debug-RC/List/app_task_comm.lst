###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Nov/2017  10:06:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\APP\Tasks\app_task_comm.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\Tasks\app_task_comm.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\app_task_comm.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\app_task_comm.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\Tasks\app_task_comm.c
      1          /*******************************************************************************
      2          *   Filename:       app_task_comm.c
      3          *   Revised:        All copyrights reserved to wumingshen.
      4          *   Revision:       v1.0
      5          *   Writer:	     wumingshen.
      6          *
      7          *   Description:    双击选中 comm 按 Ctrl + H, 钩选 Match the case, Replace with
      8          *                   输入您要的名字，点击 Replace All
      9          *                   双击选中 Comm 按 Ctrl + H, 钩选 Match the case, Replace with
     10          *                   输入您要的名字，点击 Replace All
     11          *                   双击选中 COMM 按 Ctrl + H, 钩选 Match the case, Replace with
     12          *                   输入您要的名字，点击 Replace All
     13          *                   在 app_cfg.h 中指定本任务的 优先级  （ APP_TASK_COMM_PRIO     ）
     14          *                                            和 任务堆栈（ APP_TASK_COMM_STK_SIZE ）大小
     15          *
     16          *   Notes:
     17          *     				E-mail: shenchangwei945@163.com
     18          *
     19          *******************************************************************************/
     20          
     21          /*******************************************************************************
     22          * INCLUDES
     23          */
     24          #define  SNL_APP_SOURCE
     25          #include <includes.h>
     26          #include <app_comm_protocol.h>
     27          #include <app_ctrl.h>
     28          #include <os_cfg_app.h>
     29          #include <bsp_timer.h>
     30          #include "csnc_package_deal.h"
     31          #include "app_chk.h"
     32          
     33          //#include <bsp_flash.h>
     34          //#include <iap.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *app_task_comm__c = "$Id: $";
     38          #endif
     39          
     40          #define APP_TASK_COMM_EN     DEF_ENABLED
     41          #if APP_TASK_COMM_EN == DEF_ENABLED
     42          /*******************************************************************************
     43          * CONSTANTS
     44          */
     45          
     46          /*******************************************************************************
     47          * MACROS
     48          */
     49          #define CYCLE_TIME_TICKS            (OS_TICKS_PER_SEC * 1)
     50          
     51          /*******************************************************************************
     52          * TYPEDEFS
     53          */
     54          
     55          
     56          
     57          /***********************************************
     58          * 描述： 任务控制块（TCB）
     59          */

   \                                 In section .bss, align 4
     60          static  OS_TCB   AppTaskCommTCB;
   \                     AppTaskCommTCB:
   \   00000000                      DS8 184
   \   000000B8                      DS8 1024
     61          
     62          /***********************************************
     63          * 描述： 任务堆栈（STACKS）
     64          */
     65          static  CPU_STK  AppTaskCommStk[ APP_TASK_COMM_STK_SIZE ];
     66          
     67          //StrCtrlDCB       Ctrl;
     68          

   \                                 In section .bss, align 4
     69          OS_Q             MTR_RxQ;
   \                     MTR_RxQ:
   \   00000000                      DS8 36
     70          /*******************************************************************************
     71          * LOCAL VARIABLES
     72          */
     73          
     74          /*******************************************************************************
     75          * GLOBAL VARIABLES
     76          */
     77          
     78          /***********************************************
     79          * 描述： 软定时器声明
     80          */

   \                                 In section .bss, align 4
     81          OS_TMR          OSTmr1;                         //定时器1
   \                     OSTmr1:
   \   00000000                      DS8 44
     82          
     83          /***********************************************
     84          * 描述： 软定时器回调函数
     85          */
     86          void            OSTmr1_callback             (OS_TMR *ptmr,void *p_arg);
     87          CPU_BOOLEAN     APP_CSNC_CommHandler        (MODBUS_CH  *pch);
     88          CPU_BOOLEAN     APP_MaterCommHandler        (MODBUS_CH  *pch);
     89          
     90          /*******************************************************************************
     91          * LOCAL FUNCTIONS
     92          */
     93          static void    AppTaskComm                 (void *p_arg);
     94          static void    APP_CommInit                (void);
     95          INT08U          APP_CommRxDataDealCB        (MODBUS_CH  *pch);
     96          INT08U          IAP_CommRxDataDealCB        (MODBUS_CH  *pch);
     97          /*******************************************************************************
     98          * GLOBAL FUNCTIONS
     99          */
    100          
    101          /*******************************************************************************
    102          * EXTERN VARIABLES
    103          */
    104          
    105          /*******************************************************************************
    106          * EXTERN FUNCTIONS
    107          */
    108          extern  void    app_comm_mtr(void);
    109          extern  void    app_comm_dtu(void);
    110          extern  void    app_comm_otr(void);
    111          
    112          
    113          /*******************************************************************************
    114          * 入口参数： 无
    115          * 出口参数： 无
    116          * 作　 　者： redmoringcn.
    117          * 创建日期： 2017-11-17
    118          * 修    改：
    119          * 修改日期：
    120          * 备    注： 任务创建函数需要在app.h文件中声明
    121          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    122          void  App_TaskCommCreate(void)
    123          {
   \                     App_TaskCommCreate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    124              OS_ERR  err;
    125              
    126              /***********************************************
    127              * 描述： 任务创建
    128              */
    129              OSTaskCreate((OS_TCB     *)&AppTaskCommTCB,                     // 任务控制块  （当前文件中定义）
    130                           (CPU_CHAR   *)"App Task Comm",                     // 任务名称
    131                           (OS_TASK_PTR ) AppTaskComm,                        // 任务函数指针（当前文件中定义）
    132                           (void       *) 0,                                  // 任务函数参数
    133                           (OS_PRIO     ) APP_TASK_COMM_PRIO,                 // 任务优先级，不同任务优先级可以相同，0 < 优先级 < OS_CFG_PRIO_MAX - 2（app_cfg.h中定义）
    134                           (CPU_STK    *)&AppTaskCommStk[0],                  // 任务栈顶
    135                           (CPU_STK_SIZE) APP_TASK_COMM_STK_SIZE / 10,        // 任务栈溢出报警值
    136                           (CPU_STK_SIZE) APP_TASK_COMM_STK_SIZE,             // 任务栈大小（CPU数据宽度 * 8 * size = 4 * 8 * size(字节)）（app_cfg.h中定义）
    137                           (OS_MSG_QTY  ) 0u,                                 // 可以发送给任务的最大消息队列数量
    138                           (OS_TICK     ) 0u,                                 // 相同优先级任务的轮循时间（ms），0为默认
    139                           (void       *) 0,                                  // 是一个指向它被用作一个TCB扩展用户提供的存储器位置
    140                           (OS_OPT      )(OS_OPT_TASK_STK_CHK |               // 允许堆栈检查该任务
    141                                          OS_OPT_TASK_STK_CLR),               // 创建任务时堆栈清零
    142                           (OS_ERR     *)&err);                               // 指向错误代码的指针，用于创建结果处理
   \   00000004   0x....             LDR.N    R0,??DataTable7
   \   00000006   0xA909             ADD      R1,SP,#+36
   \   00000008   0x9108             STR      R1,[SP, #+32]
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x9107             STR      R1,[SP, #+28]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x9106             STR      R1,[SP, #+24]
   \   00000012   0x9105             STR      R1,[SP, #+20]
   \   00000014   0x9104             STR      R1,[SP, #+16]
   \   00000016   0xF44F 0x7180      MOV      R1,#+256
   \   0000001A   0x9103             STR      R1,[SP, #+12]
   \   0000001C   0x2119             MOVS     R1,#+25
   \   0000001E   0x9102             STR      R1,[SP, #+8]
   \   00000020   0xF100 0x01B8      ADD      R1,R0,#+184
   \   00000024   0x9101             STR      R1,[SP, #+4]
   \   00000026   0x2114             MOVS     R1,#+20
   \   00000028   0x9100             STR      R1,[SP, #+0]
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x.... 0x....      ADR.W    R2,AppTaskComm
   \   00000030   0x.... 0x....      ADR.W    R1,?_0
   \   00000034   0x.... 0x....      BL       OSTaskCreate
    143              
    144          }
   \   00000038   0xB00B             ADD      SP,SP,#+44
   \   0000003A   0xBD00             POP      {PC}             ;; return
    145          
    146          /*******************************************************************************
    147          * 名    称： AppTaskComm
    148          * 功    能： 控制任务
    149          * 入口参数： p_arg - 由任务创建函数传入
    150          * 出口参数： 无
    151          * 作　 　者： wumingshen.
    152          * 创建日期： 2015-02-05
    153          * 修    改：
    154          * 修改日期：
    155          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    156          static  void  AppTaskComm (void *p_arg)
    157          {
   \                     AppTaskComm: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    158              OS_ERR      err;
    159              
    160              OS_TICK     dly     = CYCLE_TIME_TICKS;
    161              //OS_TICK     ticks;
    162              /***********************************************
    163              * 描述： 任务初始化
    164              */
    165              APP_CommInit();         
   \   00000002   0x.... 0x....      BL       APP_CommInit
   \   00000006   0xE008             B.N      ??AppTaskComm_0
    166              
    167              /***********************************************
    168              * 描述： Task body, always written as an infinite loop.
    169              */
    170              while (DEF_TRUE) { 
    171                  /***********************************************
    172                  * 描述： 本任务看门狗标志置位
    173                  */
    174                  OS_FlagPost(( OS_FLAG_GRP *)&WdtFlagGRP,
    175                              ( OS_FLAGS     ) WDT_FLAG_COMM,
    176                              ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    177                              ( CPU_TS       ) 0,
    178                              ( OS_ERR      *) &err);
    179                  
    180                  /***********************************************
    181                  * 描述： 等待COMM的标识组
    182                  */
    183                  OS_FLAGS    flags = 
    184                      OSFlagPend( ( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    185                                 ( OS_FLAGS     ) Ctrl.Os.CommEvtFlag,
    186                                 ( OS_TICK      ) dly,
    187                                 ( OS_OPT       ) OS_OPT_PEND_FLAG_SET_ANY,
    188                                 ( CPU_TS      *) NULL,
    189                                 ( OS_ERR      *)&err);
    190                  
    191                  //OS_ERR      terr;
    192                  //ticks   = OSTimeGet(&terr);                        // 获取当前OSTick
    193                  
    194                  /***********************************************
    195                  * 描述： 没有错误,有事件发生
    196                  */
    197                  if ( err == OS_ERR_NONE ) {
    198                      OS_FLAGS    flagClr = 0;
    199                      /***********************************************
    200                      * 和测量某块通讯有关事件发生，调用MTR通讯处理函数
    201                      */           
    202                      if(     flags & COMM_EVT_FLAG_MTR_RX 
    203                         ||   flags & COMM_EVT_FLAG_MTR_TIMEOUT ) {
    204                             
    205                             //调用mtr通讯处理函数,和测量模块进行通讯
    206                             app_comm_mtr();                             
    207                             
    208                             if(flags & COMM_EVT_FLAG_MTR_RX) {      
    209                                 flagClr |= COMM_EVT_FLAG_MTR_RX;         //接收到数据，清接收数据标示
    210                             }else{
    211                                 flagClr |= COMM_EVT_FLAG_MTR_TIMEOUT;   //超时，清接收数据标示
    212                             }
    213                         }
    214                      
    215                      /***********************************************
    216                      * 和无线发送模块事件发生，调用DTU通讯处理函数
    217                      */           
    218                      else  if(   flags & COMM_EVT_FLAG_DTU_RX 
    219                               ||  flags & COMM_EVT_FLAG_DTU_TIMEOUT ) {
    220                                   
    221                                   //调用DTU通讯处理函数
    222                                   app_comm_dtu();                            
    223                                   
    224                                   if( flags &    COMM_EVT_FLAG_DTU_RX) {      
    225                                       flagClr |= COMM_EVT_FLAG_DTU_RX;        //接收到数据，清接收数据标示
    226                                   }else{
    227                                       flagClr |= COMM_EVT_FLAG_DTU_TIMEOUT;   //接收到数据，清接收数据标示
    228                                   }
    229                               }
    230                      
    231                      /***********************************************
    232                      * 和IC模块事件发生，调用OTR通讯处理函数
    233                      */           
    234                      else if(    flags & COMM_EVT_FLAG_OTR_RX 
    235                              ||  flags & COMM_EVT_FLAG_OTR_TIMEOUT ) {
    236                                  
    237                                  //调用DTU通讯处理函数
    238                                  //app_comm_otr();                             
    239                                  
    240                                  if(flags &      COMM_EVT_FLAG_OTR_RX) {      
    241                                      flagClr |=  COMM_EVT_FLAG_OTR_RX;        //接收到数据，清接收数据标示
    242                                  }else{
    243                                      flagClr |=  COMM_EVT_FLAG_OTR_TIMEOUT;   //接收到数据，清接收数据标示
    244                                  }
    245                              }
    246                      else if(    flags & COMM_EVT_FLAG_TAX_RX 
    247                              ||  flags & COMM_EVT_FLAG_TAX_TIMEOUT ) {
    248                      
    249                                  //调用DTU通讯处理函数
    250                                  //app_comm_tax();                             
    251                                  
    252                                  if(flags &      COMM_EVT_FLAG_TAX_RX) {      
    253                                      flagClr |=  COMM_EVT_FLAG_TAX_RX;        //接收到数据，清接收数据标示
    254                                  }else{
    255                                      flagClr |=  COMM_EVT_FLAG_TAX_TIMEOUT;   //接收到数据，清接收数据标示
   \                     ??AppTaskComm_1: (+1)
   \   00000008   0x2180             MOVS     R1,#+128
    256                                  }
    257                              }
    258                      /***********************************************
    259                      * 描述： 清除标志
    260                      */
    261                      if ( !flagClr ) {
   \                     ??AppTaskComm_2: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD100             BNE.N    ??AppTaskComm_3
    262                          flagClr = flags;
   \   0000000E   0x4629             MOV      R1,R5
    263                      }
    264                      
    265                      /***********************************************
    266                      * 描述： 清除标志位
    267                      */
    268                      OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    269                                 ( OS_FLAGS      )flagClr,
    270                                 ( OS_OPT        )OS_OPT_POST_FLAG_CLR,
    271                                 ( OS_ERR       *)&err);
   \                     ??AppTaskComm_3: (+1)
   \   00000010   0xAB02             ADD      R3,SP,#+8
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       OSFlagPost
   \                     ??AppTaskComm_0: (+1)
   \   0000001A   0xA802             ADD      R0,SP,#+8
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x....             LDR.N    R0,??DataTable7_1
   \   00000026   0x.... 0x....      BL       OS_FlagPost
   \   0000002A   0x....             LDR.N    R0,??DataTable7_2
   \   0000002C   0xF200 0x4462      ADDW     R4,R0,#+1122
   \   00000030   0xA902             ADD      R1,SP,#+8
   \   00000032   0x9101             STR      R1,[SP, #+4]
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x9100             STR      R1,[SP, #+0]
   \   00000038   0x2308             MOVS     R3,#+8
   \   0000003A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000003E   0xF8D0 0x147E      LDR      R1,[R0, #+1150]
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       OSFlagPend
   \   00000048   0x4605             MOV      R5,R0
   \   0000004A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD1E3             BNE.N    ??AppTaskComm_0
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF015 0x0F09      TST      R5,#0x9
   \   00000058   0xD007             BEQ.N    ??AppTaskComm_4
   \   0000005A   0x.... 0x....      BL       app_comm_mtr
   \   0000005E   0x07E8             LSLS     R0,R5,#+31
   \   00000060   0xD501             BPL.N    ??AppTaskComm_5
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0xE7D1             B.N      ??AppTaskComm_2
   \                     ??AppTaskComm_5: (+1)
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0xE7CF             B.N      ??AppTaskComm_2
   \                     ??AppTaskComm_4: (+1)
   \   0000006A   0xF015 0x0F12      TST      R5,#0x12
   \   0000006E   0xD007             BEQ.N    ??AppTaskComm_6
   \   00000070   0x.... 0x....      BL       app_comm_dtu
   \   00000074   0x07A8             LSLS     R0,R5,#+30
   \   00000076   0xD501             BPL.N    ??AppTaskComm_7
   \   00000078   0x2102             MOVS     R1,#+2
   \   0000007A   0xE7C6             B.N      ??AppTaskComm_2
   \                     ??AppTaskComm_7: (+1)
   \   0000007C   0x2110             MOVS     R1,#+16
   \   0000007E   0xE7C4             B.N      ??AppTaskComm_2
   \                     ??AppTaskComm_6: (+1)
   \   00000080   0xF015 0x0F24      TST      R5,#0x24
   \   00000084   0xD005             BEQ.N    ??AppTaskComm_8
   \   00000086   0x0768             LSLS     R0,R5,#+29
   \   00000088   0xD501             BPL.N    ??AppTaskComm_9
   \   0000008A   0x2104             MOVS     R1,#+4
   \   0000008C   0xE7BD             B.N      ??AppTaskComm_2
   \                     ??AppTaskComm_9: (+1)
   \   0000008E   0x2120             MOVS     R1,#+32
   \   00000090   0xE7BB             B.N      ??AppTaskComm_2
   \                     ??AppTaskComm_8: (+1)
   \   00000092   0xF015 0x0FC0      TST      R5,#0xC0
   \   00000096   0xD0B8             BEQ.N    ??AppTaskComm_2
   \   00000098   0x0668             LSLS     R0,R5,#+25
   \   0000009A   0xD5B5             BPL.N    ??AppTaskComm_1
   \   0000009C   0x2140             MOVS     R1,#+64
   \   0000009E   0xE7B4             B.N      ??AppTaskComm_2
    272                  }
    273              }
    274          }
    275          
    276          /*******************************************************************************
    277          * 名    称： APP_ModbusInit
    278          * 功    能： MODBUS初始化
    279          * 入口参数： 无
    280          * 出口参数： 无
    281          * 作　 　者： 无名沈
    282          * 创建日期： 2015-03-28
    283          * 修    改：
    284          * 修改日期：
    285          * 备    注： 该初始化会创建Modbus任务。
    286          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    287          void App_ModbusInit(void)
    288          {
   \                     App_ModbusInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    289              MODBUS_CH   *pch;
    290              /***********************************************
    291              * 描述： uCModBus初始化，RTU时钟频率为1000HZ
    292              *        使用了定时器2（TIM2）
    293              */
    294              MB_Init(1000);
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0x.... 0x....      BL       MB_Init
    295              
    296              // UART1
    297              /***********************************************
    298              * 描述：  UART1串口和测量装置连接。master
    299              *        用作主机。
    300              */
    301          //#if MODBUS_CFG_MASTER_EN == DEF_TRUE
    302          //    pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    303          //                           MODBUS_SLAVE,          // ... This is a MASTER
    304          //                           500,                    // ... 0 when a slave
    305          //                           MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    306          //                           1,                      // ... Specify UART #1
    307          //                           9600,                   // ... Baud Rate
    308          //                           USART_WordLength_8b,         // ... Number of data bits 7 or 8
    309          //                           USART_Parity_No,       // ... Parity: _NONE, _ODD or _EVEN
    310          //                           USART_StopBits_1,         // ... Number of stop bits 1 or 2
    311          //                           MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
    312          //    pch->AesEn          = DEF_DISABLED;             // ... AES加密禁止
    313          //    pch->NonModbusEn    = DEF_ENABLED;              // ... 支持非MODBUS通信
    314          //    pch->IapModbusEn    = DEF_ENABLED;              // ... 支持IAP MODBUS通信
    315          //    
    316          //    pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
    317          //    pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
    318          //    
    319          //    Ctrl.Mtr.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
    320          //    
    321          //#endif
    322              // UART2
    323              /***********************************************
    324              * 描述:   UART2串口和测量装置通讯。master
    325              */
    326              
    327          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    328              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    329                                     MODBUS_MASTER,           // ... This is a MASTER
    330                                     500,                    // ... 0 when a slave
    331                                     MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    332                                     1,                      // ... Specify UART #3
    333                                     9600,                  // ... Baud Rate
    334                                     USART_WordLength_8b,         // ... Number of data bits 7 or 8
    335                                     USART_Parity_No,       // ... Parity: _NONE, _ODD or _EVEN
    336                                     USART_StopBits_1,         // ... Number of stop bits 1 or 2
    337                                     MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x9005             STR      R0,[SP, #+20]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9004             STR      R0,[SP, #+16]
   \   00000014   0x9003             STR      R0,[SP, #+12]
   \   00000016   0x9002             STR      R0,[SP, #+8]
   \   00000018   0xF44F 0x5016      MOV      R0,#+9600
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0xF44F 0x72FA      MOV      R2,#+500
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x.... 0x....      BL       MB_CfgCh
    338              pch->AesEn          =   DEF_DISABLED;           // ... AES加密禁止
   \   0000002E   0xF890 0x1452      LDRB     R1,[R0, #+1106]
   \   00000032   0xF001 0x01FE      AND      R1,R1,#0xFE
   \   00000036   0xF880 0x1452      STRB     R1,[R0, #+1106]
    339              pch->NonModbusEn    =   DEF_ENABLED;            // ... 支持非MODBUS通信
   \   0000003A   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000003E   0xF880 0x1452      STRB     R1,[R0, #+1106]
    340              pch->IapModbusEn    =   DEF_ENABLED;            // ... 支持IAP MODBUS通信
   \   00000042   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000046   0xF880 0x1452      STRB     R1,[R0, #+1106]
    341              
    342              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   0000004A   0xF200 0x314A      ADDW     R1,R0,#+842
   \   0000004E   0xF241 0x0428      MOVW     R4,#+4136
   \   00000052   0x800C             STRH     R4,[R1, #+0]
    343              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   00000054   0xF241 0x052C      MOVW     R5,#+4140
   \   00000058   0x804D             STRH     R5,[R1, #+2]
    344              
    345              
    346              Ctrl.Mtr.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
   \   0000005A   0x....             LDR.N    R6,??DataTable7_2
   \   0000005C   0xF8C6 0x02DC      STR      R0,[R6, #+732]
    347          #endif
    348              
    349              // UART3
    350              /***********************************************
    351              * 描述：  UART3串口和无线发送模块连接。master
    352              *        
    353              */
    354          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    355              
    356              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    357                                     MODBUS_SLAVE,           // ... This is a SLAVE
    358                                     500,                    // ... 0 when a slave
    359                                     MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    360                                     2,                      // ... Specify UART #3
    361                                     57600,                   // ... Baud Rate
    362                                     USART_WordLength_8b,         // ... Number of data bits 7 or 8
    363                                     USART_Parity_No,       // ... Parity: _NONE, _ODD or _EVEN
    364                                     USART_StopBits_1,         // ... Number of stop bits 1 or 2
    365                                     MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x9005             STR      R0,[SP, #+20]
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x9004             STR      R0,[SP, #+16]
   \   00000068   0x9003             STR      R0,[SP, #+12]
   \   0000006A   0x9002             STR      R0,[SP, #+8]
   \   0000006C   0xF44F 0x4061      MOV      R0,#+57600
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0xF44F 0x72FA      MOV      R2,#+500
   \   0000007C   0x4619             MOV      R1,R3
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x.... 0x....      BL       MB_CfgCh
    366              pch->AesEn          = DEF_DISABLED;             // ... AES加密禁止
   \   00000084   0xF890 0x1452      LDRB     R1,[R0, #+1106]
   \   00000088   0xF001 0x01FE      AND      R1,R1,#0xFE
   \   0000008C   0xF880 0x1452      STRB     R1,[R0, #+1106]
    367              pch->NonModbusEn    = DEF_ENABLED;              // ... 支持非MODBUS通信
   \   00000090   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000094   0xF880 0x1452      STRB     R1,[R0, #+1106]
    368              pch->IapModbusEn    = DEF_ENABLED;              // ... 支持IAP MODBUS通信
   \   00000098   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000009C   0xF880 0x1452      STRB     R1,[R0, #+1106]
    369              
    370              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   000000A0   0xF200 0x314A      ADDW     R1,R0,#+842
   \   000000A4   0x800C             STRH     R4,[R1, #+0]
    371              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   000000A6   0x804D             STRH     R5,[R1, #+2]
    372              
    373              Ctrl.Dtu.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
   \   000000A8   0xF8C6 0x043D      STR      R0,[R6, #+1085]
    374          #endif
    375              
    376              // UART3
    377              /***********************************************
    378              * 描述：  UART0串口和TAX连接。slave
    379              *        
    380              */
    381          //#if MODBUS_CFG_MASTER_EN == DEF_TRUE
    382          //    
    383          //    pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    384          //                           MODBUS_SLAVE,           // ... This is a SLAVE
    385          //                           500,                    // ... 0 when a slave
    386          //                           MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    387          //                           0,                      // ... Specify UART #0
    388          //                           28800,                   // ... Baud Rate
    389          //                           USART_WordLength_8b,         // ... Number of data bits 7 or 8
    390          //                           //UART_PARITY_NONE,       // ... Parity: _NONE, _ODD or _EVEN
    391          //                           USART_Parity_No,
    392          //                           USART_StopBits_1,         // ... Number of stop bits 1 or 2
    393          //                           MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
    394          //    pch->AesEn          = DEF_DISABLED;             // ... AES加密禁止
    395          //    pch->NonModbusEn    = DEF_ENABLED;              // ... 支持非MODBUS通信
    396          //    pch->IapModbusEn    = DEF_ENABLED;              // ... 支持IAP MODBUS通信
    397          //    
    398          //    pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
    399          //    pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
    400          //    
    401          //    pch->RTU_TimeoutCnts = 50;
    402          //    pch->RTU_TimeoutCtr  = 50;
    403          //    
    404          //    Ctrl.DevTax.pch    = pch;                      // ... modbus控制块和全局结构体建立连接
    405          //#endif
    406              
    407          }
   \   000000AC   0xB006             ADD      SP,SP,#+24
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    408          
    409          
    410          /*******************************************************************************
    411          * 名    称： APP_CommInit
    412          * 功    能： 任务初始化
    413          * 入口参数： 无
    414          * 出口参数： 无
    415          * 作　 　者： wumingshen.
    416          * 创建日期： 2015-03-28
    417          * 修    改：
    418          * 修改日期：
    419          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    420          void APP_CommInit(void)
    421          {
   \                     APP_CommInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    422              OS_ERR err;
    423              
    424              /***********************************************
    425              * 描述： 创建事件标志组,协调comm收发
    426              */
    427              OSFlagCreate(( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    428                           ( CPU_CHAR     *)"App_CommFlag",
    429                           ( OS_FLAGS      )0,
    430                           ( OS_ERR       *)&err);
   \   00000004   0x....             LDR.N    R4,??DataTable7_2
   \   00000006   0x466B             MOV      R3,SP
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x.... 0x....      ADR.W    R1,?_1
   \   0000000E   0xF204 0x4062      ADDW     R0,R4,#+1122
   \   00000012   0x.... 0x....      BL       OSFlagCreate
    431              
    432              Ctrl.Os.CommEvtFlag= COMM_EVT_FLAG_MTR_RX        // MTR 接收事件
    433                  + COMM_EVT_FLAG_DTU_RX          // DTU 接收事件
    434                      + COMM_EVT_FLAG_OTR_RX        // OTR 接收事件
    435                          + COMM_EVT_FLAG_MTR_TIMEOUT   // MTR 操作超时，定时发送使用
    436                              + COMM_EVT_FLAG_DTU_TIMEOUT   // DTU 操作超时，定时发送使用
    437                                  + COMM_EVT_FLAG_OTR_TIMEOUT  // OTR 操作超时，定时发送使用   
    438                                      + COMM_EVT_FLAG_TAX_RX   // TAX 操作超时，定时发送使用
    439                                          + COMM_EVT_FLAG_TAX_TIMEOUT;  // TAX 操作超时，定时发送使用  
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0xF8C4 0x047E      STR      R0,[R4, #+1150]
    440              
    441              /***********************************************
    442              * 描述： 初始化MODBUS通信
    443              */        
    444              App_ModbusInit();
   \   0000001C   0x.... 0x....      BL       App_ModbusInit
    445              
    446              
    447              /***********************************************
    448              * 描述： 在看门狗标志组注册本任务的看门狗标志
    449              */
    450              WdtFlags |= WDT_FLAG_COMM;
   \   00000020   0x....             LDR.N    R0,??DataTable7_3
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    451          }
   \   0000002A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    452          
    453          /*******************************************************************************
    454          * 名    称： APP_CommRxDataDealCB
    455          * 功    能： 串口数据处理回调函数，由MB_DATA.C调用
    456          * 入口参数： 无
    457          * 出口参数： 无
    458          * 作    者： 无名沈
    459          * 创建日期： 2016-01-04
    460          * 修    改：
    461          * 修改日期：
    462          * 备    注： 
    463          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    464          INT08U APP_CommRxDataDealCB(MODBUS_CH  *pch)
    465          {
   \                     APP_CommRxDataDealCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB0C6             SUB      SP,SP,#+280
   \   00000004   0x4604             MOV      R4,R0
    466              /***********************************************
    467              * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    468              */
    469          #if MB_IAPMODBUS_EN == DEF_ENABLED
    470              //    /***********************************************
    471              //    * 描述： 如果程序处在升级模式
    472              //    */
    473              //    if ( ( Iap.Status != IAP_STS_DEF ) && 
    474              //         ( Iap.Status != IAP_STS_SUCCEED ) &&
    475              //         ( Iap.Status != IAP_STS_FAILED ) ) {
    476              //        return IAP_CommRxDataDealCB(pch);
    477              //    }
    478          #endif
    479              /***********************************************
    480              * 描述： 获取帧头
    481              */
    482              //CPU_SR_ALLOC();
    483              
    484              //redmorningcn 数据复制功能由MBS_RTU_Task 已经执行。此处无需重复拷贝。
    485              
    486              //    CPU_CRITICAL_ENTER();
    487              //    //u8  Len     = pch->RxBufByteCtr;
    488              //u8  Len     = pch->RxBufByteCnt;
    489              //    memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    490              //    CPU_CRITICAL_EXIT();
    491              
    492              OS_ERR      err;
    493              
    494              //DataBuf = pch->RxFrameData;
    495              
    496              //INT08U  *DataBuf = 0 ;
    497              /***********************************************
    498              * 描述： 接收数据处理,
    499              * 根据协议，返回数据是            源地址
    500              *           目标地址由           GetRecSlaveAddr （）获得。
    501              *           数据区长度在          Len
    502              *           数据区                 DataBuf
    503              *           接收序号            GetRecvFrameNbr（）
    504              */  
    505              
    506               //在此增加新的V2.0   
    507              stcCsncProtocolPara sCsncPara;      //csnsY
    508              sCsncPara.destaddr = 0;             //地址赋值
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0009      STRB     R0,[SP, #+9]
    509              
    510              uint8       buf[256];
    511              uint8       flg; 
    512              sCsncPara.databuf = buf;
   \   0000000C   0xA806             ADD      R0,SP,#+24
   \   0000000E   0x9003             STR      R0,[SP, #+12]
    513              sCsncPara.rxtxbuf = (uint8 *)pch->RxFrameData;
   \   00000010   0xF504 0x7011      ADD      R0,R4,#+580
   \   00000014   0x9004             STR      R0,[SP, #+16]
    514              sCsncPara.rxtxlen = pch->RxBufByteCnt;
   \   00000016   0x8E60             LDRH     R0,[R4, #+50]
   \   00000018   0xF88D 0x0015      STRB     R0,[SP, #+21]
    515              flg = DataUnpack_CSNC(&sCsncPara);   
   \   0000001C   0xA802             ADD      R0,SP,#+8
   \   0000001E   0x.... 0x....      BL       DataUnpack_CSNC
    516          //   
    517          //    //fhV1.0
    518          //    uint8   DataPos;
    519          //    u8  SourceAddr = 
    520          //        CSNC_GetData(	(uint8 *)pch->RxFrameData,      //RecBuf,
    521          //                     (uint16 )Len,                      //RecLen, 
    522          //                     (uint8 *)&DataPos,                 //DataBuf,
    523          //                     (uint16 *)&Len);                   //InfoLen)
    524              /***********************************************
    525              * 描述： 如果接收地址和装置地址不符，则不处理，接收数据错误。
    526              */
    527              
    528          //    if ( MASTE_ADDR_HOST != GetRecSlaveAddr() ) 
    529          //        return FALSE;
    530              //fhDl考]
    531              if ( MASTE_ADDR_HOST != sCsncPara.destaddr || flg == 0 ) //解析错误、地址错误，退出。
   \   00000022   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   00000026   0x2980             CMP      R1,#+128
   \   00000028   0xD101             BNE.N    ??APP_CommRxDataDealCB_0
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD101             BNE.N    ??APP_CommRxDataDealCB_1
    532                  return FALSE;
   \                     ??APP_CommRxDataDealCB_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE054             B.N      ??APP_CommRxDataDealCB_2
    533              
    534              /***********************************************
    535              * 描述： 根据 地址  pch来源  判断数据是 否 合理 ，
    536              *       并赋值。
    537              */
    538              //switch  (pch->Ch )
    539              switch  (pch->PortNbr )     //根据端口号定义
   \                     ??APP_CommRxDataDealCB_1: (+1)
   \   00000032   0x7A60             LDRB     R0,[R4, #+9]
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD150             BNE.N    ??APP_CommRxDataDealCB_3
    540              {
    541                  /***********************************************
    542                  * 描述： UART0接收到数据
    543                  */
    544              case 0:
    545                  break;
    546                  
    547                  /***********************************************
    548                  * 描述： UART1接收到数据。数据发送地址：A1、A2
    549                  *                         数据接收地址：80
    550                  */        
    551              case 1:
    552          ////        if(     SLAVE_ADDR_DIP1 == SourceAddr 
    553          ////           ||   SLAVE_ADDR_DIP2 == SourceAddr    
    554          //        if(     SLAVE_ADDR_DIP1 == sCsncPara.sourceaddr 
    555          //           ||   SLAVE_ADDR_DIP2 == sCsncPara.sourceaddr                   
    556          //               
    557          //               )   
    558          //        {
    559          ////            Ctrl.Mtr.RxCtrl.SourceAddr = SourceAddr;           //源地址
    560          ////            Ctrl.Mtr.RxCtrl.DestAddr   = GetRecSlaveAddr();    //目标地址
    561          ////            Ctrl.Mtr.RxCtrl.FramNum    = GetRecvFrameNbr();    //接收到的帧号
    562          ////            Ctrl.Mtr.RxCtrl.Code       = 0;                    //指令码 ，测量装置未定义 
    563          ////            Ctrl.Mtr.RxCtrl.Len        = Len;                  //数据区长度
    564          //            
    565          //            Ctrl.Mtr.RxCtrl.SourceAddr = sCsncPara.sourceaddr;   	//源地址
    566          //            Ctrl.Mtr.RxCtrl.DestAddr   = sCsncPara.destaddr;    	//目标地址
    567          //            Ctrl.Mtr.RxCtrl.FramNum    = sCsncPara.framnum;    	//接收到的帧号
    568          //            Ctrl.Mtr.RxCtrl.FrameCode  = (uint8)sCsncPara.framcode & (0x0f);//指令码 ，测量装置未定义 
    569          //            Ctrl.Mtr.RxCtrl.Len        = sCsncPara.datalen;       	//数据区长度    
    570          //            
    571          //            //取数据记录，将数据记录保存到接收区
    572          //            //OS_CRITICAL_ENTER();
    573          ////            memcpy( (INT08U *)&Ctrl.Mtr.Rd.Buf[0], (INT08U *)&pch->RxFrameData[DataPos], Len );
    574          //            //memcpy( (INT08U *)&Ctrl.Mtr.Rd.Buf[0], buf, Len );
    575          //            memcpy( (INT08U *)&Ctrl.Mtr.Rd.Buf[0], buf, sCsncPara.datalen );
    576          //            //OS_CRITICAL_EXIT();
    577          //            
    578          //            /***********************************************
    579          //            * 描述： UART1连接状态描述
    580          //            */       
    581          //            for(uint8 i = 0;i< COMM_DEV_MTR_CONN_NUM;i++)
    582          //            {
    583          ////                if( Ctrl.Mtr.ConnCtrl[i].SlaveAddr == SourceAddr)
    584          //                if( Ctrl.Mtr.ConnCtrl[i].SlaveAddr == sCsncPara.sourceaddr )
    585          //                {
    586          //                    Ctrl.Mtr.ConnCtrl[i].RecvEndFlg   = 1;      //接收到数据，置1。数据处理后置0
    587          //                    Ctrl.Mtr.ConnCtrl[i].TimeOut      = 0;      //超时计数器清零。
    588          //                }
    589          //            }
    590          //            
    591          //            OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    592          //                        ( OS_FLAGS     ) COMM_EVT_FLAG_MTR_RX,
    593          //                        ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    594          //                        ( CPU_TS       ) 0,
    595          //                        ( OS_ERR      *) &err);       
    596          //        }
    597          //        
    598          //        Ctrl.Mtr.ConnectFlag       = 1;
    599          //        Ctrl.Mtr.ConnectTimeOut    = 0;   
    600                  
    601                  break;
    602                  
    603                  /***********************************************
    604                  * 描述： UART3接收到数据。数据发送地址：CA、C2
    605                  *                         数据接收地址:80
    606                  */   
    607              case 2:
    608                  if(        SLAVE_ADDR_DTU   == sCsncPara.sourceaddr 
    609                     ||      SLAVE_ADDR_SET   == sCsncPara.sourceaddr    
    610                         )   
   \   00000038   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000003C   0x28CA             CMP      R0,#+202
   \   0000003E   0xD001             BEQ.N    ??APP_CommRxDataDealCB_4
   \   00000040   0x28C2             CMP      R0,#+194
   \   00000042   0xD146             BNE.N    ??APP_CommRxDataDealCB_5
    611                  {
    612                      Ctrl.Dtu.RxCtrl.SourceAddr = sCsncPara.sourceaddr;   	//源地址
   \                     ??APP_CommRxDataDealCB_4: (+1)
   \   00000044   0x....             LDR.N    R4,??DataTable7_2
   \   00000046   0xF204 0x4021      ADDW     R0,R4,#+1057
   \   0000004A   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000004E   0x7042             STRB     R2,[R0, #+1]
    613                      Ctrl.Dtu.RxCtrl.DestAddr   = sCsncPara.destaddr;    	//目标地址
   \   00000050   0x7001             STRB     R1,[R0, #+0]
    614                      Ctrl.Dtu.RxCtrl.FramNum    = sCsncPara.framnum;    	//接收到的帧号
   \   00000052   0xF89D 0x100A      LDRB     R1,[SP, #+10]
   \   00000056   0x7081             STRB     R1,[R0, #+2]
    615                      Ctrl.Dtu.RxCtrl.FrameCode  = (uint8)sCsncPara.framcode & (0x0f);//指令码 ，测量装置未定义 
   \   00000058   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \   0000005C   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000060   0x7101             STRB     R1,[R0, #+4]
    616                      Ctrl.Dtu.RxCtrl.Len        = sCsncPara.datalen;       	//数据区长度               
   \   00000062   0xF89D 0x2014      LDRB     R2,[SP, #+20]
   \   00000066   0x70C2             STRB     R2,[R0, #+3]
    617          
    618          			/***********************************************
    619                      * 描述：无线通讯及IC卡通讯，定义数据区的前 4 个字节为命令字，   
    620                      *                           ，4字节后才是真正的数据。                        
    621                      */                   
    622                      //if(Len >=4)     
    623                      if(sCsncPara.datalen >=4 && Ctrl.Dtu.RxCtrl.FrameCode == 0) 
   \   00000068   0x2A04             CMP      R2,#+4
   \   0000006A   0xDB12             BLT.N    ??APP_CommRxDataDealCB_6
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD110             BNE.N    ??APP_CommRxDataDealCB_6
    624                      {
    625                          //Ctrl.Dtu.RxCtrl.Len        = Len - 4;                  //数据区长度
    626                          Ctrl.Dtu.RxCtrl.Len        = sCsncPara.datalen - 4;                  //数据区长度
   \   00000070   0x1F11             SUBS     R1,R2,#+4
   \   00000072   0x70C1             STRB     R1,[R0, #+3]
    627                          //取数据记录，将数据记录保存到接收区
    628                          //OS_CRITICAL_ENTER();
    629                          //memcpy( (INT08U *)&Ctrl.Dtu.RxCtrl.Code, (INT08U *)&pch->RxFrameData[DataPos], 4);        //功能码
    630                          //memcpy( (INT08U *)&Ctrl.Dtu.Rd.Buf[0],   (INT08U *)&pch->RxFrameData[DataPos+4], Len-4 );   //数据区
    631                          memcpy( (INT08U *)&Ctrl.Dtu.RxCtrl.DataCode, buf, 4);        //功能码
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xA906             ADD      R1,SP,#+24
   \   00000078   0xF204 0x4029      ADDW     R0,R4,#+1065
   \   0000007C   0x.... 0x....      BL       __aeabi_memcpy
    632                          memcpy( (INT08U *)&Ctrl.Dtu.Rd.Buf[0],   (INT08U *)&buf[4], sCsncPara.datalen-4 );   //数据区
   \   00000080   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000084   0x1F02             SUBS     R2,R0,#+4
   \   00000086   0xA907             ADD      R1,SP,#+28
   \   00000088   0xF204 0x20E1      ADDW     R0,R4,#+737
   \   0000008C   0x.... 0x....      BL       __aeabi_memcpy
    633          
    634                          //OS_CRITICAL_EXIT();                    
    635                      }
   \   00000090   0xE004             B.N      ??APP_CommRxDataDealCB_7
    636                      else        //V2.0协议操作  //将数据拷贝数据区，在根据协议解析   
    637                      {
    638                          memcpy( (INT08U *)&Ctrl.Dtu.Rd.Buf[0],   (INT08U *)&buf[0], sCsncPara.datalen );
   \                     ??APP_CommRxDataDealCB_6: (+1)
   \   00000092   0xA906             ADD      R1,SP,#+24
   \   00000094   0xF204 0x20E1      ADDW     R0,R4,#+737
   \   00000098   0x.... 0x....      BL       __aeabi_memcpy
    639                      }
    640                      /***********************************************
    641                      * 描述： UART3连接状态描述
    642                      */       
    643                      for(uint8 i = 0;i< COMM_DEV_DTU_CONN_NUM;i++)
   \                     ??APP_CommRxDataDealCB_7: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE00D             B.N      ??APP_CommRxDataDealCB_8
    644                      {
    645                          //if( Ctrl.Dtu.ConnCtrl[i].SlaveAddr == SourceAddr)
    646                          if( Ctrl.Dtu.ConnCtrl[i].SlaveAddr == sCsncPara.sourceaddr)
   \                     ??APP_CommRxDataDealCB_9: (+1)
   \   000000A0   0xEB04 0x01C0      ADD      R1,R4,R0, LSL #+3
   \   000000A4   0xF201 0x412E      ADDW     R1,R1,#+1070
   \   000000A8   0x78CA             LDRB     R2,[R1, #+3]
   \   000000AA   0xF89D 0x3008      LDRB     R3,[SP, #+8]
   \   000000AE   0x429A             CMP      R2,R3
   \   000000B0   0xD103             BNE.N    ??APP_CommRxDataDealCB_10
    647                          {
    648                              Ctrl.Dtu.ConnCtrl[i].RecvEndFlg  = 1;              //接收到数据，置1。数据处理后置0
   \   000000B2   0x2201             MOVS     R2,#+1
   \   000000B4   0x700A             STRB     R2,[R1, #+0]
    649                              Ctrl.Dtu.ConnCtrl[i].TimeOut     = 0;              //超时计数器清零。
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x704A             STRB     R2,[R1, #+1]
    650                          }
    651                      }
   \                     ??APP_CommRxDataDealCB_10: (+1)
   \   000000BA   0x1C40             ADDS     R0,R0,#+1
   \                     ??APP_CommRxDataDealCB_8: (+1)
   \   000000BC   0x2802             CMP      R0,#+2
   \   000000BE   0xDBEF             BLT.N    ??APP_CommRxDataDealCB_9
    652                      
    653                      OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    654                                  ( OS_FLAGS     ) COMM_EVT_FLAG_DTU_RX,
    655                                  ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    656                                  ( CPU_TS       ) 0,
    657                                  ( OS_ERR      *) &err);       
   \   000000C0   0xA801             ADD      R0,SP,#+4
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x2300             MOVS     R3,#+0
   \   000000C6   0x461A             MOV      R2,R3
   \   000000C8   0x2102             MOVS     R1,#+2
   \   000000CA   0xF204 0x4062      ADDW     R0,R4,#+1122
   \   000000CE   0x.... 0x....      BL       OS_FlagPost
    658                  }
    659                  
    660                  Ctrl.Dtu.ConnectFlag       = 1;
    661                  Ctrl.Dtu.ConnectTimeOut    = 0;   
   \                     ??APP_CommRxDataDealCB_5: (+1)
   \   000000D2   0x2080             MOVS     R0,#+128
   \   000000D4   0x....             LDR.N    R1,??DataTable7_2
   \   000000D6   0xF881 0x0441      STRB     R0,[R1, #+1089]
    662                  
    663                  break;
    664                  /***********************************************
    665                  * 描述： UART4接收到数据
    666                  */   
    667              case 3:
    668          ////        if(         SLAVE_ADDR_OTR == SourceAddr 
    669          ////           ||      SLAVE_ADDR_SET  == SourceAddr    
    670          ////               
    671          //        if(         SLAVE_ADDR_OTR == sCsncPara.sourceaddr 
    672          //           ||      SLAVE_ADDR_SET  == sCsncPara.sourceaddr    
    673          //               )   
    674          //        {
    675          ////            Ctrl.Otr.RxCtrl.SourceAddr = SourceAddr;           //源地址
    676          ////            Ctrl.Otr.RxCtrl.DestAddr   = GetRecSlaveAddr();    //目标地址
    677          ////            Ctrl.Otr.RxCtrl.FramNum    = GetRecvFrameNbr();    //接收到的帧号
    678          //
    679          //            Ctrl.Otr.RxCtrl.SourceAddr = sCsncPara.sourceaddr;   	//源地址
    680          //            Ctrl.Otr.RxCtrl.DestAddr   = sCsncPara.destaddr;    	//目标地址
    681          //            Ctrl.Otr.RxCtrl.FramNum    = sCsncPara.framnum;    	//接收到的帧号
    682          //            Ctrl.Otr.RxCtrl.FrameCode  = (uint8)sCsncPara.framcode & (0x0f);//指令码 ，测量装置未定义 
    683          //            Ctrl.Otr.RxCtrl.Len        = sCsncPara.datalen;       	//数据区长度               
    684          //
    685          //            /***********************************************
    686          //            * 描述：无线通讯及IC卡通讯，定义数据区的前 4 个字节为命令字，   
    687          //            *                           ，4字节后才是真正的数据。                        
    688          //            */                   
    689          //            //if(Len >=4)  //V1.0协议操作
    690          //            if(sCsncPara.datalen >=4 && Ctrl.Otr.RxCtrl.FrameCode == 0) 
    691          //            {
    692          //                //Ctrl.Otr.RxCtrl.Len        = Len - 4;                  //数据区长度
    693          //                Ctrl.Otr.RxCtrl.Len        = Ctrl.Otr.RxCtrl.Len  - 4;                  //数据区长度 - 4;                  //数据区长度
    694          //                //取数据记录，将数据记录保存到接收区
    695          //                //OS_CRITICAL_ENTER();
    696          //                //memcpy( (INT08U *)&Ctrl.Otr.RxCtrl.Code, (INT08U *)&pch->RxFrameData[DataPos], 4);        //功能码
    697          //                //memcpy( (INT08U *)&Ctrl.Otr.Rd.Buf[0],   (INT08U *)&pch->RxFrameData[DataPos+4], Len-4 );   //数据区
    698          //
    699          //                memcpy( (INT08U *)&Ctrl.Otr.RxCtrl.DataCode, buf, 4);        //功能码
    700          //                memcpy( (INT08U *)&Ctrl.Otr.Rd.Buf[0],   (INT08U *)&buf[4], sCsncPara.datalen-4 );   //数据区                //OS_CRITICAL_EXIT();                    
    701          //            }
    702          //            else        //V2.0协议操作    //将数据拷贝数据区，在根据协议解析 
    703          //            {
    704          //                memcpy( (INT08U *)&Ctrl.Otr.Rd.Buf[0],   (INT08U *)&buf[0], sCsncPara.datalen );
    705          //            }
    706          //            /***********************************************
    707          //            * 描述： UART2连接状态描述
    708          //            */       
    709          //            for(uint8 i = 0;i< COMM_DEV_OTR_CONN_NUM;i++)
    710          //            {
    711          //                //if( Ctrl.Otr.ConnCtrl[i].SlaveAddr == SourceAddr)
    712          //                if( Ctrl.Otr.ConnCtrl[i].SlaveAddr == sCsncPara.sourceaddr)
    713          //                {
    714          //                    Ctrl.Otr.ConnCtrl[i].RecvEndFlg  = 1;      //接收到数据，置1。数据处理后置0
    715          //                    Ctrl.Otr.ConnCtrl[i].TimeOut     = 0;      //超时计数器清零。
    716          //                }
    717          //            } 
    718          //            
    719          //            OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    720          //                        ( OS_FLAGS     ) COMM_EVT_FLAG_OTR_RX,
    721          //                        ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    722          //                        ( CPU_TS       ) 0,
    723          //                        ( OS_ERR      *) &err);       
    724          //        }
    725          //        
    726          //        Ctrl.Otr.ConnectFlag       = 1;
    727          //        Ctrl.Otr.ConnectTimeOut    = 0;   
    728          //        
    729                  break;
    730              }
    731              
    732              return TRUE;
   \                     ??APP_CommRxDataDealCB_3: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \                     ??APP_CommRxDataDealCB_2: (+1)
   \   000000DC   0xB046             ADD      SP,SP,#+280
   \   000000DE   0xBD10             POP      {R4,PC}          ;; return
    733          }
    734          
    735          /***********************************************
    736          * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    737          */
    738          #if MB_IAPMODBUS_EN == DEF_ENABLED
    739          /*******************************************************************************
    740          * 名    称： APP_CommRxDataDealCB
    741          * 功    能： 串口数据处理回调函数，由MB_DATA.C调用
    742          * 入口参数： 无
    743          * 出口参数： 无
    744          * 作    者： 无名沈
    745          * 创建日期： 2016-01-04
    746          * 修    改：
    747          * 修改日期：
    748          * 备    注： 
    749          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    750          INT08U IAP_CommRxDataDealCB(MODBUS_CH  *pch)
    751          {
    752              //    CPU_SR_ALLOC();
    753              //    CPU_CRITICAL_ENTER();
    754              //    u8  Len     = pch->RxBufByteCtr;
    755              //    memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    756              //    CPU_CRITICAL_EXIT();
    757              //    
    758              //    /***********************************************
    759              //    * 描述： 获取帧头
    760              //    */    
    761              //    INT08U  *DataBuf    = pch->RxFrameData;
    762              //    
    763              //    /***********************************************
    764              //    * 描述： 接收数据处理
    765              //    */
    766              //    u8  DstAddr = 
    767              //    CSNC_GetData(	(unsigned char *)pch->RxFrameData,          //RecBuf,
    768              //                    (unsigned char	 )Len,                       //RecLen, 
    769              //                    (unsigned char *)DataBuf,                   //DataBuf,
    770              //                    (unsigned short *)&Len);                    //InfoLen)
    771              //    /***********************************************
    772              //    * 描述： 检测接收结束
    773              //    */
    774              //    if ( ( Len == 16) && 
    775              //         ( 0 >= memcmp((const char *)"IAP_pragram end!",(const char *)&pch->RxFrameData[8], 16) ) ) {
    776              //        /***********************************************
    777              //        * 描述： 发送数据处理
    778              //        */
    779              //        CSNC_SendData(	(MODBUS_CH      *)Ctrl.Com.pch,
    780              //                        (unsigned char  ) Ctrl.Com.SlaveAddr,          // SourceAddr,
    781              //                        (unsigned char  ) Ctrl.Com.Rd.Head.SrcAddr,    // DistAddr,
    782              //                        (unsigned char *)&pch->RxFrameData[8],          // DataBuf,
    783              //                        (unsigned short ) Len); 
    784              //        /***********************************************
    785              //        * 描述： 置位IAP结束标志位
    786              //        */
    787              //        OS_ERR err;
    788              //        OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    789              //                    ( OS_FLAGS     ) COMM_EVT_FLAG_IAP_END,
    790              //                    ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    791              //                    ( CPU_TS       ) 0,
    792              //                    ( OS_ERR      *) &err);
    793              //        
    794              //        return TRUE;
    795              //    }
    796              //    
    797              //    if ( ( Len == 18) && 
    798              //         ( 0 >= memcmp((const char *)"IAP_pragram start!",(const char *)&pch->RxFrameData[8], 18) ) ) {
    799              //        
    800              //#if defined     (IMAGE_A) || defined   (IMAGE_B)
    801              //#else
    802              //        /***********************************************
    803              //        * 描述： 发送数据处理
    804              //        */
    805              //        CSNC_SendData(	(MODBUS_CH      *)Ctrl.Com.pch,
    806              //                        (unsigned char  ) Ctrl.Com.SlaveAddr,          // SourceAddr,
    807              //                        (unsigned char  ) Ctrl.Com.Rd.Head.SrcAddr,    // DistAddr,
    808              //                        (unsigned char *)&pch->RxFrameData[8],         // DataBuf,
    809              //                        (unsigned int	 ) Len);                        // DataLen 
    810              //#endif
    811              //        IAP_Restart();
    812              //        Iap.FrameIdx    = 0;
    813              //        return TRUE;
    814              //    }
    815              //    
    816              //    if ( Iap.Status < IAP_STS_START )
    817              //        return TRUE;
    818              //    /***********************************************
    819              //    * 描述： 写数据
    820              //    */
    821              //    /***********************************************
    822              //    * 描述： 将数据打包给发送结构
    823              //    */
    824              //    Ctrl.Com.Wr.Head.DataLen       = 0;
    825              //    /***********************************************
    826              //    * 描述： 编辑应答内容
    827              //    */
    828              //    char str[20];
    829              //    usprintf(str,"\n%d",Iap.FrameIdx);
    830              //    str[19]  = 0;
    831              //    /***********************************************
    832              //    * 描述： 写数据到Flash
    833              //    */
    834              //    IAP_Program((StrIapState *)&Iap, (INT16U *)&pch->RxFrameData[8], Len, (INT16U )GetRecvFrameNbr() );
    835              //    /***********************************************
    836              //    * 描述： 发送数据处理
    837              //    */
    838              //    CSNC_SendData(	(MODBUS_CH     *) Ctrl.Com.pch,
    839              //                    (unsigned char  ) Ctrl.Com.SlaveAddr,                    // SourceAddr,
    840              //                    (unsigned char  ) Ctrl.Com.Rd.Head.SrcAddr,              // DistAddr,
    841              //                    (unsigned char *) str,                                    // DataBuf,
    842              //                    (unsigned short ) strlen(str));                           // DataLen 
    843              //    if ( Len < 128 ) {
    844              //        /***********************************************
    845              //        * 描述： 置位IAP结束标志位
    846              //        */
    847              //        OS_ERR err;
    848              //        OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    849              //                    ( OS_FLAGS     ) COMM_EVT_FLAG_IAP_END,
    850              //                    ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    851              //                    ( CPU_TS       ) 0,
    852              //                    ( OS_ERR      *) &err);
    853              //    } else {
    854              //        IAP_Programing();                               // 复位超时计数器
    855              //    }
    856              //        
    857              //    /***********************************************
    858              //    * 描述： 串口接受COMM模组的消息并处理
    859              //    */
    860              //    Ctrl.Com.ConnectTimeOut    = 0;                // 超时计数器清零
    861              //    Ctrl.Com.ConnectFlag       = TRUE;             // 转连接成功标志
    862              //    
    863                  return TRUE;
   \                     IAP_CommRxDataDealCB: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    864          }
    865          #endif
    866          
    867          /*******************************************************************************
    868          * 名    称： NMBS_FCxx_Handler
    869          * 功    能： 非MODBUS串口数据处理回调函数，由mbs_core.d调用。处理接收中断应答。
    870          * 入口参数： 无
    871          * 出口参数： 无
    872          * 作    者： 无名沈
    873          * 创建日期： 2017-02-03
    874          * 修    改：
    875          * 修改日期：
    876          * 备    注： 
    877          *******************************************************************************/
    878          extern OS_Q                MTR_RxQ;
    879          extern OS_Q                COM_RxQ;
    880          extern OS_Q                DTU_RxQ;

   \                                 In section .text, align 2, keep-with-next
    881          CPU_BOOLEAN  NMBS_FCxx_Handler (MODBUS_CH  *pch)
    882          {
   \                     NMBS_FCxx_Handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
    883              //OS_ERR      err;
    884              //   CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
    885              //    CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCtr-1],
    886              //                                       pch->RxBuf[pch->RxBufByteCtr-2]);
    887              CPU_INT16U  head    = BUILD_INT16U( pch->RxFrameData[1], pch->RxFrameData[0]);
   \   00000006   0xF504 0x7511      ADD      R5,R4,#+580
   \   0000000A   0x7868             LDRB     R0,[R5, #+1]
   \   0000000C   0x7829             LDRB     R1,[R5, #+0]
   \   0000000E   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   00000012   0xB280             UXTH     R0,R0
    888              CPU_INT16U  tail    = BUILD_INT16U( pch->RxFrameData[pch->RxBufByteCnt-1],
    889                                                 pch->RxFrameData[pch->RxBufByteCnt-2]);           //20170526 RxBufByteCtr 中断函数中动态更新。
    890              
    891              /***********************************************
    892              * 描述： 长沙南车DTU协议处理
    893              */
    894              
    895              if ( ( pch->RxFrameHead == head ) &&              
    896                  ( pch->RxFrameTail == tail ) ) {
   \   00000014   0xF204 0x314A      ADDW     R1,R4,#+842
   \   00000018   0x880A             LDRH     R2,[R1, #+0]
   \   0000001A   0x4282             CMP      R2,R0
   \   0000001C   0xD110             BNE.N    ??NMBS_FCxx_Handler_0
   \   0000001E   0x8E62             LDRH     R2,[R4, #+50]
   \   00000020   0x1912             ADDS     R2,R2,R4
   \   00000022   0xF202 0x2242      ADDW     R2,R2,#+578
   \   00000026   0x8849             LDRH     R1,[R1, #+2]
   \   00000028   0x7853             LDRB     R3,[R2, #+1]
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0xEB03 0x2202      ADD      R2,R3,R2, LSL #+8
   \   00000030   0xB292             UXTH     R2,R2
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD104             BNE.N    ??NMBS_FCxx_Handler_0
    897                      APP_CommRxDataDealCB(pch);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       APP_CommRxDataDealCB
    898                      /***********************************************
    899                      * 描述： 电表调试协议协议,电表协议协议处理处理
    900                      */
    901                  } else  if ( ( 0xAA55 == head ) || ( 0xAAAA == head ) ) {
    902                      OS_ERR  err;
    903                      
    904                      CPU_SR_ALLOC();
    905                      OS_CRITICAL_ENTER();
    906                      memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, pch->RxBufByteCnt );
    907                      OS_CRITICAL_EXIT();
    908                      
    909                      (void)OSQPost((OS_Q         *)&MTR_RxQ,
    910                                    (void         *) pch,
    911                                    //(OS_MSG_SIZE   ) pch->RxBufByteCtr,
    912                                    (OS_MSG_SIZE   ) pch->RxBufByteCnt,
    913                                    (OS_OPT        ) OS_OPT_POST_FIFO,
    914                                    (OS_ERR       *)&err);
    915                       //BSP_OS_TimeDly(5);
    916                       /***********************************************
    917                       * 描述： tax通讯协议
    918                       */  
    919                  } else {
    920          //            if(pch->PortNbr == 0)                       //串口0，做 
    921          //                if(TAX_FCxx_Handler(pch) == FALSE)     //tax通讯处理
    922                              return DEF_FALSE;
    923                  }
    924              return DEF_TRUE;
   \                     ??NMBS_FCxx_Handler_1: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??NMBS_FCxx_Handler_0: (+1)
   \   00000040   0xF64A 0x2155      MOVW     R1,#+43605
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD003             BEQ.N    ??NMBS_FCxx_Handler_2
   \   00000048   0xF64A 0x21AA      MOVW     R1,#+43690
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD138             BNE.N    ??NMBS_FCxx_Handler_3
   \                     ??NMBS_FCxx_Handler_2: (+1)
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x4607             MOV      R7,R0
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000005A   0x....             LDR.N    R6,??DataTable7_4
   \   0000005C   0x7830             LDRB     R0,[R6, #+0]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x7030             STRB     R0,[R6, #+0]
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x4638             MOV      R0,R7
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
   \   0000006C   0x8E62             LDRH     R2,[R4, #+50]
   \   0000006E   0xF104 0x0138      ADD      R1,R4,#+56
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy
   \   00000078   0x.... 0x....      BL       CPU_SR_Save
   \   0000007C   0x4605             MOV      R5,R0
   \   0000007E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000082   0x7830             LDRB     R0,[R6, #+0]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x7030             STRB     R0,[R6, #+0]
   \   00000088   0xB2C0             UXTB     R0,R0
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD10B             BNE.N    ??NMBS_FCxx_Handler_4
   \   0000008E   0x....             LDR.N    R0,??DataTable7_5
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD007             BEQ.N    ??NMBS_FCxx_Handler_4
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009A   0x4628             MOV      R0,R5
   \   0000009C   0x.... 0x....      BL       CPU_SR_Restore
   \   000000A0   0x.... 0x....      BL       OS_Sched0
   \   000000A4   0xE004             B.N      ??NMBS_FCxx_Handler_5
   \                     ??NMBS_FCxx_Handler_4: (+1)
   \   000000A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
   \                     ??NMBS_FCxx_Handler_5: (+1)
   \   000000B0   0xA801             ADD      R0,SP,#+4
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x2300             MOVS     R3,#+0
   \   000000B6   0x8E62             LDRH     R2,[R4, #+50]
   \   000000B8   0x4621             MOV      R1,R4
   \   000000BA   0x....             LDR.N    R0,??DataTable7_6
   \   000000BC   0x.... 0x....      BL       OSQPost
   \   000000C0   0xE7BC             B.N      ??NMBS_FCxx_Handler_1
   \                     ??NMBS_FCxx_Handler_3: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xBDFE             POP      {R1-R7,PC}
    925          }
    926          
    927          
    928          /*******************************************************************************
    929          * 名    称： APP_MaterCommHandler
    930          * 功    能： 电表串口数据处理函数
    931          * 入口参数： 无
    932          * 出口参数： 无
    933          * 作　　者： wumingshen.
    934          * 创建日期： 2015-03-28
    935          * 修    改：
    936          * 修改日期：
    937          *******************************************************************************/
    938          /***********************************************
    939          * 描述： 2015/12/07增加，用于非MODBBUS通信
    940          *        非MODBUS通信，带帧头帧尾的通信数据处理
    941          */
    942          #if MB_NONMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    943          CPU_BOOLEAN APP_MaterCommHandler (MODBUS_CH  *pch)
    944          {    
   \                     APP_MaterCommHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    945          //    uint8_t     fram_clr[4]     = {0};
    946          //	uint8_t     IDBuf[4]        = {0};
    947          //	uint8_t     clear_buf[24]   = {0};
    948          //	uint32_t    ID              = 0;
    949          //	uint32_t    utemp;
    950              
    951          	//TIME        system; 
    952              
    953              /***********************************************
    954              * 描述： 拷贝数据到数据区
    955              */
    956              //CPU_SR_ALLOC();
    957              //CPU_CRITICAL_ENTER();
    958              //uint32_t  Len     = pch->RxBufByteCnt;
    959              //memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    960              //CPU_CRITICAL_EXIT();
    961              uint32_t    Len       = pch->RxBufByteCnt;
   \   00000002   0xF100 0x0332      ADD      R3,R0,#+50
   \   00000006   0x881C             LDRH     R4,[R3, #+0]
   \   00000008   0x4621             MOV      R1,R4
    962              INT08U      *DataBuf  = pch->RxFrameData;
   \   0000000A   0xF500 0x7211      ADD      R2,R0,#+580
    963              
    964              
    965              CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
   \   0000000E   0x79DD             LDRB     R5,[R3, #+7]
   \   00000010   0x799B             LDRB     R3,[R3, #+6]
   \   00000012   0xEB05 0x2303      ADD      R3,R5,R3, LSL #+8
    966              CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCnt-1],
    967                                                 pch->RxBuf[pch->RxBufByteCnt-2]);
    968              /***********************************************
    969              * 描述： 长沙南车DTU协议处理
    970              */
    971              if ( ( pch->RxFrameHead == head ) &&
    972                  ( pch->RxFrameTail == tail ) ) {
   \   00000016   0xF200 0x354A      ADDW     R5,R0,#+842
   \   0000001A   0x882E             LDRH     R6,[R5, #+0]
   \   0000001C   0xB29B             UXTH     R3,R3
   \   0000001E   0x429E             CMP      R6,R3
   \   00000020   0xD10F             BNE.N    ??APP_MaterCommHandler_0
   \   00000022   0x1824             ADDS     R4,R4,R0
   \   00000024   0x3436             ADDS     R4,R4,#+54
   \   00000026   0x886D             LDRH     R5,[R5, #+2]
   \   00000028   0x7866             LDRB     R6,[R4, #+1]
   \   0000002A   0x7824             LDRB     R4,[R4, #+0]
   \   0000002C   0xEB06 0x2404      ADD      R4,R6,R4, LSL #+8
   \   00000030   0xB2A4             UXTH     R4,R4
   \   00000032   0x42A5             CMP      R5,R4
   \   00000034   0xD105             BNE.N    ??APP_MaterCommHandler_0
    973                      DataBuf = &pch->RxFrameData[8];
   \   00000036   0xF500 0x7213      ADD      R2,R0,#+588
    974                      //        Len     = Ctrl.Com.Rd.Head.DataLen;        
    975                      head    = BUILD_INT16U(DataBuf[1], DataBuf[0]);
   \   0000003A   0x7850             LDRB     R0,[R2, #+1]
   \   0000003C   0x7813             LDRB     R3,[R2, #+0]
   \   0000003E   0xEB00 0x2303      ADD      R3,R0,R3, LSL #+8
    976                  }
    977              
    978              /***********************************************
    979              * 描述： 
    980              序号    内容       字节数 内容说明
    981              1       帧头       2      0xAA 0xAA
    982              2       帧长度     1      0x08 帧长度固定为8字节
    983              3       命令类型   2      0x00 0x01
    984              4       预留       2      0x00 0x00
    985              5       累加和     1      前7个字节的累加和
    986              */ 
    987              if ( 0xAAAA == head ) {
   \                     ??APP_MaterCommHandler_0: (+1)
   \   00000042   0xB29B             UXTH     R3,R3
   \   00000044   0xF64A 0x20AA      MOVW     R0,#+43690
   \   00000048   0x4283             CMP      R3,R0
   \   0000004A   0xD103             BNE.N    ??APP_MaterCommHandler_1
    988                  Len            -= 1;
    989                  int8_t chkSum   = GetCheckSum(DataBuf,Len);
   \   0000004C   0x1E49             SUBS     R1,R1,#+1
   \   0000004E   0x4610             MOV      R0,R2
   \   00000050   0x.... 0x....      BL       GetCheckSum
    990                  
    991                  if ( chkSum ==  DataBuf[Len] ) {
    992                      //            pch->TxFrameData[0]     = 0xAA;
    993                      //            pch->TxFrameData[1]     = 0xAA;
    994                      //            pch->TxFrameData[2]     = 0x30;
    995                      //            pch->TxFrameData[3]     = 0x00;
    996                      //            pch->TxFrameData[4]     = 0x71;
    997                      //            
    998                      //            CPU_SR  cpu_sr;
    999                      //            OS_CRITICAL_ENTER();
   1000                      //            memcpy(&pch->TxFrameData[5],(uint8_t *)&Mater.Energy, sizeof(StrEnergy));
   1001                      //            OS_CRITICAL_EXIT();
   1002                      //            
   1003                      //            pch->TxFrameData[45]    = 0x00;
   1004                      //            pch->TxFrameData[46]    = 0x00;
   1005                      //            
   1006                      //            pch->TxFrameData[47]    = GetCheckSum(pch->TxFrameData,47);
   1007                      //            
   1008                      //            NMB_Tx((MODBUS_CH   *)pch,
   1009                      //                   (CPU_INT08U  *)pch->TxFrameData,
   1010                      //                   (CPU_INT16U   )48);
   1011                      return TRUE;
   1012                  }
   1013                  /***********************************************
   1014                  * 描述： 调试参数
   1015                  */
   1016              } else if ( ( 0xAA55 == head ) && ( Len > 10 )) {
   1017                  /***********************************************
   1018                  * 描述： 检测是否有帧尾，没有帧尾则进行CRC校验
   1019                  */
   1020                  if ( tail != 0x55AA  ) {
   1021                      //uint16_t crc16_Cal = crc16((uint8_t *)&DataBuf[0],9);
   1022                      //uint16_t crc16_Rec = BUILD_INT16U(DataBuf[9],DataBuf[10]);
   1023                      //if(crc16_Cal != crc16_Rec) {                
   1024                      //    return TRUE;
   1025                      //}
   1026                  }
   1027                  switch(DataBuf[2])
   1028                  {
   1029                      /***********************************************
   1030                      * 描述： 设置序列号
   1031                      */
   1032                  case 0xA1:
   1033                      //ID = BUILD_INT32U(DataBuf[3], DataBuf[4], DataBuf[5], DataBuf[6]);
   1034                      //WriteFM24CL64(64 , (uint8_t *)&ID , 4);
   1035                      //ReadFM24CL64(64 , (uint8_t *)&ID , 4);
   1036                      //uartprintf(pch,"\r\n 本装置ID设置为：%d\r\n" , ID);
   1037                      break;            
   1038                      /***********************************************
   1039                      * 描述： 设置机车型号/机车号
   1040                      */
   1041                  case 0xA2:	
   1042                      //Mater.LocoTyp   = BUILD_INT16U(DataBuf[3],DataBuf[4]);
   1043                      //Mater.LocoNbr   = BUILD_INT16U(DataBuf[5],DataBuf[6]);
   1044                      //WriteFM24CL64(68 , (uint8_t *)&Mater.LocoTyp, 2);
   1045                      //WriteFM24CL64(70 , (uint8_t *)&Mater.LocoNbr, 2);
   1046                      //ReadFM24CL64(68 ,  (uint8_t *)&Mater.LocoTyp, 2);
   1047                      //ReadFM24CL64(70 ,  (uint8_t *)&Mater.LocoNbr, 2);
   1048                      //uartprintf(pch,"\r\n 当前车型：%d；当前车号：%d\r\n", Mater.LocoTyp,Mater.LocoNbr);
   1049                      break; 
   1050                      /***********************************************
   1051                      * 描述： 设置时间
   1052                      */
   1053                  case 0xA3:
   1054                      //            system.Year     =DataBuf[3];
   1055                      //            system.Month    =DataBuf[4];
   1056                      //            system.Day      =DataBuf[5];
   1057                      //            system.Hour     =DataBuf[6];
   1058                      //            system.Min      =DataBuf[7];
   1059                      //            system.Sec      =DataBuf[8];
   1060                      //            WriteTime(system);
   1061                      //            GetTime((TIME *)&recordsfr.Time[0]);
   1062                      //            uartprintf(pch,"\r\n 当前时间为：20%02d-%02d-%02d  %02d:%02d:%02d", 
   1063                      //                       recordsfr.Time[0], recordsfr.Time[1], recordsfr.Time[2],
   1064                      //                       recordsfr.Time[3], recordsfr.Time[4], recordsfr.Time[5]);
   1065                      break;
   1066                      
   1067                  default:
   1068                      break;
   1069                  }
   1070              }
   1071              /***********************************************
   1072              * 描述： 调用串口数据处理回调函数
   1073              */ 
   1074              return TRUE;
   \                     ??APP_MaterCommHandler_1: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   1075          }
   1076          
   1077          /*******************************************************************************
   1078          * 名    称： APP_CSNC_CommHandler
   1079          * 功    能： 串口数据处理函数
   1080          * 入口参数： 无
   1081          * 出口参数： 无
   1082          * 作　　者： wumingshen.
   1083          * 创建日期： 2015-03-28
   1084          * 修    改：
   1085          * 修改日期：
   1086          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1087          CPU_BOOLEAN APP_CSNC_CommHandler (MODBUS_CH  *pch)
   1088          {   
   1089              //    if ( pch->PortNbr == Ctrl.Dtu.pch->PortNbr ) {
   1090              //        if ( GetRecvFrameNbr() == Ctrl.Com.Rd.Head.PacketSn ) {
   1091              //            /***********************************************
   1092              //            * 描述： 清除定时上传标志
   1093              //            */
   1094              //            //SetSendFrameNbr();
   1095              //            //extern void UpdateRecordPoint(uint8_t storeflag);
   1096              //            //UpdateRecordPoint(1);
   1097              //            //pch->StatNoRespCtr  = 0;
   1098              //            
   1099              //            //osal_set_event( OS_TASK_ID_TMR, OS_EVT_TMR_MIN);
   1100              //        }
   1101              //    } else {
   1102              //        /***********************************************
   1103              //        * 描述： 将数据打包给发送结构
   1104              //        */ 
   1105              //        APP_MaterCommHandler(pch);
   1106              //    }
   1107              //    
   1108              //    /***********************************************
   1109              //    * 描述： 串口接受COMM模组的消息并处理
   1110              //    */
   1111              //    Ctrl.Com.ConnectTimeOut    = 0;                // 超时计数器清零
   1112              //    Ctrl.Com.ConnectFlag       = TRUE;             // 转连接成功标志
   1113              //    
   1114              return TRUE;
   \                     APP_CSNC_CommHandler: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1115          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     AppTaskCommTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     WdtFlagGRP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     WdtFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     MTR_RxQ

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x41 0x70          DC8 "App Task Comm"
   \              0x70 0x20    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x20 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x41 0x70          DC8 "App_CommFlag"
   \              0x70 0x5F    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x46 0x6C    
   \              0x61 0x67    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1116          #endif
   1117          /*******************************************************************************
   1118          * 				end of file
   1119          *******************************************************************************/
   1120          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   APP_CSNC_CommHandler
      16   APP_CommInit
        16   -> App_ModbusInit
        16   -> OSFlagCreate
     288   APP_CommRxDataDealCB
       288   -> DataUnpack_CSNC
       288   -> OS_FlagPost
       288   -> __aeabi_memcpy
      16   APP_MaterCommHandler
        16   -> GetCheckSum
      24   AppTaskComm
        24   -> APP_CommInit
        24   -> OSFlagPend
        24   -> OSFlagPost
        24   -> OS_FlagPost
        24   -> app_comm_dtu
        24   -> app_comm_mtr
      40   App_ModbusInit
        40   -> MB_CfgCh
        40   -> MB_Init
      48   App_TaskCommCreate
        48   -> OSTaskCreate
       0   IAP_CommRxDataDealCB
      32   NMBS_FCxx_Handler
        32   -> APP_CommRxDataDealCB
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSQPost
        32   -> OS_Sched0
        32   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
      16  ?_0
      16  ?_1
       4  APP_CSNC_CommHandler
      44  APP_CommInit
     224  APP_CommRxDataDealCB
      88  APP_MaterCommHandler
     160  AppTaskComm
    1208  AppTaskCommTCB
          AppTaskCommStk
     176  App_ModbusInit
      60  App_TaskCommCreate
       4  IAP_CommRxDataDealCB
      36  MTR_RxQ
     198  NMBS_FCxx_Handler
      44  OSTmr1

 
 1 288 bytes in section .bss
 1 018 bytes in section .text
 
 1 018 bytes of CODE memory
 1 288 bytes of DATA memory

Errors: none
Warnings: none
