###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       16/Nov/2017  10:23:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\SZ_STM32F107VC_LIB.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\SZ_STM32F107VC_LIB.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\SZ_STM32F107VC_LIB.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\SZ_STM32F107VC_LIB.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\SZ_STM32F107VC_LIB.c
      1          /********************   (C) COPYRIGHT 2013 www.armjishu.com   ********************
      2          * 文件名  ：SZ_STM32F107VC_LIB.c
      3          * 描述    ：提供STM32F107VC神舟IV号开发板的库函数
      4          * 实验平台：STM32神舟开发板
      5          * 作者    ：www.armjishu.com 
      6          **********************************************************************************/
      7          
      8          /* Includes ------------------------------------------------------------------*/
      9          #include "SZ_STM32F107VC_LIB.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0x0109             LSLS     R1,R1,#+4
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD507             BPL.N    ??NVIC_SetPriority_0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0xe000ed18
   \   0000000A   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000E   0x1880             ADDS     R0,R0,R2
   \   00000010   0xF800 0x1C04      STRB     R1,[R0, #-4]
   \   00000014   0x4770             BX       LR
   \                     ??NVIC_SetPriority_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xe000e400
   \   0000001A   0x5481             STRB     R1,[R0, R2]
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000008   0xD301             BCC.N    ??SysTick_Config_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD10             POP      {R4,PC}
   \                     ??SysTick_Config_0: (+1)
   \   0000000E   0x....             LDR.N    R4,??DataTable20_2  ;; 0xe000e010
   \   00000010   0x6060             STR      R0,[R4, #+4]
   \   00000012   0x210F             MOVS     R1,#+15
   \   00000014   0xF04F 0x30FF      MOV      R0,#-1
   \   00000018   0x.... 0x....      BL       NVIC_SetPriority
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x60A0             STR      R0,[R4, #+8]
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0x6020             STR      R0,[R4, #+0]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
     10          #include "RS485.h"
     11          #include "POWER_MACRO.h"
     12          #include "SPI_CS5463_AC.h"
     13          #include "FM24CL64.h"
     14          #include "MX25.h"
     15          #include "DS3231.h"
     16          #include "crccheck.h"
     17          #include "delay.h"
     18          #include <includes.h>
     19          

   \                                 In section .bss, align 4
     20          __IO uint32_t TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
     21          

   \                                 In section .data, align 4
     22          USART_TypeDef* COM_USART[COMn] = {SZ_STM32_COM1, SZ_STM32_COM2}; 
   \                     COM_USART:
   \   00000000   0x40013800         DC32 40013800H, 40004400H
   \              0x40004400   
     23          GPIO_TypeDef* COM_TX_PORT[COMn] = {SZ_STM32_COM1_TX_GPIO_PORT, SZ_STM32_COM2_TX_GPIO_PORT};
   \                     COM_TX_PORT:
   \   00000008   0x40010800         DC32 40010800H, 40010800H
   \              0x40010800   
     24          GPIO_TypeDef* COM_RX_PORT[COMn] = {SZ_STM32_COM1_RX_GPIO_PORT, SZ_STM32_COM2_RX_GPIO_PORT};
   \                     COM_RX_PORT:
   \   00000010   0x40010800         DC32 40010800H, 40010800H
   \              0x40010800   

   \                                 In section .text, align 4, keep-with-next
     25          const uint32_t COM_USART_CLK[COMn] = {SZ_STM32_COM1_CLK, SZ_STM32_COM2_CLK};
   \                     COM_USART_CLK:
   \   00000000   0x00004000         DC32 16384, 131072
   \              0x00020000   

   \                                 In section .text, align 4, keep-with-next
     26          const uint32_t COM_TX_PORT_CLK[COMn] = {SZ_STM32_COM1_TX_GPIO_CLK, SZ_STM32_COM2_TX_GPIO_CLK};
   \                     COM_TX_PORT_CLK:
   \   00000000   0x00000004         DC32 4, 4
   \              0x00000004   

   \                                 In section .text, align 4, keep-with-next
     27          const uint32_t COM_RX_PORT_CLK[COMn] = {SZ_STM32_COM1_RX_GPIO_CLK, SZ_STM32_COM2_RX_GPIO_CLK};
   \                     COM_RX_PORT_CLK:
   \   00000000   0x00000004         DC32 4, 4
   \              0x00000004   

   \                                 In section .text, align 4, keep-with-next
     28          const uint16_t COM_TX_PIN[COMn] = {SZ_STM32_COM1_TX_PIN, SZ_STM32_COM2_TX_PIN};
   \                     COM_TX_PIN:
   \   00000000   0x0200 0x0004      DC16 512, 4

   \                                 In section .text, align 4, keep-with-next
     29          const uint16_t COM_RX_PIN[COMn] = {SZ_STM32_COM1_RX_PIN, SZ_STM32_COM2_RX_PIN};
   \                     COM_RX_PIN:
   \   00000000   0x0400 0x0008      DC16 1024, 8
     30          

   \                                 In section .bss, align 4
     31          uint32_t STM32DeviceSerialID[3]; /* 全局变量IntDeviceSerial存放读到的设备ID */
   \                     STM32DeviceSerialID:
   \   00000000                      DS8 12
     32          
     33          /**-------------------------------------------------------
     34          * @函数名 delay
     35          * @功能   简单的delay延时函数.
     36          * @参数   延迟周期数 0--0xFFFFFFFF
     37          * @返回值 无
     38          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     39          void delay(__IO uint32_t nCount)
     40          {
   \                     delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \   00000002   0xE002             B.N      ??delay_0
     41              for (; nCount != 0; nCount--);
   \                     ??delay_1: (+1)
   \   00000004   0x9800             LDR      R0,[SP, #+0]
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \                     ??delay_0: (+1)
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD1F9             BNE.N    ??delay_1
     42          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
     43          
     44          /**-------------------------------------------------------
     45          * @函数名 NVIC_GroupConfig
     46          * @功能   配置NVIC中断优先级分组函数.
     47          *         默认配置为1比特表示主优先级, 3比特表示次优先级
     48          *         用户可以根据需要修改
     49          * @参数   无
     50          * @返回值 无
     51          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     52          void NVIC_GroupConfig(void)
     53          {
     54              /* 配置NVIC中断优先级分组:
     55              - 1比特表示主优先级  主优先级合法取值为 0 或 1 
     56              - 3比特表示次优先级  次优先级合法取值为 0..7
     57              - 数值越低优先级越高，取值超过合法范围时取低bit位 
     58              */
     59              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   \                     NVIC_GroupConfig: (+1)
   \   00000000   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000004   0x.... 0x....      B.W      NVIC_PriorityGroupConfig
     60              
     61              /*==================================================================================
     62              NVIC_PriorityGroup   |  主优先级范围  |  次优先级范围  |   描述
     63              ==================================================================================
     64              NVIC_PriorityGroup_0  |      0         |      0-15      |   0 比特表示主优先级
     65              |                |                |   4 比特表示次优先级 
     66              ----------------------------------------------------------------------------------
     67              NVIC_PriorityGroup_1  |      0-1       |      0-7       |   1 比特表示主优先级
     68              |                |                |   3 比特表示次优先级 
     69              ----------------------------------------------------------------------------------
     70              NVIC_PriorityGroup_2  |      0-3       |      0-3       |   2 比特表示主优先级
     71              |                |                |   2 比特表示次优先级 
     72              ----------------------------------------------------------------------------------
     73              NVIC_PriorityGroup_3  |      0-7       |      0-1       |   3 比特表示主优先级
     74              |                |                |   1 比特表示次优先级 
     75              ----------------------------------------------------------------------------------
     76              NVIC_PriorityGroup_4  |      0-15      |      0         |   4 比特表示主优先级
     77              |                |                |   0 比特表示次优先级   
     78              ==================================================================================*/
     79          }
     80          
     81          /**-------------------------------------------------------
     82          * @函数名 SZ_STM32_SysTickInit
     83          * @功能   初始化系统定时器SysTick
     84          *         用户可以根据需要修改
     85          * @参数   每秒中断次数
     86          * @返回值 无
     87          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     88          void SZ_STM32_SysTickInit(uint32_t HzPreSecond)
     89          {
   \                     SZ_STM32_SysTickInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     90              /* HzPreSecond = 1000 to Setup SysTick Timer for 1 msec interrupts.
     91              ------------------------------------------
     92              1. The SysTick_Config() function is a CMSIS function which configure:
     93              - The SysTick Reload register with value passed as function parameter.
     94              - Configure the SysTick IRQ priority to the lowest value (0x0F).
     95              - Reset the SysTick Counter register.
     96              - Configure the SysTick Counter clock source to be Core Clock Source (HCLK).
     97              - Enable the SysTick Interrupt.
     98              - Start the SysTick Counter.
     99              
    100              2. You can change the SysTick Clock source to be HCLK_Div8 by calling the
    101              SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8) just after the
    102              SysTick_Config() function call. The SysTick_CLKSourceConfig() is defined
    103              inside the misc.c file.
    104              
    105              3. You can change the SysTick IRQ priority by calling the
    106              NVIC_SetPriority(SysTick_IRQn,...) just after the SysTick_Config() function 
    107              call. The NVIC_SetPriority() is defined inside the core_cm3.h file.
    108              
    109              4. To adjust the SysTick time base, use the following formula:
    110              
    111              Reload Value = SysTick Counter Clock (Hz) x  Desired Time base (s)
    112              - Reload Value is the parameter to be passed for SysTick_Config() function
    113              - Reload Value should not exceed 0xFFFFFF
    114              */
    115              if (SysTick_Config(SystemCoreClock / HzPreSecond))
   \   00000002   0x....             LDR.N    R1,??DataTable20_3
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000000A   0x.... 0x....      BL       SysTick_Config
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD000             BEQ.N    ??SZ_STM32_SysTickInit_0
    116              { 
    117                  /* Capture error */ 
    118                  while (1);
   \                     ??SZ_STM32_SysTickInit_1: (+1)
   \   00000012   0xE7FE             B.N      ??SZ_STM32_SysTickInit_1
    119              }
    120          }
   \                     ??SZ_STM32_SysTickInit_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    121          
    122          /**-------------------------------------------------------
    123          * @函数名 SysTickDelay
    124          * @功能   系统定时器实现的延时函数，可以在用户程序中调用
    125          *         用户可以根据需要修改
    126          * @参数   延迟周期数，延迟时间为nTime/HzPreSecond
    127          *         误差为 -1/HzPreSecond
    128          * @返回值 无
    129          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    130          void SysTickDelay(__IO uint32_t nTime)
    131          { 
   \                     SysTickDelay: (+1)
   \   00000000   0xB401             PUSH     {R0}
    132              TimingDelay = nTime;
   \   00000002   0x....             LDR.N    R0,??DataTable20_4
   \   00000004   0x9900             LDR      R1,[SP, #+0]
   \   00000006   0x6001             STR      R1,[R0, #+0]
    133              
    134              while(TimingDelay != 0);
   \                     ??SysTickDelay_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD1FC             BNE.N    ??SysTickDelay_0
    135          }
   \   0000000E   0xB001             ADD      SP,SP,#+4
   \   00000010   0x4770             BX       LR               ;; return
    136          
    137          /**-------------------------------------------------------
    138          * @函数名 TimingDelay_Decrement
    139          * @功能   系统节拍定时器服务函数调用的子函数
    140          *         将全局变量TimingDelay减一，用于实现延时
    141          * @参数   无
    142          * @返回值 无
    143          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    144          void TimingDelay_Decrement(void)
    145          {
    146              if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_4
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??TimingDelay_Decrement_0
    147              { 
    148                  TimingDelay--;
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    149              }
    150          }
   \                     ??TimingDelay_Decrement_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    151          
    152          extern void SysTick_Handler_User(void);
    153          /**-------------------------------------------------------
    154          * @函数名 SysTick_Handler
    155          * @功能   系统节拍定时器服务请求处理函数
    156          * @参数   无
    157          * @返回值 无
    158          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    159          void SysTick_Handler(void)
    160          {
   \                     SysTick_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    161              TimingDelay_Decrement();
   \   00000002   0x.... 0x....      BL       TimingDelay_Decrement
    162              
    163              SysTick_Handler_User();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      SysTick_Handler_User
    164          }
    165          

   \                                 In section .text, align 2, keep-with-next
    166          void GetDeviceSerialID(void)
    167          {
    168              STM32DeviceSerialID[0] = *(__IO uint32_t*)(0x1FFFF7E8);
   \                     GetDeviceSerialID: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_5
   \   00000002   0x....             LDR.N    R1,??DataTable20_6  ;; 0x1ffff7e8
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x6002             STR      R2,[R0, #+0]
    169              STM32DeviceSerialID[1] = *(__IO uint32_t*)(0x1FFFF7EC);
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x6042             STR      R2,[R0, #+4]
    170              STM32DeviceSerialID[2] = *(__IO uint32_t*)(0x1FFFF7F0);
   \   0000000C   0x6889             LDR      R1,[R1, #+8]
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    171          }
   \   00000010   0x4770             BX       LR               ;; return
    172          
    173          /**-------------------------------------------------------
    174          * @函数名 __SZ_STM32_COMInit
    175          * @功能   对STM32的USART初始化底层函数
    176          * @参数1  COM1  对应STM32的USART1 对应开发板上串口1
    177          *         COM2  对应STM32的USART2 对应开发板上串口2
    178          * @参数2  指向一个成员已赋值USART_InitTypeDef结构体的指针
    179          * @返回值 无
    180          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    181          void __SZ_STM32_COMInit(COM_TypeDef COM, USART_InitTypeDef* USART_InitStruct)
    182          {
   \                     __SZ_STM32_COMInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
    183              GPIO_InitTypeDef GPIO_InitStructure;
    184              
    185              /* Enable GPIO clock */
    186              /* 使能STM32的USART对应GPIO的Clock时钟 */
    187              RCC_APB2PeriphClockCmd(COM_TX_PORT_CLK[COM] | COM_RX_PORT_CLK[COM] | RCC_APB2Periph_AFIO, ENABLE);
   \   00000008   0x4635             MOV      R5,R6
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x.... 0x....      ADR.W    R0,COM_TX_PORT_CLK
   \   00000010   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000014   0x.... 0x....      ADR.W    R2,COM_RX_PORT_CLK
   \   00000018   0xF852 0x2025      LDR      R2,[R2, R5, LSL #+2]
   \   0000001C   0x4310             ORRS     R0,R2,R0
   \   0000001E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    188              
    189              if (COM == COM1)
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD105             BNE.N    ??__SZ_STM32_COMInit_0
    190              {
    191                  /* 使能STM32的USART1/USART2/USART3的Clock时钟 */
    192                  RCC_APB2PeriphClockCmd(COM_USART_CLK[COM], ENABLE); 
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000030   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   00000034   0xE006             B.N      ??__SZ_STM32_COMInit_1
    193              }
    194              else
    195              {
    196                  /* Enable the USART2 Pins Software Remapping */
    197                  /* 使能STM32的USART2的管脚重映射 */
    198                  //        GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);    //电表电路中无需映射
    199                  /* 使能STM32的USART的Clock时钟 */
    200                  RCC_APB1PeriphClockCmd(COM_USART_CLK[COM], ENABLE);
   \                     ??__SZ_STM32_COMInit_0: (+1)
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x.... 0x....      ADR.W    R0,COM_USART_CLK
   \   0000003C   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000040   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    201              }
    202              
    203              /* Configure USART Tx as alternate function push-pull */
    204              /* 初始化STM32的USART的TX管脚，配置为复用功能推挽输出 */
    205              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \                     ??__SZ_STM32_COMInit_1: (+1)
   \   00000044   0x2018             MOVS     R0,#+24
   \   00000046   0xF88D 0x0003      STRB     R0,[SP, #+3]
    206              GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
   \   0000004A   0x.... 0x....      ADR.W    R0,COM_TX_PIN
   \   0000004E   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000052   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    207              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xF88D 0x0002      STRB     R0,[SP, #+2]
    208              GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
   \   0000005C   0x....             LDR.N    R0,??DataTable20_7
   \   0000005E   0xEB00 0x0685      ADD      R6,R0,R5, LSL #+2
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x68B0             LDR      R0,[R6, #+8]
   \   00000066   0x.... 0x....      BL       GPIO_Init
    209              
    210              /* Configure USART Rx as input floating */
    211              /* 初始化STM32的USART的RX管脚，配置为复用功能输入 */
    212              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000006A   0x2004             MOVS     R0,#+4
   \   0000006C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    213              GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
   \   00000070   0x.... 0x....      ADR.W    R0,COM_RX_PIN
   \   00000074   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000078   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    214              GPIO_Init(COM_RX_PORT[COM], &GPIO_InitStructure);
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0x6930             LDR      R0,[R6, #+16]
   \   00000080   0x.... 0x....      BL       GPIO_Init
    215              
    216              /* USART configuration */
    217              /* 根据传入的参数初始化STM32的USART配置 */
    218              USART_Init(COM_USART[COM], USART_InitStruct);
   \   00000084   0x4621             MOV      R1,R4
   \   00000086   0x6830             LDR      R0,[R6, #+0]
   \   00000088   0x.... 0x....      BL       USART_Init
    219              
    220              /* Enable USART */
    221              /* 使能STM32的USART功能模块 */
    222              USART_Cmd(COM_USART[COM], ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x6830             LDR      R0,[R6, #+0]
   \   00000090   0x.... 0x....      BL       USART_Cmd
    223          }
   \   00000094   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    224          
    225          /**-------------------------------------------------------
    226          * @函数名 __SZ_STM32_COMInit
    227          * @功能   面向用户的STM32的USART初始化函数
    228          * @参数1  COM1  对应STM32的USART1 对应开发板上串口1
    229          *         COM2  对应STM32的USART2 对应开发板上串口2
    230          * @参数2  BaudRate 串口的波特率，例如"115200"
    231          * @返回值 无
    232          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    233          void SZ_STM32_COMInit(COM_TypeDef COM, uint32_t BaudRate)
    234          {
   \                     SZ_STM32_COMInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    235              
    236              USART_InitTypeDef USART_InitStructure;
    237              
    238              /* USARTx 默认配置:
    239              - BaudRate = 115200 baud  
    240              - Word Length = 8 Bits
    241              - One Stop Bit
    242              - No parity
    243              - Hardware flow control disabled (RTS and CTS signals)
    244              - Receive and transmit enabled
    245              */
    246              USART_InitStructure.USART_BaudRate = BaudRate;              //串口的波特率，例如115200 最高达4.5Mbits/s
   \   00000004   0x9100             STR      R1,[SP, #+0]
    247              USART_InitStructure.USART_WordLength = USART_WordLength_8b; //数据字长度(8位或9位)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x9101             STR      R1,[SP, #+4]
    248              USART_InitStructure.USART_StopBits = USART_StopBits_1;      //可配置的停止位-支持1或2个停止位
    249              USART_InitStructure.USART_Parity = USART_Parity_No;         //无奇偶校验  
   \   0000000A   0xF8AD 0x1008      STRH     R1,[SP, #+8]
    250              USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件流控制
   \   0000000E   0xF8AD 0x100C      STRH     R1,[SP, #+12]
    251              USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //双工模式，使能发送和接收
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0xF8AD 0x100A      STRH     R1,[SP, #+10]
    252              
    253              __SZ_STM32_COMInit(COM, &USART_InitStructure);  // 调用STM32的USART初始化底层函数
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x.... 0x....      BL       __SZ_STM32_COMInit
    254              
    255              SystemCoreClockUpdate();
   \   0000001E   0x.... 0x....      BL       SystemCoreClockUpdate
    256              //    printf("\n\r 系统内核时钟频率(SystemCoreClock)为：%dHz.\n\r",
    257              //            SystemCoreClock);
    258          }
   \   00000022   0xB005             ADD      SP,SP,#+20
   \   00000024   0xBD00             POP      {PC}             ;; return
    259          
    260          /**-------------------------------------------------------
    261          * @函数名 NVIC_COMConfiguration
    262          * @功能   配置串口1和串口2的中断参数
    263          * @参数   无
    264          * @返回值 无
    265          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    266          void NVIC_COMConfiguration(void)
    267          {
   \                     NVIC_COMConfiguration: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    268              NVIC_InitTypeDef NVIC_InitStructure;
    269              
    270              USART_ITConfig(SZ_STM32_COM1, USART_IT_RXNE, ENABLE);
   \   00000004   0xF240 0x5425      MOVW     R4,#+1317
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0x....             LDR.N    R0,??DataTable20_8  ;; 0x40013800
   \   0000000E   0x.... 0x....      BL       USART_ITConfig
    271              
    272              NVIC_InitStructure.NVIC_IRQChannel = SZ_STM32_COM1_IRQn;
   \   00000012   0x2025             MOVS     R0,#+37
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    273              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    274              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    275              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000022   0xF88D 0x0003      STRB     R0,[SP, #+3]
    276              
    277              NVIC_Init(&NVIC_InitStructure);
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       NVIC_Init
    278              
    279              USART_ITConfig(SZ_STM32_COM2, USART_IT_RXNE, ENABLE);
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x....             LDR.N    R0,??DataTable20_9  ;; 0x40004400
   \   00000032   0x.... 0x....      BL       USART_ITConfig
    280              
    281              NVIC_InitStructure.NVIC_IRQChannel = SZ_STM32_COM2_IRQn;
   \   00000036   0x2026             MOVS     R0,#+38
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
    282              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    283              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
   \   00000042   0xF88D 0x0002      STRB     R0,[SP, #+2]
    284              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF88D 0x0003      STRB     R0,[SP, #+3]
    285              
    286              NVIC_Init(&NVIC_InitStructure);
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x.... 0x....      BL       NVIC_Init
    287          }
   \   00000052   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    288          

   \                                 In section .bss, align 4
    289          UART1 rx,tx;
   \                     rx:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
   \                     tx:
   \   00000000                      DS8 28
    290          //
    291          //void USART_GetInputString(void)
    292          //{
    293          //	uint8_t mychar = 0;
    294          //
    295          //	mychar = USART_ReceiveData(USART1);
    296          //	if(rx.ok == 0)
    297          //	{
    298          //		if(mychar == '\r')
    299          //		{
    300          //			rx.buf[rx.ptr] = '\0';
    301          //			rx.ok = 1;
    302          //		}
    303          //		else if(mychar == '\b')
    304          //		{
    305          //			if(rx.ptr > 0)
    306          //			{	
    307          //				rx.ptr--;
    308          //			}
    309          //		}
    310          //	    else 
    311          //		{
    312          //			rx.buf[rx.ptr++] = mychar;
    313          //			printf("%d,  %x ",rx.ptr,mychar);
    314          //		}
    315          //		if(rx.ptr >= 3)
    316          //		{
    317          //		 	rx.buf[rx.ptr] = '\0';
    318          //			rx.ok = 1;
    319          //		}
    320          //	}
    321          //}
    322          //
    323          //
    324          ////Usart_1IrqHandlerUser()
    325          ////{
    326          ////	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    327          ////    {
    328          ////         /* clear interrupt */
    329          ////		USART_GetInputString();	
    330          ////		while(USART_GetITStatus(USART1, USART_IT_RXNE) == RESET);
    331          ////	}
    332          ////	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    333          ////	{
    334          ////		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    335          ////    }
    336          ////
    337          ////    /* If overrun condition occurs, clear the ORE flag 
    338          ////                              and recover communication */
    339          ////     /*数据溢出*/
    340          ////    if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET)
    341          ////    {
    342          //////		rs = USART_GetITStatus(USART1, USART_IT_RXNE);
    343          //////		printf("RXNE状态为%d！",rs);
    344          //////        printf("数据溢出");
    345          //////		USART_ClearFlag(USART1,USART_FLAG_ORE);
    346          //////		rx.buf[rx.ptr++] = 	USART1->DR & 0x01FF;
    347          //////		printf("%d  , %x  ,  ",rx.ptr,rx.buf[rx.ptr-1]);
    348          ////		(void)USART_ReceiveData(USART1);
    349          ////    }
    350          ////  	 /*发送完成*/
    351          ////	if (USART_GetITStatus(USART1, USART_IT_TC) != RESET)
    352          ////	{
    353          ////		/* clear interrupt */
    354          ////		USART_ClearITPendingBit(USART1, USART_IT_TC);
    355          ////	}
    356          //////	while (USART1->SR & USART_FLAG_RXNE == 0);
    357          ////}
    358          //
    359          //void Usart_1IrqHandlerUser()
    360          //{
    361          //	uint8_t l_COM0TempRev = 0;
    362          // 	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    363          //    {
    364          //         /* clear interrupt */
    365          //        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    366          //		/* save on rx buffer */		
    367          //		/* save character */
    368          //        l_COM0TempRev = USART1->DR & 0x01ff;
    369          //				printf("%x-", l_COM0TempRev);
    370          //        rx.buf[rx.ptr] = l_COM0TempRev; 
    371          //		rx.ptr++;
    372          //		if(rx.ptr == 6)
    373          //			rx.ptr = 0;
    374          //		while (USART1->SR & USART_FLAG_RXNE == 0);
    375          //    }
    376          //
    377          //    /* If overrun condition occurs, clear the ORE flag 
    378          //                              and recover communication */
    379          //     /*数据溢出*/
    380          //    if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET)
    381          //    {
    382          //        (void)USART_ReceiveData(USART1);
    383          //    }
    384          //  	 /*发送完成*/
    385          //	if (USART_GetITStatus(USART1, USART_IT_TC) != RESET)
    386          //	{
    387          //		/* clear interrupt */
    388          //		USART_ClearITPendingBit(USART1, USART_IT_TC);
    389          //	}
    390          //}
    391          //
    392          //void Uart_1Control(void)
    393          //{
    394          //	uint8_t     fram_clr[4]     = {0};
    395          //	uint8_t     IDBuf[4]        = {0};
    396          //	uint8_t     clear_buf[24]   = {0};
    397          //	uint32_t    ID              = 0;
    398          //    
    399          //	uint16_t    crc16_Cal;
    400          //	uint16_t    crc16_Rec;
    401          //	
    402          //	TIME        system;    
    403          //    
    404          //    /***********************************************
    405          //    * 描述： 
    406          //    */ 
    407          //	if(rx.ok == 1) {
    408          //		crc16_Cal = AppGetCrc16Chk1((uint8_t *)&rx.buf[0],9);
    409          //		crc16_Rec = rx.buf[9] | rx.buf[10]<<8;		  //接收到的AppGetCrc16Chk1
    410          //        
    411          //		if((rx.buf[0]==0xAA)&&(rx.buf[1]==0x55)&&(crc16_Cal == crc16_Rec)) {
    412          //			switch(rx.buf[2])
    413          //			{
    414          //			case 0xA1:				
    415          //				ID = rx.buf[3]<<24 | rx.buf[4]<<16 | rx.buf[5]<<8 | rx.buf[6];
    416          //				TO_Arayy(IDBuf , ID);
    417          //				WriteFM24CL64(64 , IDBuf , 4);
    418          //				printf("\r\n ID设置成功！\r\n ");
    419          //				ReadFM24CL64(64 , IDBuf , 4);
    420          //				printf("\r\n 本装置ID设置为：%02d%02d%02d%02d\r\n" , IDBuf[3],IDBuf[2],IDBuf[1],IDBuf[0]);
    421          //				break;
    422          //                
    423          //			case 0xA2:				
    424          //				ID = rx.buf[3]<<16 | rx.buf[4]<<8 | rx.buf[5];
    425          //				ID = ID | 0xAA000000;
    426          //				TO_Arayy(IDBuf , ID);
    427          //				WriteFM24CL64(68 , IDBuf , 4);
    428          //				printf("\r\n 车型车号设置成功！\r\n ");
    429          //				ReadFM24CL64(68 , IDBuf , 4);
    430          //				if(IDBuf[2] == 0x01)
    431          //					printf("\r\n 装车车型为:HXD1D %02d%02d\r\n" , IDBuf[1],IDBuf[0]);
    432          //				break;
    433          //                
    434          //			case 0xA3:				//设置时间
    435          //				system.Year=rx.buf[3];
    436          //				system.Month=rx.buf[4];
    437          //				system.Day=rx.buf[5];
    438          //				system.Hour=rx.buf[6];
    439          //				system.Min=rx.buf[7];
    440          //				system.Sec=rx.buf[8];
    441          //				WriteTime(system);
    442          //				printf("\r\n系统时间设置成功!\r\n");
    443          //				DisplayTime();
    444          //				break;
    445          //                
    446          //			case 0xA4:				//电压直流零点校准
    447          //				CS5463_AC_Adjust(VDCOFFC);												
    448          //				break;
    449          //			case 0xA5:				//电流直流零点校准
    450          //				CS5463_AC_Adjust(IDCOFFC);										
    451          //				break;
    452          //			case 0xA6:				//电压交流零点校准
    453          //				CS5463_AC_Adjust(VACOFFC);												
    454          //				break;
    455          //			case 0xA7:				//电流交流零点校准
    456          //				CS5463_AC_Adjust(IACOFFC);											
    457          //				break;
    458          //			case 0xA8:				//电压直流增益校准
    459          //				CS5463_AC_Adjust(VACGAINC);									
    460          //				break;
    461          //			case 0xA9:				//电流直流增益校准
    462          //				CS5463_AC_Adjust(IACGAINC);									
    463          //				break;
    464          //                
    465          //			case 0xAB:
    466          //				WriteFM24CL64(32, clear_buf, 24);
    467          //				printf("\r\n 调试数据已清除\n");
    468          //				break;
    469          //			case 0xAC:				//正有功清零
    470          //				AC.PPpulse = 0;
    471          //				AC.PPpower_base = 0;
    472          //				AC.PPpower_temp = 0;
    473          //				printf("\r\n 正有功电量已清零\n");
    474          //				break;
    475          //			case 0xAD:				//负有功清零
    476          //				AC.NPpulse = 0;
    477          //				AC.NPpower_base = 0;
    478          //				AC.NPpower_temp = 0;
    479          //				printf("\r\n 负有功电量已清零\n");
    480          //				break;
    481          //			case 0xAE:				//正无功清零
    482          //				AC.PQpulse = 0;
    483          //				AC.PQpower_base = 0;
    484          //				AC.PQpower_temp = 0;
    485          //				printf("\r\n 正无功电量已清零\n");
    486          //				break;
    487          //			case 0xAF:				//负无功清零
    488          //				AC.NQpulse = 0;
    489          //				AC.NQpower_base = 0;
    490          //				AC.NQpower_temp = 0;
    491          //				printf("\r\n 负无功电量已清零\n");
    492          //				break;
    493          //                
    494          //			case 0x5A:
    495          //				CS5463_AC_Adjust(P_rate_ADD);
    496          //				break;
    497          //			case 0x5B:
    498          //				CS5463_AC_Adjust(P_rate_SUB);
    499          //				break;
    500          //			case 0x5C:
    501          //				CS5463_AC_Adjust(P_rate_DEL);
    502          //				break;
    503          //                
    504          //			case 0x51:				
    505          //				ReadFM24CL64(64 , IDBuf , 4);
    506          //				printf("\r\n 本装置ID为：%02d%02d%02d%02d\r\n" , IDBuf[3],IDBuf[2],IDBuf[1],IDBuf[0]);
    507          //				break;
    508          //                
    509          //		    case 0x52:
    510          //				ReadFM24CL64(68 , IDBuf , 4);
    511          //				if(IDBuf[3] == 0xAA)
    512          //				{
    513          //					if(IDBuf[2] == 0x01)
    514          //						printf("\r\n 装车车型为：HXD1D %02d%02d\r\n" , IDBuf[1],IDBuf[0]);
    515          //				}
    516          //				else 
    517          //					printf("\r\n 未设置装车车型！\r\n");
    518          //				break;
    519          //                
    520          //			case 0x53:				//读取时间
    521          //				DisplayTime();
    522          //				break;
    523          //                
    524          //			case 0x54:						  //通过串口转储FLASH中的所有有效数据
    525          //				DisplayTime();
    526          //				ReadFM24CL64(64 , IDBuf , 4);
    527          //				printf("\r\n 装置编号：%02d%02d%02d%02d\r\n" , IDBuf[3],IDBuf[2],IDBuf[1],IDBuf[0]);
    528          //				ReadFM24CL64(68 , IDBuf , 4);
    529          //				if(IDBuf[3] == 0xAA)
    530          //				{
    531          //					if(IDBuf[2] == 0x01)
    532          //                        printf("\r\n 装车车型为：SS4 %02d%02d\r\n" , IDBuf[1],IDBuf[0]);
    533          //				}
    534          //				else 
    535          //					printf("\r\n 未设置装车车型！\r\n");
    536          //				DOWNLOAD(g_Flash_Adr/32);				
    537          //				if(g_Flash_Adr == 0)
    538          //					printf("\r\n FLASH芯片中无有效数据！\r\n");
    539          //				break;
    540          //                
    541          //			case 0x55:				
    542          //				printf("\r\n FLASH芯片擦除中............\r\n");
    543          //				printf("\r\n 大约需要30秒，请耐心等待！\r\n");
    544          //				MX25L3206_Erase(0, 4096);
    545          //				printf("\r\n FLASH芯片已擦除\r\n");
    546          //				break;
    547          //                
    548          //			case 0x56:
    549          //				printf("\r\n FRAM芯片擦除中...\r\n");
    550          //				WriteFM24CL64(60, fram_clr, 4);
    551          //				g_Flash_Adr = 0;
    552          //				printf("\r\n FRAM芯片已擦除\r\n");
    553          //                
    554          //			default:
    555          //				break;
    556          //			}
    557          //		}
    558          //	}
    559          //	rx.ok = 0;
    560          //	rx.ptr = 0;
    561          //}	
    562          

   \                                 In section .bss, align 1
    563          uint8_t     l_COM0RdTmp;        					//串口2状态	
   \                     l_COM0RdTmp:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    564          uint8_t     l_COM0TempRev;      					//串口2接收字节
   \                     l_COM0TempRev:
   \   00000000                      DS8 1
    565          
    566          uint8_t		RecTmpFlg0 =0,RecTmpFlg1 =0,RecTmpFlg2 =0;
   \                     RecTmpFlg0:
   \   00000001                      DS8 1
    567          uint8_t		l_FramRecEndFlg = 0;
   \                     l_FramRecEndFlg:
   \   00000002                      DS8 1
   \   00000003                      DS8 1
    568          uint32_t	COM0RecNumTmp0 = 0,l_COM0RecNumEnd = 0;
   \                     COM0RecNumTmp0:
   \   00000004                      DS8 4
   \                     l_COM0RecNumEnd:
   \   00000008                      DS8 4
    569          uint32_t	l_COM0RecLen = 0;
   \                     l_COM0RecLen:
   \   0000000C                      DS8 4

   \                                 In section .bss, align 1
   \                     RecTmpFlg1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     RecTmpFlg2:
   \   00000000                      DS8 1
    570          
    571          #define	    RS485_BUF_SIZE  	256

   \                                 In section .bss, align 4
    572          uint8_t 	Rs485RecDataBuf[RS485_BUF_SIZE];
   \                     Rs485RecDataBuf:
   \   00000000                      DS8 256
    573          /**-------------------------------------------------------
    574          * @函数名 Usart_2IrqHandlerUser
    575          * @功能   串口2中断处理函数
    576          * @参数   无
    577          * @返回值 无
    578          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    579          void Usart_2IrqHandlerUser()
    580          {
   \                     Usart_2IrqHandlerUser: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    581          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) {
   \   00000002   0x....             LDR.N    R4,??DataTable20_9  ;; 0x40004400
   \   00000004   0xF240 0x5525      MOVW     R5,#+1317
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USART_GetITStatus
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD02B             BEQ.N    ??Usart_2IrqHandlerUser_0
    582                  /* clear interrupt */
    583                  USART_ClearITPendingBit(USART2, USART_IT_RXNE);
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       USART_ClearITPendingBit
    584          		/* save on rx buffer */		
    585          		/* save character */
    586                  l_COM0TempRev = USART2->DR & 0x01ff;
   \   0000001C   0x....             LDR.N    R5,??DataTable20_10
   \   0000001E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    587                  //				printf("%c-", l_COM0TempRev);
    588                  Rs485RecDataBuf[COM0RecNumTmp0 % RS485_BUF_SIZE] = l_COM0TempRev; 
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x7829             LDRB     R1,[R5, #+0]
   \   00000026   0x....             LDR.N    R2,??DataTable20_11
   \   00000028   0xB2C3             UXTB     R3,R0
   \   0000002A   0x5499             STRB     R1,[R3, R2]
    589          		COM0RecNumTmp0++;
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6068             STR      R0,[R5, #+4]
    590          		if(COM0RecNumTmp0 == RS485_BUF_SIZE)
   \   00000030   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000034   0xD101             BNE.N    ??Usart_2IrqHandlerUser_1
    591          			COM0RecNumTmp0 = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6068             STR      R0,[R5, #+4]
    592          		RecTmpFlg0 = l_COM0TempRev;
   \                     ??Usart_2IrqHandlerUser_1: (+1)
   \   0000003A   0x7069             STRB     R1,[R5, #+1]
    593                  if(RecTmpFlg0 == 0x7E) {
   \   0000003C   0x297E             CMP      R1,#+126
   \   0000003E   0xD114             BNE.N    ??Usart_2IrqHandlerUser_2
    594                  	printf("\n\r接收到帧尾\n");
   \   00000040   0x.... 0x....      ADR.W    R0,?_0
   \   00000044   0x.... 0x....      BL       printf
    595          			//if(l_FramRecEndFlg == 0)							//数据未处理，不更新
    596                  	{
    597          	        	l_FramRecEndFlg = 1;							//帧接收完成，标志位赋值
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x70A8             STRB     R0,[R5, #+2]
    598          	        	
    599          	        	if(COM0RecNumTmp0 > l_COM0RecNumEnd)
   \   0000004C   0x6868             LDR      R0,[R5, #+4]
   \   0000004E   0x68A9             LDR      R1,[R5, #+8]
   \   00000050   0x4281             CMP      R1,R0
   \   00000052   0xD202             BCS.N    ??Usart_2IrqHandlerUser_3
    600          	        	{
    601          	           		l_COM0RecLen 	= COM0RecNumTmp0 - l_COM0RecNumEnd;
   \   00000054   0x1A41             SUBS     R1,R0,R1
   \   00000056   0x60E9             STR      R1,[R5, #+12]
   \   00000058   0xE004             B.N      ??Usart_2IrqHandlerUser_4
    602          				}
    603          				else
    604          				{
    605          	           		l_COM0RecLen 	= COM0RecNumTmp0 + (255 - l_COM0RecNumEnd) + 1; //考虑数据溢出
   \                     ??Usart_2IrqHandlerUser_3: (+1)
   \   0000005A   0xF100 0x02FF      ADD      R2,R0,#+255
   \   0000005E   0x1A51             SUBS     R1,R2,R1
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \   00000062   0x60E9             STR      R1,[R5, #+12]
    606          				}
    607          				
    608          	        	l_COM0RecNumEnd 	= COM0RecNumTmp0;
   \                     ??Usart_2IrqHandlerUser_4: (+1)
   \   00000064   0x60A8             STR      R0,[R5, #+8]
    609                  	}
    610                      
    611          			RecRs485();
   \   00000066   0x.... 0x....      BL       RecRs485
    612              	}
    613          		while (USART2->SR & USART_FLAG_RXNE == 0);
   \                     ??Usart_2IrqHandlerUser_2: (+1)
   \   0000006A   0x8820             LDRH     R0,[R4, #+0]
    614              }
    615              
    616              /* If overrun condition occurs, clear the ORE flag 
    617              and recover communication */
    618              /*数据溢出*/
    619              if (USART_GetFlagStatus(USART2, USART_FLAG_ORE) != RESET)
   \                     ??Usart_2IrqHandlerUser_0: (+1)
   \   0000006C   0x2108             MOVS     R1,#+8
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD002             BEQ.N    ??Usart_2IrqHandlerUser_5
    620              {
    621                  (void)USART_ReceiveData(USART2);
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       USART_ReceiveData
    622              }
    623              /*发送完成*/
    624          	if (USART_GetITStatus(USART2, USART_IT_TC) != RESET)
   \                     ??Usart_2IrqHandlerUser_5: (+1)
   \   0000007E   0xF240 0x6526      MOVW     R5,#+1574
   \   00000082   0x4629             MOV      R1,R5
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       USART_GetITStatus
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD005             BEQ.N    ??Usart_2IrqHandlerUser_6
    625          	{
    626          		/* clear interrupt */
    627          		USART_ClearITPendingBit(USART2, USART_IT_TC);
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000096   0x.... 0x....      B.W      USART_ClearITPendingBit
    628          	}
    629          }
   \                     ??Usart_2IrqHandlerUser_6: (+1)
   \   0000009A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    630          
    631          
    632          //取接收完成标志  南睿+思S

   \                                 In section .text, align 2, keep-with-next
    633          uint8_t	GetFramRecEndFlg(void)
    634          {
    635          	return	l_FramRecEndFlg;
   \                     GetFramRecEndFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_10
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x4770             BX       LR               ;; return
    636          }
    637          
    638          //清接收完成标志  南睿+思S

   \                                 In section .text, align 2, keep-with-next
    639          void  ClearFramRecEndFlg(void)
    640          {
    641          	l_FramRecEndFlg = 0;
   \                     ClearFramRecEndFlg: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable20_10
   \   00000004   0x7088             STRB     R0,[R1, #+2]
    642          }
   \   00000006   0x4770             BX       LR               ;; return
    643          
    644          //取485数据  南睿+思S

   \                                 In section .text, align 2, keep-with-next
    645          uint16_t  ReadRs485Data(uint8_t *Buf)
    646          {
   \                     ReadRs485Data: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    647          	uint32_t  i;
    648          	
    649          	printf("\r\n RS485 %d %d ",l_COM0RecNumEnd,l_COM0RecLen);
   \   00000004   0x....             LDR.N    R5,??DataTable20_10
   \   00000006   0x68EA             LDR      R2,[R5, #+12]
   \   00000008   0x68A9             LDR      R1,[R5, #+8]
   \   0000000A   0x.... 0x....      ADR.W    R0,?_1
   \   0000000E   0x.... 0x....      BL       printf
    650          	
    651          	if(l_COM0RecLen > RS485_BUF_SIZE)
   \   00000012   0x68E8             LDR      R0,[R5, #+12]
   \   00000014   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000018   0xD902             BLS.N    ??ReadRs485Data_0
    652          	{
    653          		l_COM0RecLen = RS485_BUF_SIZE;
   \   0000001A   0xF44F 0x7080      MOV      R0,#+256
   \   0000001E   0x60E8             STR      R0,[R5, #+12]
    654          	}
    655              //	printf("去重复通讯前数据:");
    656          	for(i = 0;i < l_COM0RecLen;i++)
   \                     ??ReadRs485Data_0: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR.N    R2,??DataTable20_11
   \   00000024   0xE006             B.N      ??ReadRs485Data_1
    657          	{
    658          		Buf[i] = Rs485RecDataBuf[(l_COM0RecNumEnd + RS485_BUF_SIZE - l_COM0RecLen + i) 
    659                      % RS485_BUF_SIZE];
   \                     ??ReadRs485Data_2: (+1)
   \   00000026   0x68AB             LDR      R3,[R5, #+8]
   \   00000028   0x1A18             SUBS     R0,R3,R0
   \   0000002A   0x1808             ADDS     R0,R1,R0
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x5C80             LDRB     R0,[R0, R2]
   \   00000030   0x5508             STRB     R0,[R1, R4]
    660                  //		printf("%x ",Buf[i]);				
    661          	}
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \                     ??ReadRs485Data_1: (+1)
   \   00000034   0x68E8             LDR      R0,[R5, #+12]
   \   00000036   0x4281             CMP      R1,R0
   \   00000038   0xD3F5             BCC.N    ??ReadRs485Data_2
    662              //	Sendrs485(Buf,l_COM0RecLen);						//打印接收到的数据
    663          	
    664          	return	l_COM0RecLen;
   \   0000003A   0xB280             UXTH     R0,R0
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    665          }
    666          
    667          ///**-------------------------------------------------------
    668          //  * @函数名 USART1_IRQHandler
    669          //  * @功能   串口1中断处理函数
    670          //  * @参数   无
    671          //  * @返回值 无
    672          //***------------------------------------------------------*/
    673          //void USART1_IRQHandler(void)
    674          //{
    675          //    /* 开始临界资源访问，禁止中断 */
    676          ////	__disable_irq(); 
    677          //
    678          //    /* 调用串口1中断处理子函数 */
    679          //    Usart_1IrqHandlerUser();
    680          //    
    681          //    /* 结束临界资源访问，开放中断 */
    682          ////    __enable_irq();
    683          //}
    684          
    685          ///**-------------------------------------------------------
    686          //  * @函数名 USART2_IRQHandler
    687          //  * @功能   串口2中断处理函数
    688          //  * @参数   无
    689          //  * @返回值 无
    690          //***------------------------------------------------------*/
    691          //void USART2_IRQHandler(void)
    692          //{
    693          //	/* 开始临界资源访问，禁止中断 */
    694          ////	__disable_irq(); 
    695          //
    696          //    /* 调用串口2中断处理子函数 */
    697          //    Usart_2IrqHandlerUser();
    698          ////	RecRs485();
    699          //    /* 结束临界资源访问，开放中断 */
    700          ////   __enable_irq();
    701          //}
    702          
    703          //uint32_t GetSysTime(void)
    704          //{
    705          //	return(SysTime);
    706          //}
    707          

   \                                 In section .bss, align 4
    708          SZ_USART_DATA_TypeDef SZ_USART1_DATA, SZ_USART2_DATA;
   \                     SZ_USART1_DATA:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
   \                     SZ_USART2_DATA:
   \   00000000                      DS8 36
    709          
    710          /**-------------------------------------------------------
    711          * @函数名 UsartIrqHandlerUser
    712          * @功能   共用的串口中断处理函数
    713          * @参数   SZ_USART 串口数据结构体指针
    714          * @返回值 无
    715          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    716          void UsartIrqHandlerUser(SZ_USART_DATA_TypeDef* SZ_USART)
    717          {
   \                     UsartIrqHandlerUser: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    718              uint8_t uartRxData = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    719              //	static uint32_t Time = 0;
    720              //	Time = GetSysTime();
    721              if(USART_GetITStatus(SZ_USART->uart, USART_IT_RXNE) != RESET) {
   \   00000006   0xF240 0x5525      MOVW     R5,#+1317
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       USART_GetITStatus
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0x....             LDR.N    R7,??DataTable20_12
   \   00000016   0xD106             BNE.N    ??UsartIrqHandlerUser_0
   \   00000018   0xE014             B.N      ??UsartIrqHandlerUser_1
    722                  /* save on rx buffer */
    723                  while (SZ_USART->uart->SR & USART_FLAG_RXNE) {
    724                      /* save character */
    725                      uartRxData      = SZ_USART->uart->DR & 0xff;
   \                     ??UsartIrqHandlerUser_2: (+1)
   \   0000001A   0x8886             LDRH     R6,[R0, #+4]
    726                      rx.buf[rx.ptr]  = uartRxData;
   \   0000001C   0x7D38             LDRB     R0,[R7, #+20]
   \   0000001E   0x55C6             STRB     R6,[R0, R7]
    727                      //			printf("%x",uartRxData);
    728                      rx.ptr++;
   \   00000020   0x7D38             LDRB     R0,[R7, #+20]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x7538             STRB     R0,[R7, #+20]
    729                  }
   \                     ??UsartIrqHandlerUser_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x8801             LDRH     R1,[R0, #+0]
   \   0000002A   0x0689             LSLS     R1,R1,#+26
   \   0000002C   0xD4F5             BMI.N    ??UsartIrqHandlerUser_2
    730                  
    731                  /* clear interrupt */
    732                  USART_ClearITPendingBit(SZ_USART->uart, USART_IT_RXNE);
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x.... 0x....      BL       USART_ClearITPendingBit
    733                  
    734                  /* 接收完成 */
    735                  if ((uartRxData == '\r') || (rx.ptr >= UART_RX_BUFFER_SIZE)) {
   \   00000034   0xB2F6             UXTB     R6,R6
   \   00000036   0x2E0D             CMP      R6,#+13
   \   00000038   0xD002             BEQ.N    ??UsartIrqHandlerUser_3
   \   0000003A   0x7D38             LDRB     R0,[R7, #+20]
   \   0000003C   0x280B             CMP      R0,#+11
   \   0000003E   0xDB01             BLT.N    ??UsartIrqHandlerUser_1
    736          			rx.ok = 1;
   \                     ??UsartIrqHandlerUser_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7578             STRB     R0,[R7, #+21]
    737                      //			printf("接收完成");
    738                  }
    739              }
    740              
    741              
    742              /* If overrun condition occurs, clear the ORE flag 
    743              and recover communication */
    744              if (USART_GetFlagStatus(SZ_USART->uart, USART_FLAG_ORE) != RESET)
   \                     ??UsartIrqHandlerUser_1: (+1)
   \   00000044   0x2108             MOVS     R1,#+8
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??UsartIrqHandlerUser_4
    745              {
    746                  (void)USART_ReceiveData(SZ_USART->uart);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       USART_ReceiveData
    747              }
    748              
    749          	if (USART_GetITStatus(SZ_USART->uart, USART_IT_TC) != RESET)
   \                     ??UsartIrqHandlerUser_4: (+1)
   \   00000056   0xF240 0x6526      MOVW     R5,#+1574
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       USART_GetITStatus
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD005             BEQ.N    ??UsartIrqHandlerUser_5
    750          	{
    751          		/* clear interrupt */
    752          		USART_ClearITPendingBit(SZ_USART->uart, USART_IT_TC);
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000006E   0x.... 0x....      B.W      USART_ClearITPendingBit
    753          	}
    754          }
   \                     ??UsartIrqHandlerUser_5: (+1)
   \   00000072   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    755          
    756          /**-------------------------------------------------------
    757          * @函数名 UsartReadData
    758          * @功能   共用的串口数据读取子函数
    759          * @参数1  SZ_USART 串口数据结构体指针
    760          * @参数2  串口数据存放的Buffer
    761          * @返回值 无
    762          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    763          uint32_t UsartReadData(SZ_USART_DATA_TypeDef* SZ_USART,  uint8_t* Buffer)
    764          {
   \                     UsartReadData: (+1)
   \   00000000   0xB410             PUSH     {R4}
    765              uint32_t uartRxLength = 0, i;
   \   00000002   0x2200             MOVS     R2,#+0
    766              
    767              /* if the next position is read index, discard this 'read char' */
    768              if (SZ_USART->uart_rx_length != 0)
   \   00000004   0x6843             LDR      R3,[R0, #+4]
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD016             BEQ.N    ??UsartReadData_0
    769              {
    770                  /* 开始临界资源访问，禁止中断 */
    771                  __disable_irq(); 
   \   0000000A   0xB672             CPSID    I
    772                  
    773                  uartRxLength = SZ_USART->uart_rx_length;
   \   0000000C   0x461A             MOV      R2,R3
    774                  SZ_USART->uart_rx_length = 0;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x6043             STR      R3,[R0, #+4]
    775                  SZ_USART->uart_rx_done = 0;
   \   00000012   0x6083             STR      R3,[R0, #+8]
    776                  
    777                  /* 结束临界资源访问，开放中断 */
    778                  __enable_irq();
   \   00000014   0xB662             CPSIE    I
    779                  
    780                  for(i=0; i<uartRxLength; i++)
   \   00000016   0xE00B             B.N      ??UsartReadData_1
    781                  {
    782                      Buffer[i] = SZ_USART->uartRxBuffer[SZ_USART->uart_rx_read_point];
   \                     ??UsartReadData_2: (+1)
   \   00000018   0x6904             LDR      R4,[R0, #+16]
   \   0000001A   0x1824             ADDS     R4,R4,R0
   \   0000001C   0x7E24             LDRB     R4,[R4, #+24]
   \   0000001E   0x545C             STRB     R4,[R3, R1]
    783                      SZ_USART->uart_rx_read_point++;
   \   00000020   0x6904             LDR      R4,[R0, #+16]
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \   00000024   0x6104             STR      R4,[R0, #+16]
    784                      
    785                      if (SZ_USART->uart_rx_read_point >= UART_RX_BUFFER_SIZE)
   \   00000026   0x2C0B             CMP      R4,#+11
   \   00000028   0xD301             BCC.N    ??UsartReadData_3
    786                      {
    787                          SZ_USART->uart_rx_read_point = 0;
   \   0000002A   0x2400             MOVS     R4,#+0
   \   0000002C   0x6104             STR      R4,[R0, #+16]
    788                      }
    789                  }
   \                     ??UsartReadData_3: (+1)
   \   0000002E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??UsartReadData_1: (+1)
   \   00000030   0x4293             CMP      R3,R2
   \   00000032   0xD3F1             BCC.N    ??UsartReadData_2
    790                  
    791                  Buffer[i] = '\0';
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x5458             STRB     R0,[R3, R1]
    792              }
    793              
    794              return uartRxLength;
   \                     ??UsartReadData_0: (+1)
   \   00000038   0x4610             MOV      R0,R2
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    795          }
    796          
    797          /**-------------------------------------------------------
    798          * @函数名 USART1_IRQHandler
    799          * @功能   串口1中断处理函数
    800          * @参数   无
    801          * @返回值 无
    802          ***------------------------------------------------------*/
    803          //void USART1_IRQHandler(void)
    804          //{
    805          //    /* 开始临界资源访问，禁止中断 */
    806          //	__disable_irq(); 
    807          //
    808          //    /* 串口1中断时将指示灯1状态取反 */
    809          ////	LED1OBB = !LED1OBB;
    810          //
    811          //    /* 调用共用的串口中断处理子函数 */
    812          //    UsartIrqHandlerUser(&SZ_USART1_DATA);
    813          //    
    814          //    /* 结束临界资源访问，开放中断 */
    815          //    __enable_irq();
    816          //}
    817          
    818          //
    819          ///*
    820          //    加入以下代码,支持printf函数,不需要选择use MicroLIB	  
    821          //*/
    822          //#ifndef MicroLIB
    823          //#pragma import(__use_no_semihosting)   //没有实现fgetc时需要声明该参数          
    824          ///* 标准库需要的支持函数 使用printf()调试打印不需要实现该函数 */               
    825          //struct _Filet//__FILE 
    826          //{ 
    827          //	int handle; 
    828          //    /* Whatever you require here. If the only file you are using is */    
    829          //    /* standard output using printf() for debugging, no file handling */    
    830          //    /* is required. */
    831          //}; 
    832          //
    833          //FILE __stdout;       
    834          ////定义_sys_exit()以避免使用半主机模式    
    835          //_sys_exit(int x) 
    836          //{ 
    837          //	x = x; 
    838          //} 
    839          ///* 重定义fputc函数 如果使用MicroLIB只需要重定义fputc函数即可 */  
    840          //int fputc(int ch, FILE *f)
    841          //{
    842          //    /* Place your implementation of fputc here */
    843          //    /* Loop until the end of transmission */
    844          //    while (USART_GetFlagStatus(SZ_STM32_COM1, USART_FLAG_TC) == RESET)
    845          //    {}
    846          //
    847          //    /* e.g. write a character to the USART */
    848          //    USART_SendData(SZ_STM32_COM1, (uint8_t) ch);
    849          //
    850          //    return ch;
    851          //}
    852          ///*
    853          //可以直接使用putchar
    854          //不需要再定义 int putchar(int ch)，因为stdio.h中有如下定义
    855          // #define putchar(c) putc(c, stdout)
    856          //*/
    857          //
    858          //int ferror(FILE *f) {  
    859          //    /* Your implementation of ferror */  
    860          //    return EOF;  
    861          //} 
    862          //#endif 
    863          //
    864          //FILE __stdin;
    865          //
    866          //int fgetc(FILE *fp)
    867          //{
    868          //	int ch = 0;
    869          //	
    870          //    while(USART_GetFlagStatus(SZ_STM32_COM1, USART_FLAG_RXNE) == RESET)
    871          //    {
    872          //    }
    873          //
    874          //    ch = (int)SZ_STM32_COM1->DR & 0xFF;
    875          //	
    876          //    putchar(ch); //回显
    877          //	
    878          //	return ch;
    879          //}
    880          #define USE_IAR
    881          #ifdef  USE_IAR
    882          #define PUTCHAR_PROTOTYPE int putchar(int ch)
    883          #else
    884          #define PUTCHAR_PROTOTYPE int fputc(int ch,FILE *f)   
    885          #endif
    886          

   \                                 In section .text, align 2, keep-with-next
    887          PUTCHAR_PROTOTYPE{
   \                     putchar: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    888              //HAL_UART_Transmit(&huart1, (char *)(&(ch)), 1, 10);
    889              //return ch;
    890              int8_t retrys  = 5;
   \   00000004   0x2505             MOVS     R5,#+5
   \   00000006   0x....             LDR.N    R6,??DataTable20_8  ;; 0x40013800
   \   00000008   0xE002             B.N      ??putchar_0
    891              
    892              while (USART_GetFlagStatus(SZ_STM32_COM1, USART_FLAG_TC) == RESET){
    893                  if ( retrys -- < 0 )
    894                      break;
    895                  else
    896                      BSP_OS_TimeDly(1);
   \                     ??putchar_1: (+1)
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       BSP_OS_TimeDly
   \                     ??putchar_0: (+1)
   \   00000010   0x2140             MOVS     R1,#+64
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE.N    ??putchar_2
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x1E45             SUBS     R5,R0,#+1
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD5F1             BPL.N    ??putchar_1
    897              }
    898              
    899              /* e.g. write a character to the USART */
    900              USART_SendData(SZ_STM32_COM1, (uint8_t) ch);
   \                     ??putchar_2: (+1)
   \   00000026   0x4621             MOV      R1,R4
   \   00000028   0xB2C9             UXTB     R1,R1
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       USART_SendData
    901              
    902              return ch;
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    903          } 
    904          
    905          #ifdef USE_ADC
    906          /**-------------------------------------------------------
    907          * @函数名 ADC_GPIO_Configuration
    908          * @功能   ADC模数转换的GPIO配置初始化函数
    909          * @参数   无
    910          * @返回值 无
    911          ***------------------------------------------------------*/
    912          void ADC_GPIO_Configuration(void)
    913          {
    914              GPIO_InitTypeDef GPIO_InitStructure;
    915              
    916              /* Enable GPIOC clock */
    917              /* 使能GPIOC时钟      */
    918              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);	  //
    919              
    920              /* Configure PA.01 (ADC Channel12) as analog input -------------------------*/
    921              //PC0 作为模拟通道11输入引脚                         
    922              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;       //管脚0
    923              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;   //输入模式
    924              GPIO_Init(GPIOC, &GPIO_InitStructure);          //GPIO组
    925          }
    926          
    927          /* STM32芯片ADC转换结果DR寄存器基地址 */
    928          #define DR_ADDRESS                  ((uint32_t)0x4001244C) 
    929          /* 存放ADC为12位模数转换器结果的变量，只有ADCConvertedValue的低12位有效 */
    930          __IO uint16_t ADCConvertedValue;     // 
    931          
    932          /**-------------------------------------------------------
    933          * @函数名 SZ_STM32_ADC_Configuration
    934          * @功能   ADC模数转换的参数配置函数
    935          * @参数   无
    936          * @返回值 无
    937          ***------------------------------------------------------*/
    938          void SZ_STM32_ADC_Configuration(void)
    939          {
    940              ADC_InitTypeDef ADC_InitStructure;        //ADC初始化结构体声明
    941              DMA_InitTypeDef DMA_InitStructure;        //DMA初始化结构体声明     
    942              
    943              ADC_GPIO_Configuration();
    944              
    945              /* Enable DMA1 clock */
    946              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		 //使能DMA时钟
    947              
    948              /* DMA1 channel1 configuration ----------------------------------------------*/
    949              DMA_DeInit(DMA1_Channel1);		  //开启DMA1的第一通道
    950              DMA_InitStructure.DMA_PeripheralBaseAddr = DR_ADDRESS;		  //DMA对应的外设基地址
    951              DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&ADCConvertedValue;   //内存存储基地址
    952              DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;	//DMA的转换模式为SRC模式，由外设搬移到内存
    953              DMA_InitStructure.DMA_BufferSize = 1;		   //DMA缓存大小，1个
    954              DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	//接收一次数据后，设备地址禁止后移
    955              DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;	//关闭接收一次数据后，目标内存地址后移
    956              DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;  //定义外设数据宽度为16位
    957              DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;  //DMA搬移数据尺寸，HalfWord就是为16位
    958              DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;   //转换模式，循环缓存模式。
    959              DMA_InitStructure.DMA_Priority = DMA_Priority_High;	//DMA优先级高
    960              DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;		  //M2M模式禁用
    961              DMA_Init(DMA1_Channel1, &DMA_InitStructure);          
    962              /* Enable DMA1 channel1 */
    963              DMA_Cmd(DMA1_Channel1, ENABLE);
    964              
    965              /* Enable ADC1 and GPIOC clock */
    966              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	  //使能ADC时钟
    967              
    968              /* ADC1 configuration ------------------------------------------------------*/
    969              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;		//独立的转换模式
    970              ADC_InitStructure.ADC_ScanConvMode = ENABLE;		  //开启扫描模式
    971              ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;   //开启连续转换模式
    972              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//ADC外部开关，关闭状态
    973              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;   //对齐方式,ADC为12位中，右对齐方式
    974              ADC_InitStructure.ADC_NbrOfChannel = 1;	 //开启通道数，1个
    975              ADC_Init(ADC1, &ADC_InitStructure);
    976              
    977              /* ADC1 regular channel10 configuration */ 
    978              ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);
    979              //ADC通道组， 第1个通道 采样顺序1，转换时间 
    980              /* Enable ADC1 DMA */
    981              ADC_DMACmd(ADC1, ENABLE);	  //ADC命令，使能
    982              /* Enable ADC1 */
    983              ADC_Cmd(ADC1, ENABLE);  //开启ADC1
    984              
    985              /* Enable ADC1 reset calibaration register */   
    986              ADC_ResetCalibration(ADC1);	  //重新校准
    987              /* Check the end of ADC1 reset calibration register */
    988              while(ADC_GetResetCalibrationStatus(ADC1));  //等待重新校准完成
    989              /* Start ADC1 calibaration */
    990              ADC_StartCalibration(ADC1);		//开始校准
    991              /* Check the end of ADC1 calibration */
    992              while(ADC_GetCalibrationStatus(ADC1));	   //等待校准完成
    993              /* Start ADC1 Software Conversion */ 
    994              ADC_SoftwareStartConvCmd(ADC1, ENABLE);	//连续转换开始，ADC通过DMA方式不断的更新RAM区。
    995          }
    996          
    997          /**-------------------------------------------------------
    998          * @函数名 GetADCConvertedValue
    999          * @功能   获取ADC模数转换的结果
   1000          * @参数   无
   1001          * @返回值 ADC转换结果的变量，只有的低12位有效
   1002          ***------------------------------------------------------*/
   1003          uint16_t GetADCConvertedValue(void)
   1004          {
   1005              return ADCConvertedValue;
   1006          }
   1007          #endif
   1008          
   1009          /**-------------------------------------------------------
   1010          * @函数名 Buffercmp
   1011          * @功能   比较两个缓冲区给定长度的内容是否相同的函数
   1012          * @参数1  pBuffer1 和 pBuffer2 需要比较两个缓冲区起始地址
   1013          * @参数2  BufferLength 给定的比较长度，字节为单位
   1014          * @返回值 PASSED: 缓冲器给定长度的内容相同
   1015          *         FAILED: 缓冲器给定长度的内容不相同
   1016          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1017          TestStatus Buffercmp(u8* pBuffer1, u8* pBuffer2, u16 BufferLength)
   1018          {
   \                     Buffercmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xE001             B.N      ??Buffercmp_0
   1019              while(BufferLength--)
   1020              {
   1021                  if(*pBuffer1 != *pBuffer2)
   1022                  {
   1023                      return FAILED;
   1024                  }
   1025                  
   1026                  pBuffer1++;
   \                     ??Buffercmp_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   1027                  pBuffer2++;
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \                     ??Buffercmp_0: (+1)
   \   00000008   0x4613             MOV      R3,R2
   \   0000000A   0x1E5A             SUBS     R2,R3,#+1
   \   0000000C   0xB29B             UXTH     R3,R3
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD005             BEQ.N    ??Buffercmp_2
   \   00000012   0x7803             LDRB     R3,[R0, #+0]
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x42A3             CMP      R3,R4
   \   00000018   0xD0F4             BEQ.N    ??Buffercmp_1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??Buffercmp_3
   1028              }
   1029              
   1030              return PASSED;
   \                     ??Buffercmp_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??Buffercmp_3: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
   1031          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     TimingDelay

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     STM32DeviceSerialID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x1FFFF7E8         DC32     0x1ffff7e8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     COM_USART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     l_COM0TempRev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     Rs485RecDataBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     rx

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x0A 0x0D          DC8 "\012\015\275\323\312\325\265\275\326\241\316\262\012"
   \              0xBD 0xD3    
   \              0xCA 0xD5    
   \              0xB5 0xBD    
   \              0xD6 0xA1    
   \              0xCE 0xB2    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x0D 0x0A          DC8 "\015\012 RS485 %d %d "
   \              0x20 0x52    
   \              0x53 0x34    
   \              0x38 0x35    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x25 0x64    
   \              0x20 0x00    
   1032          
   1033          #ifdef USE_TIM5
   1034          /**-------------------------------------------------------
   1035          * @函数名 NVIC_TIM5Configuration
   1036          * @功能   配置TIM5中断向量参数函数
   1037          * @参数   无
   1038          * @返回值 无
   1039          ***------------------------------------------------------*/
   1040          static void NVIC_TIM5Configuration(void)
   1041          { 
   1042              NVIC_InitTypeDef NVIC_InitStructure;
   1043              
   1044              /* Set the Vector Table base address at 0x08000000 */
   1045              //NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0000);
   1046              
   1047              /* Enable the TIM5 gloabal Interrupt */
   1048              NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
   1049              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 7;
   1050              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 7;
   1051              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   1052              
   1053              NVIC_Init(&NVIC_InitStructure);
   1054          }
   1055          
   1056          /**-------------------------------------------------------
   1057          * @函数名 NVIC_TIM5Configuration
   1058          * @功能   配置TIM5参数函数，每秒计数器中断一次 
   1059          * @参数   无
   1060          * @返回值 无
   1061          ***------------------------------------------------------*/
   1062          void TIM5_Init(void)
   1063          {
   1064              TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
   1065              
   1066              /* TIM5 clock enable */
   1067              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
   1068              
   1069              /* ---------------------------------------------------------------
   1070              TIM4 Configuration: Output Compare Timing Mode:
   1071              TIM2CLK = 36 MHz, Prescaler = 7200, TIM2 counter clock = 7.2 MHz
   1072              --------------------------------------------------------------- */
   1073              
   1074              /* Time base configuration */
   1075              //这个就是自动装载的计数值，由于计数是从0开始的，计数10000次后为9999
   1076              TIM_TimeBaseStructure.TIM_Period = (10000 - 1);
   1077              // 这个就是预分频系数，当由于为0时表示不分频所以要减1
   1078              TIM_TimeBaseStructure.TIM_Prescaler = (7200 - 1);
   1079              // 高级应用本次不涉及。定义在定时器时钟(CK_INT)频率与数字滤波器(ETR,TIx)
   1080              // 使用的采样频率之间的分频比例
   1081              TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1082              //向上计数
   1083              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1084              //初始化定时器5
   1085              TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
   1086              
   1087              /* Clear TIM5 update pending flag[清除TIM5溢出中断标志] */
   1088              TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
   1089              
   1090              /* TIM IT enable */ //打开溢出中断
   1091              TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
   1092              
   1093              /* TIM5 enable counter */
   1094              TIM_Cmd(TIM5, ENABLE);  //计数器使能，开始工作
   1095              
   1096              /* 中断参数配置 */
   1097              NVIC_TIM5Configuration();
   1098          }
   1099          
   1100          
   1101          /**-------------------------------------------------------
   1102          * @函数名 TIM5_IRQHandler
   1103          * @功能   TIM5中断处理函数，每秒中断一次 
   1104          * @参数   无
   1105          * @返回值 无
   1106          ***------------------------------------------------------*/
   1107          void TIM5_IRQHandler(void)
   1108          {
   1109              /* www.armjishu.com ARM技术论坛 */
   1110              static u32 counter = 0;
   1111              
   1112              if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)
   1113              {
   1114                  TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
   1115                  /* LED1指示灯状态取反 */
   1116                  //        SZ_STM32_LEDToggle(LED1);
   1117                  
   1118                  /* armjishu.com提心您: 不建议在中断中使用Printf, 此示例只是演示。 */
   1119                  printf("\n\rarmjishu.com提示您: 不建议在中断中使用Printf, 此示例只是演示。\n\r");
   1120                  printf("ARMJISHU.COM-->TIM5:%d\n\r", counter++);
   1121              }
   1122          }
   1123          #endif
   1124          
   1125          #ifdef USE_TIM3
   1126          /**-------------------------------------------------------
   1127          * @函数名 NVIC_TIM3Configuration
   1128          * @功能   配置TIM3中断向量参数函数
   1129          * @参数   无
   1130          * @返回值 无
   1131          ***------------------------------------------------------*/
   1132          static void NVIC_TIM3Configuration(void)
   1133          { 
   1134              NVIC_InitTypeDef NVIC_InitStructure;
   1135              
   1136              /* Set the Vector Table base address at 0x08000000 */
   1137              //NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0000);
   1138              
   1139              /* Enable the TIM5 gloabal Interrupt */
   1140              NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
   1141              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
   1142              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
   1143              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   1144              
   1145              NVIC_Init(&NVIC_InitStructure);
   1146          }
   1147          
   1148          /**-------------------------------------------------------
   1149          * @函数名 TIM3_PWM_Init
   1150          * @功能   配置TIM3为PWM模式
   1151          * @参数   无
   1152          * @返回值 无
   1153          ***------------------------------------------------------*/
   1154          void TIM3_PWM_Init(void)
   1155          {
   1156              TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
   1157              TIM_OCInitTypeDef  TIM_OCInitStructure;
   1158            	const uint16_t Period_Val = 1020;
   1159              __IO uint16_t CCR1_Val = Period_Val/2;
   1160              __IO uint16_t CCR2_Val = Period_Val-20;
   1161              uint16_t PrescalerValue = 0;
   1162              
   1163              /* System Clocks Configuration */ /* PCLK1 = HCLK/2 = 36MHz */
   1164              /* TIM3 clock enable */
   1165              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   1166              
   1167              /* -----------------------------------------------------------------------
   1168              TIM3 Configuration: generate 4 PWM signals with 4 different duty cycles:
   1169              The TIM3CLK frequency is set to SystemCoreClock (Hz), to get TIM3 counter
   1170              clock at 24 MHz the Prescaler is computed as following:
   1171              - Prescaler = (TIM3CLK / TIM3 counter clock) - 1
   1172              SystemCoreClock is set to 72 MHz for Low-density, Medium-density, High-density
   1173              and Connectivity line devices and to 24 MHz for Low-Density Value line and
   1174              Medium-Density Value line devices
   1175              
   1176              The TIM3 is running at 36 KHz: TIM3 Frequency = TIM3 counter clock/(ARR + 1)
   1177              = 24 MHz / 1000 = 24 KHz
   1178              TIM3 Channel1 duty cycle = (TIM3_CCR1/ TIM3_ARR)* 100 = 50%
   1179              TIM3 Channel2 duty cycle = (TIM3_CCR2/ TIM3_ARR)* 100 = 37.5%
   1180              ----------------------------------------------------------------------- */
   1181              /* Compute the prescaler value */
   1182              PrescalerValue = (uint16_t) (SystemCoreClock / 24000000) - 1;
   1183              /* Time base configuration */
   1184              TIM_TimeBaseStructure.TIM_Period = Period_Val;
   1185              TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
   1186              TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1187              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1188              
   1189              TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   1190              
   1191              /* PWM1 Mode configuration: Channel1 */
   1192              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
   1193              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1194              TIM_OCInitStructure.TIM_Pulse = CCR1_Val;
   1195              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   1196              
   1197              TIM_OC1Init(TIM3, &TIM_OCInitStructure);
   1198              
   1199              TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
   1200              
   1201              /* PWM1 Mode configuration: Channel2 */
   1202              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1203              TIM_OCInitStructure.TIM_Pulse = CCR2_Val;
   1204              
   1205              TIM_OC2Init(TIM3, &TIM_OCInitStructure);
   1206              
   1207              TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);
   1208              
   1209              /* TIM IT enable */
   1210              TIM_ITConfig(TIM3, TIM_IT_CC1 | TIM_IT_CC2, ENABLE);
   1211              
   1212              //TIM_ARRPreloadConfig(TIM3, ENABLE);
   1213              
   1214              /* TIM3 enable counter */
   1215              TIM_Cmd(TIM3, ENABLE);
   1216              
   1217              NVIC_TIM3Configuration();
   1218          }
   1219          
   1220          
   1221          
   1222          /**-------------------------------------------------------
   1223          * @函数名 TIM3_IRQHandler
   1224          * @功能   TIM3中断处理函数，PWM控制指示灯亮度
   1225          * @参数   无
   1226          * @返回值 无
   1227          ***------------------------------------------------------*/
   1228          void TIM3_IRQHandler(void)
   1229          {
   1230              if (TIM_GetITStatus(TIM3, TIM_IT_CC1) != RESET)
   1231              {
   1232                  TIM_ClearITPendingBit(TIM3, TIM_IT_CC1);
   1233              }
   1234              
   1235              if (TIM_GetITStatus(TIM3, TIM_IT_CC2) != RESET)
   1236              {
   1237                  TIM_ClearITPendingBit(TIM3, TIM_IT_CC2);
   1238              }
   1239          }
   1240          #endif
   1241          
   1242          #ifdef USE_IWDG
   1243          /**-------------------------------------------------------
   1244          * @函数名 SZ_STM32_IWDGInit
   1245          * @功能   STM32独立看门狗初始化配置函数
   1246          * @参数   TimeoutFreMs  看门狗定时器多少毫秒溢出一次
   1247          * @返回值 无
   1248          * @喂狗方式(Reload IWDG counter) IWDG_ReloadCounter(); 
   1249          ***------------------------------------------------------*/
   1250          void SZ_STM32_IWDGInit(uint32_t TimeoutFreMs)/* 2 -  3276*/
   1251          {
   1252              uint32_t ReloadValue;
   1253              
   1254              /* IWDG timeout equal to 280 ms (the timeout may varies due to LSI frequency
   1255              dispersion) */
   1256              /* Enable write access to IWDG_PR and IWDG_RLR registers */
   1257              IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
   1258              
   1259              /* IWDG counter clock: 40KHz(LSI) / 32 = 1.25 KHz */
   1260              IWDG_SetPrescaler(IWDG_Prescaler_32);
   1261              
   1262              /* Set counter reload value to 349 *//* range from 0 to 4095 */
   1263              //IWDG_SetReload(349);
   1264              if(TimeoutFreMs < 2)
   1265              {
   1266                  TimeoutFreMs = 2;
   1267              }
   1268              
   1269              if(TimeoutFreMs > 3276)
   1270              {
   1271                  TimeoutFreMs = 3276;
   1272              }
   1273              
   1274              ReloadValue = ((TimeoutFreMs * 1250)/1000) - 1;
   1275              IWDG_SetReload(ReloadValue);
   1276              
   1277              printf("\r\n IWDG Timeout frequency %dms, ReloadValue is set to %d.", TimeoutFreMs, ReloadValue);
   1278              
   1279              /* Reload IWDG counter */
   1280              IWDG_ReloadCounter();
   1281              
   1282              /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
   1283              IWDG_Enable();
   1284              
   1285          }
   1286          #endif
   1287          
   1288          
   1289          #ifdef  USE_FULL_ASSERT
   1290          // 需要在工程设置Option(快捷键ALT+F7)C++属性页的define栏输入"USE_FULL_ASSERT"
   1291          /**
   1292          * @brief  Reports the name of the source file and the source line number
   1293          *   where the assert_param error has occurred.
   1294          * @param  file: pointer to the source file name
   1295          * @param  line: assert_param error line source number
   1296          * @retval None
   1297          */
   1298          void assert_failed(uint8_t* file, uint32_t line)
   1299          { 
   1300              /* User can add his own implementation to report the file name and line number,
   1301              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
   1302              
   1303              printf("Wrong parameters value: file %s on line %d\r\n", file, line);
   1304              
   1305              /* Infinite loop */
   1306              while (1)
   1307              {
   1308              }
   1309          }
   1310          #endif
   1311          
   1312          /******************* (C) COPYRIGHT 2013 www.armjishu.com *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   Buffercmp
       0   ClearFramRecEndFlg
       0   GetDeviceSerialID
       0   GetFramRecEndFlg
      16   NVIC_COMConfiguration
        16   -> NVIC_Init
        16   -> USART_ITConfig
       0   NVIC_GroupConfig
         0   -> NVIC_PriorityGroupConfig
       0   NVIC_SetPriority
      16   ReadRs485Data
        16   -> printf
      24   SZ_STM32_COMInit
        24   -> SystemCoreClockUpdate
        24   -> __SZ_STM32_COMInit
       8   SZ_STM32_SysTickInit
         8   -> SysTick_Config
       4   SysTickDelay
       8   SysTick_Config
         8   -> NVIC_SetPriority
       8   SysTick_Handler
         0   -> SysTick_Handler_User
         8   -> TimingDelay_Decrement
       0   TimingDelay_Decrement
      24   UsartIrqHandlerUser
         0   -> USART_ClearITPendingBit
        24   -> USART_ClearITPendingBit
        24   -> USART_GetFlagStatus
        24   -> USART_GetITStatus
        24   -> USART_ReceiveData
       4   UsartReadData
      16   Usart_2IrqHandlerUser
        16   -> RecRs485
         0   -> USART_ClearITPendingBit
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
        16   -> printf
      24   __SZ_STM32_COMInit
        24   -> GPIO_Init
        24   -> RCC_APB1PeriphClockCmd
        24   -> RCC_APB2PeriphClockCmd
        24   -> USART_Cmd
        24   -> USART_Init
       4   delay
      16   putchar
        16   -> BSP_OS_TimeDly
        16   -> USART_GetFlagStatus
        16   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      16  ?_0
      16  ?_1
      36  Buffercmp
       4  COM_RX_PIN
       8  COM_RX_PORT_CLK
       4  COM_TX_PIN
       8  COM_TX_PORT_CLK
      24  COM_USART
          COM_TX_PORT
          COM_RX_PORT
       8  COM_USART_CLK
       8  ClearFramRecEndFlg
      18  GetDeviceSerialID
       6  GetFramRecEndFlg
      84  NVIC_COMConfiguration
       8  NVIC_GroupConfig
      30  NVIC_SetPriority
      62  ReadRs485Data
       1  RecTmpFlg1
       1  RecTmpFlg2
     256  Rs485RecDataBuf
      12  STM32DeviceSerialID
      38  SZ_STM32_COMInit
      22  SZ_STM32_SysTickInit
      36  SZ_USART1_DATA
      36  SZ_USART2_DATA
      18  SysTickDelay
      40  SysTick_Config
      14  SysTick_Handler
       4  TimingDelay
      16  TimingDelay_Decrement
     116  UsartIrqHandlerUser
      62  UsartReadData
     156  Usart_2IrqHandlerUser
     150  __SZ_STM32_COMInit
      20  delay
       1  l_COM0RdTmp
      16  l_COM0TempRev
          RecTmpFlg0
          l_FramRecEndFlg
          COM0RecNumTmp0
          l_COM0RecNumEnd
          l_COM0RecLen
      52  putchar
      28  rx
      28  tx

 
   419 bytes in section .bss
    24 bytes in section .data
 1 072 bytes in section .text
 
 1 072 bytes of CODE memory
   443 bytes of DATA memory

Errors: none
Warnings: none
