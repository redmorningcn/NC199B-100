###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       23/Nov/2017  13:36:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\MX25L1602Drv.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\MX25L1602Drv.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\MX25L1602Drv.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\MX25L1602Drv.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\MX25L1602Drv.c
      1          /****************************************Copyright (c)**************************************************
      2          **                               Guangzou ZLG-MCU Development Co.,LTD.
      3          **                                      graduate school
      4          **                                 http://www.zlgmcu.com
      5          **
      6          **--------------File Info-------------------------------------------------------------------------------
      7          ** File name:       MX25L1602.c
      8          ** Descriptions:    SST25VF016B驱动
      9          **
     10          **------------------------------------------------------------------------------------------------------
     11          ** Created by:      Litiantian
     12          ** Created date:    2007-04-16
     13          ** Version:         1.0
     14          ** Descriptions:    The original version
     15          **
     16          **------------------------------------------------------------------------------------------------------
     17          ** Modified by:     
     18          ** Modified date:   
     19          ** Version:         
     20          ** Descriptions:    
     21          ********************************************************************************************************/
     22          #include   "MX25L1602Drv.h"
     23          #include   "includes.h"
     24          /*
     25           * 移植本软件包时需要修改以下的函数或宏 
     26           */
     27          //#define     CE_Low()    LPC_GPIO0->FIOCLR |= SPI_CS;
     28          //#define     CE_High()   LPC_GPIO0->FIOSET |= SPI_CS;
     29          

   \                                 In section .text, align 2, keep-with-next
     30          void nop(void)
     31          {
     32          	uint8_t i = 10; 
   \                     `nop`: (+1)
   \   00000000   0x200A             MOVS     R0,#+10
   \   00000002   0xE000             B.N      ??nop_0
     33              
     34          	while(i) 
     35          	{ 
     36          		i--; 
   \                     ??nop_1: (+1)
   \   00000004   0x1E40             SUBS     R0,R0,#+1
     37          	} 
   \                     ??nop_0: (+1)
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD1FB             BNE.N    ??nop_1
     38          //    #if DEBUG_MODEL_DISENABLE > 0 
     39          //        WDT_Feed();                                               /* Determine CPU capacity                               */
     40          //    #endif
     41          }
   \   0000000C   0x4770             BX       LR               ;; return
     42          
     43          extern	void WriteSoftSpiCSF(uint8 temp);
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void	CE_Low(void)
     46          {
     47          	WriteSoftSpiCSF(0);
   \                     CE_Low: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      WriteSoftSpiCSF
     48          }
     49          

   \                                 In section .text, align 2, keep-with-next
     50          void	CE_High(void)
     51          {
     52          	WriteSoftSpiCSF(1);
   \                     CE_High: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             B.N      WriteSoftSpiCSF
     53          }
     54          
     55          //#define			SCKF					204    	    //p1.20  
     56          //#define			MISOF					203			//p1.23  
     57          //#define			MOSIF					205			//p1.24 
     58          //#define   		SOFT_SPI_CSF			202			//p1.22
     59          
     60          #define			SCKF					005         //pA5  
     61          #define			MISOF					006			//pA6  
     62          #define			MOSIF					007			//pA7 
     63          #define   		SOFT_SPI_CSF			004			//pA4
     64          
     65          #define	uint8	uint8_t
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void	InitFlashIO(void)
     68          {
   \                     InitFlashIO: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     69          	GPIO_PinselConfig(MOSIF,0);	
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2007             MOVS     R0,#+7
   \   00000006   0x.... 0x....      BL       GPIO_PinselConfig
     70          	GPIO_PinselConfig(MISOF,0);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2006             MOVS     R0,#+6
   \   0000000E   0x.... 0x....      BL       GPIO_PinselConfig
     71          	GPIO_PinselConfig(MISOF,0);	
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2006             MOVS     R0,#+6
   \   00000016   0x.... 0x....      BL       GPIO_PinselConfig
     72          	GPIO_PinselConfig(SOFT_SPI_CSF,0);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       GPIO_PinselConfig
     73          	GPIO_PinselConfig(MOSIF,0);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x2007             MOVS     R0,#+7
   \   00000026   0x.... 0x....      BL       GPIO_PinselConfig
     74          	GPIO_PinselConfig(SCKF,0);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x2005             MOVS     R0,#+5
   \   0000002E   0x.... 0x....      BL       GPIO_PinselConfig
     75          	GPIO_PinselConfig(SCKF,0);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0xE8BD 0x4004      POP      {R2,LR}
   \   0000003A   0x.... 0x....      B.W      GPIO_PinselConfig
     76          }
     77          
     78          //------------------------------------------------------------------------
     79          //  名  称 ：void WriteSCKF( uint8 temp )
     80          //  功  能 ：设置 SCKF
     81          // 入口参数：无
     82          // 出口参数：无
     83          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     84          void WriteSCKF(uint8 temp)
     85          {
   \                     WriteSCKF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     86          	
     87          	if(temp)		
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??WriteSCKF_0
     88          	{
     89          		GPIO_SetOrClearValue(SCKF,1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000000E   0xE003             B.N      ??WriteSCKF_1
     90                  
     91                  
     92                  
     93                  
     94                  
     95                  
     96                  
     97                  
     98                  
     99                  
    100                  
    101                  
    102                  
    103                  
    104                  
    105                  
    106                  
    107                  
    108                  
    109                  
    110                  
    111                  
    112                  
    113                  
    114                  
    115                  
    116                  
    117                  
    118                  
    119                  
    120                  
    121                  
    122                  
    123                  
    124          	}
    125          	else
    126          	{
    127          		GPIO_SetOrClearValue(SCKF,0);		
   \                     ??WriteSCKF_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2005             MOVS     R0,#+5
   \   00000014   0x.... 0x....      BL       GPIO_SetOrClearValue
    128          	}	
    129          	nop();	
   \                     ??WriteSCKF_1: (+1)
   \   00000018   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001C   0x....             B.N      `nop`
    130          }
    131          
    132          //------------------------------------------------------------------------
    133          //  名  称 ：uint8 ReadSCKF(void)
    134          //  功  能 ：读取 SCKF 的值
    135          // 入口参数：无
    136          // 出口参数：无
    137          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    138          uint8 ReadSCKF(void)
    139          {
   \                     ReadSCKF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    140          	uint8 temp;
    141          
    142          	temp = 	GPIO_ReadIoVal(SCKF);
   \   00000002   0x2005             MOVS     R0,#+5
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x4604             MOV      R4,R0
    143          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
    144          	return temp;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    145          }
    146          
    147          //------------------------------------------------------------------------
    148          //  名  称 ：void WriteMOSIF( uint8 temp )
    149          //  功  能 ：设置 MOSIF
    150          // 入口参数：无
    151          // 出口参数：无
    152          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    153          void WriteMOSIF(uint8 temp)
    154          {	
   \                     WriteMOSIF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    155          	if(temp)		
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??WriteMOSIF_0
    156          	{
    157          		GPIO_SetOrClearValue(MOSIF,1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2007             MOVS     R0,#+7
   \   0000000A   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000000E   0xE003             B.N      ??WriteMOSIF_1
    158          	}
    159          	else
    160          	{
    161          		GPIO_SetOrClearValue(MOSIF,0);		
   \                     ??WriteMOSIF_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2007             MOVS     R0,#+7
   \   00000014   0x.... 0x....      BL       GPIO_SetOrClearValue
    162          	}	
    163          	nop();		
   \                     ??WriteMOSIF_1: (+1)
   \   00000018   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001C   0x....             B.N      `nop`
    164          
    165          }
    166          
    167          //------------------------------------------------------------------------
    168          //  名  称 ：uint8 ReadMOSIF(void)
    169          //  功  能 ：读取 MOSIF 的值
    170          // 入口参数：无
    171          // 出口参数：无
    172          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    173          uint8 ReadMOSIF(void)
    174          {
   \                     ReadMOSIF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    175          	uint8 temp;
    176          	
    177          	temp = 	GPIO_ReadIoVal(MOSIF);
   \   00000002   0x2007             MOVS     R0,#+7
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x4604             MOV      R4,R0
    178          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
    179          	return temp;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    180          }
    181          
    182          //------------------------------------------------------------------------
    183          //  名  称 ：void WriteMOSIF( uint8 temp )
    184          //  功  能 ：设置 MOSIF
    185          // 入口参数：无
    186          // 出口参数：无
    187          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    188          void WriteMISOF(uint8 temp)
    189          {	
   \                     WriteMISOF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    190          	if(temp)		
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??WriteMISOF_0
    191          	{
    192          		GPIO_SetOrClearValue(MISOF,1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2006             MOVS     R0,#+6
   \   0000000A   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000000E   0xE003             B.N      ??WriteMISOF_1
    193          	}
    194          	else
    195          	{
    196          		GPIO_SetOrClearValue(MISOF,0);		
   \                     ??WriteMISOF_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2006             MOVS     R0,#+6
   \   00000014   0x.... 0x....      BL       GPIO_SetOrClearValue
    197          	}
    198          		
    199          	nop();		
   \                     ??WriteMISOF_1: (+1)
   \   00000018   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001C   0x....             B.N      `nop`
    200          }
    201          
    202          //------------------------------------------------------------------------
    203          //  名  称 ：uint8 ReadMOSIF(void)
    204          //  功  能 ：读取 MOSIF 的值
    205          // 入口参数：无
    206          // 出口参数：无
    207          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    208          uint8 ReadMISOF(void)
    209          {
   \                     ReadMISOF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    210          	uint8 temp;
    211          
    212          	temp = 	GPIO_ReadIoVal(MISOF);
   \   00000002   0x2006             MOVS     R0,#+6
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x4604             MOV      R4,R0
    213          
    214          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
    215          	return temp;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    216          }
    217          
    218          //------------------------------------------------------------------------
    219          //  名  称 ：void WriteMOSIF( uint8 temp )
    220          //  功  能 ：设置 MOSIF
    221          // 入口参数：无
    222          // 出口参数：无
    223          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    224          void WriteSoftSpiCSF(uint8 temp)
    225          {
   \                     WriteSoftSpiCSF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    226          	if(temp)		
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??WriteSoftSpiCSF_0
    227          	{
    228          		GPIO_SetOrClearValue(SOFT_SPI_CSF,1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000000E   0xE003             B.N      ??WriteSoftSpiCSF_1
    229          	}
    230          	else
    231          	{
    232          		GPIO_SetOrClearValue(SOFT_SPI_CSF,0);		
   \                     ??WriteSoftSpiCSF_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x.... 0x....      BL       GPIO_SetOrClearValue
    233          	}	
    234          
    235          	nop();		
   \                     ??WriteSoftSpiCSF_1: (+1)
   \   00000018   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001C   0x....             B.N      `nop`
    236          }
    237          
    238          //---------------------------------------------------------------------------------
    239          //函数名称:             SentByte_SPI()
    240          //功    能:             SPI发送一字节数据
    241          //入口参数:             Data8
    242          //出口参数:             无
    243          //说    明:				以模拟SPI总线方式发送数据
    244          //----------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    245          uint8 SendOrRecByte_SPIF(uint8 ch)
    246          {
   \                     SendOrRecByte_SPIF: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    247          	uint8 i,temp;   
    248          	
    249              for (i=0;i<8;i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE00C             B.N      ??SendOrRecByte_SPIF_0
    250              {
    251          		temp=ch&0x80;
    252              	ch=ch<<1;
    253                if(temp)
    254                {
    255                	WriteMOSIF( 1 );	
    256          
    257                	WriteSCKF ( 0 );
    258          
    259                	WriteSCKF ( 1 );	        	
    260                }
    261                else
    262                {
    263                	WriteMOSIF( 0 );	
   \                     ??SendOrRecByte_SPIF_1: (+1)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       WriteMOSIF
    264          
    265                  WriteSCKF ( 0 );
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       WriteSCKF
    266                    
    267                	WriteSCKF ( 1 );
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       WriteSCKF
    268                }
    269                
    270                ch |= ReadMISOF();
   \                     ??SendOrRecByte_SPIF_2: (+1)
   \   00000018   0x.... 0x....      BL       ReadMISOF
   \   0000001C   0x4328             ORRS     R0,R0,R5
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??SendOrRecByte_SPIF_0: (+1)
   \   00000020   0x2C08             CMP      R4,#+8
   \   00000022   0xDA0E             BGE.N    ??SendOrRecByte_SPIF_3
   \   00000024   0xF000 0x0180      AND      R1,R0,#0x80
   \   00000028   0x0045             LSLS     R5,R0,#+1
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD0EB             BEQ.N    ??SendOrRecByte_SPIF_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       WriteMOSIF
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       WriteSCKF
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       WriteSCKF
   \   00000040   0xE7EA             B.N      ??SendOrRecByte_SPIF_2
    271              }
    272              
    273              return	ch;
   \                     ??SendOrRecByte_SPIF_3: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    274          }
    275          

   \                                 In section .text, align 2, keep-with-next
    276          void	SendByte_SPIF(uint8	ch)
    277          {
    278          	SendOrRecByte_SPIF(ch);
   \                     SendByte_SPIF: (+1)
   \   00000000   0x....             B.N      SendOrRecByte_SPIF
    279          }
    280          

   \                                 In section .text, align 2, keep-with-next
    281          uint8	RecByte_SPIF(void)
    282          {
    283          	uint8		ch =0;
    284          	return	SendOrRecByte_SPIF(ch);
   \                     RecByte_SPIF: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      SendOrRecByte_SPIF
    285          }
    286          
    287          /*********************************************************************************************************
    288          ** 函数名称：SPIInit
    289          ** 功能说明：初始化SPI
    290          ** 输入参数：无
    291          ** 输出参数：无
    292          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    293          void  SPIInit (void)
    294          {
    295          
    296          }
   \                     SPIInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    297          
    298          /*********************************************************************************************************
    299          ** 函数名称: Send_Byte
    300          ** 函数功能：SPI发送一个字节数据
    301          ** 输入参数: data
    302          ** 输出参数: 无
    303          ** 返 回 值：无
    304          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    305          void Send_Byte (INT8U data)
    306          {
    307          	SendByte_SPIF(data);    
   \                     Send_Byte: (+1)
   \   00000000   0x....             B.N      SendByte_SPIF
    308          }
    309          
    310          /*********************************************************************************************************
    311          ** 函数名称:Get_Byte
    312          ** 函数功能:SPI接口接收一个字节数据
    313          ** 输入参数:无
    314          ** 输出参数:无
    315          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    316          INT8U Get_Byte (void)
    317          {
    318          	return	RecByte_SPIF();
   \                     Get_Byte: (+1)
   \   00000000   0x....             B.N      RecByte_SPIF
    319          }
    320           
    321          /*********************************************************************************************************
    322          ** 用户接口层
    323          ** 以下函数在移植时无需修改
    324          *********************************************************************************************************/
    325          /********************************************************************************************************
    326          ** 函数名称:MX25L1602_RD
    327          ** 函数功能:MX25L1602的读函数,可选择读ID和读数据操作
    328          ** 输入参数:
    329          **          INT32U Dst：目标地址,范围 0x0 - MAX_ADDR（MAX_ADDR = 0x1FFFFF）
    330          **          INT32U NByte:  要读取的数据字节数
    331          **          INT8U* RcvBufPt:接收缓存的指针
    332          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    333          ** 特殊说明:若某功能下,某一入口参数无效,可在该入口参数处填Invalid，该参数将被忽略
    334          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    335          INT8U MX25L1602_RD(INT32U Dst, INT32U NByte,INT8U* RcvBufPt)
    336          {
   \                     MX25L1602_RD: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    337                INT32U i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    338                if ((Dst+NByte > MAX_ADDR)||(NByte == 0))  return (ERROR_0);            /*  检查入口参数                */
   \   0000000A   0x1928             ADDS     R0,R5,R4
   \   0000000C   0xF5B0 0x0F00      CMP      R0,#+8388608
   \   00000010   0xD201             BCS.N    ??MX25L1602_RD_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??MX25L1602_RD_1
   \                     ??MX25L1602_RD_0: (+1)
   \   00000016   0x4638             MOV      R0,R7
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}
    339                
    340                CE_Low();
   \                     ??MX25L1602_RD_1: (+1)
   \   0000001A   0x.... 0x....      BL       CE_Low
    341                Send_Byte(0x0B);                                                      /* 发送读命令                   */
   \   0000001E   0x200B             MOVS     R0,#+11
   \   00000020   0x.... 0x....      BL       Send_Byte
    342                Send_Byte(((Dst & 0xFFFFFF) >> 16));                                  /* 发送地址信息:该地址为3个字节 */
   \   00000024   0x0C20             LSRS     R0,R4,#+16
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x.... 0x....      BL       Send_Byte
    343                Send_Byte(((Dst & 0xFFFF) >> 8));
   \   0000002C   0x0A20             LSRS     R0,R4,#+8
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x.... 0x....      BL       Send_Byte
    344                Send_Byte(Dst & 0xFF);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x.... 0x....      BL       Send_Byte
    345                Send_Byte(0xFF);                                                      /* 发送一个哑字节以读取数据     */
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x.... 0x....      BL       Send_Byte
    346                for (i = 0; i < NByte; i++) {
   \   00000042   0xE003             B.N      ??MX25L1602_RD_2
    347                  RcvBufPt[i] = Get_Byte();
   \                     ??MX25L1602_RD_3: (+1)
   \   00000044   0x.... 0x....      BL       Get_Byte
   \   00000048   0x55B8             STRB     R0,[R7, R6]
    348                }
   \   0000004A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??MX25L1602_RD_2: (+1)
   \   0000004C   0x42AF             CMP      R7,R5
   \   0000004E   0xD3F9             BCC.N    ??MX25L1602_RD_3
    349                CE_High();
   \   00000050   0x.... 0x....      BL       CE_High
    350                return (OK);
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    351          }
    352          
    353          /*********************************************************************************************************
    354          ** 函数名称:MX25L1602_RdID
    355          ** 函数功能:MX25L1602的读ID函数,可选择读ID和读数据操作
    356          ** 输入参数:
    357          **          idtype IDType:ID类型。用户可在Jedec_ID,Dev_ID,Manu_ID三者里选择
    358          **          INT32U* RcvbufPt:存储ID变量的指针
    359          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    360          ** 特殊说明:若填入的参数不符合要求，则返回ERROR_0
    361          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    362          INT8U MX25L1602_RdID(idtype IDType, INT32U* RcvbufPt)
    363          {
   \                     MX25L1602_RdID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    364                INT32U temp = 0;
    365                if (IDType == Jedec_ID) {
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD113             BNE.N    ??MX25L1602_RdID_0
    366                  CE_Low();
   \   0000000A   0x.... 0x....      BL       CE_Low
    367                  Send_Byte(0x9F);                                                    /* 发送读JEDEC ID命令(9Fh)      */
   \   0000000E   0x209F             MOVS     R0,#+159
   \   00000010   0x.... 0x....      BL       Send_Byte
    368                  temp = (temp | Get_Byte()) << 8;                                    /* 接收数据                     */
   \   00000014   0x.... 0x....      BL       Get_Byte
   \   00000018   0x0204             LSLS     R4,R0,#+8
    369                  temp = (temp | Get_Byte()) << 8;
   \   0000001A   0x.... 0x....      BL       Get_Byte
   \   0000001E   0x4320             ORRS     R0,R0,R4
   \   00000020   0x0204             LSLS     R4,R0,#+8
    370                  temp = (temp | Get_Byte());                                         /* 在本例中,temp的值应为0xBF2541*/
   \   00000022   0x.... 0x....      BL       Get_Byte
   \   00000026   0x4304             ORRS     R4,R0,R4
    371                  CE_High();
   \   00000028   0x.... 0x....      BL       CE_High
    372                  *RcvbufPt = temp;
   \   0000002C   0x602C             STR      R4,[R5, #+0]
    373                  return (OK);
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    374                }
    375              
    376                if ((IDType == Manu_ID) || (IDType == Dev_ID) ) {
   \                     ??MX25L1602_RdID_0: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD001             BEQ.N    ??MX25L1602_RdID_1
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD115             BNE.N    ??MX25L1602_RdID_2
    377                  CE_Low();
   \                     ??MX25L1602_RdID_1: (+1)
   \   0000003A   0x.... 0x....      BL       CE_Low
    378                  Send_Byte(0x90);                                                    /* 发送读ID命令 (90h or ABh)    */
   \   0000003E   0x2090             MOVS     R0,#+144
   \   00000040   0x.... 0x....      BL       Send_Byte
    379                  Send_Byte(0x00);                                                    /* 发送地址                     */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      BL       Send_Byte
    380                  Send_Byte(0x00);                                                    /* 发送地址                     */
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       Send_Byte
    381                  Send_Byte(IDType);                                                  /* 发送地址 - 不是00H就是01H    */
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       Send_Byte
    382                  temp = Get_Byte();                                                  /* 接收获取的数据字节           */
   \   00000056   0x.... 0x....      BL       Get_Byte
   \   0000005A   0x4604             MOV      R4,R0
    383                  CE_High();
   \   0000005C   0x.... 0x....      BL       CE_High
    384                  *RcvbufPt = temp;
   \   00000060   0x602C             STR      R4,[R5, #+0]
    385                  return (OK);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}
    386                } else {
    387                  return (ERROR_0);
   \                     ??MX25L1602_RdID_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    388                }
    389          }
    390          
    391          /*********************************************************************************************************
    392          ** 函数名称:MX25L1602_WR
    393          ** 函数功能:MX25L1602的写函数，可写1个和多个数据到指定地址
    394          ** 输入参数:
    395          **          INT32U Dst：目标地址,范围 0x0 - MAX_ADDR（MAX_ADDR = 0x1FFFFF）
    396          **          INT8U* SndbufPt:发送缓存区指针
    397          **          INT32U NByte:要写的数据字节数
    398          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    399          ** 特殊说明:若某功能下,某一入口参数无效,可在该入口参数处填Invalid，该参数将被忽略
    400          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    401          INT8U MX25L1602_WR(INT32U Dst, INT8U* SndbufPt, INT32U NByte)
    402          {
   \                     MX25L1602_WR: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    403                INT32U temp = 0,i = 0,StatRgVal = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    404                if (( (Dst+NByte-1 > MAX_ADDR)||(NByte == 0) )) {
   \   0000000C   0x1930             ADDS     R0,R6,R4
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0xF5B0 0x0F00      CMP      R0,#+8388608
   \   00000014   0xD201             BCS.N    ??MX25L1602_WR_0
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD101             BNE.N    ??MX25L1602_WR_1
    405                  return (ERROR_0);                                                     /*  检查入口参数                */
   \                     ??MX25L1602_WR_0: (+1)
   \   0000001A   0x4638             MOV      R0,R7
   \   0000001C   0xE06D             B.N      ??MX25L1602_WR_2
    406                }
    407                CE_Low();
   \                     ??MX25L1602_WR_1: (+1)
   \   0000001E   0x.... 0x....      BL       CE_Low
    408                Send_Byte(0x05);                                                      /* 发送读状态寄存器命令         */
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0x.... 0x....      BL       Send_Byte
    409                temp = Get_Byte();                                                    /* 保存读得的状态寄存器值       */
   \   00000028   0x.... 0x....      BL       Get_Byte
   \   0000002C   0x4680             MOV      R8,R0
    410                CE_High();
   \   0000002E   0x.... 0x....      BL       CE_High
    411              
    412                CE_Low();
   \   00000032   0x.... 0x....      BL       CE_Low
    413               Send_Byte(0x50);                                                      /* 使状态寄存器可写             */
   \   00000036   0x2050             MOVS     R0,#+80
   \   00000038   0x.... 0x....      BL       Send_Byte
    414          //         Send_Byte(0x06);                                                    /* 发送写使能命令               */
    415                CE_High();
   \   0000003C   0x.... 0x....      BL       CE_High
    416                CE_Low();
   \   00000040   0x.... 0x....      BL       CE_Low
    417                Send_Byte(0x01);                                                      /* 发送写状态寄存器指令         */
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       Send_Byte
    418                Send_Byte(0);                                                         /* 清0BPx位，使Flash芯片全区可写*/
   \   0000004A   0x4638             MOV      R0,R7
   \   0000004C   0x.... 0x....      BL       Send_Byte
    419                CE_High();
   \   00000050   0x.... 0x....      BL       CE_High
    420              
    421                for(i = 0; i < NByte; i++) {
   \   00000054   0xE036             B.N      ??MX25L1602_WR_3
    422          ////新增20131126  跨块擦除扇
    423          //		printfcom0(" %d,%d, ",Dst+i,Dst+i % 4096);
    424          		if((Dst+i) % 4096 == 0)
   \                     ??MX25L1602_WR_4: (+1)
   \   00000056   0xEB07 0x0904      ADD      R9,R7,R4
   \   0000005A   0xEA5F 0x5009      LSLS     R0,R9,#+20
   \   0000005E   0xD104             BNE.N    ??MX25L1602_WR_5
    425          		{
    426          			MX25L1602_Erase((Dst+i)/4096,(Dst+i)/4096);
   \   00000060   0xEA4F 0x3019      LSR      R0,R9,#+12
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x.... 0x....      BL       MX25L1602_Erase
    427          			//printfcom0("\r\n EraseEraseEraseErase");
    428          		}
    429          //////		
    430           
    431                  CE_Low();
   \                     ??MX25L1602_WR_5: (+1)
   \   0000006A   0x.... 0x....      BL       CE_Low
    432                  Send_Byte(0x06);                                                    /* 发送写使能命令               */
   \   0000006E   0x2006             MOVS     R0,#+6
   \   00000070   0x.... 0x....      BL       Send_Byte
    433                  CE_High();
   \   00000074   0x.... 0x....      BL       CE_High
    434              
    435                  CE_Low();
   \   00000078   0x.... 0x....      BL       CE_Low
    436                  Send_Byte(0x02);                                                    /* 发送字节数据烧写命令         */
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x.... 0x....      BL       Send_Byte
    437                  Send_Byte((((Dst+i) & 0xFFFFFF) >> 16));                            /* 发送3个字节的地址信息        */
   \   00000082   0xEA4F 0x4019      LSR      R0,R9,#+16
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0x.... 0x....      BL       Send_Byte
    438                  Send_Byte((((Dst+i) & 0xFFFF) >> 8));
   \   0000008C   0xEA4F 0x2019      LSR      R0,R9,#+8
   \   00000090   0xB2C0             UXTB     R0,R0
   \   00000092   0x.... 0x....      BL       Send_Byte
    439                  Send_Byte((Dst+i) & 0xFF);
   \   00000096   0x1938             ADDS     R0,R7,R4
   \   00000098   0xB2C0             UXTB     R0,R0
   \   0000009A   0x.... 0x....      BL       Send_Byte
    440                  Send_Byte(SndbufPt[i]);                                             /* 发送被烧写的数据             */
   \   0000009E   0x5D78             LDRB     R0,[R7, R5]
   \   000000A0   0x.... 0x....      BL       Send_Byte
    441                  CE_High();
   \   000000A4   0x.... 0x....      BL       CE_High
    442              
    443                  do {
    444                    CE_Low();
   \                     ??MX25L1602_WR_6: (+1)
   \   000000A8   0x.... 0x....      BL       CE_Low
    445                    Send_Byte(0x05);                                                  /* 发送读状态寄存器命令         */
   \   000000AC   0x2005             MOVS     R0,#+5
   \   000000AE   0x.... 0x....      BL       Send_Byte
    446                    StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值       */
   \   000000B2   0x.... 0x....      BL       Get_Byte
   \   000000B6   0x4681             MOV      R9,R0
    447                    CE_High();
   \   000000B8   0x.... 0x....      BL       CE_High
    448                  } while (StatRgVal == 0x03);                                        /* 一直等待，直到芯片空闲       */
   \   000000BC   0xF1B9 0x0F03      CMP      R9,#+3
   \   000000C0   0xD0F2             BEQ.N    ??MX25L1602_WR_6
    449                }
   \   000000C2   0x1C7F             ADDS     R7,R7,#+1
   \                     ??MX25L1602_WR_3: (+1)
   \   000000C4   0x42B7             CMP      R7,R6
   \   000000C6   0xD3C6             BCC.N    ??MX25L1602_WR_4
    450              
    451                CE_Low();
   \   000000C8   0x.... 0x....      BL       CE_Low
    452                Send_Byte(0x06);                                                      /* 发送写使能命令               */
   \   000000CC   0x2006             MOVS     R0,#+6
   \   000000CE   0x.... 0x....      BL       Send_Byte
    453                CE_High();
   \   000000D2   0x.... 0x....      BL       CE_High
    454              
    455                CE_Low();
   \   000000D6   0x.... 0x....      BL       CE_Low
    456                Send_Byte(0x50);                                                      /* 使状态寄存器可写             */
   \   000000DA   0x2050             MOVS     R0,#+80
   \   000000DC   0x.... 0x....      BL       Send_Byte
    457                CE_High();
   \   000000E0   0x.... 0x....      BL       CE_High
    458                CE_Low();
   \   000000E4   0x.... 0x....      BL       CE_Low
    459                Send_Byte(0x01);                                                      /* 发送写状态寄存器指令         */
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x.... 0x....      BL       Send_Byte
    460                Send_Byte(temp);                                                      /* 恢复状态寄存器设置信息       */
   \   000000EE   0x4640             MOV      R0,R8
   \   000000F0   0x.... 0x....      BL       Send_Byte
    461                CE_High();
   \   000000F4   0x.... 0x....      BL       CE_High
    462              
    463                return (OK);
   \   000000F8   0x2001             MOVS     R0,#+1
   \                     ??MX25L1602_WR_2: (+1)
   \   000000FA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    464          }
    465          
    466          /*********************************************************************************************************
    467          ** 函数名称:MX25L1602_Erase
    468          ** 函数功能:根据指定的扇区号选取最高效的算法擦除
    469          ** 输入参数:
    470          **          INT32U sec1：起始扇区号,范围(0~499)
    471          **          INT32U sec2：终止扇区号,范围(0~499)
    472          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    473          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    474          INT8U MX25L1602_Erase(INT32U sec1, INT32U sec2)
    475          {
   \                     MX25L1602_Erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    476            INT8U  temp1 = 0,temp2 = 0,StatRgVal = 0;
    477            INT32U SecnHdAddr = 0;
    478            INT32U no_SecsToEr = 0;                                               /* 要擦除的扇区数目             */
    479            INT32U CurSecToEr = 0;                                                /* 当前要擦除的扇区号           */
    480          
    481            /*
    482             *  检查入口参数
    483             */
    484            if ((sec1 > SEC_MAX)||(sec2 > SEC_MAX)) {
   \   00000006   0xF640 0x0001      MOVW     R0,#+2049
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD201             BCS.N    ??MX25L1602_Erase_0
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD301             BCC.N    ??MX25L1602_Erase_1
    485              return (ERROR_0);
   \                     ??MX25L1602_Erase_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    486            }
    487          
    488            CE_Low();
   \                     ??MX25L1602_Erase_1: (+1)
   \   00000016   0x.... 0x....      BL       CE_Low
    489            Send_Byte(0x05);                                                     /* 发送读状态寄存器命令          */
   \   0000001A   0x2005             MOVS     R0,#+5
   \   0000001C   0x.... 0x....      BL       Send_Byte
    490            temp1 = Get_Byte();                                                  /* 保存读得的状态寄存器值        */
   \   00000020   0x.... 0x....      BL       Get_Byte
   \   00000024   0x4605             MOV      R5,R0
    491            CE_High();
   \   00000026   0x.... 0x....      BL       CE_High
    492          
    493            CE_Low();
   \   0000002A   0x.... 0x....      BL       CE_Low
    494          //  Send_Byte(0x50);                                                     /* 使状态寄存器可写              */
    495          
    496            Send_Byte(0x06);
   \   0000002E   0x2006             MOVS     R0,#+6
   \   00000030   0x.... 0x....      BL       Send_Byte
    497            CE_High();
   \   00000034   0x.... 0x....      BL       CE_High
    498          
    499            CE_Low();
   \   00000038   0x.... 0x....      BL       CE_Low
    500            Send_Byte(0x01);                                                     /* 发送写状态寄存器指令          */
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       Send_Byte
    501            Send_Byte(0);                                                        /* 清0BPx位，使Flash芯片全区可写 */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       Send_Byte
    502            CE_High();
   \   00000048   0x.... 0x....      BL       CE_High
    503          
    504            CE_Low();
   \   0000004C   0x.... 0x....      BL       CE_Low
    505            Send_Byte(0x06);                                                      /* 发送写使能命令               */
   \   00000050   0x2006             MOVS     R0,#+6
   \   00000052   0x.... 0x....      BL       Send_Byte
    506            CE_High();
   \   00000056   0x.... 0x....      BL       CE_High
    507          
    508            /*
    509             * 如果用户输入的起始扇区号大于终止扇区号，则在内部作出调整
    510             */
    511            if (sec1 > sec2)
   \   0000005A   0x42A6             CMP      R6,R4
   \   0000005C   0xD203             BCS.N    ??MX25L1602_Erase_2
    512            {
    513              temp2 = sec1;
   \   0000005E   0x4620             MOV      R0,R4
    514              sec1  = sec2;
   \   00000060   0x4634             MOV      R4,R6
    515              sec2  = temp2;
   \   00000062   0x4606             MOV      R6,R0
   \   00000064   0xB2F6             UXTB     R6,R6
    516            }
    517            /*
    518             * 若起止扇区号相等则擦除单个扇区
    519             */
    520            if (sec1 == sec2)
   \                     ??MX25L1602_Erase_2: (+1)
   \   00000066   0x42B4             CMP      R4,R6
   \   00000068   0xD120             BNE.N    ??MX25L1602_Erase_3
    521            {
    522              SecnHdAddr = SEC_SIZE * sec1;                                       /* 计算扇区的起始地址           */
   \   0000006A   0x0326             LSLS     R6,R4,#+12
    523              CE_Low();
   \   0000006C   0x.... 0x....      BL       CE_Low
    524              Send_Byte(0x20);                                                    /* 发送扇区擦除指令             */
   \   00000070   0x2020             MOVS     R0,#+32
   \   00000072   0x.... 0x....      BL       Send_Byte
    525              Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16));                         /* 发送3个字节的地址信息        */
   \   00000076   0x0C30             LSRS     R0,R6,#+16
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x.... 0x....      BL       Send_Byte
    526              Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   0000007E   0x0A30             LSRS     R0,R6,#+8
   \   00000080   0xB2C0             UXTB     R0,R0
   \   00000082   0x.... 0x....      BL       Send_Byte
    527              Send_Byte(SecnHdAddr & 0xFF);
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0
   \   0000008A   0x.... 0x....      BL       Send_Byte
    528              CE_High();
   \   0000008E   0x.... 0x....      BL       CE_High
    529              do {
    530                CE_Low();
   \                     ??MX25L1602_Erase_4: (+1)
   \   00000092   0x.... 0x....      BL       CE_Low
    531                Send_Byte(0x05);                                                  /* 发送读状态寄存器命令        */
   \   00000096   0x2005             MOVS     R0,#+5
   \   00000098   0x.... 0x....      BL       Send_Byte
    532                StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值      */
   \   0000009C   0x.... 0x....      BL       Get_Byte
   \   000000A0   0x4606             MOV      R6,R0
    533                CE_High();
   \   000000A2   0x.... 0x....      BL       CE_High
    534              } while (StatRgVal & 0x01);                                         /* 一直等待，直到芯片空闲      */
   \   000000A6   0x07F0             LSLS     R0,R6,#+31
   \   000000A8   0xD4F3             BMI.N    ??MX25L1602_Erase_4
   \   000000AA   0xE016             B.N      ??MX25L1602_Erase_5
    535              return (OK);
    536            }
    537          
    538            /*
    539             * 根据起始扇区和终止扇区间距调用最快速的擦除功能
    540             */
    541          
    542            if (sec2 - sec1 == SEC_MAX) {
   \                     ??MX25L1602_Erase_3: (+1)
   \   000000AC   0x1B30             SUBS     R0,R6,R4
   \   000000AE   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000B2   0xD114             BNE.N    ??MX25L1602_Erase_6
    543              CE_Low();
   \   000000B4   0x.... 0x....      BL       CE_Low
    544              Send_Byte(0x60);                                                    /* 发送芯片擦除指令(60h or C7h) */
   \   000000B8   0x2060             MOVS     R0,#+96
   \   000000BA   0x.... 0x....      BL       Send_Byte
    545              CE_High();
   \   000000BE   0x.... 0x....      BL       CE_High
    546              do {
    547                CE_Low();
   \                     ??MX25L1602_Erase_7: (+1)
   \   000000C2   0x.... 0x....      BL       CE_Low
    548                Send_Byte(0x05);                                                  /* 发送读状态寄存器命令         */
   \   000000C6   0x2005             MOVS     R0,#+5
   \   000000C8   0x.... 0x....      BL       Send_Byte
    549                StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值       */
   \   000000CC   0x.... 0x....      BL       Get_Byte
   \   000000D0   0x4606             MOV      R6,R0
    550                CE_High();
   \   000000D2   0x.... 0x....      BL       CE_High
    551              } while (StatRgVal & 0x01);                                         /* 一直等待，直到芯片空闲       */
   \   000000D6   0x07F0             LSLS     R0,R6,#+31
   \   000000D8   0xD4F3             BMI.N    ??MX25L1602_Erase_7
    552              return (OK);
   \                     ??MX25L1602_Erase_5: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0xBDF2             POP      {R1,R4-R7,PC}
    553            }
    554          
    555            no_SecsToEr = sec2 - sec1 +1;                                         /* 获取要擦除的扇区数目         */
   \                     ??MX25L1602_Erase_6: (+1)
   \   000000DE   0x1C47             ADDS     R7,R0,#+1
    556            CurSecToEr  = sec1;                                                   /* 从起始扇区开始擦除           */
   \   000000E0   0xE028             B.N      ??MX25L1602_Erase_8
    557          
    558            /*
    559             * 若两个扇区之间的间隔够大，则采取16扇区擦除算法
    560             */
    561            while (no_SecsToEr >= 16)
    562            {
    563              CE_Low();
   \                     ??MX25L1602_Erase_9: (+1)
   \   000000E2   0x.... 0x....      BL       CE_Low
    564              Send_Byte(0x06);                                                     /* 发送允许写命令              */
   \   000000E6   0x2006             MOVS     R0,#+6
   \   000000E8   0x.... 0x....      BL       Send_Byte
    565              CE_High();
   \   000000EC   0x.... 0x....      BL       CE_High
    566          
    567              SecnHdAddr = SEC_SIZE * CurSecToEr;                                  /* 计算扇区的起始地址          */
   \   000000F0   0x0326             LSLS     R6,R4,#+12
    568              CE_Low();
   \   000000F2   0x.... 0x....      BL       CE_Low
    569              Send_Byte(0xD8);                                                     /* 发送64KB块擦除指令          */
   \   000000F6   0x20D8             MOVS     R0,#+216
   \   000000F8   0x.... 0x....      BL       Send_Byte
    570              Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16));                          /* 发送3个字节的地址信息       */
   \   000000FC   0x0C30             LSRS     R0,R6,#+16
   \   000000FE   0xB2C0             UXTB     R0,R0
   \   00000100   0x.... 0x....      BL       Send_Byte
    571              Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   00000104   0x0A30             LSRS     R0,R6,#+8
   \   00000106   0xB2C0             UXTB     R0,R0
   \   00000108   0x.... 0x....      BL       Send_Byte
    572              Send_Byte(SecnHdAddr & 0xFF);
   \   0000010C   0x4630             MOV      R0,R6
   \   0000010E   0xB2C0             UXTB     R0,R0
   \   00000110   0x.... 0x....      BL       Send_Byte
    573              CE_High();
   \   00000114   0x.... 0x....      BL       CE_High
    574              do {
    575                CE_Low();
   \                     ??MX25L1602_Erase_10: (+1)
   \   00000118   0x.... 0x....      BL       CE_Low
    576                Send_Byte(0x05);                                                  /* 发送读状态寄存器命令        */
   \   0000011C   0x2005             MOVS     R0,#+5
   \   0000011E   0x.... 0x....      BL       Send_Byte
    577                StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值      */
   \   00000122   0x.... 0x....      BL       Get_Byte
   \   00000126   0x4606             MOV      R6,R0
    578                CE_High();
   \   00000128   0x.... 0x....      BL       CE_High
    579              } while (StatRgVal & 0x01);                                         /* 一直等待，直到芯片空闲      */
   \   0000012C   0x07F0             LSLS     R0,R6,#+31
   \   0000012E   0xD4F3             BMI.N    ??MX25L1602_Erase_10
    580              CurSecToEr  += 16;                                                  /* 计算擦除了16个扇区后和擦除区*/
   \   00000130   0x3410             ADDS     R4,R4,#+16
    581                                                                                  /* 域相邻的待擦除扇区号        */
    582              no_SecsToEr -=  16;                                                 /* 对需擦除的扇区总数作出调整  */
   \   00000132   0x3F10             SUBS     R7,R7,#+16
    583            }
   \                     ??MX25L1602_Erase_8: (+1)
   \   00000134   0x2F10             CMP      R7,#+16
   \   00000136   0xD2D4             BCS.N    ??MX25L1602_Erase_9
    584          
    585            /*
    586             * 采用扇区擦除算法擦除剩余的扇区
    587             */
    588            while (no_SecsToEr >= 1) {
   \                     ??MX25L1602_Erase_11: (+1)
   \   00000138   0x2F00             CMP      R7,#+0
   \   0000013A   0xD029             BEQ.N    ??MX25L1602_Erase_12
    589              CE_Low();
   \   0000013C   0x.... 0x....      BL       CE_Low
    590              Send_Byte(0x06);                                                   /* 发送允许写命令              */
   \   00000140   0x2006             MOVS     R0,#+6
   \   00000142   0x.... 0x....      BL       Send_Byte
    591              CE_High();
   \   00000146   0x.... 0x....      BL       CE_High
    592          
    593              SecnHdAddr = SEC_SIZE * CurSecToEr;                                /* 计算扇区的起始地址          */
   \   0000014A   0x0326             LSLS     R6,R4,#+12
    594              CE_Low();
   \   0000014C   0x.... 0x....      BL       CE_Low
    595              Send_Byte(0x20);                                                   /* 发送扇区擦除指令            */
   \   00000150   0x2020             MOVS     R0,#+32
   \   00000152   0x.... 0x....      BL       Send_Byte
    596              Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16));                        /* 发送3个字节的地址信息       */
   \   00000156   0x0C30             LSRS     R0,R6,#+16
   \   00000158   0xB2C0             UXTB     R0,R0
   \   0000015A   0x.... 0x....      BL       Send_Byte
    597              Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   0000015E   0x0A30             LSRS     R0,R6,#+8
   \   00000160   0xB2C0             UXTB     R0,R0
   \   00000162   0x.... 0x....      BL       Send_Byte
    598              Send_Byte(SecnHdAddr & 0xFF);
   \   00000166   0x4630             MOV      R0,R6
   \   00000168   0xB2C0             UXTB     R0,R0
   \   0000016A   0x.... 0x....      BL       Send_Byte
    599              CE_High();
   \   0000016E   0x.... 0x....      BL       CE_High
    600              do {
    601                CE_Low();
   \                     ??MX25L1602_Erase_13: (+1)
   \   00000172   0x.... 0x....      BL       CE_Low
    602                Send_Byte(0x05);                                                 /* 发送读状态寄存器命令        */
   \   00000176   0x2005             MOVS     R0,#+5
   \   00000178   0x.... 0x....      BL       Send_Byte
    603                StatRgVal = Get_Byte();                                          /* 保存读得的状态寄存器值      */
   \   0000017C   0x.... 0x....      BL       Get_Byte
   \   00000180   0x4606             MOV      R6,R0
    604                CE_High();
   \   00000182   0x.... 0x....      BL       CE_High
    605              } while (StatRgVal & 0x01 );                                       /* 一直等待，直到芯片空闲      */
   \   00000186   0x07F0             LSLS     R0,R6,#+31
   \   00000188   0xD4F3             BMI.N    ??MX25L1602_Erase_13
    606              CurSecToEr  += 1;
   \   0000018A   0x1C64             ADDS     R4,R4,#+1
    607              no_SecsToEr -=  1;
   \   0000018C   0x1E7F             SUBS     R7,R7,#+1
   \   0000018E   0xE7D3             B.N      ??MX25L1602_Erase_11
    608            }
    609            /*
    610             * 擦除结束,恢复状态寄存器信息
    611             */
    612            CE_Low();
   \                     ??MX25L1602_Erase_12: (+1)
   \   00000190   0x.... 0x....      BL       CE_Low
    613            Send_Byte(0x06);                                                    /* 发送写使能命令               */
   \   00000194   0x2006             MOVS     R0,#+6
   \   00000196   0x.... 0x....      BL       Send_Byte
    614            CE_High();
   \   0000019A   0x.... 0x....      BL       CE_High
    615          
    616            CE_Low();
   \   0000019E   0x.... 0x....      BL       CE_Low
    617            Send_Byte(0x50);                                                    /* 使状态寄存器可写             */
   \   000001A2   0x2050             MOVS     R0,#+80
   \   000001A4   0x.... 0x....      BL       Send_Byte
    618            CE_High();
   \   000001A8   0x.... 0x....      BL       CE_High
    619            CE_Low();
   \   000001AC   0x.... 0x....      BL       CE_Low
    620            Send_Byte(0x01);                                                    /* 发送写状态寄存器指令         */
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0x.... 0x....      BL       Send_Byte
    621            Send_Byte(temp1);                                                   /* 恢复状态寄存器设置信息       */
   \   000001B6   0x4628             MOV      R0,R5
   \   000001B8   0x.... 0x....      BL       Send_Byte
    622            CE_High();
   \   000001BC   0x.... 0x....      BL       CE_High
    623            return (OK);
   \   000001C0   0x2001             MOVS     R0,#+1
   \   000001C2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    624          }
    625          
    626          #define		FLSH_ERR  36

   \                                 In section .data, align 1
    627          uint8	flsherrflg = 0xff;
   \                     flsherrflg:
   \   00000000   0xFF               DC8 255

   \                                 In section .text, align 2, keep-with-next
    628          uint8 JudgeFlashIDErrFlg(void)   
    629          {
   \                     JudgeFlashIDErrFlg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    630          	uint32_t 	GulChipID = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    631          
    632          	//if(GetSysTime() %100*30==1 || GetSysTime() < 60*100)
    633          	{
    634          	    MX25L1602_RdID(Jedec_ID, &GulChipID);		                        /* 单步运行到此处时,在IAR里查看 */
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       MX25L1602_RdID
    635          
    636          	    GulChipID &= ~0xFF000000;                                           /* 仅保留低24位数据             */            
    637          	    if (GulChipID != 0x00C22017)//c22015 
   \   0000000E   0x....             LDR.N    R0,??DataTable0
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x0209             LSLS     R1,R1,#+8
   \   00000014   0x0A09             LSRS     R1,R1,#+8
   \   00000016   0x....             LDR.N    R2,??DataTable0_1  ;; 0xc22017
   \   00000018   0x4291             CMP      R1,R2
   \   0000001A   0xD002             BEQ.N    ??JudgeFlashIDErrFlg_0
    638          		{
    639          			flsherrflg = FLSH_ERR;
   \   0000001C   0x2124             MOVS     R1,#+36
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
   \   00000020   0xE001             B.N      ??JudgeFlashIDErrFlg_1
    640          	   	}
    641          		else
    642          		{
    643          			flsherrflg = 0xff;
   \                     ??JudgeFlashIDErrFlg_0: (+1)
   \   00000022   0x21FF             MOVS     R1,#+255
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    644          		}
    645          	}
    646          
    647          	return 	flsherrflg;
   \                     ??JudgeFlashIDErrFlg_1: (+1)
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    648          }
    649          

   \                                 In section .text, align 2, keep-with-next
    650          uint8 ReadFlsh(uint32 Addr,uint8 *buf,uint32 Len)
    651          {	
   \                     ReadFlsh: (+1)
   \   00000000   0x4613             MOV      R3,R2
    652          	return	MX25L1602_RD(Addr, Len,(INT8U* )buf);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4619             MOV      R1,R3
   \   00000006   0x....             B.N      MX25L1602_RD
    653          }
    654          

   \                                 In section .text, align 2, keep-with-next
    655          INT8U	WriteFlsh(INT32U Dst, uint8 * sFlshRec, INT32U NByte)
    656          {
    657          	return	MX25L1602_WR(Dst,(INT8U*)sFlshRec,NByte);
   \                     WriteFlsh: (+1)
   \   00000000   0x....             B.N      MX25L1602_WR
    658          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     flsherrflg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x00C22017         DC32     0xc22017
    659          
    660          
    661          //uint8   testbuf[256];
    662          //
    663          //void    TestFlsh(void)
    664          //{
    665          //    
    666          //    for(uint16 i = 0; i < 256; i++)
    667          //    {
    668          //        testbuf[i] = i;
    669          //    }
    670          //    
    671          //    WriteFlsh(0,testbuf,sizeof(testbuf));
    672          //    ReadFlsh(0,testbuf,sizeof(testbuf));
    673          //    return;
    674          //
    675          //}
    676          
    677          
    678          
    679          /*********************************************************************************************************
    680          ** End Of File
    681          *********************************************************************************************************/
    682          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CE_High
         0   -> WriteSoftSpiCSF
       0   CE_Low
         0   -> WriteSoftSpiCSF
       0   Get_Byte
         0   -> RecByte_SPIF
       8   InitFlashIO
         0   -> GPIO_PinselConfig
         8   -> GPIO_PinselConfig
       8   JudgeFlashIDErrFlg
         8   -> MX25L1602_RdID
      24   MX25L1602_Erase
        24   -> CE_High
        24   -> CE_Low
        24   -> Get_Byte
        24   -> Send_Byte
      24   MX25L1602_RD
        24   -> CE_High
        24   -> CE_Low
        24   -> Get_Byte
        24   -> Send_Byte
      16   MX25L1602_RdID
        16   -> CE_High
        16   -> CE_Low
        16   -> Get_Byte
        16   -> Send_Byte
      32   MX25L1602_WR
        32   -> CE_High
        32   -> CE_Low
        32   -> Get_Byte
        32   -> MX25L1602_Erase
        32   -> Send_Byte
       0   ReadFlsh
         0   -> MX25L1602_RD
       8   ReadMISOF
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadMOSIF
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadSCKF
         8   -> GPIO_ReadIoVal
         8   -> nop
       0   RecByte_SPIF
         0   -> SendOrRecByte_SPIF
       0   SPIInit
       0   SendByte_SPIF
         0   -> SendOrRecByte_SPIF
      16   SendOrRecByte_SPIF
        16   -> ReadMISOF
        16   -> WriteMOSIF
        16   -> WriteSCKF
       0   Send_Byte
         0   -> SendByte_SPIF
       0   WriteFlsh
         0   -> MX25L1602_WR
       8   WriteMISOF
         8   -> GPIO_SetOrClearValue
         0   -> nop
       8   WriteMOSIF
         8   -> GPIO_SetOrClearValue
         0   -> nop
       8   WriteSCKF
         8   -> GPIO_SetOrClearValue
         0   -> nop
       8   WriteSoftSpiCSF
         8   -> GPIO_SetOrClearValue
         0   -> nop
       0   nop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  CE_High
       4  CE_Low
       2  Get_Byte
      62  InitFlashIO
      42  JudgeFlashIDErrFlg
     452  MX25L1602_Erase
      88  MX25L1602_RD
     106  MX25L1602_RdID
     254  MX25L1602_WR
       8  ReadFlsh
      18  ReadMISOF
      18  ReadMOSIF
      18  ReadSCKF
       4  RecByte_SPIF
       2  SPIInit
       2  SendByte_SPIF
      70  SendOrRecByte_SPIF
       2  Send_Byte
       2  WriteFlsh
      30  WriteMISOF
      30  WriteMOSIF
      30  WriteSCKF
      30  WriteSoftSpiCSF
       1  flsherrflg
      14  nop

 
     1 byte  in section .data
 1 300 bytes in section .text
 
 1 300 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: 2
