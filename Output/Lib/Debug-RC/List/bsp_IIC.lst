###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Nov/2017  10:06:09
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_IIC.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_IIC.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\bsp_IIC.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\bsp_IIC.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_IIC.c
      1          /*******************************************************************************
      2           *   Filename:      bsp_IIC.c
      3           *   Revised:       $Date: 2017-05-15$
      4           *   Revision:      $
      5           *   Writer:	    redmorningcn.
      6           *
      7           *   Description:
      8           *   Notes:
      9           *     			E-mail:redmorningcn@qq.com
     10           *
     11           *   All copyrights reserved to redmorningcn.
     12           *
     13           *******************************************************************************/
     14          #include <includes.h>
     15          #include <bsp_IIC.h>
     16          
     17          
     18          #define     SCL     	407		//PE7
     19          #define     SDA         408		//PE8
     20          
     21          
     22          #ifndef FALSE
     23          #define FALSE              1
     24          #endif
     25          
     26          #ifndef TRUE
     27          #define TRUE               0
     28          #endif
     29          
     30          #define Delay_Factor       5                                        		//延时因子
     31          
     32          
     33          
     34          /*******************************************************************************
     35          * Function Name  : I2C_delay
     36          * Description    : 延时程序，i决定延时时间
     37          * Input          : None
     38          * Output         : None
     39          * Return         : None
     40          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
     41          void I2C_delay(void)
     42          {
     43          	uint8_t i = Delay_Factor; 
   \                     I2C_delay: (+1)
   \   00000000   0x2005             MOVS     R0,#+5
   \   00000002   0xE000             B.N      ??I2C_delay_0
     44          	while(i) 
     45          	{ 
     46          		i--; 
   \                     ??I2C_delay_1: (+1)
   \   00000004   0x1E40             SUBS     R0,R0,#+1
     47          	} 
   \                     ??I2C_delay_0: (+1)
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD1FB             BNE.N    ??I2C_delay_1
     48          //    #if DEBUG_MODEL_DISENABLE > 0 
     49          //        WDT_Feed();                                               /* Determine CPU capacity                               */
     50          //    #endif
     51          }
   \   0000000C   0x4770             BX       LR               ;; return
     52          
     53          //------------------------------------------------------------------------
     54          //  名  称 ：		GPIO_Fram_Init
     55          //  功  能 :    		初始化铁电的 IO口，为通用IO 口
     56          // 入口参数：	无
     57          // 出口参数：	无
     58          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     59          void	GPIO_Fram_Init(void)
     60          {
   \                     GPIO_Fram_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     61          	GPIO_PinselConfig(SCL,0);
   \   00000002   0xF240 0x1497      MOVW     R4,#+407
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       GPIO_PinselConfig
     62          	GPIO_PinselConfig(SCL,0);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       GPIO_PinselConfig
     63          	GPIO_PinselConfig(SDA,0);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF44F 0x70CC      MOV      R0,#+408
   \   0000001C   0x.... 0x....      BL       GPIO_PinselConfig
     64          	GPIO_PinselConfig(SDA,0);
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF44F 0x70CC      MOV      R0,#+408
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x.... 0x....      B.W      GPIO_PinselConfig
     65          }
     66          
     67          
     68          //------------------------------------------------------------------------
     69          //  名  称 ：void WriteSCL( uint8 temp )
     70          //  功  能 ：设置 SCL
     71          // 入口参数：无
     72          // 出口参数：无
     73          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     74          void WriteSCL(uint8 temp)
     75          {	
   \                     WriteSCL: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     76          	if(temp)		
   \   00000002   0xF240 0x1297      MOVW     R2,#+407
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??WriteSCL_0
     77          	{
     78          		GPIO_SetOrClearValue(SCL,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteSCL_1
     79          	}
     80          	else
     81          	{
     82          		GPIO_SetOrClearValue(SCL,0);		
   \                     ??WriteSCL_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4610             MOV      R0,R2
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
     83          	}	
     84          
     85          	I2C_delay();
   \                     ??WriteSCL_1: (+1)
   \   0000001C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000020   0x....             B.N      I2C_delay
     86          }
     87          
     88          //------------------------------------------------------------------------
     89          //  名  称 ：uint8 ReadSCL(void)
     90          //  功  能 ：读取 SCL 的值
     91          // 入口参数：无
     92          // 出口参数：无
     93          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     94          uint8 ReadSCL(void)
     95          {
   \                     ReadSCL: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     96             uint8    temp;
     97              temp = 	GPIO_ReadIoVal(SCL);
   \   00000002   0xF240 0x1097      MOVW     R0,#+407
   \   00000006   0x.... 0x....      BL       GPIO_ReadIoVal
   \   0000000A   0x4604             MOV      R4,R0
     98              I2C_delay();
   \   0000000C   0x.... 0x....      BL       I2C_delay
     99              return temp;
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    100          }
    101          
    102          //------------------------------------------------------------------------
    103          //  名  称 ：void WriteSDA( uint8 temp )
    104          //  功  能 ：设置 SDA
    105          // 入口参数：无
    106          // 出口参数：无
    107          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    108          void WriteSDA(uint8 temp)
    109          {
   \                     WriteSDA: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    110          	if(temp)		
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD005             BEQ.N    ??WriteSDA_0
    111          	{
    112          		GPIO_SetOrClearValue(SDA,1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF44F 0x70CC      MOV      R0,#+408
   \   0000000C   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000010   0xE004             B.N      ??WriteSDA_1
    113          	}
    114          	else
    115          	{
    116          		GPIO_SetOrClearValue(SDA,0);		
   \                     ??WriteSDA_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF44F 0x70CC      MOV      R0,#+408
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    117          	}	
    118          	I2C_delay();
   \                     ??WriteSDA_1: (+1)
   \   0000001C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000020   0x....             B.N      I2C_delay
    119          }
    120          
    121          //------------------------------------------------------------------------
    122          //  名  称 ：uint8 ReadSDA(void)
    123          //  功  能 ：读取 SDA 的值
    124          // 入口参数：无
    125          // 出口参数：无
    126          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    127          uint8 ReadSDA(void)
    128          {
   \                     ReadSDA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    129              uint8 temp;
    130              
    131              temp = 	GPIO_ReadIoVal(SDA);
   \   00000002   0xF44F 0x70CC      MOV      R0,#+408
   \   00000006   0x.... 0x....      BL       GPIO_ReadIoVal
   \   0000000A   0x4604             MOV      R4,R0
    132              I2C_delay();
   \   0000000C   0x.... 0x....      BL       I2C_delay
    133          
    134              return temp;
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    135          }
    136          
    137          //------------------------------------------------------------
    138          //函数名称:         StartI2C()
    139          //功    能:         I2C总线开始条件
    140          //入口参数:         无
    141          //出口参数:         无
    142          //说明：            I2C总线的开始条件：
    143          //                  SCL高电平时SDA的下降沿
    144          //------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    145          void StartI2C(void)
    146          {
   \                     StartI2C: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    147              WriteSCL(0);                                // SCL=0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       WriteSCL
    148              WriteSDA(1);                                //SDA=1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       WriteSDA
    149              WriteSCL(1);                                //SCL=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       WriteSCL
    150              WriteSDA(0);                                //SDA=0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       WriteSDA
    151              WriteSCL(0);                                // SCL=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x....             B.N      WriteSCL
    152          }
    153          
    154          //---------------------------------------------------------------
    155          //函数名称:         StopI2C()
    156          //功    能:         I2C总线结束条件
    157          //入口参数:         无
    158          //出口参数:         无
    159          //说明：            I2C总线结束条件：SCL为高电平时SDA的上升沿
    160          //--------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    161          void StopI2C(void)
    162          {
   \                     StopI2C: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    163              WriteSCL(0);                                // SCL=0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       WriteSCL
    164              WriteSDA(0);                                //SDA=0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       WriteSDA
    165              WriteSCL(1);                                //SCL=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       WriteSCL
    166              WriteSDA(1);                                //SDA=1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       WriteSDA
    167              WriteSCL(0);                                //SCL=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x....             B.N      WriteSCL
    168          }
    169          
    170          //-------------------------------------------------------------------------------
    171          //函数名称:         MasterAckI2C()
    172          //功    能:         主机接收应答，在接收到1字节数据后，返回应答，告诉从机接收完成
    173          //入口参数:         无
    174          //出口参数:         无
    175          //说明：            I2C总线应答：读完一个字节后将SDA线拉低，即应答0
    176          //---------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    177          void MasterAckI2C(void)
    178          {
   \                     MasterAckI2C: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    179              WriteSCL(0);                                // SCL=0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       WriteSCL
    180              WriteSDA(0);                               //SDA=0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       WriteSDA
    181              WriteSCL(1);                                //SCL=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       WriteSCL
    182              WriteSCL(0);                                 //SCL=0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       WriteSCL
    183              WriteSDA(0);                                //SDA=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x....             B.N      WriteSDA
    184          }
    185          
    186          //-----------------------------------------------------------------------------------
    187          //函数名称:         MasterNoAckI2C()
    188          //功    能:         主机接收应答，告诉通信从机接收完成
    189          //入口参数:         无
    190          //出口参数:         无
    191          //说明：            I2C总线应答：
    192          //                  读完所要求的字节数据后将SDA线拉高，为结束IIC总线操作做准备
    193          //-------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    194          void MasterNoAckI2C(void)
    195          {
   \                     MasterNoAckI2C: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196              WriteSCL(0);                                    // SCL=0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       WriteSCL
    197              WriteSDA(1);                                    //SDA=1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       WriteSDA
    198              WriteSCL(1);                                    //SCL=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       WriteSCL
    199              WriteSCL(0);                                    //SCL=0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       WriteSCL
    200              WriteSDA(0);                                    //SDA=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x....             B.N      WriteSDA
    201          }
    202          
    203          //------------------------------------------------------------------------------------
    204          //函数名称:         CheckSlaveAckI2C()
    205          //功    能:         读I2C从机应答
    206          //入口参数:         无
    207          //出口参数:         ackflag
    208          //                  如果从机产生应答，则返回0，
    209          //                  从机没有产生应答,否则返回1
    210          //说明：            检查I2C器件(从机)应答情况,应答返回1,否则为零
    211          //these waw a bug befor 2008/05/17.
    212          //------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    213          uint8 CheckSlaveAckI2C(void)
    214          {
   \                     CheckSlaveAckI2C: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    215              uint8 ackflag;                                  //清除应答标志;
    216              
    217              ackflag = ReadSDA();
   \   00000002   0x.... 0x....      BL       ReadSDA
   \   00000006   0x4604             MOV      R4,R0
    218              WriteSCL(1);                                    //SCL=1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       WriteSCL
    219              WriteSCL(0);                                    //SCL=0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       WriteSCL
    220              
    221              return ackflag;
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    222          }
    223          
    224          //------------------------------------------------------------------------------------
    225          //函数名称:         WriteByteWithI2C()
    226          //功    能:         	主机对I2C总线写1操作
    227          //入口参数:         Data:要写出的数据
    228          //出口参数:         无
    229          //说明：            	写一字节数据Data
    230          //------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    231          void WriteByteWithI2C(uint8 Data)  
    232          {
   \                     WriteByteWithI2C: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    233              uint8 i;
    234              for(i=0;i<8;i++)
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE00D             B.N      ??WriteByteWithI2C_0
    235              {
    236                  if(Data & 0x80)                             //传输位从高位到低位,先传最高位 
    237                  {
    238                      WriteSDA(1);                            //SDA=1;
    239                      WriteSCL(1);                            //SCL=1;
    240                  }
    241                  else
    242                  {  
    243                      WriteSDA(0);                            //SDA=0;
   \                     ??WriteByteWithI2C_1: (+1)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       WriteSDA
    244                      WriteSCL(1);                            //SCL=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       WriteSCL
    245                  }   
    246                  WriteSCL(0);                                //SCL=0;
   \                     ??WriteByteWithI2C_2: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       WriteSCL
    247                  WriteSDA(0);                                //SDA=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       WriteSDA
    248                  Data <<= 1;                                 //数据左移             
   \   00000020   0x0064             LSLS     R4,R4,#+1
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \                     ??WriteByteWithI2C_0: (+1)
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xDA08             BGE.N    ??WriteByteWithI2C_3
   \   00000028   0x0620             LSLS     R0,R4,#+24
   \   0000002A   0xD5ED             BPL.N    ??WriteByteWithI2C_1
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       WriteSDA
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       WriteSCL
   \   00000038   0xE7EC             B.N      ??WriteByteWithI2C_2
    249              }
    250          }
   \                     ??WriteByteWithI2C_3: (+1)
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    251          
    252          //-------------------------------------------------------------------------------------------------------
    253          //函数名称:         ReadByteWithI2C()
    254          //功    能:         主机对I2C总线写1操作
    255          //入口参数:         无
    256          //出口参数:         无
    257          //说明：            读一字节数据：返回值即读的数据
    258          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    259          uint8 ReadByteWithI2C(void)            
    260          {
   \                     ReadByteWithI2C: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    261              uint8 readdata=0;                           // Read_Data为读入的数据，0
   \   00000002   0x2400             MOVS     R4,#+0
    262              uint8 j;
    263              
    264              for (j=0;j<8;j++)
   \   00000004   0x4625             MOV      R5,R4
   \   00000006   0xE00D             B.N      ??ReadByteWithI2C_0
    265              {
    266                  readdata <<=1;
   \                     ??ReadByteWithI2C_1: (+1)
   \   00000008   0x0064             LSLS     R4,R4,#+1
    267          								  //数据读出，若是0则移位；若是1则与0x01或
    268                  if(ReadSDA())
   \   0000000A   0x.... 0x....      BL       ReadSDA
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??ReadByteWithI2C_2
    269                  {
    270                      readdata =(readdata | 0x01);               
   \   00000012   0xF044 0x0401      ORR      R4,R4,#0x1
    271                  }
    272                  WriteSCL(1);                              //SCL=1;
   \                     ??ReadByteWithI2C_2: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       WriteSCL
    273                  WriteSCL(0);                              //SCL=0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       WriteSCL
    274              }
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ReadByteWithI2C_0: (+1)
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xDBEF             BLT.N    ??ReadByteWithI2C_1
    275              
    276              return   readdata ;                         //返回读出的字节
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    277          }
    278          
    279          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CheckSlaveAckI2C
         8   -> ReadSDA
         8   -> WriteSCL
       8   GPIO_Fram_Init
         0   -> GPIO_PinselConfig
         8   -> GPIO_PinselConfig
       0   I2C_delay
       8   MasterAckI2C
         8   -> WriteSCL
         0   -> WriteSDA
         8   -> WriteSDA
       8   MasterNoAckI2C
         8   -> WriteSCL
         0   -> WriteSDA
         8   -> WriteSDA
      16   ReadByteWithI2C
        16   -> ReadSDA
        16   -> WriteSCL
       8   ReadSCL
         8   -> GPIO_ReadIoVal
         8   -> I2C_delay
       8   ReadSDA
         8   -> GPIO_ReadIoVal
         8   -> I2C_delay
       8   StartI2C
         0   -> WriteSCL
         8   -> WriteSCL
         8   -> WriteSDA
       8   StopI2C
         0   -> WriteSCL
         8   -> WriteSCL
         8   -> WriteSDA
      16   WriteByteWithI2C
        16   -> WriteSCL
        16   -> WriteSDA
       8   WriteSCL
         8   -> GPIO_SetOrClearValue
         0   -> I2C_delay
       8   WriteSDA
         8   -> GPIO_SetOrClearValue
         0   -> I2C_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  CheckSlaveAckI2C
      46  GPIO_Fram_Init
      14  I2C_delay
      34  MasterAckI2C
      34  MasterNoAckI2C
      46  ReadByteWithI2C
      20  ReadSCL
      20  ReadSDA
      34  StartI2C
      34  StopI2C
      60  WriteByteWithI2C
      34  WriteSCL
      34  WriteSDA

 
 434 bytes in section .text
 
 434 bytes of CODE memory

Errors: none
Warnings: none
