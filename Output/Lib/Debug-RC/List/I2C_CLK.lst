###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       22/Nov/2017  18:23:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\I2C_CLK.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\I2C_CLK.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\I2C_CLK.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\I2C_CLK.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\I2C_CLK.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : i2c_clk.c
      3          * Author             : ZHOUWEI
      4          * Version            : V3.5.0
      5          * Date               : 01/07/2014
      6          * Description        : This file provides a set of functions needed to manage the
      7          *                      communication between I2C peripheral and I2C DS3231SN.
      8          ********************************************************************************
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     11          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     12          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     13          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     14          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *******************************************************************************/
     16          
     17          #include "stm32f10x.h"
     18          #include "stm32f10x_gpio.h"
     19          #include "I2C_CLK.h"
     20          #include "DS3231.h"
     21          #include <stdio.h>
     22          
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          
     27          
     28          #define RCC_GPIO_I2C1      RCC_APB2Periph_GPIOE
     29          #define SCL                GPIO_Pin_7
     30          #define SDA                GPIO_Pin_8
     31          #define GPIO_I2C1_PORT     GPIOE
     32          
     33          #define FALSE              1
     34          #define TRUE               0
     35          #define Delay_Factor       5                                        		//延时因子
     36          
     37          #define SCL_SET            GPIO_SetBits(GPIO_I2C1_PORT, SCL)				//SCL=1
     38          #define SCL_RESET          GPIO_ResetBits(GPIO_I2C1_PORT, SCL)			    //SCL=0
     39             
     40          #define SDA_SET            GPIO_SetBits(GPIO_I2C1_PORT, SDA)				//SDA=1
     41          #define SDA_RESET          GPIO_ResetBits(GPIO_I2C1_PORT, SDA)			    //SDA=0
     42                                      
     43          #define SDA_read()         GPIO_ReadInputDataBit(GPIO_I2C1_PORT, SDA)	    //读取SDA状态
     44          
     45          
     46          /* Private macro -------------------------------------------------------------*/
     47          /* Private variables ---------------------------------------------------------*/
     48          
     49          /* Private function prototypes -----------------------------------------------*/
     50          /*******************************************************************************
     51          * Function Name  : I2C_GPIO_Config
     52          * Description    : Configration Simulation IIC GPIO
     53          * Input          : None 
     54          * Output         : None
     55          * Return         : None
     56          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
     57          void I2C_GPIO_Config(void)
     58          {
   \                     I2C_GPIO_Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     59            GPIO_InitTypeDef  GPIO_InitStructure; 			     //定义结构体
     60            
     61            RCC_APB2PeriphClockCmd(RCC_GPIO_I2C1 , ENABLE);	     //使能GPIOB时钟
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     62          
     63            GPIO_InitStructure.GPIO_Pin =  SCL;				 
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     64            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;	     //设置SCL口速度为2MHz
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xF88D 0x0002      STRB     R0,[SP, #+2]
     65            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;       //设置SCL口为开漏极输出
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     66            GPIO_Init(GPIO_I2C1_PORT, &GPIO_InitStructure);
   \   0000001E   0x....             LDR.N    R4,??DataTable6  ;; 0x40011800
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       GPIO_Init
     67          
     68            GPIO_InitStructure.GPIO_Pin =  SDA;
   \   00000028   0xF44F 0x7080      MOV      R0,#+256
   \   0000002C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     69            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;	     //设置SDA口速度为2MHz
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xF88D 0x0002      STRB     R0,[SP, #+2]
     70            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	     //设置SDA口为开漏极输出
   \   00000036   0x2014             MOVS     R0,#+20
   \   00000038   0xF88D 0x0003      STRB     R0,[SP, #+3]
     71            GPIO_Init(GPIO_I2C1_PORT, &GPIO_InitStructure);
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       GPIO_Init
     72          }
   \   00000044   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     73          
     74          /*******************************************************************************
     75          * Function Name  : I2C_delayms
     76          * Description    : 延时程序，i决定延时时间
     77          * Input          : None
     78          * Output         : None
     79          * Return         : None
     80          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
     81          void I2C_delayms(void)
     82          {
     83          	uint8_t i = Delay_Factor; 
   \                     I2C_delayms: (+1)
   \   00000000   0x2005             MOVS     R0,#+5
   \   00000002   0xE000             B.N      ??I2C_delayms_0
     84          	while(i) 
     85          	{ 
     86          		i--; 
   \                     ??I2C_delayms_1: (+1)
   \   00000004   0x1E40             SUBS     R0,R0,#+1
     87          	}  
   \                     ??I2C_delayms_0: (+1)
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD1FB             BNE.N    ??I2C_delayms_1
     88          }
   \   0000000C   0x4770             BX       LR               ;; return
     89          
     90          /*******************************************************************************
     91          * Function Name  : SCL_L
     92          * Description    : 设置SCL为低电平，并产生延时
     93          * Input          : None
     94          * Output         : None
     95          * Return         : None
     96          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
     97          void SCL_L(void)
     98          {
   \                     SCL_L: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     99            SCL_RESET;
   \   00000002   0x2180             MOVS     R1,#+128
   \   00000004   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    100            I2C_delayms();  
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x....             B.N      I2C_delayms
    101          }
    102          
    103          /*******************************************************************************
    104          * Function Name  : SCL_H
    105          * Description    : 设置SCL为高电平，并产生延时
    106          * Input          : None
    107          * Output         : None
    108          * Return         : None
    109          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    110          void SCL_H(void)
    111          {
   \                     SCL_H: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    112            SCL_SET;
   \   00000002   0x2180             MOVS     R1,#+128
   \   00000004   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000006   0x.... 0x....      BL       GPIO_SetBits
    113            I2C_delayms();  
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x....             B.N      I2C_delayms
    114          }
    115          
    116          /*******************************************************************************
    117          * Function Name  : SDA_L
    118          * Description    : 设置SDA为低电平，并产生延时
    119          * Input          : None
    120          * Output         : None
    121          * Return         : None
    122          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    123          void SDA_L(void)
    124          {
   \                     SDA_L: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    125            SDA_RESET;
   \   00000002   0xF44F 0x7180      MOV      R1,#+256
   \   00000006   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000008   0x.... 0x....      BL       GPIO_ResetBits
    126            I2C_delayms();  
   \   0000000C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000010   0x....             B.N      I2C_delayms
    127          }
    128          
    129          /*******************************************************************************
    130          * Function Name  : SDA_H
    131          * Description    : 设置SDA为高电平，并产生延时
    132          * Input          : None
    133          * Output         : None
    134          * Return         : None
    135          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    136          void SDA_H(void)
    137          {
   \                     SDA_H: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    138            SDA_SET;
   \   00000002   0xF44F 0x7180      MOV      R1,#+256
   \   00000006   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000008   0x.... 0x....      BL       GPIO_SetBits
    139            I2C_delayms();  
   \   0000000C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000010   0x....             B.N      I2C_delayms
    140          }
    141          
    142          /*******************************************************************************
    143          * Function Name  : I2C_Start
    144          * Description    : 启动I2C： SCL为1时，SDA从1到0跳变
    145          * Input          : None
    146          * Output         : None
    147          * Return         : None
    148          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    149          void I2C_Start(void)
    150          {
   \                     I2C_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    151          	SCL_L();	                  //SCL = 0
   \   00000002   0x.... 0x....      BL       SCL_L
    152          	SDA_H();					  //SDA = 1
   \   00000006   0x.... 0x....      BL       SDA_H
    153          	SCL_H();					  //SCL = 1
   \   0000000A   0x.... 0x....      BL       SCL_H
    154          	SDA_L();					  //SDA = 0
   \   0000000E   0x.... 0x....      BL       SDA_L
    155          	SCL_L();					  //SCL = 0
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x....             B.N      SCL_L
    156          }
    157          /*******************************************************************************
    158          * Function Name  : I2C_Stop
    159          * Description    : 停止I2C： SCL为1时，SDA从0到1跳变
    160          * Input          : None
    161          * Output         : None
    162          * Return         : None
    163          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    164          void I2C_Stop(void)
    165          {
   \                     I2C_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    166          	SCL_L();					  //SCL = 0
   \   00000002   0x.... 0x....      BL       SCL_L
    167          	SDA_L();					  //SDA = 0
   \   00000006   0x.... 0x....      BL       SDA_L
    168          	SCL_H();					  //SCL = 1
   \   0000000A   0x.... 0x....      BL       SCL_H
    169          	SDA_H();					  //SDA = 1
   \   0000000E   0x.... 0x....      BL       SDA_H
    170          	SCL_L();					  //SCL = 0
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x....             B.N      SCL_L
    171          } 
    172          /*******************************************************************************
    173          * Function Name  : I2C_Ack
    174          * Description    : 主设备返回应答信号
    175          * Input          : None
    176          * Output         : None
    177          * Return         : None
    178          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    179          void I2C_Ack(void)
    180          {	
   \                     I2C_Ack: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    181          	SCL_L();					  //SCL = 0
   \   00000002   0x.... 0x....      BL       SCL_L
    182          	SDA_L();					  //SDA = 0    
   \   00000006   0x.... 0x....      BL       SDA_L
    183          	SCL_H();					  //SCL = 1
   \   0000000A   0x.... 0x....      BL       SCL_H
    184          	SCL_L();					  //SCL = 0
   \   0000000E   0x.... 0x....      BL       SCL_L
    185          	SDA_L();					  //SDA = 0
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x....             B.N      SDA_L
    186          }   
    187          /*******************************************************************************
    188          * Function Name  : I2C_NoAck
    189          * Description    : 主设备返回最后一次应答信号
    190          * Input          : None
    191          * Output         : None
    192          * Return         : None
    193          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    194          void I2C_NoAck(void)
    195          {	
   \                     I2C_NoAck: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196          	SCL_L();				      //SCL = 0
   \   00000002   0x.... 0x....      BL       SCL_L
    197          	SDA_H();					  //SDA = 1 
   \   00000006   0x.... 0x....      BL       SDA_H
    198          	SCL_H();					  //SCL = 1   
   \   0000000A   0x.... 0x....      BL       SCL_H
    199          	SCL_L();					  //SCL = 0
   \   0000000E   0x.... 0x....      BL       SCL_L
    200          	SDA_L();					  //SDA = 0
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x....             B.N      SDA_L
    201          } 
    202          /*******************************************************************************
    203          * Function Name  : I2C_WaitAck
    204          * Description    : 从设备返回应答信号
    205          * Input          : None
    206          * Output         : None
    207          * Return         : 应答信号，FALSE = 1无应答；TURE = 0有应答
    208          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    209          uint8_t I2C_WaitAck(void) 	                      //返回为:=0有ACK,=1无ACK
    210          {
   \                     I2C_WaitAck: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    211          	SCL_L();				                      //SCL = 0
   \   00000002   0x.... 0x....      BL       SCL_L
    212          	SDA_H();					                  //SDA = 1
   \   00000006   0x.... 0x....      BL       SDA_H
    213          	SCL_H();					                  //SCL = 1
   \   0000000A   0x.... 0x....      BL       SCL_H
    214          	
    215          	SCL_L();					                  //SCL = 0
   \   0000000E   0x.... 0x....      BL       SCL_L
    216          
    217          	if(SDA_read())			                      //读SDA状态，总线是否被占用？
   \   00000012   0xF44F 0x7180      MOV      R1,#+256
   \   00000016   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   00000018   0x.... 0x....      BL       GPIO_ReadInputDataBit
    218          	{
    219              	SCL_L();				                  //SCL = 0
    220          		I2C_delayms();
    221          //   	return FALSE;			                  //返回FALSE = 1，无应答     ?????   未弄明白
    222              	return TRUE;
    223          	}
    224          	else
    225          	{
    226          		SCL_L();					              //SCL = 0
   \   0000001C   0x.... 0x....      BL       SCL_L
    227          		I2C_delayms();
   \   00000020   0x.... 0x....      BL       I2C_delayms
    228          		return TRUE;			                  //返回TRUE = 0，有应答
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    229          	}
    230          }
    231          /*******************************************************************************
    232          * Function Name  : I2C_SendByte
    233          * Description    : 发送一个字节到接收设备
    234          * Input          : SendByte：需要发送的数据
    235          * Output         : None
    236          * Return         : None
    237          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    238          void I2C_SendByte(uint8_t SendByte) //数据从高位到低位
    239          {
   \                     I2C_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    240          	uint8_t i = 8;
   \   00000004   0x2508             MOVS     R5,#+8
   \   00000006   0xE008             B.N      ??I2C_SendByte_0
    241          	
    242          	while(i--)
    243          	{
    244          		SCL_L();				 	             //SCL = 0
    245          		if(SendByte&0x80)		 	             //先发高位
    246          		{                         
    247          	    	SDA_H();				 	         //SDA = 1
    248          		}  
    249          		else 
    250          		{
    251          	  		SDA_L();  			 	            //SDA = 0
   \                     ??I2C_SendByte_1: (+1)
   \   00000008   0x.... 0x....      BL       SDA_L
    252          		}
    253          		SendByte<<=1;				            //左移1位
   \                     ??I2C_SendByte_2: (+1)
   \   0000000C   0x0064             LSLS     R4,R4,#+1
    254          		I2C_delayms();
   \   0000000E   0x.... 0x....      BL       I2C_delayms
    255          		SCL_H();					            //SCL = 1
   \   00000012   0x.... 0x....      BL       SCL_H
    256          		I2C_delayms();
   \   00000016   0x.... 0x....      BL       I2C_delayms
   \                     ??I2C_SendByte_0: (+1)
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x1E45             SUBS     R5,R0,#+1
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD006             BEQ.N    ??I2C_SendByte_3
   \   00000024   0x.... 0x....      BL       SCL_L
   \   00000028   0x0620             LSLS     R0,R4,#+24
   \   0000002A   0xD5ED             BPL.N    ??I2C_SendByte_1
   \   0000002C   0x.... 0x....      BL       SDA_H
   \   00000030   0xE7EC             B.N      ??I2C_SendByte_2
    257          	}
    258          	SCL_L();					 	            //SCL = 0
   \                     ??I2C_SendByte_3: (+1)
   \   00000032   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000036   0x....             B.N      SCL_L
    259          }  
    260          /*******************************************************************************
    261          * Function Name  : I2C_ReadByte
    262          * Description    : 通过I2C读取1个字节的数据
    263          * Input          : None
    264          * Output         : None
    265          * Return         : 读取到的数据 
    266          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    267          uint8_t I2C_ReadByte(void) 		 	       		//数据从低位到高位
    268          { 
   \                     I2C_ReadByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    269          	uint8_t i = 8;
   \   00000002   0x2408             MOVS     R4,#+8
    270          	uint8_t ReceiveByte = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    271          	
    272          	SDA_H();				    		        //SDA = 1
   \   00000006   0x.... 0x....      BL       SDA_H
   \   0000000A   0xE00D             B.N      ??I2C_ReadByte_0
    273          	while(i--)
    274          	{
    275          		ReceiveByte<<=1;      		            //先接收低位 
   \                     ??I2C_ReadByte_1: (+1)
   \   0000000C   0x006D             LSLS     R5,R5,#+1
    276          		SCL_L();			    		        //SCL = 0
   \   0000000E   0x.... 0x....      BL       SCL_L
    277          		SCL_H();			   		 	        //SCL = 1
   \   00000012   0x.... 0x....      BL       SCL_H
    278          		if(SDA_read())	    		            //读SDA状态，是否为1，为1则赋值；为0，则忽略
   \   00000016   0xF44F 0x7180      MOV      R1,#+256
   \   0000001A   0x....             LDR.N    R0,??DataTable6  ;; 0x40011800
   \   0000001C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??I2C_ReadByte_0
    279          		{
    280          			ReceiveByte|=0x01;  	  	        //给最低位赋值
   \   00000024   0xF045 0x0501      ORR      R5,R5,#0x1
    281          		}                         
    282          	}
   \                     ??I2C_ReadByte_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x1E44             SUBS     R4,R0,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EC             BNE.N    ??I2C_ReadByte_1
    283          	SCL_L();				    		        //SCL = 0，释放总线
   \   00000032   0x.... 0x....      BL       SCL_L
    284          	return ReceiveByte;	    		       		//返回数据
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    285          } 
    286                    
    287          /*******************************************************************************
    288          * Function Name  : Single_Write(uint8_t SlaveAddress,uint8_t REG_Address,uint8_t REG_data)
    289          * Description    : 发送一个字节数据到指定的从设备的寄存器中
    290          * Input          : SlaveAddress为从设备地址，REG_Address为寄存器地址，REG_data为要写的数据
    291          * Output         : None
    292          * Return         : None
    293          ****************************************************************************** */
    294          

   \                                 In section .text, align 2, keep-with-next
    295          void Single_Write(uint8_t SlaveAddress,uint8_t REG_Address,uint8_t REG_data)
    296          {
   \                     Single_Write: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    297          	I2C_Start();				           //启动I2C
   \   00000008   0x.... 0x....      BL       I2C_Start
    298          	I2C_SendByte(SlaveAddress);            //写从设备地址(DS3231写模式为0xD0) 
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_SendByte
    299          	while(I2C_WaitAck());			  	   //等待从设备应答
   \                     ??Single_Write_0: (+1)
   \   00000012   0x.... 0x....      BL       I2C_WaitAck
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1FB             BNE.N    ??Single_Write_0
    300          	I2C_SendByte(REG_Address );            //写从设备寄存器地址      
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       I2C_SendByte
    301          	while(I2C_WaitAck());				   //等待从设备应答
   \                     ??Single_Write_1: (+1)
   \   00000020   0x.... 0x....      BL       I2C_WaitAck
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD1FB             BNE.N    ??Single_Write_1
    302          	I2C_SendByte(REG_data);		           //写数据到寄存器
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       I2C_SendByte
    303          	while(I2C_WaitAck());				   //等待从设备应答
   \                     ??Single_Write_2: (+1)
   \   0000002E   0x.... 0x....      BL       I2C_WaitAck
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1FB             BNE.N    ??Single_Write_2
    304          	I2C_Stop(); 				           //停止I2C
   \   00000036   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003A   0x....             B.N      I2C_Stop
    305          }
    306          
    307          
    308          /*******************************************************************************
    309          * Function Name  : Single_Read(uint8_t SlaveAddress,uint8_t REG_Address)
    310          * Description    : 从从设备读取1个字节的数据
    311          * Input          : SlaveAddress为从设备地址，REG_Address为寄存器地址
    312          * Output         : None
    313          * Return         : None
    314          ****************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    315          uint8_t Single_Read(uint8_t SlaveAddress,uint8_t REG_Address)
    316          {   
   \                     Single_Read: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    317          	uint8_t REG_data;     	
    318          	I2C_Start();				        	//启动I2C
   \   00000006   0x.... 0x....      BL       I2C_Start
    319          	I2C_SendByte(SlaveAddress); 	        //写从设备地址(DS3231写模式为0xD0) 
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       I2C_SendByte
    320          	while(I2C_WaitAck());				    //等待从设备应答
   \                     ??Single_Read_0: (+1)
   \   00000010   0x.... 0x....      BL       I2C_WaitAck
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1FB             BNE.N    ??Single_Read_0
    321          	I2C_SendByte(REG_Address);              //写从设备寄存器地址      
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       I2C_SendByte
    322          	while(I2C_WaitAck());				    //等待从设备应答
   \                     ??Single_Read_1: (+1)
   \   0000001E   0x.... 0x....      BL       I2C_WaitAck
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1FB             BNE.N    ??Single_Read_1
    323          	I2C_Start();					        //启动I2C
   \   00000026   0x.... 0x....      BL       I2C_Start
    324          	I2C_SendByte(SlaveAddress+1);	        //写从设备地址(DS3231写模式为0xD1=0xD0+1)
   \   0000002A   0x1C60             ADDS     R0,R4,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x.... 0x....      BL       I2C_SendByte
    325          	while(I2C_WaitAck());				    //等待从设备应答
   \                     ??Single_Read_2: (+1)
   \   00000032   0x.... 0x....      BL       I2C_WaitAck
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1FB             BNE.N    ??Single_Read_2
    326          	
    327          	REG_data= I2C_ReadByte();		        //主机接收数据
   \   0000003A   0x.... 0x....      BL       I2C_ReadByte
   \   0000003E   0x4604             MOV      R4,R0
    328          	I2C_NoAck();					        //等待主机应答
   \   00000040   0x.... 0x....      BL       I2C_NoAck
    329          	I2C_Stop();						        //停止I2C
   \   00000044   0x.... 0x....      BL       I2C_Stop
    330          	return REG_data;				        //返回读取到的数据
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    331          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40011800         DC32     0x40011800
    332           
    333          /* END OF I2C_CLK.C */
    334          
    335          
    336          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   I2C_Ack
         8   -> SCL_H
         8   -> SCL_L
         0   -> SDA_L
         8   -> SDA_L
      16   I2C_GPIO_Config
        16   -> GPIO_Init
        16   -> RCC_APB2PeriphClockCmd
       8   I2C_NoAck
         8   -> SCL_H
         8   -> SCL_L
         8   -> SDA_H
         0   -> SDA_L
      16   I2C_ReadByte
        16   -> GPIO_ReadInputDataBit
        16   -> SCL_H
        16   -> SCL_L
        16   -> SDA_H
      16   I2C_SendByte
        16   -> I2C_delayms
        16   -> SCL_H
         0   -> SCL_L
        16   -> SCL_L
        16   -> SDA_H
        16   -> SDA_L
       8   I2C_Start
         8   -> SCL_H
         0   -> SCL_L
         8   -> SCL_L
         8   -> SDA_H
         8   -> SDA_L
       8   I2C_Stop
         8   -> SCL_H
         0   -> SCL_L
         8   -> SCL_L
         8   -> SDA_H
         8   -> SDA_L
       8   I2C_WaitAck
         8   -> GPIO_ReadInputDataBit
         8   -> I2C_delayms
         8   -> SCL_H
         8   -> SCL_L
         8   -> SDA_H
       0   I2C_delayms
       8   SCL_H
         8   -> GPIO_SetBits
         0   -> I2C_delayms
       8   SCL_L
         8   -> GPIO_ResetBits
         0   -> I2C_delayms
       8   SDA_H
         8   -> GPIO_SetBits
         0   -> I2C_delayms
       8   SDA_L
         8   -> GPIO_ResetBits
         0   -> I2C_delayms
      16   Single_Read
        16   -> I2C_NoAck
        16   -> I2C_ReadByte
        16   -> I2C_SendByte
        16   -> I2C_Start
        16   -> I2C_Stop
        16   -> I2C_WaitAck
      16   Single_Write
        16   -> I2C_SendByte
        16   -> I2C_Start
         0   -> I2C_Stop
        16   -> I2C_WaitAck


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
      24  I2C_Ack
      70  I2C_GPIO_Config
      24  I2C_NoAck
      60  I2C_ReadByte
      56  I2C_SendByte
      24  I2C_Start
      24  I2C_Stop
      40  I2C_WaitAck
      14  I2C_delayms
      16  SCL_H
      16  SCL_L
      18  SDA_H
      18  SDA_L
      76  Single_Read
      60  Single_Write

 
 544 bytes in section .text
 
 544 bytes of CODE memory

Errors: none
Warnings: none
