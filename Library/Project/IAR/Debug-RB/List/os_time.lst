###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:16
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_time.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Source\os_time.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\os_time.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\os_time.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\Micrium\uC-OS-III\Source\os_time.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIME MANAGEMENT
     10          *
     11          * File    : OS_TIME.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_time__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                  DELAY TASK 'n' TICKS
     43          *
     44          * Description: This function is called to delay execution of the currently running task until the specified number of
     45          *              system ticks expires.  This, of course, directly equates to delaying the current task for some time to
     46          *              expire.  No delay will result if the specified delay is 0.  If the specified delay is greater than 0
     47          *              then, a context switch will result.
     48          *
     49          * Arguments  : dly       is a value in 'clock ticks' that the task will either delay for or, the target match value
     50          *                        of the tick counter (OSTickCtr).  Note that specifying 0 means the task is not to delay.
     51          *
     52          *                        depending on the option argument, the task will wake up when OSTickCtr reaches:
     53          *
     54          *                            OS_OPT_TIME_DLY      : OSTickCtr + dly
     55          *                            OS_OPT_TIME_TIMEOUT  : OSTickCtr + dly
     56          *                            OS_OPT_TIME_MATCH    : dly
     57          *                            OS_OPT_TIME_PERIODIC : OSTCBCurPtr->TickCtrPrev + dly
     58          *
     59          *              opt       specifies whether 'dly' represents absolute or relative time; default option marked with *** :
     60          *
     61          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
     62          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
     63          *                            OS_OPT_TIME_MATCH      indicates that 'dly' specifies the absolute value that OSTickCtr
     64          *                                                   must reach before the task will be resumed.
     65          *                            OS_OPT_TIME_PERIODIC   indicates that 'dly' specifies the periodic value that OSTickCtr
     66          *                                                   must reach before the task will be resumed.
     67          *
     68          *              p_err     is a pointer to a variable that will contain an error code from this call.
     69          *
     70          *                            OS_ERR_NONE            the call was successful and the delay occurred.
     71          *                            OS_ERR_OPT_INVALID     if you specified an invalid option for this function.
     72          *                            OS_ERR_SCHED_LOCKED    can't delay when the scheduler is locked.
     73          *                            OS_ERR_TIME_DLY_ISR    if you called this function from an ISR.
     74          *                            OS_ERR_TIME_ZERO_DLY   if you specified a delay of zero.
     75          *
     76          * Returns    : none
     77          ************************************************************************************************************************
     78          */
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void  OSTimeDly (OS_TICK   dly,
     81                           OS_OPT    opt,
     82                           OS_ERR   *p_err)
     83          {
   \                     OSTimeDly: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x0014             MOVS     R4,R2
     84              CPU_SR_ALLOC();
     85          
     86          
     87          
     88          #ifdef OS_SAFETY_CRITICAL
     89              if (p_err == (OS_ERR *)0) {
     90                  OS_SAFETY_CRITICAL_EXCEPTION();
     91                  return;
     92              }
     93          #endif
     94          
     95          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     96              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000006   0x....             LDR      R0,??DataTable1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ      ??OSTimeDly_0
     97                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   0000000E   0x....             LDR      R0,??DataTable1_1  ;; 0x7275
   \   00000010   0xE04B             B        ??OSTimeDly_1
     98                  return;
     99              }
    100          #endif
    101          
    102              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
   \                     ??OSTimeDly_0: (+1)
   \   00000012   0x....             LDR      R5,??DataTable1_2
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ      ??OSTimeDly_2
    103                 *p_err = OS_ERR_SCHED_LOCKED;
   \   0000001A   0x....             LDR      R0,??DataTable1_3  ;; 0x6d63
   \   0000001C   0xE045             B        ??OSTimeDly_1
    104                  return;
    105              }
    106          
    107              switch (opt) {
   \                     ??OSTimeDly_2: (+1)
   \   0000001E   0x0008             MOVS     R0,R1
   \   00000020   0xD005             BEQ      ??OSTimeDly_3
   \   00000022   0x2902             CMP      R1,#+2
   \   00000024   0xD003             BEQ      ??OSTimeDly_3
   \   00000026   0x2904             CMP      R1,#+4
   \   00000028   0xD007             BEQ      ??OSTimeDly_4
   \   0000002A   0x2908             CMP      R1,#+8
   \   0000002C   0xD103             BNE      ??OSTimeDly_5
    108                  case OS_OPT_TIME_DLY:
    109                  case OS_OPT_TIME_TIMEOUT:
    110                  case OS_OPT_TIME_PERIODIC:
    111                       if (dly == (OS_TICK)0u) {                      /* 0 means no delay!                                      */
   \                     ??OSTimeDly_3: (+1)
   \   0000002E   0x2F00             CMP      R7,#+0
   \   00000030   0xD103             BNE      ??OSTimeDly_4
    112                          *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000032   0x....             LDR      R0,??DataTable1_4  ;; 0x727e
   \   00000034   0xE039             B        ??OSTimeDly_1
    113                           return;
    114                       }
    115                       break;
    116          
    117                  case OS_OPT_TIME_MATCH:
    118                       break;
    119          
    120                  default:
    121                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDly_5: (+1)
   \   00000036   0x....             LDR      R0,??DataTable1_5  ;; 0x5e25
   \   00000038   0xE037             B        ??OSTimeDly_1
    122                       return;
    123              }
    124          
    125              OS_CRITICAL_ENTER();
   \                     ??OSTimeDly_4: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000044   0x7828             LDRB     R0,[R5, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x7028             STRB     R0,[R5, #+0]
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
    126              OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \   00000054   0x....             LDR      R6,??DataTable4
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x6831             LDR      R1,[R6, #+0]
   \   0000005A   0x3136             ADDS     R1,R1,#+54
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
    127              OS_TickListInsert(OSTCBCurPtr,
    128                                dly,
    129                                opt,
    130                                p_err);
   \   0000005E   0x0023             MOVS     R3,R4
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0x8802             LDRH     R2,[R0, #+0]
   \   00000064   0x0039             MOVS     R1,R7
   \   00000066   0x6830             LDR      R0,[R6, #+0]
   \   00000068   0x.... 0x....      BL       OS_TickListInsert
    131              if (*p_err != OS_ERR_NONE) {
   \   0000006C   0x8820             LDRH     R0,[R4, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD008             BEQ      ??OSTimeDly_6
    132                   OS_CRITICAL_EXIT_NO_SCHED();
   \   00000072   0x.... 0x....      BL       CPU_SR_Save
   \   00000076   0x0006             MOVS     R6,R0
   \   00000078   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000007C   0x7828             LDRB     R0,[R5, #+0]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x7028             STRB     R0,[R5, #+0]
   \   00000082   0x....             B.N      ?Subroutine0
    133                   return;
    134              }
    135              OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                    */
   \                     ??OSTimeDly_6: (+1)
   \   00000084   0x6830             LDR      R0,[R6, #+0]
   \   00000086   0x.... 0x....      BL       OS_RdyListRemove
    136              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000008A   0x.... 0x....      BL       CPU_SR_Save
   \   0000008E   0x0006             MOVS     R6,R0
   \   00000090   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000094   0x7828             LDRB     R0,[R5, #+0]
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x7028             STRB     R0,[R5, #+0]
   \   0000009A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       CPU_SR_Restore
    137              OSSched();                                              /* Find next task to run!                                 */
   \   000000A4   0x.... 0x....      BL       OSSched
    138             *p_err = OS_ERR_NONE;
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDly_1: (+1)
   \   000000AA   0x8020             STRH     R0,[R4, #+0]
    139          }
   \   000000AC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000004   0x0030             MOVS     R0,R6
   \   00000006   0x.... 0x....      BL       CPU_SR_Restore
   \   0000000A   0xBDF1             POP      {R0,R4-R7,PC}
    140          
    141          /*$PAGE*/
    142          /*
    143          ************************************************************************************************************************
    144          *                                             DELAY TASK FOR SPECIFIED TIME
    145          *
    146          * Description: This function is called to delay execution of the currently running task until some time expires.  This
    147          *              call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
    148          *
    149          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 999 if the tick rate is
    150          *                        1000 Hz or less otherwise, a higher value would overflow a 32-bit unsigned counter).
    151          *
    152          *              minutes   specifies the number of minutes (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    153          *
    154          *              seconds   specifies the number of seconds (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    155          *
    156          *              milli     specifies the number of milliseconds (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    157          *
    158          *              opt       specifies time delay bit-field options logically OR'd; default options marked with *** :
    159          *
    160          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
    161          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
    162          *                            OS_OPT_TIME_MATCH      indicates that the delay specifies the absolute value that OSTickCtr
    163          *                                                   must reach before the task will be resumed.
    164          *                            OS_OPT_TIME_PERIODIC   indicates that the delay specifies the periodic value that OSTickCtr
    165          *                                                   must reach before the task will be resumed.
    166          *
    167          *                        *** OS_OPT_TIME_HMSM_STRICT            strictly allow only hours        (0...99)
    168          *                                                                                   minutes      (0...59)
    169          *                                                                                   seconds      (0...59)
    170          *                                                                                   milliseconds (0...999)
    171          *                            OS_OPT_TIME_HMSM_NON_STRICT        allow any value of  hours        (0...999)
    172          *                                                                                   minutes      (0...9999)
    173          *                                                                                   seconds      (0...65535)
    174          *                                                                                   milliseconds (0...4294967295)
    175          *
    176          *              p_err     is a pointer to a variable that will receive an error code from this call.
    177          *
    178          *                            OS_ERR_NONE                        If the function returns from the desired delay
    179          *                            OS_ERR_OPT_INVALID                 If you specified an invalid option for 'opt'
    180          *                            OS_ERR_SCHED_LOCKED                Can't delay when the scheduler is locked
    181          *                            OS_ERR_TIME_DLY_ISR                If called from an ISR
    182          *                            OS_ERR_TIME_INVALID_HOURS          If you didn't specify a valid value for 'hours'
    183          *                            OS_ERR_TIME_INVALID_MINUTES        If you didn't specify a valid value for 'minutes'
    184          *                            OS_ERR_TIME_INVALID_SECONDS        If you didn't specify a valid value for 'seconds'
    185          *                            OS_ERR_TIME_INVALID_MILLISECONDS   If you didn't specify a valid value for 'milli'
    186          *                            OS_ERR_TIME_ZERO_DLY               If hours, minutes, seconds and milli are all 0
    187          *
    188          * Returns    : none
    189          *
    190          * Note(s)    : 1) The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay
    191          *                 if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay
    192          *                 is rounded to the nearest tick.
    193          *
    194          *              2) Although this function allows you to delay a task for many, many hours, it's not recommended to put
    195          *                 a task to sleep for that long.
    196          ************************************************************************************************************************
    197          */
    198          
    199          #if OS_CFG_TIME_DLY_HMSM_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    200          void  OSTimeDlyHMSM (CPU_INT16U   hours,
    201                               CPU_INT16U   minutes,
    202                               CPU_INT16U   seconds,
    203                               CPU_INT32U   milli,
    204                               OS_OPT       opt,
    205                               OS_ERR      *p_err)
    206          {
   \                     OSTimeDlyHMSM: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x9C09             LDR      R4,[SP, #+36]
    207          #if OS_CFG_ARG_CHK_EN > 0u
    208              CPU_BOOLEAN  opt_invalid;
    209              CPU_BOOLEAN  opt_non_strict;
    210          #endif
    211              OS_OPT       opt_time;
    212              OS_RATE_HZ   tick_rate;
    213              OS_TICK      ticks;
    214              CPU_SR_ALLOC();
    215          
    216          
    217          
    218          #ifdef OS_SAFETY_CRITICAL
    219              if (p_err == (OS_ERR *)0) {
    220                  OS_SAFETY_CRITICAL_EXCEPTION();
    221                  return;
    222              }
    223          #endif
    224          
    225          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    226              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000006   0x....             LDR      R0,??DataTable1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ      ??OSTimeDlyHMSM_0
    227                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   0000000E   0x....             LDR      R0,??DataTable1_1  ;; 0x7275
   \   00000010   0xE09A             B        ??OSTimeDlyHMSM_1
    228                  return;
    229              }
    230          #endif
    231          
    232              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
   \                     ??OSTimeDlyHMSM_0: (+1)
   \   00000012   0x....             LDR      R5,??DataTable1_2
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ      ??OSTimeDlyHMSM_2
    233                 *p_err = OS_ERR_SCHED_LOCKED;
   \   0000001A   0x....             LDR      R0,??DataTable1_3  ;; 0x6d63
   \   0000001C   0xE094             B        ??OSTimeDlyHMSM_1
    234                  return;
    235              }
   \                     ??OSTimeDlyHMSM_2: (+1)
   \   0000001E   0x9808             LDR      R0,[SP, #+32]
    236          
    237              opt_time = opt & OS_OPT_TIME_MASK;                      /* Retrieve time options only.                            */
   \   00000020   0x466E             MOV      R6,SP
   \   00000022   0x270E             MOVS     R7,#+14
   \   00000024   0x4007             ANDS     R7,R7,R0
   \   00000026   0x80B7             STRH     R7,[R6, #+4]
    238              switch (opt_time) {
   \   00000028   0xD005             BEQ      ??OSTimeDlyHMSM_3
   \   0000002A   0x2F02             CMP      R7,#+2
   \   0000002C   0xD003             BEQ      ??OSTimeDlyHMSM_3
   \   0000002E   0x2F04             CMP      R7,#+4
   \   00000030   0xD00A             BEQ      ??OSTimeDlyHMSM_4
   \   00000032   0x2F08             CMP      R7,#+8
   \   00000034   0xD113             BNE      ??OSTimeDlyHMSM_5
    239                  case OS_OPT_TIME_DLY:
    240                  case OS_OPT_TIME_TIMEOUT:
    241                  case OS_OPT_TIME_PERIODIC:
    242                       if (milli == (CPU_INT32U)0u) {                 /* Make sure we didn't specify a 0 delay                  */
   \                     ??OSTimeDlyHMSM_3: (+1)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD106             BNE      ??OSTimeDlyHMSM_4
    243                           if (seconds == (CPU_INT16U)0u) {
    244                               if (minutes == (CPU_INT16U)0u) {
    245                                   if (hours == (CPU_INT16U)0u) {
   \   0000003A   0x000E             MOVS     R6,R1
   \   0000003C   0x4316             ORRS     R6,R6,R2
   \   0000003E   0x466F             MOV      R7,SP
   \   00000040   0x893F             LDRH     R7,[R7, #+8]
   \   00000042   0x4337             ORRS     R7,R7,R6
   \   00000044   0xD100             BNE      .+4
   \   00000046   0xE07E             B        ??OSTimeDlyHMSM_6
    246                                      *p_err = OS_ERR_TIME_ZERO_DLY;
    247                                       return;
    248                                   }
    249                               }
    250                           }
    251                       }
    252                       break;
    253          
    254                  case OS_OPT_TIME_MATCH:
    255                       break;
    256          
    257                  default:
    258                      *p_err = OS_ERR_OPT_INVALID;
    259                       return;
    260              }
    261          
    262          #if OS_CFG_ARG_CHK_EN > 0u                                  /* Validate arguments to be within range                  */
    263              opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
   \                     ??OSTimeDlyHMSM_4: (+1)
   \   00000048   0x....             LDR      R6,??DataTable5  ;; 0xffe1
   \   0000004A   0x4230             TST      R0,R6
   \   0000004C   0xD107             BNE      ??OSTimeDlyHMSM_5
    264              if (opt_invalid == DEF_YES) {
    265                 *p_err = OS_ERR_OPT_INVALID;
    266                  return;
    267              }
    268          
    269              opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
    270              if (opt_non_strict != DEF_YES) {
   \   0000004E   0x06C0             LSLS     R0,R0,#+27
   \   00000050   0xD458             BMI      ??OSTimeDlyHMSM_7
    271                   if (milli   > (CPU_INT32U)999u) {
   \   00000052   0x20FA             MOVS     R0,#+250
   \   00000054   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \   00000056   0x4283             CMP      R3,R0
   \   00000058   0xD303             BCC      ??OSTimeDlyHMSM_8
    272                      *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
   \   0000005A   0x....             LDR      R0,??DataTable5_1  ;; 0x727b
   \   0000005C   0xE074             B        ??OSTimeDlyHMSM_1
    273                       return;
    274                   }
   \                     ??OSTimeDlyHMSM_5: (+1)
   \   0000005E   0x....             LDR      R0,??DataTable1_5  ;; 0x5e25
   \   00000060   0xE072             B        ??OSTimeDlyHMSM_1
    275                   if (seconds > (CPU_INT16U)59u) {
   \                     ??OSTimeDlyHMSM_8: (+1)
   \   00000062   0x2A3C             CMP      R2,#+60
   \   00000064   0xDB01             BLT      ??OSTimeDlyHMSM_9
    276                      *p_err = OS_ERR_TIME_INVALID_SECONDS;
   \   00000066   0x....             LDR      R0,??DataTable5_2  ;; 0x727a
   \   00000068   0xE06E             B        ??OSTimeDlyHMSM_1
    277                       return;
    278                   }
    279                   if (minutes > (CPU_INT16U)59u) {
   \                     ??OSTimeDlyHMSM_9: (+1)
   \   0000006A   0x293C             CMP      R1,#+60
   \   0000006C   0xDA4D             BGE      ??OSTimeDlyHMSM_10
    280                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
    281                       return;
    282                   }
    283                   if (hours   > (CPU_INT16U)99u) {
   \   0000006E   0x4668             MOV      R0,SP
   \   00000070   0x8900             LDRH     R0,[R0, #+8]
   \   00000072   0x2864             CMP      R0,#+100
   \   00000074   0xDA51             BGE      ??OSTimeDlyHMSM_11
    284                      *p_err = OS_ERR_TIME_INVALID_HOURS;
    285                       return;
    286                   }
    287              } else {
    288                   if (minutes > (CPU_INT16U)9999u) {
    289                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
    290                       return;
    291                   }
    292                   if (hours   > (CPU_INT16U)999u) {
    293                      *p_err = OS_ERR_TIME_INVALID_HOURS;
    294                       return;
    295                   }
    296              }
    297          #endif
    298          
    299                                                                      /* Compute the total number of clock ticks required..     */
    300                                                                      /* .. (rounded to the nearest tick)                       */
    301              tick_rate = OSCfg_TickRate_Hz;
    302              ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
    303                        + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;
   \                     ??OSTimeDlyHMSM_12: (+1)
   \   00000076   0x....             LDR      R0,??DataTable5_3
   \   00000078   0x6806             LDR      R6,[R0, #+0]
   \   0000007A   0x4668             MOV      R0,SP
   \   0000007C   0x8907             LDRH     R7,[R0, #+8]
   \   0000007E   0x20E1             MOVS     R0,#+225
   \   00000080   0x0100             LSLS     R0,R0,#+4        ;; #+3600
   \   00000082   0x4378             MULS     R0,R7,R0
   \   00000084   0x010F             LSLS     R7,R1,#+4
   \   00000086   0x1A79             SUBS     R1,R7,R1
   \   00000088   0x0089             LSLS     R1,R1,#+2
   \   0000008A   0x1840             ADDS     R0,R0,R1
   \   0000008C   0x1881             ADDS     R1,R0,R2
   \   0000008E   0x4371             MULS     R1,R6,R1
   \   00000090   0x9100             STR      R1,[SP, #+0]
   \   00000092   0x001F             MOVS     R7,R3
   \   00000094   0x20FA             MOVS     R0,#+250
   \   00000096   0x0040             LSLS     R0,R0,#+1        ;; #+500
   \   00000098   0x0031             MOVS     R1,R6
   \   0000009A   0x.... 0x....      BL       __aeabi_uidiv
   \   0000009E   0x1838             ADDS     R0,R7,R0
   \   000000A0   0x4370             MULS     R0,R6,R0
   \   000000A2   0x21FA             MOVS     R1,#+250
   \   000000A4   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   000000A6   0x.... 0x....      BL       __aeabi_uidiv
   \   000000AA   0x9900             LDR      R1,[SP, #+0]
   \   000000AC   0x180F             ADDS     R7,R1,R0
    304          
    305              if (ticks > (OS_TICK)0u) {
   \   000000AE   0xD04A             BEQ      ??OSTimeDlyHMSM_6
    306                  OS_CRITICAL_ENTER();
   \   000000B0   0x.... 0x....      BL       CPU_SR_Save
   \   000000B4   0x0006             MOVS     R6,R0
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000BA   0x7828             LDRB     R0,[R5, #+0]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \   000000BE   0x7028             STRB     R0,[R5, #+0]
   \   000000C0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0x.... 0x....      BL       CPU_SR_Restore
    307                  OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \   000000CA   0x....             LDR      R6,??DataTable4
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x6831             LDR      R1,[R6, #+0]
   \   000000D0   0x3136             ADDS     R1,R1,#+54
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
    308                  OS_TickListInsert(OSTCBCurPtr,
    309                                    ticks,
    310                                    opt_time,
    311                                    p_err);
   \   000000D4   0x0023             MOVS     R3,R4
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x8882             LDRH     R2,[R0, #+4]
   \   000000DA   0x0039             MOVS     R1,R7
   \   000000DC   0x6830             LDR      R0,[R6, #+0]
   \   000000DE   0x.... 0x....      BL       OS_TickListInsert
    312                  if (*p_err != OS_ERR_NONE) {
   \   000000E2   0x8820             LDRH     R0,[R4, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD01A             BEQ      ??OSTimeDlyHMSM_13
    313                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000E8   0x.... 0x....      BL       CPU_SR_Save
   \   000000EC   0x0006             MOVS     R6,R0
   \   000000EE   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000F2   0x7828             LDRB     R0,[R5, #+0]
   \   000000F4   0x1E40             SUBS     R0,R0,#+1
   \   000000F6   0x7028             STRB     R0,[R5, #+0]
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x0030             MOVS     R0,R6
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
    314                       return;
   \   00000102   0xE022             B        ??OSTimeDlyHMSM_14
    315                  }
   \                     ??OSTimeDlyHMSM_7: (+1)
   \   00000104   0x....             LDR      R0,??DataTable5_4  ;; 0x2710
   \   00000106   0x4281             CMP      R1,R0
   \   00000108   0xDB01             BLT      ??OSTimeDlyHMSM_15
   \                     ??OSTimeDlyHMSM_10: (+1)
   \   0000010A   0x....             LDR      R0,??DataTable5_5  ;; 0x7279
   \   0000010C   0xE01C             B        ??OSTimeDlyHMSM_1
   \                     ??OSTimeDlyHMSM_15: (+1)
   \   0000010E   0x4668             MOV      R0,SP
   \   00000110   0x8900             LDRH     R0,[R0, #+8]
   \   00000112   0x26FA             MOVS     R6,#+250
   \   00000114   0x00B6             LSLS     R6,R6,#+2        ;; #+1000
   \   00000116   0x42B0             CMP      R0,R6
   \   00000118   0xDBAD             BLT      ??OSTimeDlyHMSM_12
   \                     ??OSTimeDlyHMSM_11: (+1)
   \   0000011A   0x....             LDR      R0,??DataTable5_6  ;; 0x7278
   \   0000011C   0xE014             B        ??OSTimeDlyHMSM_1
    316                  OS_RdyListRemove(OSTCBCurPtr);                      /* Remove current task from ready list                    */
   \                     ??OSTimeDlyHMSM_13: (+1)
   \   0000011E   0x6830             LDR      R0,[R6, #+0]
   \   00000120   0x.... 0x....      BL       OS_RdyListRemove
    317                  OS_CRITICAL_EXIT_NO_SCHED();
   \   00000124   0x.... 0x....      BL       CPU_SR_Save
   \   00000128   0x0006             MOVS     R6,R0
   \   0000012A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000012E   0x7828             LDRB     R0,[R5, #+0]
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0x7028             STRB     R0,[R5, #+0]
   \   00000134   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000138   0x0030             MOVS     R0,R6
   \   0000013A   0x.... 0x....      BL       CPU_SR_Restore
    318                  OSSched();                                          /* Find next task to run!                                 */
   \   0000013E   0x.... 0x....      BL       OSSched
    319                 *p_err = OS_ERR_NONE;
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xE000             B        ??OSTimeDlyHMSM_1
    320              } else {
    321                 *p_err = OS_ERR_TIME_ZERO_DLY;
   \                     ??OSTimeDlyHMSM_6: (+1)
   \   00000146   0x....             LDR      R0,??DataTable1_4  ;; 0x727e
   \                     ??OSTimeDlyHMSM_1: (+1)
   \   00000148   0x8020             STRH     R0,[R4, #+0]
    322              }
    323          }
   \                     ??OSTimeDlyHMSM_14: (+1)
   \   0000014A   0xB003             ADD      SP,SP,#+12
   \   0000014C   0xBDF0             POP      {R4-R7,PC}       ;; return
    324          #endif
    325          /*$PAGE*/
    326          /*
    327          ************************************************************************************************************************
    328          *                                                RESUME A DELAYED TASK
    329          *
    330          * Description: This function is used resume a task that has been delayed through a call to either OSTimeDly() or
    331          *              OSTimeDlyHMSM().  Note that cannot call this function to resume a task that is waiting for an event
    332          *              with timeout.
    333          *
    334          * Arguments  : p_tcb    is a pointer to the TCB of the task to resume.
    335          *
    336          *              p_err    is a pointer to a variable that will receive an error code
    337          *
    338          *                           OS_ERR_NONE                  Task has been resumed
    339          *                           OS_ERR_STATE_INVALID         Task is in an invalid state
    340          *                           OS_ERR_TIME_DLY_RESUME_ISR   If called from an ISR
    341          *                           OS_ERR_TIME_NOT_DLY          Task is not waiting for time to expire
    342          *                           OS_ERR_TASK_SUSPENDED        Task cannot be resumed, it was suspended by OSTaskSuspend()
    343          *
    344          * Note(s)    : none
    345          ************************************************************************************************************************
    346          */
    347          
    348          #if OS_CFG_TIME_DLY_RESUME_EN > 0u

   \                                 In section .text, align 4, keep-with-next
    349          void  OSTimeDlyResume (OS_TCB  *p_tcb,
    350                                 OS_ERR  *p_err)
    351          {
   \                     OSTimeDlyResume: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
    352              CPU_SR_ALLOC();
    353          
    354          
    355          
    356          #ifdef OS_SAFETY_CRITICAL
    357              if (p_err == (OS_ERR *)0) {
    358                  OS_SAFETY_CRITICAL_EXCEPTION();
    359                  return;
    360              }
    361          #endif
    362          
    363          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    364              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000004   0x....             LDR      R0,??DataTable5_7
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ      ??OSTimeDlyResume_1
    365                 *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
   \   0000000C   0x....             LDR      R0,??DataTable5_8  ;; 0x7276
   \   0000000E   0xE003             B.N      ??OSTimeDlyResume_2
    366                  return;
    367              }
    368          #endif
    369          
    370          #if OS_CFG_ARG_CHK_EN > 0u
    371              if (p_tcb == (OS_TCB *)0) {                             /* Not possible for the running task to be delayed!       */
   \                     ??OSTimeDlyResume_1: (+1)
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE      ??OSTimeDlyResume_3
    372                 *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000016   0x....             LDR      R0,??DataTable5_9  ;; 0x7151
   \                     ??OSTimeDlyResume_2: (+1)
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    373                  return;
   \   0000001A   0xBDF1             POP      {R0,R4-R7,PC}
    374              }
    375          #endif
    376          
    377              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDlyResume_3: (+1)
   \   0000001C   0x.... 0x....      BL       CPU_SR_Save
   \   00000020   0x0006             MOVS     R6,R0
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStart
    378              if (p_tcb == OSTCBCurPtr) {                             /* Not possible for the running task to be delayed!       */
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x....             LDR      R1,??DataTable4
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD102             BNE      ??OSTimeDlyResume_4
    379                 *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000030   0x....             LDR      R0,??DataTable5_9  ;; 0x7151
   \   00000032   0x8020             STRH     R0,[R4, #+0]
    380                  CPU_CRITICAL_EXIT();
   \   00000034   0x....             B.N      ?Subroutine0
    381                  return;
    382              }
    383          
    384              switch (p_tcb->TaskState) {
   \                     ??OSTimeDlyResume_4: (+1)
   \   00000036   0x3036             ADDS     R0,R0,#+54
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2807             CMP      R0,#+7
   \   0000003C   0xD84E             BHI      ??OSTimeDlyResume_5
   \   0000003E   0xA101             ADR      R1,??OSTimeDlyResume_0
   \   00000040   0x5C09             LDRB     R1,[R1, R0]
   \   00000042   0x448F             ADD      PC,PC,R1
   \                     ??OSTimeDlyResume_0:
   \   00000044   0x88 0x06          DC8      0x88,0x6,0x88,0x88
   \              0x88 0x88    
   \   00000048   0x88 0x4A          DC8      0x88,0x4A,0x88,0x88
   \              0x88 0x88    
    385                  case OS_TASK_STATE_RDY:                             /* Cannot Abort delay if task is ready                    */
    386                       CPU_CRITICAL_EXIT();
    387                      *p_err = OS_ERR_TASK_NOT_DLY;
    388                       break;
    389          
    390                  case OS_TASK_STATE_DLY:
    391                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTimeDlyResume_6: (+1)
   \   0000004C   0x....             LDR      R5,??DataTable5_10
   \   0000004E   0x7828             LDRB     R0,[R5, #+0]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x7028             STRB     R0,[R5, #+0]
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x0030             MOVS     R0,R6
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    392                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   0000005E   0x2700             MOVS     R7,#+0
   \   00000060   0x9900             LDR      R1,[SP, #+0]
   \   00000062   0x3136             ADDS     R1,R1,#+54
   \   00000064   0x700F             STRB     R7,[R1, #+0]
    393                       OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x.... 0x....      BL       OS_TickListRemove
    394                       OS_RdyListInsert(p_tcb);                       /* Add to ready list                                      */
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x.... 0x....      BL       OS_RdyListInsert
    395                       OS_CRITICAL_EXIT_NO_SCHED();
   \   00000072   0x.... 0x....      BL       CPU_SR_Save
   \   00000076   0x0006             MOVS     R6,R0
   \   00000078   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000007C   0x7828             LDRB     R0,[R5, #+0]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x7028             STRB     R0,[R5, #+0]
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    396                      *p_err = OS_ERR_NONE;
   \   0000008C   0x8027             STRH     R7,[R4, #+0]
    397                       break;
   \   0000008E   0xE02C             B        ??OSTimeDlyResume_7
    398          
    399                  case OS_TASK_STATE_PEND:
    400                       CPU_CRITICAL_EXIT();
    401                      *p_err = OS_ERR_TASK_NOT_DLY;
    402                       break;
    403          
    404                  case OS_TASK_STATE_PEND_TIMEOUT:
    405                       CPU_CRITICAL_EXIT();
    406                      *p_err = OS_ERR_TASK_NOT_DLY;
    407                       break;
    408          
    409                  case OS_TASK_STATE_SUSPENDED:
    410                       CPU_CRITICAL_EXIT();
    411                      *p_err = OS_ERR_TASK_NOT_DLY;
    412                       break;
    413          
    414                  case OS_TASK_STATE_DLY_SUSPENDED:
    415                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTimeDlyResume_8: (+1)
   \   00000090   0x....             LDR      R5,??DataTable5_10
   \   00000092   0x7828             LDRB     R0,[R5, #+0]
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \   00000096   0x7028             STRB     R0,[R5, #+0]
   \   00000098   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009C   0x0030             MOVS     R0,R6
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
    416                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \   000000A2   0x2004             MOVS     R0,#+4
   \   000000A4   0x9900             LDR      R1,[SP, #+0]
   \   000000A6   0x3136             ADDS     R1,R1,#+54
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
    417                       OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
   \   000000AC   0x.... 0x....      BL       OS_TickListRemove
    418                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000B0   0x.... 0x....      BL       CPU_SR_Save
   \   000000B4   0x0006             MOVS     R6,R0
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000BA   0x7828             LDRB     R0,[R5, #+0]
   \   000000BC   0x1E40             SUBS     R0,R0,#+1
   \   000000BE   0x7028             STRB     R0,[R5, #+0]
   \   000000C0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0x.... 0x....      BL       CPU_SR_Restore
    419                      *p_err            = OS_ERR_TASK_SUSPENDED;
   \   000000CA   0x....             LDR      R0,??DataTable5_11  ;; 0x715a
   \   000000CC   0xE00C             B        ??OSTimeDlyResume_9
    420                       break;
    421          
    422                  case OS_TASK_STATE_PEND_SUSPENDED:
    423                       CPU_CRITICAL_EXIT();
    424                      *p_err = OS_ERR_TASK_NOT_DLY;
    425                       break;
    426          
    427                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    428                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_10: (+1)
   \   000000CE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0x.... 0x....      BL       CPU_SR_Restore
    429                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   000000D8   0x....             LDR      R0,??DataTable5_9  ;; 0x7151
   \   000000DA   0xE005             B        ??OSTimeDlyResume_9
    430                       break;
    431          
    432                  default:
    433                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_5: (+1)
   \   000000DC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E0   0x0030             MOVS     R0,R6
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
    434                      *p_err = OS_ERR_STATE_INVALID;
   \   000000E6   0x....             LDR      R0,??DataTable5_12  ;; 0x6e2d
   \                     ??OSTimeDlyResume_9: (+1)
   \   000000E8   0x8020             STRH     R0,[R4, #+0]
    435                       break;
    436              }
    437          
    438              OSSched();
   \                     ??OSTimeDlyResume_7: (+1)
   \   000000EA   0x.... 0x....      BL       OSSched
    439          }
   \   000000EE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    440          #endif
    441          /*$PAGE*/
    442          /*
    443          ************************************************************************************************************************
    444          *                                               GET CURRENT SYSTEM TIME
    445          *
    446          * Description: This function is used by your application to obtain the current value of the counter which keeps track of
    447          *              the number of clock ticks.
    448          *
    449          * Arguments  : p_err    is a pointer to a variable that will receive an error code
    450          *
    451          *                           OS_ERR_NONE           If the call was successful
    452          *
    453          * Returns    : The current value of OSTickCtr
    454          ************************************************************************************************************************
    455          */
    456          

   \                                 In section .text, align 2, keep-with-next
    457          OS_TICK  OSTimeGet (OS_ERR  *p_err)
    458          {
   \                     OSTimeGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    459              OS_TICK  ticks;
    460              CPU_SR_ALLOC();
    461          
    462          
    463          
    464          #ifdef OS_SAFETY_CRITICAL
    465              if (p_err == (OS_ERR *)0) {
    466                  OS_SAFETY_CRITICAL_EXCEPTION();
    467                  return ((OS_TICK)0);
    468              }
    469          #endif
    470          
    471              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x0005             MOVS     R5,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    472              ticks = OSTickCtr;
   \   0000000E   0x....             LDR      R0,??DataTable5_13
   \   00000010   0x6806             LDR      R6,[R0, #+0]
    473              CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       CPU_SR_Restore
    474             *p_err = OS_ERR_NONE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
    475              return (ticks);
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    476          }
    477          
    478          /*
    479          ************************************************************************************************************************
    480          *                                                   SET SYSTEM CLOCK
    481          *
    482          * Description: This function sets the counter which keeps track of the number of clock ticks.
    483          *
    484          * Arguments  : ticks    is the desired tick value
    485          *
    486          *              p_err    is a pointer to a variable that will receive an error code
    487          *
    488          *                           OS_ERR_NONE           If the call was successful
    489          *
    490          * Returns    : none
    491          ************************************************************************************************************************
    492          */
    493          

   \                                 In section .text, align 2, keep-with-next
    494          void  OSTimeSet (OS_TICK   ticks,
    495                           OS_ERR   *p_err)
    496          {
   \                     OSTimeSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    497              CPU_SR_ALLOC();
    498          
    499          
    500          
    501          #ifdef OS_SAFETY_CRITICAL
    502              if (p_err == (OS_ERR *)0) {
    503                  OS_SAFETY_CRITICAL_EXCEPTION();
    504                  return;
    505              }
    506          #endif
    507          
    508              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    509              OSTickCtr = ticks;
   \   00000010   0x....             LDR      R0,??DataTable5_13
   \   00000012   0x6005             STR      R5,[R0, #+0]
    510              CPU_CRITICAL_EXIT();
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       CPU_SR_Restore
    511             *p_err     = OS_ERR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    512          }
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    513          
    514          /*$PAGE*/
    515          /*
    516          ************************************************************************************************************************
    517          *                                                 PROCESS SYSTEM TICK
    518          *
    519          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    520          *              'clock tick').  This function should be called by the tick ISR.
    521          *
    522          * Arguments  : none
    523          *
    524          * Returns    : none
    525          ************************************************************************************************************************
    526          */
    527          

   \                                 In section .text, align 2, keep-with-next
    528          void  OSTimeTick (void)
    529          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    530              OS_ERR  err;
    531          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    532              CPU_TS  ts;
    533          #endif
    534          
    535          
    536              OSTimeTickHook();                                       /* Call user definable hook                               */
   \   00000004   0x.... 0x....      BL       OSTimeTickHook
    537          
    538          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    539          
    540              ts = OS_TS_GET();                                       /* Get timestamp                                          */
    541              OS_IntQPost((OS_OBJ_TYPE) OS_OBJ_TYPE_TICK,             /* Post to ISR queue                                      */
    542                          (void      *)&OSRdyList[OSPrioCur],
    543                          (void      *) 0,
    544                          (OS_MSG_SIZE) 0u,
    545                          (OS_FLAGS   ) 0u,
    546                          (OS_OPT     ) 0u,
    547                          (CPU_TS     ) ts,
    548                          (OS_ERR    *)&err);
   \   00000008   0xA804             ADD      R0,SP,#+16
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x....             LDR      R0,??DataTable5_14
   \   0000001A   0x....             LDR      R1,??DataTable5_15
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x004C             LSLS     R4,R1,#+1
   \   00000020   0x1861             ADDS     R1,R4,R1
   \   00000022   0x0089             LSLS     R1,R1,#+2
   \   00000024   0x1841             ADDS     R1,R0,R1
   \   00000026   0x....             LDR      R0,??DataTable5_16  ;; 0x4b434954
   \   00000028   0x.... 0x....      BL       OS_IntQPost
    549          
    550          #else
    551          
    552             (void)OSTaskSemPost((OS_TCB *)&OSTickTaskTCB,            /* Signal tick task                                       */
    553                                 (OS_OPT  ) OS_OPT_POST_NONE,
    554                                 (OS_ERR *)&err);
    555          
    556          
    557          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    558              OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
    559          #endif
    560          
    561          #if OS_CFG_TMR_EN > 0u
    562              OSTmrUpdateCtr--;
    563              if (OSTmrUpdateCtr == (OS_CTR)0u) {
    564                  OSTmrUpdateCtr = OSTmrUpdateCnt;
    565                  OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
    566                                (OS_OPT  ) OS_OPT_POST_NONE,
    567                                (OS_ERR *)&err);
    568              }
    569          #endif
    570          
    571          #endif
    572          }
   \   0000002C   0xB006             ADD      SP,SP,#+24
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x00007275         DC32     0x7275

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x00006D63         DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x0000727E         DC32     0x727e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x00005E25         DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x0000FFE1         DC32     0xffe1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x0000727B         DC32     0x727b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x0000727A         DC32     0x727a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x00007279         DC32     0x7279

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x00007278         DC32     0x7278

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x00007276         DC32     0x7276

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x00007151         DC32     0x7151

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x0000715A         DC32     0x715a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x00006E2D         DC32     0x6e2d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x4B434954         DC32     0x4b434954

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTimeDly
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsert
      32   OSTimeDlyHMSM
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_RdyListRemove
        32   -> OS_TickListInsert
        32 __aeabi_uidiv
      24   OSTimeDlyResume
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListInsert
        24   -> OS_TickListRemove
      16   OSTimeGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTimeSet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      32   OSTimeTick
        32   -> OSTimeTickHook
        32   -> OS_IntQPost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      12  ?Subroutine0
     174  OSTimeDly
     334  OSTimeDlyHMSM
     240  OSTimeDlyResume
      36  OSTimeGet
      36  OSTimeSet
      48  OSTimeTick

 
 976 bytes in section .text
 
 976 bytes of CODE memory

Errors: none
Warnings: none
