###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:12
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\os_cpu_c.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\os_cpu_c.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-III
      4          *                                          The Real-Time Kernel
      5          *
      6          *
      7          *                           (c) Copyright 2009-2010; Micrium, Inc.; Weston, FL
      8          *                    All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                                           ARM Cortex-M3 Port
     11          *
     12          * File    : OS_CPU_C.C
     13          * Version : V3.02.01
     14          * By      : JJL
     15          *           BAN
     16          *
     17          * LICENSING TERMS:
     18          * ---------------
     19          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     20          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     21          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     22          *           application/product.   We provide ALL the source code for your convenience and to help you 
     23          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     24          *           it commercially without paying a licensing fee.
     25          *
     26          *           Knowledge of the source code may NOT be used to develop a similar product.
     27          *
     28          *           Please help us continue to provide the embedded community with the finest software available.
     29          *           Your honesty is greatly appreciated.
     30          *
     31          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     32          *
     33          * For       : ARMv7M Cortex-M3
     34          * Mode      : Thumb2
     35          * Toolchain : IAR EWARM
     36          *********************************************************************************************************
     37          */
     38          
     39          #define   OS_CPU_GLOBALS
     40          
     41          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     42          const  CPU_CHAR  *os_cpu_c__c = "$Id: $";
     43          #endif
     44          
     45          /*$PAGE*/
     46          /*
     47          *********************************************************************************************************
     48          *                                             INCLUDE FILES
     49          *********************************************************************************************************
     50          */
     51          
     52          #include  <os.h>

   \                                 In section .bss, align 4
   \   __absolute unsigned int *OS_CPU_ExceptStkBase
   \                     OS_CPU_ExceptStkBase:
   \   00000000                      DS8 4
     53          
     54          /*
     55          *********************************************************************************************************
     56          *                                           IDLE TASK HOOK
     57          *
     58          * Description: This function is called by the idle task.  This hook has been added to allow you to do
     59          *              such things as STOP the CPU to conserve power.
     60          *
     61          * Arguments  : None.
     62          *
     63          * Note(s)    : None.
     64          *********************************************************************************************************
     65          */
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void  OSIdleTaskHook (void)
     68          {
     69          #if OS_CFG_APP_HOOKS_EN > 0u
     70              if (OS_AppIdleTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \                     OSIdleTaskHook: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD100             BNE      ??OSIdleTaskHook_0
   \   00000008   0x4770             BX       LR
     71                  (*OS_AppIdleTaskHookPtr)();
   \                     ??OSIdleTaskHook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       ??__iar_via_R0_0
     72              }
     73          #endif
     74          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
     75          
     76          
     77          /*$PAGE*/
     78          /*
     79          *********************************************************************************************************
     80          *                                       OS INITIALIZATION HOOK
     81          *
     82          * Description: This function is called by OSInit() at the beginning of OSInit().
     83          *
     84          * Arguments  : None.
     85          *
     86          * Note(s)    : None.
     87          *********************************************************************************************************
     88          */
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void  OSInitHook (void)
     91          {
     92              OS_CPU_ExceptStkBase = (CPU_STK *)(OSCfg_ISRStkBasePtr + OSCfg_ISRStkSize - 1u);
   \                     OSInitHook: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10_1
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR      R1,??DataTable10_2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0089             LSLS     R1,R1,#+2
   \   0000000A   0x1840             ADDS     R0,R0,R1
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0x....             LDR      R1,??DataTable10_3
   \   00000010   0x6008             STR      R0,[R1, #+0]
     93          }
   \   00000012   0x4770             BX       LR               ;; return
     94          
     95          
     96          /*$PAGE*/
     97          /*
     98          *********************************************************************************************************
     99          *                                         STATISTIC TASK HOOK
    100          *
    101          * Description: This function is called every second by uC/OS-III's statistics task.  This allows your
    102          *              application to add functionality to the statistics task.
    103          *
    104          * Arguments  : None.
    105          *
    106          * Note(s)    : None.
    107          *********************************************************************************************************
    108          */
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void  OSStatTaskHook (void)
    111          {
    112          #if OS_CFG_APP_HOOKS_EN > 0u
    113              if (OS_AppStatTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \                     OSStatTaskHook: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10_4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD100             BNE      ??OSStatTaskHook_0
   \   00000008   0x4770             BX       LR
    114                  (*OS_AppStatTaskHookPtr)();
   \                     ??OSStatTaskHook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       ??__iar_via_R0_0
    115              }
    116          #endif
    117          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    118          
    119          
    120          /*$PAGE*/
    121          /*
    122          *********************************************************************************************************
    123          *                                          TASK CREATION HOOK
    124          *
    125          * Description: This function is called when a task is created.
    126          *
    127          * Arguments  : p_tcb        Pointer to the task control block of the task being created.
    128          *
    129          * Note(s)    : None.
    130          *********************************************************************************************************
    131          */
    132          

   \                                 In section .text, align 2, keep-with-next
    133          void  OSTaskCreateHook (OS_TCB  *p_tcb)
    134          {
    135          #if OS_CFG_APP_HOOKS_EN > 0u
    136              if (OS_AppTaskCreateHookPtr != (OS_APP_HOOK_TCB)0) {
   \                     OSTaskCreateHook: (+1)
   \   00000000   0x....             LDR      R1,??DataTable10_5
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x000A             MOVS     R2,R1
   \   00000006   0xD100             BNE      ??OSTaskCreateHook_0
   \   00000008   0x4770             BX       LR
    137                  (*OS_AppTaskCreateHookPtr)(p_tcb);
   \                     ??OSTaskCreateHook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       ??__iar_via_R1_0
    138              }
    139          #else
    140              (void)p_tcb;                                            /* Prevent compiler warning                               */
    141          #endif
    142          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    143          
    144          
    145          /*$PAGE*/
    146          /*
    147          *********************************************************************************************************
    148          *                                           TASK DELETION HOOK
    149          *
    150          * Description: This function is called when a task is deleted.
    151          *
    152          * Arguments  : p_tcb        Pointer to the task control block of the task being deleted.
    153          *
    154          * Note(s)    : None.
    155          *********************************************************************************************************
    156          */
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void  OSTaskDelHook (OS_TCB  *p_tcb)
    159          {
    160          #if OS_CFG_APP_HOOKS_EN > 0u
    161              if (OS_AppTaskDelHookPtr != (OS_APP_HOOK_TCB)0) {
   \                     OSTaskDelHook: (+1)
   \   00000000   0x....             LDR      R1,??DataTable10_6
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x000A             MOVS     R2,R1
   \   00000006   0xD100             BNE      ??OSTaskDelHook_0
   \   00000008   0x4770             BX       LR
    162                  (*OS_AppTaskDelHookPtr)(p_tcb);
   \                     ??OSTaskDelHook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       ??__iar_via_R1_0
    163              }
    164          #else
    165              (void)p_tcb;                                            /* Prevent compiler warning                               */
    166          #endif
    167          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    168          
    169          
    170          /*$PAGE*/
    171          /*
    172          *********************************************************************************************************
    173          *                                            TASK RETURN HOOK
    174          *
    175          * Description: This function is called if a task accidentally returns.  In other words, a task should
    176          *              either be an infinite loop or delete itself when done.
    177          *
    178          * Arguments  : p_tcb        Pointer to the task control block of the task that is returning.
    179          *
    180          * Note(s)    : None.
    181          *********************************************************************************************************
    182          */
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void  OSTaskReturnHook (OS_TCB  *p_tcb)
    185          {
    186          #if OS_CFG_APP_HOOKS_EN > 0u
    187              if (OS_AppTaskReturnHookPtr != (OS_APP_HOOK_TCB)0) {
   \                     OSTaskReturnHook: (+1)
   \   00000000   0x....             LDR      R1,??DataTable10_7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x000A             MOVS     R2,R1
   \   00000006   0xD100             BNE      ??OSTaskReturnHook_0
   \   00000008   0x4770             BX       LR
    188                  (*OS_AppTaskReturnHookPtr)(p_tcb);
   \                     ??OSTaskReturnHook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       ??__iar_via_R1_0
    189              }
    190          #else
    191              (void)p_tcb;                                            /* Prevent compiler warning                               */
    192          #endif
    193          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    194          
    195          
    196          /*$PAGE*/
    197          /*
    198          **********************************************************************************************************
    199          *                                       INITIALIZE A TASK'S STACK
    200          *
    201          * Description: This function is called by OS_Task_Create() or OSTaskCreateExt() to initialize the stack
    202          *              frame of the task being created. This function is highly processor specific.
    203          *
    204          * Arguments  : p_task       Pointer to the task entry point address.
    205          *
    206          *              p_arg        Pointer to a user supplied data area that will be passed to the task
    207          *                               when the task first executes.
    208          *
    209          *              p_stk_base   Pointer to the base address of the stack.
    210          *
    211          *              stk_size     Size of the stack, in number of CPU_STK elements.
    212          *
    213          *              opt          Options used to alter the behavior of OS_Task_StkInit().
    214          *                            (see OS.H for OS_TASK_OPT_xxx).
    215          *
    216          * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
    217          *              been placed on the stack in the proper order.
    218          *
    219          * Note(s)    : 1) Interrupts are enabled when task starts executing.
    220          *
    221          *              2) All tasks run in Thread mode, using process stack.
    222          **********************************************************************************************************
    223          */
    224          

   \                                 In section .text, align 2, keep-with-next
    225          CPU_STK  *OSTaskStkInit (OS_TASK_PTR    p_task,
    226                                   void          *p_arg,
    227                                   CPU_STK       *p_stk_base,
    228                                   CPU_STK       *p_stk_limit,
    229                                   CPU_STK_SIZE   stk_size,
    230                                   OS_OPT         opt)
    231          {
   \                     OSTaskStkInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0004             MOVS     R4,R0
    232              CPU_STK  *p_stk;
    233          
    234          
    235              (void)opt;                                              /* Prevent compiler warning                               */
    236          
    237              p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
    238                                                                      /* Registers stacked as if auto-saved on exception        */
    239              *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x0080             LSLS     R0,R0,#+2
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0x1F00             SUBS     R0,R0,#+4
   \   0000000C   0x2280             MOVS     R2,#+128
   \   0000000E   0x0452             LSLS     R2,R2,#+17       ;; #+16777216
   \   00000010   0x6002             STR      R2,[R0, #+0]
    240              *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
   \   00000012   0x1F00             SUBS     R0,R0,#+4
   \   00000014   0x6004             STR      R4,[R0, #+0]
    241              *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
   \   00000016   0x1F00             SUBS     R0,R0,#+4
   \   00000018   0x....             LDR      R2,??DataTable10_8
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    242              *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
   \   0000001C   0x1F00             SUBS     R0,R0,#+4
   \   0000001E   0x....             LDR      R2,??DataTable10_9  ;; 0x12121212
   \   00000020   0x6002             STR      R2,[R0, #+0]
    243              *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
   \   00000022   0x1F00             SUBS     R0,R0,#+4
   \   00000024   0x....             LDR      R2,??DataTable10_10  ;; 0x3030303
   \   00000026   0x6002             STR      R2,[R0, #+0]
    244              *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
   \   00000028   0x1F00             SUBS     R0,R0,#+4
   \   0000002A   0x....             LDR      R2,??DataTable10_11  ;; 0x2020202
   \   0000002C   0x6002             STR      R2,[R0, #+0]
    245              *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
   \   0000002E   0x1F00             SUBS     R0,R0,#+4
   \   00000030   0x6003             STR      R3,[R0, #+0]
    246              *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
   \   00000032   0x1F00             SUBS     R0,R0,#+4
   \   00000034   0x6001             STR      R1,[R0, #+0]
    247                                                                      /* Remaining registers saved on process stack             */
    248              *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
   \   00000036   0x1F00             SUBS     R0,R0,#+4
   \   00000038   0x....             LDR      R1,??DataTable10_12  ;; 0x11111111
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    249              *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
   \   0000003C   0x1F00             SUBS     R0,R0,#+4
   \   0000003E   0x00D1             LSLS     R1,R2,#+3
   \   00000040   0x6001             STR      R1,[R0, #+0]
    250              *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
   \   00000042   0x1F00             SUBS     R0,R0,#+4
   \   00000044   0x....             LDR      R1,??DataTable10_13  ;; 0x9090909
   \   00000046   0x6001             STR      R1,[R0, #+0]
    251              *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
   \   00000048   0x1F00             SUBS     R0,R0,#+4
   \   0000004A   0x0091             LSLS     R1,R2,#+2
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    252              *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
   \   0000004E   0x1F00             SUBS     R0,R0,#+4
   \   00000050   0x....             LDR      R1,??DataTable10_14  ;; 0x7070707
   \   00000052   0x6001             STR      R1,[R0, #+0]
    253              *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
   \   00000054   0x1F00             SUBS     R0,R0,#+4
   \   00000056   0x....             LDR      R1,??DataTable10_15  ;; 0x6060606
   \   00000058   0x6001             STR      R1,[R0, #+0]
    254              *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
   \   0000005A   0x1F00             SUBS     R0,R0,#+4
   \   0000005C   0x....             LDR      R1,??DataTable10_16  ;; 0x5050505
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    255              *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
   \   00000060   0x1F00             SUBS     R0,R0,#+4
   \   00000062   0x0051             LSLS     R1,R2,#+1
   \   00000064   0x6001             STR      R1,[R0, #+0]
    256          
    257              return (p_stk);
   \   00000066   0xBC10             POP      {R4}
   \   00000068   0x4770             BX       LR               ;; return
    258          }
    259          
    260          
    261          /*$PAGE*/
    262          /*
    263          *********************************************************************************************************
    264          *                                           TASK SWITCH HOOK
    265          *
    266          * Description: This function is called when a task switch is performed.  This allows you to perform other
    267          *              operations during a context switch.
    268          *
    269          * Arguments  : None.
    270          *
    271          * Note(s)    : 1) Interrupts are disabled during this call.
    272          *              2) It is assumed that the global pointer 'OSTCBHighRdyPtr' points to the TCB of the task
    273          *                 that will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCurPtr' points
    274          *                 to the task being switched out (i.e. the preempted task).
    275          *********************************************************************************************************
    276          */
    277          

   \                                 In section .text, align 2, keep-with-next
    278          void  OSTaskSwHook (void)
    279          {
   \                     OSTaskSwHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    280          #if OS_CFG_TASK_PROFILE_EN > 0u
    281              CPU_TS  ts;
    282          #endif
    283          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    284              CPU_TS  int_dis_time;
    285          #endif
    286          
    287          
    288          
    289          #if OS_CFG_APP_HOOKS_EN > 0u
    290              if (OS_AppTaskSwHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR      R0,??DataTable10_17
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xD001             BEQ      ??OSTaskSwHook_0
    291                  (*OS_AppTaskSwHookPtr)();
   \   0000000A   0x.... 0x....      BL       ??__iar_via_R0_0
    292              }
    293          #endif
    294          
    295          #if OS_CFG_TASK_PROFILE_EN > 0u
    296              ts = OS_TS_GET();
    297              if (OSTCBCurPtr != OSTCBHighRdyPtr) {
   \                     ??OSTaskSwHook_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable10_18
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x....             LDR      R4,??DataTable10_19
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD006             BEQ      ??OSTaskSwHook_1
    298                  OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
   \   0000001A   0x3194             ADDS     R1,R1,#+148
   \   0000001C   0x684B             LDR      R3,[R1, #+4]
   \   0000001E   0x425A             RSBS     R2,R3,#+0
   \   00000020   0x600A             STR      R2,[R1, #+0]
    299                  OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
   \   00000022   0x688B             LDR      R3,[R1, #+8]
   \   00000024   0x189A             ADDS     R2,R3,R2
   \   00000026   0x608A             STR      R2,[R1, #+8]
    300              }
    301          
    302              OSTCBHighRdyPtr->CyclesStart = ts;
   \                     ??OSTaskSwHook_1: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x3098             ADDS     R0,R0,#+152
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    303          #endif
    304          
    305          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    306              int_dis_time = CPU_IntDisMeasMaxCurReset();             /* Keep track of per-task interrupt disable time          */
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasMaxCurReset
    307              if (OSTCBCurPtr->IntDisTimeMax < int_dis_time) {
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x31B4             ADDS     R1,R1,#+180
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xD200             BCS      ??OSTaskSwHook_2
   \   0000003C   0x0002             MOVS     R2,R0
   \                     ??OSTaskSwHook_2: (+1)
   \   0000003E   0x600A             STR      R2,[R1, #+0]
    308                  OSTCBCurPtr->IntDisTimeMax = int_dis_time;
    309              }
    310          #endif
    311          
    312          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    313                                                                      /* Keep track of per-task scheduler lock time             */
    314              if (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur) {
    315                  OSTCBCurPtr->SchedLockTimeMax = OSSchedLockTimeMaxCur;
    316              }
    317              OSSchedLockTimeMaxCur = (CPU_TS)0;                      /* Reset the per-task value                               */
    318          #endif
    319          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    320          
    321          
    322          /*$PAGE*/
    323          /*
    324          *********************************************************************************************************
    325          *                                              TICK HOOK
    326          *
    327          * Description: This function is called every tick.
    328          *
    329          * Arguments  : None.
    330          *
    331          * Note(s)    : 1) This function is assumed to be called from the Tick ISR.
    332          *********************************************************************************************************
    333          */
    334          

   \                                 In section .text, align 2, keep-with-next
    335          void  OSTimeTickHook (void)
    336          {
    337          #if OS_CFG_APP_HOOKS_EN > 0u
    338              if (OS_AppTimeTickHookPtr != (OS_APP_HOOK_VOID)0) {
   \                     OSTimeTickHook: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10_20
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD100             BNE      ??OSTimeTickHook_0
   \   00000008   0x4770             BX       LR
    339                  (*OS_AppTimeTickHookPtr)();
   \                     ??OSTimeTickHook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       ??__iar_via_R0_0
    340              }
    341          #endif
    342          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    343          
    344          
    345          /*$PAGE*/
    346          /*
    347          *********************************************************************************************************
    348          *                                          SYS TICK HANDLER
    349          *
    350          * Description: Handle the system tick (SysTick) interrupt, which is used to generate the uC/OS-II tick
    351          *              interrupt.
    352          *
    353          * Arguments  : None.
    354          *
    355          * Note(s)    : 1) This function MUST be placed on entry 15 of the Cortex-M3 vector table.
    356          *********************************************************************************************************
    357          */
    358          

   \                                 In section .text, align 2, keep-with-next
    359          void  OS_CPU_SysTickHandler (void)
    360          {
   \                     OS_CPU_SysTickHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    361              CPU_SR_ALLOC();
    362          
    363          
    364              CPU_CRITICAL_ENTER();
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x.... 0x....      BL       CPU_IntDisMeasStart
    365              OSIntNestingCtr++;                                      /* Tell uC/OS-III that we are starting an ISR             */
   \   0000000C   0x....             LDR      R0,??DataTable10_21
   \   0000000E   0x7801             LDRB     R1,[R0, #+0]
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    366              CPU_CRITICAL_EXIT();
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       CPU_SR_Restore
    367          
    368              OSTimeTick();                                           /* Call uC/OS-III's OSTimeTick()                          */
   \   0000001E   0x.... 0x....      BL       OSTimeTick
    369          
    370              OSIntExit();                                            /* Tell uC/OS-III that we are leaving the ISR             */
   \   00000022   0x.... 0x....      BL       OSIntExit
    371          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    372          
    373          
    374          /*$PAGE*/
    375          /*
    376          *********************************************************************************************************
    377          *                                         INITIALIZE SYS TICK
    378          *
    379          * Description: Initialize the SysTick.
    380          *
    381          * Arguments  : cnts         Number of SysTick counts between two OS tick interrupts.
    382          *
    383          * Note(s)    : 1) This function MUST be called after OSStart() & after processor initialization.
    384          *********************************************************************************************************
    385          */
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void  OS_CPU_SysTickInit (CPU_INT32U  cnts)
    388          {
    389              CPU_INT32U  prio;
    390          
    391          
    392              CPU_REG_NVIC_ST_RELOAD = cnts - 1u;
   \                     OS_CPU_SysTickInit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable10_22  ;; 0xe000e010
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0x6048             STR      R0,[R1, #+4]
    393          
    394                                                                      /* Set SysTick handler prio.                              */
    395              prio  = CPU_REG_NVIC_SHPRI3;
   \   00000006   0x....             LDR      R0,??DataTable10_23  ;; 0xe000ed20
   \   00000008   0x6802             LDR      R2,[R0, #+0]
    396              prio &= DEF_BIT_FIELD(24, 0);
    397              prio |= DEF_BIT_MASK(OS_CPU_CFG_SYSTICK_PRIO, 24);
    398          
    399              CPU_REG_NVIC_SHPRI3 = prio;
   \   0000000A   0x0212             LSLS     R2,R2,#+8
   \   0000000C   0x0A12             LSRS     R2,R2,#+8
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    400          
    401                                                                      /* Enable timer.                                          */
    402              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_CLKSOURCE |
    403                                      CPU_REG_NVIC_ST_CTRL_ENABLE;
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0x2205             MOVS     R2,#+5
   \   00000014   0x4302             ORRS     R2,R2,R0
   \   00000016   0x600A             STR      R2,[R1, #+0]
    404                                                                      /* Enable timer interrupt.                                */
    405              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_TICKINT;
   \   00000018   0x6808             LDR      R0,[R1, #+0]
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x4302             ORRS     R2,R2,R0
   \   0000001E   0x600A             STR      R2,[R1, #+0]
    406          }
   \   00000020   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OS_CPU_ExceptStkBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     OS_TaskReturn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x12121212         DC32     0x12121212

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x03030303         DC32     0x3030303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x02020202         DC32     0x2020202

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x11111111         DC32     0x11111111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x09090909         DC32     0x9090909

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x07070707         DC32     0x7070707

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x06060606         DC32     0x6060606

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x05050505         DC32     0x5050505

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   0xE000ED20         DC32     0xe000ed20
    407          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSIdleTaskHook
         8   -- Indirect call
       0   OSInitHook
       8   OSStatTaskHook
         8   -- Indirect call
       8   OSTaskCreateHook
         8   -- Indirect call
       8   OSTaskDelHook
         8   -- Indirect call
       8   OSTaskReturnHook
         8   -- Indirect call
       4   OSTaskStkInit
       8   OSTaskSwHook
         8   -- Indirect call
         8   -> CPU_IntDisMeasMaxCurReset
       8   OSTimeTickHook
         8   -- Indirect call
       8   OS_CPU_SysTickHandler
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIntExit
         8   -> OSTimeTick
       0   OS_CPU_SysTickInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      18  OSIdleTaskHook
      20  OSInitHook
      18  OSStatTaskHook
      18  OSTaskCreateHook
      18  OSTaskDelHook
      18  OSTaskReturnHook
     106  OSTaskStkInit
      66  OSTaskSwHook
      18  OSTimeTickHook
       4  OS_CPU_ExceptStkBase
      40  OS_CPU_SysTickHandler
      34  OS_CPU_SysTickInit
       4  -- Other

 
   4 bytes in section .bss
 474 bytes in section .text
 
 474 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
