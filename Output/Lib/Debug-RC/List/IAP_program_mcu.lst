###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:21:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\APP\Iap\IAP_program_mcu.C
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\APP\Iap\IAP_program_mcu.C -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\IAP_program_mcu.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\IAP_program_mcu.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\APP\Iap\IAP_program_mcu.C
      1          #include  "includes.h"
      2          #include  "IAP_program_mcu.h"
      3          #include  "app_ctrl.h"
      4          
      5          //#define	CVI	0
      6          
      7          //#define	USER_APP_START_ADDR		0x00020000	
      8          //#define	USER_APP_PRO_SIZE		0x0000FFFF	
      9          
     10          #define	IAP_DATA_LEN		    128
     11          #define SEC_DIV_TIMENS          (IAP_WRITE_1024/IAP_DATA_LEN)
     12          
     13          //存放IAP参数地址
     14          //#define	IAP_PARA_START_ADDR     0x00070000	
     15          //#define	IAP_PARA_PRO_SIZE		0x00010000	
     16          //#define	IAP_PARA_START_ADDR     0x00030000	
     17          //#define	IAP_PARA_PRO_SIZE		0x0000FFFF	
     18          
     19          
     20          
     21          #define	USER_APP_START_ADDR		(STM32_FLASH_BASE + 0x00020000	)
     22          #define	USER_APP_PRO_SIZE		0x0000FFFF	
     23          
     24          //#define	USER_BACK_START_ADDR	(STM32_FLASH_BASE + 0x00020000	)
     25          
     26          #define IAP_WRITE_1024          1024
     27          #define	IAP_PARA_START_ADDR     (STM32_FLASH_BASE + 0x00030000)
     28          #define	IAP_PARA_PRO_SIZE		0x0000FFFF	
     29          
     30          
     31          #define IAP_START_CODE              1
     32          #define IAP_DATA_CODE               2
     33          #define IAP_END_CODE                3
     34          
     35          #define  IAP_WRITE_1024             1024
     36          
     37          
     38          #define zyIrqDisable()  __disable_irq()
     39          #define zyIrqEnable()   __enable_irq()
     40          
     41          
     42          void iap_write_appbin(u32 appxaddr,u8 *appbuf,u32 appsize);
     43          
     44          
     45          /*******************************************************************************
     46           * TYPEDEFS
     47           */
     48          
     49          /*******************************************************************************
     50           * LOCAL VARIABLES
     51           */
     52          stcIAPPara  gsIAPPara;
     53          stcIAPCtrl  gsIAPCtrl;      //升级参数
     54          
     55          ///*******************************************************************************
     56          // * 名    称： IAP_ReadDeviceInfo
     57          // * 功    能： 读芯片信息
     58          // * 入口参数： 无
     59          // * 出口参数： 无
     60          // * 作　　者： redmorningcn.
     61          // * 创建日期： 2017-08-08
     62          // * 修    改：
     63          // * 修改日期：
     64          // *******************************************************************************/
     65          //void    IAP_ReadDeviceInfo(void)
     66          //{
     67          //    IAP_STATUS_CODE status;    
     68          //    uint8_t ver_major, ver_minor; 
     69          //    uint32_t result[4];
     70          //
     71          //    zyIrqDisable();										//关中断
     72          //    
     73          //    status = ReadPartID(result);                        //读芯片ID
     74          //    status = ReadBootCodeVer(&ver_major, &ver_minor);   //读启动代码版本
     75          //    status = ReadDeviceSerialNum(result);               //读设备ID号    
     76          //    
     77          //    zyIrqEnable();                                      //写flash完成时，开全局中断
     78          //}
     79          
     80          /*******************************************************************************
     81           * 名    称： IAP_WriteParaFlash
     82           * 功    能： 将IAP参数数据写入Flash区
     83           * 入口参数： stcIAPCtrl
     84           * 出口参数： 无
     85           * 作　　者： redmorningcn.
     86           * 创建日期： 2017-08-08
     87           * 修    改：
     88           * 修改日期：
     89           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     90          void    IAP_WriteParaFlash(stcIAPPara *sIAPPara)
     91          {
   \                     IAP_WriteParaFlash: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     92          //    IAP_STATUS_CODE status;
     93          //    uint32_t result[4];
     94          //
     95          //    uint32_t flash_prog_area_sec_start;
     96          //    uint32_t flash_prog_area_sec_end;
     97              
     98              zyIrqDisable();										                                //关中断
   \   00000002   0xB672             CPSID    I
     99          
    100          //    flash_prog_area_sec_start   = 	GetSecNum(IAP_PARA_START_ADDR);
    101          //    flash_prog_area_sec_end 	=  	GetSecNum(IAP_PARA_START_ADDR + IAP_PARA_PRO_SIZE); //准备擦除
    102          //
    103          //    status = EraseSector(flash_prog_area_sec_start, flash_prog_area_sec_end);           //一次所写区间
    104          //    status = BlankCheckSector(flash_prog_area_sec_start, flash_prog_area_sec_end,
    105          //                &result[0], &result[1]);
    106          //    
    107          //    //开始flash编写,写入整块数据
    108          //    status 	= CopyRAM2Flash( (uint8_t *)IAP_PARA_START_ADDR,
    109          //                                  (uint8 *)sIAPPara,
    110          //                                   256
    111          //                            );                                                          //拷贝数据
    112              
    113               iap_write_appbin(     IAP_PARA_START_ADDR,
    114                                      (uint8 *)sIAPPara,
    115                                      256
    116                                      );              
   \   00000004   0xF44F 0x7280      MOV      R2,#+256
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x....             LDR.N    R0,??DataTable2  ;; 0x8030000
   \   0000000C   0x.... 0x....      BL       iap_write_appbin
    117          //    status =  Compare((uint8_t *)IAP_PARA_START_ADDR,
    118          //                            (uint8 *)sIAPPara,
    119          //                            sizeof(stcIAPPara)
    120          //                    );                                                                  //比较数据
    121                      
    122              zyIrqEnable();                                                                      //写flash完成时，开全局中断
   \   00000010   0xB662             CPSIE    I
    123          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    124          
    125          
    126          /*******************************************************************************
    127           * 名    称： IAP_WriteParaFlash
    128           * 功    能： 将IAP参数数据写入Flash区
    129           * 入口参数： stcIAPCtrl
    130           * 出口参数： 无
    131           * 作　　者： redmorningcn.
    132           * 创建日期： 2017-08-08
    133           * 修    改：
    134           * 修改日期：
    135           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          void    IAP_ReadParaFlash(stcIAPPara *sIAPPara)
    137          {
   \                     IAP_ReadParaFlash: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    138          //    IAP_STATUS_CODE status;
    139          //    uint32_t result[4];
    140          //    
    141          //    uint32_t flash_prog_area_sec_start;
    142          //    uint32_t flash_prog_area_sec_end;
    143              
    144              zyIrqDisable();                                 //关中断
   \   00000002   0xB672             CPSID    I
    145                                                              //数据copy
    146              memcpy((uint8 *)sIAPPara,(uint8 *)IAP_PARA_START_ADDR,sizeof(stcIAPPara));
   \   00000004   0x2214             MOVS     R2,#+20
   \   00000006   0x....             LDR.N    R1,??DataTable2  ;; 0x8030000
   \   00000008   0x.... 0x....      BL       __aeabi_memcpy
    147              
    148                      
    149              zyIrqEnable();                                  //开全局中断
   \   0000000C   0xB662             CPSIE    I
    150          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    151          
    152          /*******************************************************************************
    153           * 名    称： IAP_WriteFlash
    154           * 功    能： 将数据写入Flash区
    155           * 入口参数： stcIAPCtrl
    156           * 出口参数： 无
    157           * 作　　者： redmorningcn.
    158           * 创建日期： 2017-08-08
    159           * 修    改：
    160           * 修改日期：
    161           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          void    IAP_WriteFlash(stcIAPCtrl * sIAPCtrl)
    163          {
   \                     IAP_WriteFlash: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    164          //    IAP_STATUS_CODE status;
    165          //    uint32_t result[4];
    166          //
    167          //    uint32_t flash_prog_area_sec_start;
    168          //    uint32_t flash_prog_area_sec_end;
    169              
    170              zyIrqDisable();										    //关中断
   \   00000002   0xB672             CPSID    I
    171          
    172              //如果从程序下载地址开始，则先插除所有IAP地址数据。
    173          //    if(sIAPCtrl->addr == USER_APP_START_ADDR)
    174          //    {
    175          //        flash_prog_area_sec_start   = 	GetSecNum(USER_APP_START_ADDR);
    176          //        flash_prog_area_sec_end 	=  	GetSecNum(USER_APP_START_ADDR + USER_APP_PRO_SIZE);//准备擦除
    177          //
    178          //        status = EraseSector(flash_prog_area_sec_start, flash_prog_area_sec_end);           //一次性擦除所有
    179          //
    180          //        status = BlankCheckSector(flash_prog_area_sec_start, flash_prog_area_sec_end,
    181          //                      &result[0], &result[1]);
    182          //    }
    183          //    
    184              //开始flash编写
    185          //    status 	= CopyRAM2Flash((uint8 *)sIAPCtrl->addr,
    186          //                                     sIAPCtrl->buf,
    187          //                                     IAP_WRITE_1024
    188          //                            );                      //拷贝数据
    189          //    
    190          //    status =  Compare((uint8 *) sIAPCtrl->addr,
    191          //                                sIAPCtrl->buf,
    192          //                                IAP_WRITE_1024);    //比较数据
    193              
    194              iap_write_appbin(                sIAPCtrl->addr,
    195                                               (u8 *)sIAPCtrl->buf,
    196                                               IAP_WRITE_1024
    197                                      );
   \   00000004   0xF44F 0x6280      MOV      R2,#+1024
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0xF8D0 0x0400      LDR      R0,[R0, #+1024]
   \   0000000E   0x.... 0x....      BL       iap_write_appbin
    198              
    199          //   sIAPCtrl->addr += IAP_WRITE_1024;              //数据地址累加  
    200          //      sIAPCtrl->addr += IAP_WRITE_1024;              //数据地址累加  
    201                  
    202              zyIrqEnable();                                  //写flash完成时，开全局中断
   \   00000012   0xB662             CPSIE    I
    203          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    204                                 
    205                                 
    206          
    207          /*******************************************************************************
    208           * 名    称： IAP_PragramDeal
    209           * 功    能： 对传入数据处理
    210           * 入口参数： 数据区，数据长度
    211           * 出口参数： 指令成功，返回0；（发在指令后一位返回）
    212                  否则，返回错误值
    213                          1，发送帧序号不连续
    214                          2，指令不识别
    215                          3，程序大小不符
    216           * 作　　者： redmorningcn.
    217           * 创建日期： 2017-08-08
    218           * 修    改：
    219           * 修改日期：
    220           *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    221          int8    IAP_PragramDeal(uint8 *databuf,char datalen)
    222          {
   \                     IAP_PragramDeal: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
    223              uint16  iapcode;                                        //升级命令字
    224              uint16  iapnum;                                         //升级序号
    225          //    uint16  crc16;
    226              static  uint16  lastiapnum = 0;                         //上一帧序号
    227          //    static  uint8   times = 0;
    228              static  uint16  bufsize = 0;
    229              stcIAPPara  sIAPParatmp;
    230          
    231              if(datalen < 2 || datalen > 250)                                //数据异常，退出
   \   0000000A   0x1EB8             SUBS     R0,R7,#+2
   \   0000000C   0x28F9             CMP      R0,#+249
   \   0000000E   0xD301             BCC.N    ??IAP_PragramDeal_1
    232                  return  0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE043             B.N      ??IAP_PragramDeal_2
    233              
    234              memcpy((char *)&iapcode,databuf,sizeof(iapcode));              //取升级命令字
   \                     ??IAP_PragramDeal_1: (+1)
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    235              databuf[1] = 0;                                                 //返回状态标示，默认正常
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7060             STRB     R0,[R4, #+1]
    236              
    237              switch(iapcode & 0xff)                                          //地8位指令区
   \   00000024   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xF200 0x80D1      BHI.W    ??IAP_PragramDeal_3
   \   00000032   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??IAP_PragramDeal_0:
   \   00000036   0x02 0x36          DC8      0x2,0x36,0x96,0xCA
   \              0x96 0xCA    
    238              {
    239                  case IAP_START_CODE:                                        //开始升级指令（考虑断续传）
    240                                                                              //端点续传，更改地址。（如需考虑，根据序号计算地址）
    241                      memcpy(&gsIAPPara,&databuf[sizeof(iapcode)],2+2+4+4+2); //cpoy硬件版本，软件版本，程序大小，当前地址，当前帧号
   \                     ??IAP_PragramDeal_4: (+1)
   \   0000003A   0x....             LDR.N    R6,??DataTable2_1
   \   0000003C   0xF206 0x4704      ADDW     R7,R6,#+1028
   \   00000040   0x220E             MOVS     R2,#+14
   \   00000042   0x1CA1             ADDS     R1,R4,#+2
   \   00000044   0x4638             MOV      R0,R7
   \   00000046   0x.... 0x....      BL       __aeabi_memcpy
    242                      
    243                      lastiapnum = 0;
   \   0000004A   0xF506 0x6580      ADD      R5,R6,#+1024
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x8328             STRH     R0,[R5, #+24]
    244                      ////////////////断点续传，读出已存信息
    245                      IAP_ReadParaFlash(&sIAPParatmp);
   \   00000052   0xA801             ADD      R0,SP,#+4
   \   00000054   0x.... 0x....      BL       IAP_ReadParaFlash
    246                      
    247                      gsIAPPara.softver = Ctrl.Para.dat.SoftWareID;                   //返回版本信息
   \   00000058   0x....             LDR.N    R0,??DataTable2_2
   \   0000005A   0x8840             LDRH     R0,[R0, #+2]
   \   0000005C   0x80E8             STRH     R0,[R5, #+6]
    248                      
    249                      if(
    250                                  sIAPParatmp.softsize == gsIAPPara.softsize  //软件大小
    251                             &&   gsIAPPara.framenum                          //开始包序号不为0   
    252                         ) 
   \   0000005E   0x9802             LDR      R0,[SP, #+8]
   \   00000060   0x68A9             LDR      R1,[R5, #+8]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD109             BNE.N    ??IAP_PragramDeal_5
   \   00000066   0x6928             LDR      R0,[R5, #+16]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD006             BEQ.N    ??IAP_PragramDeal_5
    253                      {                                                       //数据未接收完成，发送当前序号
    254                          gsIAPPara.framenum  = sIAPParatmp.framenum;         //返回当前序号
   \   0000006C   0x9804             LDR      R0,[SP, #+16]
   \   0000006E   0x6128             STR      R0,[R5, #+16]
    255                          lastiapnum          = sIAPParatmp.framenum;         //下载序号。断点续传 
   \   00000070   0x8328             STRH     R0,[R5, #+24]
    256                          gsIAPCtrl.addr      = sIAPParatmp.addr;
   \   00000072   0x9803             LDR      R0,[SP, #+12]
   \   00000074   0x6028             STR      R0,[R5, #+0]
    257                          gsIAPPara.addr      = gsIAPCtrl.addr;
   \   00000076   0x60E8             STR      R0,[R5, #+12]
   \   00000078   0xE004             B.N      ??IAP_PragramDeal_6
    258                          
    259                      }else
    260                      {
    261                          gsIAPPara.framenum  = 0;                            //信息不正确，
   \                     ??IAP_PragramDeal_5: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x6128             STR      R0,[R5, #+16]
    262                          lastiapnum = 0;
   \   0000007E   0x8328             STRH     R0,[R5, #+24]
    263                          gsIAPCtrl.addr = USER_APP_START_ADDR;               //开始发送时，初始化地址。
   \   00000080   0x....             LDR.N    R0,??DataTable2_3  ;; 0x8020000
   \   00000082   0x6028             STR      R0,[R5, #+0]
    264                      }
    265                      
    266                      memcpy(&databuf[sizeof(iapcode)],&gsIAPPara,2+2+4+4+2); //cpoy硬件版本，软件版本，程序大小，当前地址，当前帧号
   \                     ??IAP_PragramDeal_6: (+1)
   \   00000084   0x220E             MOVS     R2,#+14
   \   00000086   0x4639             MOV      R1,R7
   \   00000088   0x1CA0             ADDS     R0,R4,#+2
   \   0000008A   0x.... 0x....      BL       __aeabi_memcpy
    267          
    268                      gsIAPPara.code = 0x00;                                  //升级有效指令变为0，需要全部下载完成，才能改写成功1            
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x82A8             STRH     R0,[R5, #+20]
    269                      IAP_WriteParaFlash(&gsIAPPara);
   \   00000092   0x4638             MOV      R0,R7
   \   00000094   0x.... 0x....      BL       IAP_WriteParaFlash
    270          
    271                      break;
    272                  case IAP_DATA_CODE:                                         //传输数据包
    273                      memcpy((char *)&iapnum,&databuf[sizeof(iapcode)],sizeof(iapnum));   //取帧序号
    274                      
    275                      if(     iapnum == lastiapnum+1 
    276                          ||  iapnum == lastiapnum )                  //相同帧号（重发数据）
    277                      {
    278                          memcpy(&gsIAPCtrl.buf[(iapnum % SEC_DIV_TIMENS)*IAP_DATA_LEN],
    279                          &databuf[2 + 2],                            //数据区是从第4字节开始
    280                          datalen - 4);                                //拷贝数据到升级缓冲区
    281          
    282                          bufsize += datalen - 4;                     //4字节代码，数据区前标示
    283                                                                      //准备数据
    284                          if(     (iapnum % SEC_DIV_TIMENS ) == (SEC_DIV_TIMENS - 1) 
    285                              || (datalen -4) != IAP_DATA_LEN )       //如果数据凑满1024字节，或者升级结束。进行写flash操作。
    286                          {
    287                              if((datalen - 4) != IAP_DATA_LEN)       //如果升级结束，将1024字节剩余空间写0xff
    288                              {
    289                                  for(int i = bufsize;i < IAP_WRITE_1024;i++ )
    290                                      gsIAPCtrl.buf[i] = 0xff;	
    291                              }
    292          
    293                              if(iapnum != lastiapnum && iapnum )     //重复接收退出
    294                              {
    295                                  if(gsIAPCtrl.addr >= USER_APP_START_ADDR)
    296                                  {
    297                                      IAP_WriteFlash(&gsIAPCtrl);        //写数据(地址，gsIAPCtrl.addr依次写入)
    298                                      gsIAPCtrl.addr += IAP_WRITE_1024;  //数据地址累加  
    299                                       
    300                                      gsIAPPara.addr =  gsIAPCtrl.addr;  //已写地址
    301                                       
    302                                      bufsize = 0;
    303                                  
    304                                      gsIAPPara.code      = 0x00;         //未完成，存序号
    305                                      gsIAPPara.framenum  = iapnum;       //当前序号
    306                                      gsIAPPara.crc16 = GetCrc16Check((uint8 *)&gsIAPPara,sizeof(gsIAPPara)-2);
    307                                      IAP_WriteParaFlash(&gsIAPPara);
    308                                  }
    309                                  else
    310                                  {
    311                                      databuf[1] = 4;                             //返回状态
    312                                      return 4;                            
    313                                  }
    314                                     
    315                              }
    316                              
    317                              bufsize = 0;                                //重复数据清空（满足写条件的，不论是否已写，都清空缓冲）
    318                          }
    319                          
    320                          lastiapnum = iapnum;                            //序号赋值
    321                      }
    322                      else
    323                      {
    324                          databuf[1] = 1;
    325                          return 1; 
    326                      }
    327                  
    328                      break;
    329                      
    330                   //结束升级指令   //做升级后程序完整性判断。程序大小？ //写程序完成标示
    331                  case IAP_END_CODE:                                          
    332                                                                      
    333                      if( bufsize )                                   //最后的数据未写入，补充写入
    334                      {
    335                           IAP_WriteFlash(&gsIAPCtrl);                //写数据(地址，gsIAPCtrl.addr依次写入)
    336                           gsIAPCtrl.addr += IAP_WRITE_1024;          //数据地址累加  
    337          
    338                           gsIAPPara.addr =  gsIAPCtrl.addr;          //已写地址
    339                           bufsize = 0;
    340                      }
    341                          
    342                      memcpy(&gsIAPPara,&databuf[sizeof(iapcode)],2+2+4+4+2); //cpoy硬件版本，软件版本，程序大小，当前地址，当前帧号
    343                     
    344                      if(     gsIAPPara.softsize > (gsIAPCtrl.addr - USER_APP_START_ADDR)     //程序大小不符，软件退出。
    345                         ||   (gsIAPCtrl.addr - USER_APP_START_ADDR - IAP_WRITE_1024) > gsIAPPara.softsize
    346                         )
    347                      {
    348                          databuf[1] = 3;                             //返回状态
    349                          return 3;
    350                      }
    351                      
    352                      //如果程序大小相符，认为下载正确。修改下载成功标示
    353                      gsIAPPara.code = 0x01;
    354                      gsIAPPara.framenum  = 0;                        //恢复开始状态
    355                      gsIAPPara.crc16 = GetCrc16Check((uint8 *)&gsIAPPara,sizeof(gsIAPPara)-2);
    356                      IAP_WriteParaFlash(&gsIAPPara);
    357                      IAP_ReadParaFlash(&gsIAPPara);
    358                      
    359                      
    360                      break;
    361                  case 0x04:                                          //终止升级指令
    362                      gsIAPCtrl.addr = USER_APP_START_ADDR;           //初始化地址。
    363          
    364                      break;  
    365                  default:                                            //其他指令，直接返回
    366                      databuf[1] = 2;
    367                      return 2;
    368              }
    369              
    370              databuf[1] = 0;
   \                     ??IAP_PragramDeal_7: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x7060             STRB     R0,[R4, #+1]
    371              return 0;
   \                     ??IAP_PragramDeal_2: (+1)
   \   0000009C   0xB007             ADD      SP,SP,#+28
   \   0000009E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   \                     ??IAP_PragramDeal_8: (+1)
   \   000000A2   0x2202             MOVS     R2,#+2
   \   000000A4   0x1CA1             ADDS     R1,R4,#+2
   \   000000A6   0x4668             MOV      R0,SP
   \   000000A8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000AC   0x....             LDR.N    R6,??DataTable2_1
   \   000000AE   0xF506 0x6580      ADD      R5,R6,#+1024
   \   000000B2   0x8B28             LDRH     R0,[R5, #+24]
   \   000000B4   0xF8BD 0x8000      LDRH     R8,[SP, #+0]
   \   000000B8   0x1C41             ADDS     R1,R0,#+1
   \   000000BA   0x4588             CMP      R8,R1
   \   000000BC   0xD002             BEQ.N    ??IAP_PragramDeal_9
   \   000000BE   0x4641             MOV      R1,R8
   \   000000C0   0x4281             CMP      R1,R0
   \   000000C2   0xD14B             BNE.N    ??IAP_PragramDeal_10
   \                     ??IAP_PragramDeal_9: (+1)
   \   000000C4   0xF1A7 0x0904      SUB      R9,R7,#+4
   \   000000C8   0x464A             MOV      R2,R9
   \   000000CA   0x1D21             ADDS     R1,R4,#+4
   \   000000CC   0xF008 0x0007      AND      R0,R8,#0x7
   \   000000D0   0xEB06 0x10C0      ADD      R0,R6,R0, LSL #+7
   \   000000D4   0x.... 0x....      BL       __aeabi_memcpy
   \   000000D8   0x8B68             LDRH     R0,[R5, #+26]
   \   000000DA   0x1F39             SUBS     R1,R7,#+4
   \   000000DC   0x1808             ADDS     R0,R1,R0
   \   000000DE   0x8368             STRH     R0,[R5, #+26]
   \   000000E0   0xF008 0x0007      AND      R0,R8,#0x7
   \   000000E4   0x2807             CMP      R0,#+7
   \   000000E6   0xD002             BEQ.N    ??IAP_PragramDeal_11
   \   000000E8   0xF1B9 0x0F80      CMP      R9,#+128
   \   000000EC   0xD02F             BEQ.N    ??IAP_PragramDeal_12
   \                     ??IAP_PragramDeal_11: (+1)
   \   000000EE   0xF1B9 0x0F80      CMP      R9,#+128
   \   000000F2   0xD007             BEQ.N    ??IAP_PragramDeal_13
   \   000000F4   0x8B68             LDRH     R0,[R5, #+26]
   \   000000F6   0x21FF             MOVS     R1,#+255
   \   000000F8   0xE001             B.N      ??IAP_PragramDeal_14
   \                     ??IAP_PragramDeal_15: (+1)
   \   000000FA   0x5581             STRB     R1,[R0, R6]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \                     ??IAP_PragramDeal_14: (+1)
   \   000000FE   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000102   0xDBFA             BLT.N    ??IAP_PragramDeal_15
   \                     ??IAP_PragramDeal_13: (+1)
   \   00000104   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000108   0x8B29             LDRH     R1,[R5, #+24]
   \   0000010A   0x4288             CMP      R0,R1
   \   0000010C   0xD01D             BEQ.N    ??IAP_PragramDeal_16
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD01B             BEQ.N    ??IAP_PragramDeal_16
   \   00000112   0x6828             LDR      R0,[R5, #+0]
   \   00000114   0x....             LDR.N    R1,??DataTable2_3  ;; 0x8020000
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xDB1D             BLT.N    ??IAP_PragramDeal_17
   \   0000011A   0x4630             MOV      R0,R6
   \   0000011C   0x.... 0x....      BL       IAP_WriteFlash
   \   00000120   0x6828             LDR      R0,[R5, #+0]
   \   00000122   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000126   0x6028             STR      R0,[R5, #+0]
   \   00000128   0x60E8             STR      R0,[R5, #+12]
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x8368             STRH     R0,[R5, #+26]
   \   0000012E   0x82A8             STRH     R0,[R5, #+20]
   \   00000130   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000134   0x6128             STR      R0,[R5, #+16]
   \   00000136   0xF206 0x4704      ADDW     R7,R6,#+1028
   \   0000013A   0x2112             MOVS     R1,#+18
   \   0000013C   0x4638             MOV      R0,R7
   \   0000013E   0x.... 0x....      BL       GetCrc16Check
   \   00000142   0x82E8             STRH     R0,[R5, #+22]
   \   00000144   0x4638             MOV      R0,R7
   \   00000146   0x.... 0x....      BL       IAP_WriteParaFlash
   \                     ??IAP_PragramDeal_16: (+1)
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x8368             STRH     R0,[R5, #+26]
   \                     ??IAP_PragramDeal_12: (+1)
   \   0000014E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000152   0x8328             STRH     R0,[R5, #+24]
   \   00000154   0xE7A0             B.N      ??IAP_PragramDeal_7
   \                     ??IAP_PragramDeal_17: (+1)
   \   00000156   0x2004             MOVS     R0,#+4
   \   00000158   0x7060             STRB     R0,[R4, #+1]
   \   0000015A   0xE79F             B.N      ??IAP_PragramDeal_2
   \                     ??IAP_PragramDeal_10: (+1)
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x7060             STRB     R0,[R4, #+1]
   \   00000160   0xE79C             B.N      ??IAP_PragramDeal_2
   \                     ??IAP_PragramDeal_18: (+1)
   \   00000162   0x....             LDR.N    R6,??DataTable2_1
   \   00000164   0xF506 0x6580      ADD      R5,R6,#+1024
   \   00000168   0x8B68             LDRH     R0,[R5, #+26]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD009             BEQ.N    ??IAP_PragramDeal_19
   \   0000016E   0x4630             MOV      R0,R6
   \   00000170   0x.... 0x....      BL       IAP_WriteFlash
   \   00000174   0x6828             LDR      R0,[R5, #+0]
   \   00000176   0xF500 0x6080      ADD      R0,R0,#+1024
   \   0000017A   0x6028             STR      R0,[R5, #+0]
   \   0000017C   0x60E8             STR      R0,[R5, #+12]
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x8368             STRH     R0,[R5, #+26]
   \                     ??IAP_PragramDeal_19: (+1)
   \   00000182   0xF206 0x4704      ADDW     R7,R6,#+1028
   \   00000186   0x220E             MOVS     R2,#+14
   \   00000188   0x1CA1             ADDS     R1,R4,#+2
   \   0000018A   0x4638             MOV      R0,R7
   \   0000018C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000190   0x68A8             LDR      R0,[R5, #+8]
   \   00000192   0x6829             LDR      R1,[R5, #+0]
   \   00000194   0x....             LDR.N    R2,??DataTable2_4  ;; 0xf7fe0000
   \   00000196   0x1852             ADDS     R2,R2,R1
   \   00000198   0x4282             CMP      R2,R0
   \   0000019A   0xD303             BCC.N    ??IAP_PragramDeal_20
   \   0000019C   0x....             LDR.N    R2,??DataTable2_5  ;; 0xf7fdfc00
   \   0000019E   0x1851             ADDS     R1,R2,R1
   \   000001A0   0x4288             CMP      R0,R1
   \   000001A2   0xD202             BCS.N    ??IAP_PragramDeal_21
   \                     ??IAP_PragramDeal_20: (+1)
   \   000001A4   0x2003             MOVS     R0,#+3
   \   000001A6   0x7060             STRB     R0,[R4, #+1]
   \   000001A8   0xE778             B.N      ??IAP_PragramDeal_2
   \                     ??IAP_PragramDeal_21: (+1)
   \   000001AA   0x2001             MOVS     R0,#+1
   \   000001AC   0x82A8             STRH     R0,[R5, #+20]
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x6128             STR      R0,[R5, #+16]
   \   000001B2   0x2112             MOVS     R1,#+18
   \   000001B4   0x4638             MOV      R0,R7
   \   000001B6   0x.... 0x....      BL       GetCrc16Check
   \   000001BA   0x82E8             STRH     R0,[R5, #+22]
   \   000001BC   0x4638             MOV      R0,R7
   \   000001BE   0x.... 0x....      BL       IAP_WriteParaFlash
   \   000001C2   0x4638             MOV      R0,R7
   \   000001C4   0x.... 0x....      BL       IAP_ReadParaFlash
   \   000001C8   0xE766             B.N      ??IAP_PragramDeal_7
   \                     ??IAP_PragramDeal_22: (+1)
   \   000001CA   0x....             LDR.N    R0,??DataTable2_3  ;; 0x8020000
   \   000001CC   0x....             LDR.N    R1,??DataTable2_1
   \   000001CE   0xF8C1 0x0400      STR      R0,[R1, #+1024]
   \   000001D2   0xE761             B.N      ??IAP_PragramDeal_7
   \                     ??IAP_PragramDeal_3: (+1)
   \   000001D4   0x2002             MOVS     R0,#+2
   \   000001D6   0x7060             STRB     R0,[R4, #+1]
   \   000001D8   0xE760             B.N      ??IAP_PragramDeal_2
    372          }

   \                                 In section .bss, align 4
   \                     gsIAPCtrl:
   \   00000000                      DS8 1028
   \                     gsIAPPara:
   \   00000404                      DS8 20
   \   00000418                      DS8 2
   \   0000041A                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x08030000         DC32     0x8030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     gsIAPCtrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x08020000         DC32     0x8020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0xF7FE0000         DC32     0xf7fe0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0xF7FDFC00         DC32     0xf7fdfc00
    373          
    374          //
    375          //typedef  void (*pFunction)(void);			                //定义一个函数类型的参数.
    376          //
    377          ///*******************************************************************************
    378          // * LOCAL VARIABLES
    379          // */
    380          ///***********************************************
    381          //* 描述：定义函数指针
    382          //*/
    383          //pFunction   pApp;
    384          //
    385          //void Boot( void )
    386          //{
    387          //    u32     JumpAddress = 0;
    388          //    u8      cpu_sr;
    389          //    //SCB->VTOR = USER_APP_START_ADDR & 0x1FFFFF80;	
    390          //
    391          //	//JMP_Boot(USER_APP_START_ADDR);
    392          //    
    393          ////   __ASM void JMP_Boot( uint32_t address ){
    394          ////   LDR SP, [R0]		;Load new stack pointer address
    395          ////   LDR PC, [R0, #4]	;Load new program counter address
    396          ////   }
    397          //
    398          //    CPU_CRITICAL_ENTER();
    399          //
    400          //    JumpAddress   =*(volatile u32*) (USER_APP_START_ADDR + 4); // 地址+4为PC地址
    401          //    pApp          = (pFunction)JumpAddress;                     // 函数指针指向APP
    402          //    __set_MSP       (*(volatile u32*) USER_APP_START_ADDR);    // 初始化主堆栈指针（MSP）
    403          //    __set_PSP       (*(volatile u32*) USER_APP_START_ADDR);    // 初始化进程堆栈指针（PSP）
    404          //    __set_CONTROL   (0);                                        // 清零CONTROL
    405          //    
    406          //    pApp();                                                     //跳转运行
    407          //    
    408          //    //(*pApp)();
    409          //    
    410          //    CPU_CRITICAL_EXIT();
    411          //
    412          //}
    413          //
    414          //void    Restart(void)
    415          //{
    416          //    u32     JumpAddress = 0;
    417          //    u8      cpu_sr;
    418          //    //SCB->VTOR = USER_APP_START_ADDR & 0x1FFFFF80;	
    419          //
    420          //	//JMP_Boot(USER_APP_START_ADDR);
    421          //    
    422          ////   __ASM void JMP_Boot( uint32_t address ){
    423          ////   LDR SP, [R0]		;Load new stack pointer address
    424          ////   LDR PC, [R0, #4]	;Load new program counter address
    425          ////   }
    426          //
    427          //    CPU_CRITICAL_ENTER();
    428          //
    429          //    JumpAddress   =*(volatile u32*) (0 + 4);    // 地址+4为PC地址
    430          //    pApp          = (pFunction)JumpAddress;      // 函数指针指向APP
    431          //    __set_MSP       (*(volatile u32*) 0);       // 初始化主堆栈指针（MSP）
    432          //    __set_PSP       (*(volatile u32*) 0);       // 初始化进程堆栈指针（PSP）
    433          //    __set_CONTROL   (0);                                        // 清零CONTROL
    434          //    
    435          //    pApp();                                                     //跳转运行
    436          //    
    437          //    //(*pApp)();
    438          //    
    439          //    CPU_CRITICAL_EXIT();
    440          //}
    441          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   IAP_PragramDeal
        56   -> GetCrc16Check
        56   -> IAP_ReadParaFlash
        56   -> IAP_WriteFlash
        56   -> IAP_WriteParaFlash
        56   -> __aeabi_memcpy
       8   IAP_ReadParaFlash
         8   -> __aeabi_memcpy
       8   IAP_WriteFlash
         8   -> iap_write_appbin
       8   IAP_WriteParaFlash
         8   -> iap_write_appbin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
     474  IAP_PragramDeal
      16  IAP_ReadParaFlash
      22  IAP_WriteFlash
      20  IAP_WriteParaFlash
    1052  gsIAPCtrl
          gsIAPPara
          lastiapnum
          bufsize

 
 1 052 bytes in section .bss
   556 bytes in section .text
 
   556 bytes of CODE memory
 1 052 bytes of DATA memory

Errors: none
Warnings: none
