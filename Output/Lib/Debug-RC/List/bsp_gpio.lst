###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Nov/2017  10:06:09
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_gpio.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_gpio.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\bsp_gpio.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\bsp_gpio.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_gpio.c
      1          /*******************************************************************************
      2           *   Filename:      bsp_gpio.c
      3           *   Revised:       $Date: 2017-05-15$
      4           *   Revision:      $
      5           *   Writer:	    redmorningcn.
      6           *
      7           *   Description:
      8           *   Notes:
      9           *     			E-mail:redmorningcn@qq.com
     10           *
     11           *   All copyrights reserved to redmorningcn.
     12           *
     13           *******************************************************************************/
     14          #include 		<includes.h>  
     15          #include 		"string.h"
     16          #include    	"stdio.h" 
     17          #include   	    "stdarg.h"
     18          
     19          //-------------------------------------------------------------------------------------------------------
     20          //函数名称:         GPIO_SetOrClearValue()
     21          //功    能:         	对指定的端口写1或0
     22          //入口参数:         GpioNum:   引脚编号，由端口*100+ 引脚编号 组成。
     23          //                  		Val:   设定值，0 或
     24          //作		者:		redmorningcn
     25          //日		期:		2017-05-15
     26          //出口参数:         无
     27          //说明：            
     28          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     29          void	GPIO_SetOrClearValue(uint32_t GpioNum,uint8_t Val)
     30          {
   \                     GPIO_SetOrClearValue: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
     31          	GPIO_TypeDef 	*PortBuf[] = {GPIOA,GPIOB,GPIOC,GPIOD,GPIOE};
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x.... 0x....      ADR.W    R1,?_1
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
     32              GPIO_InitTypeDef  GPIO_InitStructure;
     33          
     34          	uint8		PortNum;
     35          	uint8		IoNum;
     36          
     37          	PortNum 	= GpioNum/100;
   \   00000014   0x2064             MOVS     R0,#+100
   \   00000016   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0xB2C9             UXTB     R1,R1
     38          	IoNum	    = GpioNum%100;
   \   0000001E   0x2264             MOVS     R2,#+100
   \   00000020   0xFB02 0x5010      MLS      R0,R2,R0,R5
     39              
     40              GPIO_InitStructure.GPIO_Pin     =  0x01<<IoNum;;
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xFA02 0xF500      LSL      R5,R2,R0
   \   0000002A   0xF8AD 0x5000      STRH     R5,[SP, #+0]
     41              GPIO_InitStructure.GPIO_Speed   =  GPIO_Speed_50MHz;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xF88D 0x0002      STRB     R0,[SP, #+2]
     42              GPIO_InitStructure.GPIO_Mode    =  GPIO_Mode_Out_PP;
   \   00000034   0x2010             MOVS     R0,#+16
   \   00000036   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000003A   0xA801             ADD      R0,SP,#+4
   \   0000003C   0xF850 0x6021      LDR      R6,[R0, R1, LSL #+2]
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x4630             MOV      R0,R6
     43              
     44              GPIO_Init(PortBuf[PortNum], &GPIO_InitStructure);  //io output 
   \   00000044   0x.... 0x....      BL       GPIO_Init
     45              
     46              //GPIO_WriteBit(PortBuf[PortNum],IoNum,(BitAction)Val);
     47              GPIO_WriteBit(PortBuf[PortNum],0x01<<IoNum,(BitAction)Val);
   \   00000048   0x4622             MOV      R2,R4
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0xB289             UXTH     R1,R1
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       GPIO_WriteBit
     48          }
   \   00000054   0xB006             ADD      SP,SP,#+24
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   
     49          
     50          //-------------------------------------------------------------------------------------------------------
     51          //函数名称:         GPIO_PinselConfig()
     52          //功    能:         	配置引脚功能
     53          //入口参数:         GpioNum:   引脚编号，由端口*100+ 引脚编号 组成。
     54          //                  		FuncNum:    引脚功能号，一般功能0~4
     55          //作		者:		redmorningcn
     56          //日		期:		2017-05-15
     57          //出口参数:         无
     58          //说明：            
     59          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     60          void	GPIO_PinselConfig(uint32_t GpioNum,uint8_t FuncNum)
     61          {
   \                     GPIO_PinselConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x4605             MOV      R5,R0
     62          	GPIO_InitTypeDef	gpio_init;
     63          
     64          	GPIO_TypeDef 	*PortBuf[] = {GPIOA,GPIOB,GPIOC,GPIOD,GPIOE};
   \   00000006   0xA806             ADD      R0,SP,#+24
   \   00000008   0x.... 0x....      ADR.W    R1,?_2
   \   0000000C   0x2214             MOVS     R2,#+20
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
     65              uint32          RCC_APPBuf[] = {RCC_APB2Periph_GPIOA,
     66                                              RCC_APB2Periph_GPIOB,
     67                                              RCC_APB2Periph_GPIOC,
     68                                              RCC_APB2Periph_GPIOD,
     69                                              RCC_APB2Periph_GPIOE};
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x.... 0x....      ADR.W    R1,?_0
   \   00000018   0x2214             MOVS     R2,#+20
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy4
     70          	uint8		PortNum;
     71          	uint8		IoNum;
     72          
     73                  
     74          	PortNum 	= GpioNum/100;
   \   0000001E   0x2064             MOVS     R0,#+100
   \   00000020   0xFBB5 0xF6F0      UDIV     R6,R5,R0
   \   00000024   0x4634             MOV      R4,R6
   \   00000026   0xB2E4             UXTB     R4,R4
     75          	IoNum	    = GpioNum%100;
     76          
     77              RCC_APB2PeriphClockCmd(RCC_APPBuf[PortNum] , ENABLE);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000030   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     78              
     79              gpio_init.GPIO_Pin   = 0x01<<IoNum;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x2164             MOVS     R1,#+100
   \   00000038   0xFB01 0x5116      MLS      R1,R1,R6,R5
   \   0000003C   0x4088             LSLS     R0,R0,R1
   \   0000003E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     80              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xF88D 0x0002      STRB     R0,[SP, #+2]
     81              //gpio_init.GPIO_Mode  = GPIO_Mode_Out_OD;
     82              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     83                  
     84              GPIO_Init(PortBuf[PortNum], &gpio_init);
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0xA806             ADD      R0,SP,#+24
   \   00000052   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000056   0x.... 0x....      BL       GPIO_Init
     85          
     86          }
   \   0000005A   0xB00C             ADD      SP,SP,#+48
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   
     87          
     88          //-------------------------------------------------------------------------------------------------------
     89          //函数名称:        GPIO_ReadIoVal()
     90          //功    能:         	读取引脚上值
     91          //入口参数:         GpioNum:   引脚编号，由端口*100+ 引脚编号 组成。
     92          //出口参数:		0 或1                 		
     93          //作		者:		redmorningcn
     94          //日		期:		2017-05-15
     95          //出口参数:         无
     96          //说明：            
     97          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     98          uint8	GPIO_ReadIoVal(uint32_t GpioNum)
     99          {
   \                     GPIO_ReadIoVal: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
    100              GPIO_InitTypeDef  GPIO_InitStructure;
    101          
    102          	GPIO_TypeDef 	*PortBuf[] = {GPIOA,GPIOB,GPIOC,GPIOD,GPIOE};
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x.... 0x....      ADR.W    R1,?_3
   \   0000000C   0x2214             MOVS     R2,#+20
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    103          	uint8		    PortNum;
    104          	uint8		    IoNum;
    105          	uint32 		    PortVal;	
    106          
    107          	PortNum = GpioNum/100;
   \   00000012   0x2064             MOVS     R0,#+100
   \   00000014   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0xB2C9             UXTB     R1,R1
    108          	IoNum	= GpioNum%100;
   \   0000001C   0x2264             MOVS     R2,#+100
   \   0000001E   0xFB02 0x4010      MLS      R0,R2,R0,R4
    109              
    110              GPIO_InitStructure.GPIO_Pin     =  0x01<<IoNum;;
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xFA02 0xF400      LSL      R4,R2,R0
   \   00000028   0xF8AD 0x4000      STRH     R4,[SP, #+0]
    111              GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_50MHz;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    112              GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_IPU;
   \   00000032   0x2048             MOVS     R0,#+72
   \   00000034   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000038   0xA801             ADD      R0,SP,#+4
   \   0000003A   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x4628             MOV      R0,R5
    113              
    114              GPIO_Init(PortBuf[PortNum], &GPIO_InitStructure);   //io input
   \   00000042   0x.... 0x....      BL       GPIO_Init
    115              
    116              PortVal = GPIO_ReadInputDataBit(PortBuf[PortNum],0x01<<IoNum);
   \   00000046   0x4621             MOV      R1,R4
   \   00000048   0xB289             UXTH     R1,R1
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       GPIO_ReadInputDataBit
    117          //
    118          //	if(PortVal & 1ul<<IoNum)
    119          //	{
    120          //		return	1;
    121          //	}
    122              
    123              if(PortVal)
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x4180             SBCS     R0,R0,R0
   \   00000054   0x43C0             MVNS     R0,R0
   \   00000056   0x0FC0             LSRS     R0,R0,#+31
    124                 return	1;
    125              
    126          	return	0;
   \   00000058   0xB007             ADD      SP,SP,#+28
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
    127          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00000004         DC32 4, 8, 16, 32, 64
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   GPIO_PinselConfig
        64   -> GPIO_Init
        64   -> RCC_APB2PeriphClockCmd
        64   -> __aeabi_memcpy4
      40   GPIO_ReadIoVal
        40   -> GPIO_Init
        40   -> GPIO_ReadInputDataBit
        40   -> __aeabi_memcpy4
      40   GPIO_SetOrClearValue
        40   -> GPIO_Init
        40   -> GPIO_WriteBit
        40   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?_0
      20  ?_1
      20  ?_2
      20  ?_3
      94  GPIO_PinselConfig
      92  GPIO_ReadIoVal
      88  GPIO_SetOrClearValue

 
 354 bytes in section .text
 
 354 bytes of CODE memory

Errors: none
Warnings: none
