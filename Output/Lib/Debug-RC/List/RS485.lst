###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:40:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\RS485.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\RS485.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\RS485.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\RS485.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\RS485.c
      1          /*------------------------------------------------------------------------/
      2          /  Universal string handler for user console interface
      3          /-------------------------------------------------------------------------/
      4          /
      5          /  Copyright (C) 2011, ChaN, all right reserved.
      6          /
      7          / * This software is a free software and there is NO WARRANTY.
      8          / * No restriction on use. You can use, modify and redistribute it for
      9          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     10          / * Redistributions of source code must retain the above copyright notice.
     11          / modified by www.armjishu.com
     12          /-------------------------------------------------------------------------*/
     13          #include "stm32f10x.h"
     14          #include "SZ_STM32F107VC_LIB.h"
     15          #include "stm32f10x_gpio.h"
     16          #include "RS485.h"
     17          #include <stdio.h>
     18          #include "DELAY.h"
     19          #include "app_chk.h"
     20          #include "string.h"
     21          #include "POWER_MACRO.h"
     22          
     23          #define RCC_RS485_DIR      		RCC_APB2Periph_GPIOA
     24          #define GPIO_RS485_DIR          GPIO_Pin_1
     25          #define GPIO_RS485_DIR_PORT     GPIOA
     26          
     27          #define SetRS485Rev()           GPIO_ResetBits(GPIO_RS485_DIR_PORT, GPIO_RS485_DIR)
     28          #define SetRS485Snd()           GPIO_SetBits(GPIO_RS485_DIR_PORT, GPIO_RS485_DIR)
     29          
     30          //思维公司和南车公司通讯协议
     31          //#define         FRAM_HERD0     		0x7c         	//报文头			
     32          //#define     	HOST_ID      		0x11				//上位机地址	  		   
     33          //#define   		DEVICE_ID0      	0x51				//本机地址0	
     34          //#define         FRAM_END0     		0x7e         	//报文尾
     35          #define			HOST_CODE_FLG		0x0c	
     36          #define			DEVICE_CODE_FLG		0x8c
     37          #define			ID_NUM				0x01	
     38          #define			CODE_TYPE			0x01	
     39          
     40          #define			HDLC_CODE0			0x7d
     41          #define			HDLC_CODE1			0x5c
     42          #define			HDLC_CODE2			0x5e
     43          #define			HDLC_CODE3			0x5d
     44          
     45          
     46          #if _USE_XFUNC_OUT
     47          #include <stdarg.h>
     48          void (*xfunc_out)(unsigned char);	/* Pointer to the output stream */
     49          static char *outptr;
     50          
     51          #ifndef SZ_STM32_COM1_STR
     52          #define SZ_STM32_COM1_STR                    "USART2"
     53          #endif
     54          
     55          extern const uint8_t STM32F10x_STR[];
     56          /* Private functions ---------------------------------------------------------*/
     57          /**-------------------------------------------------------
     58          * @函数名 RS485_SET_RX_Mode
     59          * @功能   设置RS485为接收模式
     60          * @参数   无
     61          * @返回值 无
     62          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     63          void RS485_SET_RX_Mode(void)
     64          {
     65              /*设置为接收模式*/
     66              SetRS485Rev();
   \                     RS485_SET_RX_Mode: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40010800
   \   00000006   0x.... 0x....      B.W      GPIO_ResetBits
     67          }
     68          
     69          /**-------------------------------------------------------
     70          * @函数名 RS485_SET_TX_Mode
     71          * @功能   设置RS485为发送模式
     72          * @参数   无
     73          * @返回值 无
     74          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     75          void RS485_SET_TX_Mode(void)
     76          {
     77              /*设置为发送模式*/
     78              SetRS485Snd();
   \                     RS485_SET_TX_Mode: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40010800
   \   00000006   0x.... 0x....      B.W      GPIO_SetBits
     79          }
     80          
     81          
     82          /**-------------------------------------------------------
     83          * @函数名 RS485_DIR_Config
     84          * @功能   RS485方向设置IO口初始化
     85          * @参数   无
     86          * @返回值 无
     87          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     88          void RS485_DIR_Config(void)
     89          {
   \                     RS485_DIR_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     90              GPIO_InitTypeDef GPIO_InitStructure;
     91              /* Enable GPIOB, GPIOC and AFIO clock */
     92              RCC_APB2PeriphClockCmd(RCC_RS485_DIR , ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     93              
     94              /* LEDs pins configuration */
     95              GPIO_InitStructure.GPIO_Pin = GPIO_RS485_DIR;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     96              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
     97              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000016   0x2010             MOVS     R0,#+16
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
     98              GPIO_Init(GPIO_RS485_DIR_PORT, &GPIO_InitStructure);
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40010800
   \   00000022   0x.... 0x....      BL       GPIO_Init
     99          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    100          
    101          

   \                                 In section .text, align 2, keep-with-next
    102          void xPrintf_Init(uint32_t BaudRate)
    103          {
   \                     xPrintf_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    104              USART_InitTypeDef USART_InitStructure;   
    105              
    106              /* USARTx configured as follow:
    107              - BaudRate = 115200 baud  
    108              - Word Length = 8 Bits
    109              - One Stop Bit
    110              - No parity
    111              - Hardware flow control disabled (RTS and CTS signals)
    112              - Receive and transmit enabled
    113              */
    114              USART_InitStructure.USART_BaudRate = BaudRate;
   \   00000004   0x9000             STR      R0,[SP, #+0]
    115              USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9001             STR      R0,[SP, #+4]
    116              USART_InitStructure.USART_StopBits = USART_StopBits_1;
    117              USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000000A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    118              USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000000E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    119              USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000012   0x200C             MOVS     R0,#+12
   \   00000014   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    120              
    121              __SZ_STM32_COMInit(COM2, &USART_InitStructure);
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       __SZ_STM32_COMInit
    122              RS485_DIR_Config();							  //RS485方向设置IO口初始化
   \   00000020   0x.... 0x....      BL       RS485_DIR_Config
    123              xdev_out(xUSART2_putchar);
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000028   0x.... 0x....      ADR.W    R1,xUSART2_putchar
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    124              xdev_in(xUSART2_getchar);  
   \   0000002E   0x.... 0x....      ADR.W    R1,xUSART2_getchar
   \   00000032   0x6081             STR      R1,[R0, #+8]
    125              
    126              SystemCoreClockUpdate();
   \   00000034   0x.... 0x....      BL       SystemCoreClockUpdate
    127          }
   \   00000038   0xB005             ADD      SP,SP,#+20
   \   0000003A   0xBD00             POP      {PC}             ;; return
    128          

   \                                 In section .text, align 2, keep-with-next
    129          unsigned char xUSART1_putchar(unsigned char ch)
    130          {
   \                     xUSART1_putchar: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    131          	/* Place your implementation of fputc here */
    132          	/* e.g. write a character to the USART */
    133          	USART_SendData(SZ_STM32_COM1, (uint8_t) ch); /*发送一个字符函数*/ 
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable21_2  ;; 0x40013800
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       USART_SendData
    134          	
    135          	/* Loop until the end of transmission */
    136          	while (USART_GetFlagStatus(SZ_STM32_COM1, USART_FLAG_TC) == RESET)/*等待发送完成*/
   \                     ??xUSART1_putchar_0: (+1)
   \   00000010   0x2140             MOVS     R1,#+64
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD0F9             BEQ.N    ??xUSART1_putchar_0
    137          	{
    138                  
    139          	}
    140          	return ch;
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    141          }
    142          

   \                                 In section .text, align 4, keep-with-next
    143          unsigned char xUSART2_putchar(unsigned char ch)
    144          {
   \                     xUSART2_putchar: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    145          	/* Place your implementation of fputc here */
    146          	/* e.g. write a character to the USART */
    147          	RS485_SET_TX_Mode();
   \   00000004   0x.... 0x....      BL       RS485_SET_TX_Mode
    148          	Delay(10);
   \   00000008   0x200A             MOVS     R0,#+10
   \   0000000A   0x.... 0x....      BL       Delay
    149          	USART_SendData(SZ_STM32_COM2, (uint8_t) ch); /*发送一个字符函数*/ 
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable21_3  ;; 0x40004400
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       USART_SendData
    150          	
    151          	/* Loop until the end of transmission */
    152          	while (USART_GetFlagStatus(SZ_STM32_COM2, USART_FLAG_TC) == RESET)/*等待发送完成*/
   \                     ??xUSART2_putchar_0: (+1)
   \   0000001A   0x2140             MOVS     R1,#+64
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??xUSART2_putchar_0
    153          	{
    154                  
    155          	}
    156          	Delay(10);
   \   00000026   0x200A             MOVS     R0,#+10
   \   00000028   0x.... 0x....      BL       Delay
    157          	RS485_SET_RX_Mode();
   \   0000002C   0x.... 0x....      BL       RS485_SET_RX_Mode
    158          	return ch;
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    159          }
    160          
    161          
    162          
    163          //------------------------------------------------------------------------
    164          // 名    称：   uint8_t SendCOM2(void *buf,uint32_t len)
    165          // 功    能：   串口0查询发送
    166          // 入口参数：   *buf   入口地址
    167          //              len    读取长度
    168          // 出口参数：   发送成功返回1，不正常返回0
    169          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    170          uint8_t SendCOM2(void *buf,uint32_t len)
    171          {
   \                     SendCOM2: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    172              uint8_t ch = 0;
    173          	uint8_t *p;
    174              if( (!len) )
   \   00000006   0xD112             BNE.N    ??SendCOM2_0
    175              {
    176                  return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD70             POP      {R4-R6,PC}
    177              }   
    178              p = buf;
    179              for(;len > 0;len--)
    180              {
    181                  //        U0THR = *p++;
    182                  xUSART2_putchar(*p++);
   \                     ??SendCOM2_1: (+1)
   \   0000000C   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000010   0x.... 0x....      BL       xUSART2_putchar
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable21_3  ;; 0x40004400
    183                  //		SysFastHoldTast();
    184          		
    185                  while (USART_GetFlagStatus(SZ_STM32_COM2, USART_FLAG_TC) == RESET);/*等待发送完成*/
   \                     ??SendCOM2_2: (+1)
   \   00000018   0x2140             MOVS     R1,#+64
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0F9             BEQ.N    ??SendCOM2_2
    186          		ch = (int)SZ_STM32_COM2->DR & 0xFF;
   \   00000024   0x88B0             LDRH     R0,[R6, #+4]
    187                  
    188              	putchar(ch); //回显
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x.... 0x....      BL       putchar
    189                  //        {SysFastHoldTast();}  
    190              }
   \   0000002C   0x1E6D             SUBS     R5,R5,#+1
   \                     ??SendCOM2_0: (+1)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD1EC             BNE.N    ??SendCOM2_1
    191              
    192              RS485_SET_RX_Mode();    
   \   00000032   0x.... 0x....      BL       RS485_SET_RX_Mode
    193              return 1;    
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    194          }
    195          
    196          
    197          /*----------------------------------------------*/
    198          /* Put a character                              */
    199          /*----------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    200          void xputc (char c /* A character to be output */) 
    201          {
    202          	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
    203              
    204          	if (outptr) {
   \                     xputc: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD004             BEQ.N    ??xputc_0
    205          		*outptr++ = (unsigned char)c;
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0x7010             STRB     R0,[R2, #+0]
    206          		return;
   \   00000012   0x4770             BX       LR
    207          	}
    208              
    209          	if (xfunc_out) xfunc_out((unsigned char)c);
   \                     ??xputc_0: (+1)
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x000A             MOVS     R2,R1
   \   00000018   0xD000             BEQ.N    ??xputc_1
   \   0000001A   0x4708             BX       R1
    210          }
   \                     ??xputc_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    211          
    212          
    213          
    214          /*----------------------------------------------*/
    215          /* Put a null-terminated string                 */
    216          /*----------------------------------------------*/
    217          

   \                                 In section .text, align 2, keep-with-next
    218          void xputs (					/* Put a string to the default device */
    219                      const char* str				/* Pointer to the string */
    220                          )
    221          {
   \                     xputs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??xputs_0
    222          	while (*str)
    223          		xputc(*str++);
   \                     ??xputs_1: (+1)
   \   00000006   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000000A   0x.... 0x....      BL       xputc
   \                     ??xputs_0: (+1)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD1F8             BNE.N    ??xputs_1
    224          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    225          
    226          

   \                                 In section .text, align 2, keep-with-next
    227          void xfputs (					/* Put a string to the specified device */
    228                       void(*func)(unsigned char),	/* Pointer to the output function */
    229                       const char*	str				/* Pointer to the string */
    230                           )
    231          {
   \                     xfputs: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    232          	void (*pf)(unsigned char);
    233              
    234              
    235          	pf = xfunc_out;		/* Save current output device */
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable21_1
   \   00000008   0x682E             LDR      R6,[R5, #+0]
    236          	xfunc_out = func;	/* Switch output to specified device */
   \   0000000A   0x6028             STR      R0,[R5, #+0]
   \   0000000C   0xE003             B.N      ??xfputs_0
    237          	while (*str)		/* Put the string */
    238          		xputc(*str++);
   \                     ??xfputs_1: (+1)
   \   0000000E   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000012   0x.... 0x....      BL       xputc
   \                     ??xfputs_0: (+1)
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F8             BNE.N    ??xfputs_1
    239          	xfunc_out = pf;		/* Restore output device */
   \   0000001C   0x602E             STR      R6,[R5, #+0]
    240          }
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    241          
    242          
    243          
    244          /*----------------------------------------------*/
    245          /* Formatted string output                      */
    246          /*----------------------------------------------*/
    247          /*  xprintf("%d", 1234);			"1234"
    248          xprintf("%6d,%3d%%", -200, 5);	"  -200,  5%"
    249          xprintf("%-6u", 100);			"100   "
    250          xprintf("%ld", 12345678L);		"12345678"
    251          xprintf("%04x", 0xA3);			"00a3"
    252          xprintf("%08LX", 0x123ABC);		"00123ABC"
    253          xprintf("%016b", 0x550F);		"0101010100001111"
    254          xprintf("%s", "String");		"String"
    255          xprintf("%-4s", "abc");			"abc "
    256          xprintf("%4s", "abc");			" abc"
    257          xprintf("%c", 'a');				"a"
    258          xprintf("%f", 10.0);            <xprintf lacks floating point support>
    259          */
    260          

   \                                 In section .text, align 2, keep-with-next
    261          static
    262          void xvprintf (
    263                         const char*	fmt,	/* Pointer to the format string */
    264                         va_list arp			/* Pointer to arguments */
    265                             )
    266          {
   \                     xvprintf: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0xE004             B.N      ??xvprintf_0
    267          	unsigned int r, i, j, w, f;
    268          	unsigned long v;
    269          	char s[16], c, d, *p;
    270              
    271              
    272          	for (;;) {
    273          		c = *fmt++;					/* Get a char */
    274          		if (!c) break;				/* End of format? */
    275          		if (c != '%') {				/* Pass through it if not a % sequense */
    276          			xputc(c); continue;
    277          		}
    278          		f = 0;
    279          		c = *fmt++;					/* Get first char of the sequense */
    280          		if (c == '0') {				/* Flag: '0' padded */
    281          			f = 1; c = *fmt++;
    282          		} else {
    283          			if (c == '-') {			/* Flag: left justified */
    284          				f = 2; c = *fmt++;
    285          			}
    286          		}
    287          		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    288          			w = w * 10 + c - '0';
    289          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
    290          			f |= 4; c = *fmt++;
    291          		}
    292          		if (!c) break;				/* End of format? */
    293          		d = c;
    294          		if (d >= 'a') d -= 0x20;
    295          		switch (d) {				/* Type is... */
    296          		case 'S' :					/* String */
    297          			p = va_arg(arp, char*);
    298          			for (j = 0; p[j]; j++) ;
    299          			while (!(f & 2) && j++ < w) xputc(' ');
    300          			xputs(p);
    301          			while (j++ < w) xputc(' ');
    302          			continue;
    303          		case 'C' :					/* Character */
    304          			xputc((char)va_arg(arp, int)); continue;
   \                     ??xvprintf_1: (+1)
   \   0000000C   0xF857 0x0B04      LDR      R0,[R7], #+4
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x.... 0x....      BL       xputc
   \                     ??xvprintf_0: (+1)
   \   00000016   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF000 0x80C5      BEQ.W    ??xvprintf_2
   \   00000020   0x2825             CMP      R0,#+37
   \   00000022   0xD16A             BNE.N    ??xvprintf_3
   \   00000024   0x2600             MOVS     R6,#+0
   \   00000026   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000002A   0x2830             CMP      R0,#+48
   \   0000002C   0xD103             BNE.N    ??xvprintf_4
   \   0000002E   0x2601             MOVS     R6,#+1
   \   00000030   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000034   0xE004             B.N      ??xvprintf_5
   \                     ??xvprintf_4: (+1)
   \   00000036   0x282D             CMP      R0,#+45
   \   00000038   0xD102             BNE.N    ??xvprintf_5
   \   0000003A   0x2602             MOVS     R6,#+2
   \   0000003C   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \                     ??xvprintf_5: (+1)
   \   00000040   0x2500             MOVS     R5,#+0
   \   00000042   0xE007             B.N      ??xvprintf_6
   \                     ??xvprintf_7: (+1)
   \   00000044   0xEB05 0x0185      ADD      R1,R5,R5, LSL #+2
   \   00000048   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   0000004C   0xF1A0 0x0530      SUB      R5,R0,#+48
   \   00000050   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \                     ??xvprintf_6: (+1)
   \   00000054   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000058   0x290A             CMP      R1,#+10
   \   0000005A   0xD3F3             BCC.N    ??xvprintf_7
   \   0000005C   0x286C             CMP      R0,#+108
   \   0000005E   0xD001             BEQ.N    ??xvprintf_8
   \   00000060   0x284C             CMP      R0,#+76
   \   00000062   0xD103             BNE.N    ??xvprintf_9
   \                     ??xvprintf_8: (+1)
   \   00000064   0xF046 0x0604      ORR      R6,R6,#0x4
   \   00000068   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \                     ??xvprintf_9: (+1)
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xF000 0x809C      BEQ.W    ??xvprintf_2
   \   00000072   0x4682             MOV      R10,R0
   \   00000074   0xF1BA 0x0F61      CMP      R10,#+97
   \   00000078   0xDB03             BLT.N    ??xvprintf_10
   \   0000007A   0xF1AA 0x0A20      SUB      R10,R10,#+32
   \   0000007E   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??xvprintf_10: (+1)
   \   00000082   0x4651             MOV      R1,R10
   \   00000084   0x2942             CMP      R1,#+66
   \   00000086   0xD02E             BEQ.N    ??xvprintf_11
   \   00000088   0x2943             CMP      R1,#+67
   \   0000008A   0xD0BF             BEQ.N    ??xvprintf_1
   \   0000008C   0x2944             CMP      R1,#+68
   \   0000008E   0xD030             BEQ.N    ??xvprintf_12
   \   00000090   0x294F             CMP      R1,#+79
   \   00000092   0xD02C             BEQ.N    ??xvprintf_13
   \   00000094   0x2953             CMP      R1,#+83
   \   00000096   0xD004             BEQ.N    ??xvprintf_14
   \   00000098   0x2955             CMP      R1,#+85
   \   0000009A   0xD02A             BEQ.N    ??xvprintf_12
   \   0000009C   0x2958             CMP      R1,#+88
   \   0000009E   0xD02A             BEQ.N    ??xvprintf_15
   \   000000A0   0xE02B             B.N      ??xvprintf_3
   \                     ??xvprintf_14: (+1)
   \   000000A2   0xF857 0x8B04      LDR      R8,[R7], #+4
   \   000000A6   0xF04F 0x0B00      MOV      R11,#+0
   \   000000AA   0xE001             B.N      ??xvprintf_16
   \                     ??xvprintf_17: (+1)
   \   000000AC   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??xvprintf_16: (+1)
   \   000000B0   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD1F9             BNE.N    ??xvprintf_17
   \                     ??xvprintf_18: (+1)
   \   000000B8   0x07B0             LSLS     R0,R6,#+30
   \   000000BA   0xD408             BMI.N    ??xvprintf_19
   \   000000BC   0x4658             MOV      R0,R11
   \   000000BE   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000000C2   0x42A8             CMP      R0,R5
   \   000000C4   0xD203             BCS.N    ??xvprintf_19
   \   000000C6   0x2020             MOVS     R0,#+32
   \   000000C8   0x.... 0x....      BL       xputc
   \   000000CC   0xE7F4             B.N      ??xvprintf_18
   \                     ??xvprintf_19: (+1)
   \   000000CE   0x4640             MOV      R0,R8
   \   000000D0   0x.... 0x....      BL       xputs
   \                     ??xvprintf_20: (+1)
   \   000000D4   0x4658             MOV      R0,R11
   \   000000D6   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000000DA   0x42A8             CMP      R0,R5
   \   000000DC   0xD29B             BCS.N    ??xvprintf_0
   \   000000DE   0x2020             MOVS     R0,#+32
   \   000000E0   0x.... 0x....      BL       xputc
   \   000000E4   0xE7F6             B.N      ??xvprintf_20
    305          		case 'B' :					/* Binary */
    306          			r = 2; break;
   \                     ??xvprintf_11: (+1)
   \   000000E6   0x2102             MOVS     R1,#+2
    307          		case 'O' :					/* Octal */
    308          			r = 8; break;
    309          		case 'D' :					/* Signed decimal */
    310          		case 'U' :					/* Unsigned decimal */
    311          			r = 10; break;
    312          		case 'X' :					/* Hexdecimal */
    313          			r = 16; break;
    314          		default:					/* Unknown type (passthrough) */
    315          			xputc(c); continue;
    316          		}
    317                  
    318          		/* Get an argument and put it in numeral */
    319          		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
   \                     ??xvprintf_21: (+1)
   \   000000E8   0xF857 0x2B04      LDR      R2,[R7], #+4
   \   000000EC   0xE008             B.N      ??xvprintf_22
   \                     ??xvprintf_13: (+1)
   \   000000EE   0x2108             MOVS     R1,#+8
   \   000000F0   0xE7FA             B.N      ??xvprintf_21
   \                     ??xvprintf_12: (+1)
   \   000000F2   0x210A             MOVS     R1,#+10
   \   000000F4   0xE7F8             B.N      ??xvprintf_21
   \                     ??xvprintf_15: (+1)
   \   000000F6   0x2110             MOVS     R1,#+16
   \   000000F8   0xE7F6             B.N      ??xvprintf_21
   \                     ??xvprintf_3: (+1)
   \   000000FA   0x.... 0x....      BL       xputc
   \   000000FE   0xE78A             B.N      ??xvprintf_0
    320          		if (d == 'D' && (v & 0x80000000)) {
   \                     ??xvprintf_22: (+1)
   \   00000100   0xF1BA 0x0F44      CMP      R10,#+68
   \   00000104   0xD104             BNE.N    ??xvprintf_23
   \   00000106   0x2A00             CMP      R2,#+0
   \   00000108   0xD502             BPL.N    ??xvprintf_23
    321          			v = 0 - v;
   \   0000010A   0x4252             RSBS     R2,R2,#+0
    322          			f |= 8;
   \   0000010C   0xF046 0x0608      ORR      R6,R6,#0x8
    323          		}
    324          		i = 0;
   \                     ??xvprintf_23: (+1)
   \   00000110   0xF04F 0x0900      MOV      R9,#+0
   \   00000114   0x46E8             MOV      R8,SP
    325          		do {
    326          			d = (char)(v % r); v /= r;
   \                     ??xvprintf_24: (+1)
   \   00000116   0xFBB2 0xF3F1      UDIV     R3,R2,R1
   \   0000011A   0xFB01 0x2A13      MLS      R10,R1,R3,R2
   \   0000011E   0xFA5F 0xFA8A      UXTB     R10,R10
   \   00000122   0x461A             MOV      R2,R3
    327          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   \   00000124   0x4653             MOV      R3,R10
   \   00000126   0x2B0A             CMP      R3,#+10
   \   00000128   0xDB07             BLT.N    ??xvprintf_25
   \   0000012A   0x2878             CMP      R0,#+120
   \   0000012C   0xD101             BNE.N    ??xvprintf_26
   \   0000012E   0x2327             MOVS     R3,#+39
   \   00000130   0xE000             B.N      ??xvprintf_27
   \                     ??xvprintf_26: (+1)
   \   00000132   0x2307             MOVS     R3,#+7
   \                     ??xvprintf_27: (+1)
   \   00000134   0x449A             ADD      R10,R3,R10
   \   00000136   0xFA5F 0xFA8A      UXTB     R10,R10
    328          			s[i++] = d + '0';
   \                     ??xvprintf_25: (+1)
   \   0000013A   0xF10A 0x0330      ADD      R3,R10,#+48
   \   0000013E   0xF809 0x3008      STRB     R3,[R9, R8]
   \   00000142   0xF109 0x0901      ADD      R9,R9,#+1
    329          		} while (v && i < sizeof(s));
   \   00000146   0x2A00             CMP      R2,#+0
   \   00000148   0xD002             BEQ.N    ??xvprintf_28
   \   0000014A   0xF1B9 0x0F10      CMP      R9,#+16
   \   0000014E   0xD3E2             BCC.N    ??xvprintf_24
    330          		if (f & 8) s[i++] = '-';
   \                     ??xvprintf_28: (+1)
   \   00000150   0x0730             LSLS     R0,R6,#+28
   \   00000152   0xD504             BPL.N    ??xvprintf_29
   \   00000154   0x202D             MOVS     R0,#+45
   \   00000156   0xF809 0x0008      STRB     R0,[R9, R8]
   \   0000015A   0xF109 0x0901      ADD      R9,R9,#+1
    331          		j = i; d = (f & 1) ? '0' : ' ';
   \                     ??xvprintf_29: (+1)
   \   0000015E   0x46CB             MOV      R11,R9
   \   00000160   0x07F0             LSLS     R0,R6,#+31
   \   00000162   0xD502             BPL.N    ??xvprintf_30
   \   00000164   0xF04F 0x0A30      MOV      R10,#+48
   \   00000168   0xE005             B.N      ??xvprintf_31
   \                     ??xvprintf_30: (+1)
   \   0000016A   0xF04F 0x0A20      MOV      R10,#+32
   \   0000016E   0xE002             B.N      ??xvprintf_31
    332          		while (!(f & 2) && j++ < w) xputc(d);
   \                     ??xvprintf_32: (+1)
   \   00000170   0x4650             MOV      R0,R10
   \   00000172   0x.... 0x....      BL       xputc
   \                     ??xvprintf_31: (+1)
   \   00000176   0x07B0             LSLS     R0,R6,#+30
   \   00000178   0xD404             BMI.N    ??xvprintf_33
   \   0000017A   0x4658             MOV      R0,R11
   \   0000017C   0xF100 0x0B01      ADD      R11,R0,#+1
   \   00000180   0x42A8             CMP      R0,R5
   \   00000182   0xD3F5             BCC.N    ??xvprintf_32
    333          		do xputc(s[--i]); while(i);
   \                     ??xvprintf_33: (+1)
   \   00000184   0xF1A9 0x0901      SUB      R9,R9,#+1
   \   00000188   0xF819 0x0008      LDRB     R0,[R9, R8]
   \   0000018C   0x.... 0x....      BL       xputc
   \   00000190   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000194   0xD1F6             BNE.N    ??xvprintf_33
    334          		while (j++ < w) xputc(' ');
   \                     ??xvprintf_34: (+1)
   \   00000196   0x4658             MOV      R0,R11
   \   00000198   0xF100 0x0B01      ADD      R11,R0,#+1
   \   0000019C   0x42A8             CMP      R0,R5
   \   0000019E   0xF4BF 0xAF3A      BCS.W    ??xvprintf_0
   \   000001A2   0x2020             MOVS     R0,#+32
   \   000001A4   0x.... 0x....      BL       xputc
   \   000001A8   0xE7F5             B.N      ??xvprintf_34
    335          	}
    336          }
   \                     ??xvprintf_2: (+1)
   \   000001AA   0xB005             ADD      SP,SP,#+20
   \   000001AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    337          
    338          
    339          /*----------------------------------------------/
    340          /  xprintf - Formatted string output
    341          /----------------------------------------------*/
    342          /*  xprintf("%d", 1234);            "1234"
    343          xprintf("%6d,%3d%%", -200, 5);  "  -200,  5%"
    344          xprintf("%-6u", 100);           "100   "
    345          xprintf("%ld", 12345678L);      "12345678"
    346          xprintf("%04x", 0xA3);          "00a3"
    347          xprintf("%08LX", 0x123ABC);     "00123ABC"
    348          xprintf("%016b", 0x550F);       "0101010100001111"
    349          xprintf("%s", "String");        "String"
    350          xprintf("%-4s", "abc");         "abc "
    351          xprintf("%4s", "abc");          " abc"
    352          xprintf("%c", 'a');             "a"
    353          xprintf("%f", 10.0);            <xprintf lacks floating point support>
    354          */

   \                                 In section .text, align 2, keep-with-next
    355          void xprintf (			/* Put a formatted string to the default device */
    356                        const char*	fmt,	/* Pointer to the format string */
    357                        ...					/* Optional arguments */
    358                            )
    359          {
   \                     xprintf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
    360          	va_list arp;
    361              
    362              
    363          	va_start(arp, fmt);
   \   00000004   0xA901             ADD      R1,SP,#+4
    364          	xvprintf(fmt, arp);
   \   00000006   0x.... 0x....      BL       xvprintf
    365          	va_end(arp);
    366          }
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    367          
    368          

   \                                 In section .text, align 2, keep-with-next
    369          void xsprintf (			/* Put a formatted string to the memory */
    370                         char* buff,			/* Pointer to the output buffer */
    371                         const char*	fmt,	/* Pointer to the format string */
    372                         ...					/* Optional arguments */
    373                             )
    374          {
   \                     xsprintf: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x460A             MOV      R2,R1
    375          	va_list arp;
    376              
    377              
    378          	outptr = buff;		/* Switch destination for memory */
   \   00000006   0x....             LDR.N    R4,??DataTable21_1
   \   00000008   0x6060             STR      R0,[R4, #+4]
    379              
    380          	va_start(arp, fmt);
   \   0000000A   0xA902             ADD      R1,SP,#+8
    381          	xvprintf(fmt, arp);
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x.... 0x....      BL       xvprintf
    382          	va_end(arp);
    383              
    384          	*outptr = 0;		/* Terminate output string with a \0 */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6861             LDR      R1,[R4, #+4]
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    385          	outptr = 0;			/* Switch destination for device */
   \   00000018   0x6060             STR      R0,[R4, #+4]
    386          }
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    387          
    388          

   \                                 In section .text, align 2, keep-with-next
    389          void xfprintf (					/* Put a formatted string to the specified device */
    390                         void(*func)(unsigned char),	/* Pointer to the output function */
    391                         const char*	fmt,			/* Pointer to the format string */
    392                         ...							/* Optional arguments */
    393                             )
    394          {
   \                     xfprintf: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x460A             MOV      R2,R1
    395          	va_list arp;
    396          	void (*pf)(unsigned char);
    397              
    398              
    399          	pf = xfunc_out;		/* Save current output device */
   \   00000006   0x....             LDR.N    R4,??DataTable21_1
   \   00000008   0x6825             LDR      R5,[R4, #+0]
    400          	xfunc_out = func;	/* Switch output to specified device */
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    401              
    402          	va_start(arp, fmt);
   \   0000000C   0xA904             ADD      R1,SP,#+16
    403          	xvprintf(fmt, arp);
   \   0000000E   0x4610             MOV      R0,R2
   \   00000010   0x.... 0x....      BL       xvprintf
    404          	va_end(arp);
    405              
    406          	xfunc_out = pf;		/* Restore output device */
   \   00000014   0x6025             STR      R5,[R4, #+0]
    407          }
   \   00000016   0xBC31             POP      {R0,R4,R5}
   \   00000018   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    408          
    409          
    410          
    411          /*----------------------------------------------*/
    412          /* Dump a line of binary dump                   */
    413          /*----------------------------------------------*/
    414          

   \                                 In section .text, align 2, keep-with-next
    415          void put_dump (
    416                         const void* buff,		/* Pointer to the array to be dumped */
    417                         unsigned long addr,		/* Heading address value */
    418                         int len,				/* Number of items to be dumped */
    419                         int width				/* Size of the items (DF_CHAR, DF_SHORT, DF_LONG) */
    420                             )
    421          {
   \                     put_dump: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x461E             MOV      R6,R3
    422          	int i;
    423          	const unsigned char *bp;
    424          	const unsigned short *sp;
    425          	const unsigned long *lp;
    426              
    427              
    428          	xprintf("%08lX ", addr);		/* address */
   \   00000008   0x.... 0x....      ADR.W    R0,?_0
   \   0000000C   0x.... 0x....      BL       xprintf
    429              
    430          	switch (width) {
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xD004             BEQ.N    ??put_dump_0
   \   00000014   0x2E02             CMP      R6,#+2
   \   00000016   0xD01D             BEQ.N    ??put_dump_1
   \   00000018   0x2E04             CMP      R6,#+4
   \   0000001A   0xD024             BEQ.N    ??put_dump_2
   \   0000001C   0xE02B             B.N      ??put_dump_3
    431          	case DW_CHAR:
    432          		bp = buff;
    433          		for (i = 0; i < len; i++)		/* Hexdecimal dump */
   \                     ??put_dump_0: (+1)
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0xE005             B.N      ??put_dump_4
    434          			xprintf(" %02X", bp[i]);
   \                     ??put_dump_5: (+1)
   \   00000022   0x5D31             LDRB     R1,[R6, R4]
   \   00000024   0x.... 0x....      ADR.W    R0,?_1
   \   00000028   0x.... 0x....      BL       xprintf
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \                     ??put_dump_4: (+1)
   \   0000002E   0x42AE             CMP      R6,R5
   \   00000030   0xDBF7             BLT.N    ??put_dump_5
    435          		xputc(' ');
   \   00000032   0x2020             MOVS     R0,#+32
   \   00000034   0x.... 0x....      BL       xputc
    436          		for (i = 0; i < len; i++)		/* ASCII dump */
   \   00000038   0x2600             MOVS     R6,#+0
   \   0000003A   0xE003             B.N      ??put_dump_6
    437          			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
   \                     ??put_dump_7: (+1)
   \   0000003C   0x202E             MOVS     R0,#+46
   \                     ??put_dump_8: (+1)
   \   0000003E   0x.... 0x....      BL       xputc
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \                     ??put_dump_6: (+1)
   \   00000044   0x42AE             CMP      R6,R5
   \   00000046   0xDA16             BGE.N    ??put_dump_3
   \   00000048   0x5D30             LDRB     R0,[R6, R4]
   \   0000004A   0xF1A0 0x0120      SUB      R1,R0,#+32
   \   0000004E   0x295F             CMP      R1,#+95
   \   00000050   0xD2F4             BCS.N    ??put_dump_7
   \   00000052   0xE7F4             B.N      ??put_dump_8
    438          		break;
    439          	case DW_SHORT:
    440          		sp = buff;
    441          		do								/* Hexdecimal dump */
    442          			xprintf(" %04X", *sp++);
   \                     ??put_dump_1: (+1)
   \   00000054   0xF834 0x1B02      LDRH     R1,[R4], #+2
   \   00000058   0x.... 0x....      ADR.W    R0,?_2
   \   0000005C   0x.... 0x....      BL       xprintf
    443          		while (--len);
   \   00000060   0x1E6D             SUBS     R5,R5,#+1
   \   00000062   0xD1F7             BNE.N    ??put_dump_1
   \   00000064   0xE007             B.N      ??put_dump_3
    444          		break;
    445          	case DW_LONG:
    446          		lp = buff;
    447          		do								/* Hexdecimal dump */
    448          			xprintf(" %08LX", *lp++);
   \                     ??put_dump_2: (+1)
   \   00000066   0xF854 0x1B04      LDR      R1,[R4], #+4
   \   0000006A   0x.... 0x....      ADR.W    R0,?_3
   \   0000006E   0x.... 0x....      BL       xprintf
    449          		while (--len);
   \   00000072   0x1E6D             SUBS     R5,R5,#+1
   \   00000074   0xD1F7             BNE.N    ??put_dump_2
    450          		break;
    451          	}
    452              
    453          	xputc('\n');
   \                     ??put_dump_3: (+1)
   \   00000076   0x200A             MOVS     R0,#+10
   \   00000078   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007C   0x....             B.N      xputc
    454          }

   \                                 In section .bss, align 4
   \                     xfunc_out:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    455          
    456          #endif /* _USE_XFUNC_OUT */
    457          
    458          
    459          
    460          #if _USE_XFUNC_IN
    461          unsigned char (*xfunc_in)(void);	/* Pointer to the input stream */
   \                     xfunc_in:
   \   00000008                      DS8 4
    462          
    463          

   \                                 In section .text, align 4, keep-with-next
    464          unsigned char xUSART2_getchar(void)
    465          {
   \                     xUSART2_getchar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable21_3  ;; 0x40004400
    466              unsigned char key = 0;
    467              
    468              /* Waiting for user input */
    469              //  RS485_SET_RX_Mode();
    470              while (1)
    471              {
    472                  if ( USART_GetFlagStatus(SZ_STM32_COM2, USART_FLAG_RXNE) != RESET)
   \                     ??xUSART2_getchar_0: (+1)
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD0F9             BEQ.N    ??xUSART2_getchar_0
    473                  {
    474                      key = (uint8_t)SZ_STM32_COM2->DR & 0xFF;
   \   00000010   0x88A0             LDRH     R0,[R4, #+4]
    475                      break;
    476                  }
    477              }
    478              return key;
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    479          }
    480          

   \                                 In section .text, align 2, keep-with-next
    481          unsigned char xUSART1_getchar(void)
    482          {
   \                     xUSART1_getchar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable21_2  ;; 0x40013800
    483              unsigned char key = 0;
    484              
    485              /* Waiting for user input */
    486              while (1)
    487              {
    488                  if ( USART_GetFlagStatus(SZ_STM32_COM1, USART_FLAG_RXNE) != RESET)
   \                     ??xUSART1_getchar_0: (+1)
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD0F9             BEQ.N    ??xUSART1_getchar_0
    489                  {
    490                      key = (uint8_t)SZ_STM32_COM1->DR & 0xFF;
   \   00000010   0x88A0             LDRH     R0,[R4, #+4]
    491                      break;
    492                  }
    493              }
    494              return key;
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    495          }
    496          
    497          /*----------------------------------------------*/
    498          /* Get a line from the input                    */
    499          /*----------------------------------------------*/
    500          

   \                                 In section .text, align 2, keep-with-next
    501          int xgets (		/* 0:End of stream, 1:A line arrived */
    502                     char* buff,	/* Pointer to the buffer */
    503                     int len		/* Buffer length */
    504                         )
    505          {
   \                     xgets: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    506          	int c, i;
    507              
    508              
    509          	if (!xfunc_in) return 0;		/* No input function specified */
   \   00000006   0x....             LDR.N    R6,??DataTable21_1
   \   00000008   0x68B0             LDR      R0,[R6, #+8]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD009             BEQ.N    ??xgets_0
    510              
    511          	i = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
   \   00000010   0xE003             B.N      ??xgets_1
    512          	for (;;) {
    513          		c = xfunc_in();				/* Get a char from the incoming stream */
    514          		if (!c) return 0;			/* End of stream? */
    515          		if (c == '\r') break;		/* End of line? */
    516          		if (c == '\b' && i) {		/* Back space? */
    517          			i--;
   \                     ??xgets_2: (+1)
   \   00000012   0x1E7F             SUBS     R7,R7,#+1
    518          			if (_LINE_ECHO) xputc(c);
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x.... 0x....      BL       xputc
    519          			continue;
    520          		}
   \                     ??xgets_1: (+1)
   \   0000001A   0x68B0             LDR      R0,[R6, #+8]
   \   0000001C   0x4780             BLX      R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??xgets_3
   \                     ??xgets_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??xgets_3: (+1)
   \   00000026   0x280D             CMP      R0,#+13
   \   00000028   0xD106             BNE.N    ??xgets_4
    521          		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    522          			buff[i++] = c;
    523          			if (_LINE_ECHO) xputc(c);
    524          		}
    525          	}
    526          	buff[i] = 0;	/* Terminate with a \0 */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x5538             STRB     R0,[R7, R4]
    527          	if (_LINE_ECHO) xputc('\n');
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0x.... 0x....      BL       xputc
    528          	return 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??xgets_4: (+1)
   \   00000038   0x2808             CMP      R0,#+8
   \   0000003A   0xD101             BNE.N    ??xgets_5
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD1E8             BNE.N    ??xgets_2
   \                     ??xgets_5: (+1)
   \   00000040   0x2820             CMP      R0,#+32
   \   00000042   0xDBEA             BLT.N    ??xgets_1
   \   00000044   0x1E69             SUBS     R1,R5,#+1
   \   00000046   0x428F             CMP      R7,R1
   \   00000048   0xDAE7             BGE.N    ??xgets_1
   \   0000004A   0x5538             STRB     R0,[R7, R4]
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0x.... 0x....      BL       xputc
   \   00000052   0xE7E2             B.N      ??xgets_1
    529          }
    530          
    531          /**
    532          * @brief  Test to see if a key has been pressed on the HyperTerminal
    533          * @param  key: The key pressed
    534          * @retval 1: Correct
    535          *         0: Error
    536          */

   \                                 In section .text, align 2, keep-with-next
    537          uint32_t xUSART2_ValidInput(void)
    538          {
   \                     xUSART2_ValidInput: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    539              
    540              if ( USART_GetFlagStatus(SZ_STM32_COM2, USART_FLAG_RXNE) != RESET)
   \   00000002   0x2120             MOVS     R1,#+32
   \   00000004   0x....             LDR.N    R0,??DataTable21_3  ;; 0x40004400
   \   00000006   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
    541              {
    542                  return 1;
    543              }
    544              else
    545              {
    546                  return 0;
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    547              }
    548          }
    549          
    550          /**
    551          * @brief  Test to see if a key has been pressed on the HyperTerminal
    552          * @param  key: The key pressed
    553          * @retval 1: Correct
    554          *         0: Error
    555          */

   \                                 In section .text, align 2, keep-with-next
    556          uint32_t xUSART1_ValidInput(void)
    557          {
   \                     xUSART1_ValidInput: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    558              
    559              if ( USART_GetFlagStatus(SZ_STM32_COM1, USART_FLAG_RXNE) != RESET)
   \   00000002   0x2120             MOVS     R1,#+32
   \   00000004   0x....             LDR.N    R0,??DataTable21_2  ;; 0x40013800
   \   00000006   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
    560              {
    561                  return 1;
    562              }
    563              else
    564              {
    565                  return 0;
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    566              }
    567          }
    568          

   \                                 In section .text, align 2, keep-with-next
    569          uint32_t xgets_nowait (uint8_t * buffP, uint32_t length)
    570          {
   \                     xgets_nowait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
    571              static uint32_t bytes_read = 0;
    572              uint8_t c = 0;
    573              
    574              if(xUSART2_ValidInput())
   \   00000006   0x.... 0x....      BL       xUSART2_ValidInput
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD030             BEQ.N    ??xgets_nowait_0
    575              {
    576                  c = xUSART2_getchar();
   \   0000000E   0x.... 0x....      BL       xUSART2_getchar
    577                  if (c == '\r')
   \   00000012   0x....             LDR.N    R4,??DataTable21_4
   \   00000014   0x280D             CMP      R0,#+13
   \   00000016   0xD10B             BNE.N    ??xgets_nowait_1
    578                  {
    579                      xUSART2_putchar('\n');
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x.... 0x....      BL       xUSART2_putchar
    580                      xUSART2_putchar('\r');          
   \   0000001E   0x200D             MOVS     R0,#+13
   \   00000020   0x.... 0x....      BL       xUSART2_putchar
    581                      buffP[bytes_read] = '\0';
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x5548             STRB     R0,[R1, R5]
    582                      bytes_read = 0;
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    583                      
    584                      return 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD70             POP      {R4-R6,PC}
    585                  }
    586                  
    587                  if (c == '\b') /* Backspace */
   \                     ??xgets_nowait_1: (+1)
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xD10E             BNE.N    ??xgets_nowait_2
    588                  {
    589                      if (bytes_read > 0)
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD01A             BEQ.N    ??xgets_nowait_0
    590                      {
    591                          xUSART2_putchar('\b');
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0x.... 0x....      BL       xUSART2_putchar
    592                          xUSART2_putchar(' ');
   \   00000040   0x2020             MOVS     R0,#+32
   \   00000042   0x.... 0x....      BL       xUSART2_putchar
    593                          xUSART2_putchar('\b');
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0x.... 0x....      BL       xUSART2_putchar
    594                          bytes_read--;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x6020             STR      R0,[R4, #+0]
   \   00000052   0xE00D             B.N      ??xgets_nowait_0
    595                      }
    596                      return 0;          
    597                  }
    598                  //if (bytes_read >= (CMD_STRING_SIZE))
    599                  if (bytes_read >= (length))
   \                     ??xgets_nowait_2: (+1)
   \   00000054   0x42B1             CMP      R1,R6
   \   00000056   0xD302             BCC.N    ??xgets_nowait_3
    600                  {
    601                      //printf("Command string size overflow\r\n");
    602                      bytes_read = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6020             STR      R0,[R4, #+0]
    603                      return 0;
   \   0000005C   0xBD70             POP      {R4-R6,PC}
    604                  }
    605                  if (c >= 0x20 && c <= 0x7E)
   \                     ??xgets_nowait_3: (+1)
   \   0000005E   0xF1A0 0x0220      SUB      R2,R0,#+32
   \   00000062   0x2A5F             CMP      R2,#+95
   \   00000064   0xD204             BCS.N    ??xgets_nowait_0
    606                  {
    607                      buffP[bytes_read] = c;
   \   00000066   0x5548             STRB     R0,[R1, R5]
    608                      bytes_read++;
   \   00000068   0x1C49             ADDS     R1,R1,#+1
   \   0000006A   0x6021             STR      R1,[R4, #+0]
    609                      xUSART2_putchar(c);
   \   0000006C   0x.... 0x....      BL       xUSART2_putchar
    610                  }
    611              }
    612              
    613              return 0;
   \                     ??xgets_nowait_0: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    614          }

   \                                 In section .bss, align 4
   \                     ??bytes_read:
   \   00000000                      DS8 4
    615          
    616          

   \                                 In section .text, align 2, keep-with-next
    617          int xfgets (	/* 0:End of stream, 1:A line arrived */
    618                      unsigned char (*func)(void),	/* Pointer to the input stream function */
    619                      char* buff,	/* Pointer to the buffer */
    620                      int len		/* Buffer length */
    621                          )
    622          {
   \                     xfgets: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460B             MOV      R3,R1
   \   00000004   0x4611             MOV      R1,R2
    623          	unsigned char (*pf)(void);
    624          	int n;
    625              
    626              
    627          	pf = xfunc_in;			/* Save current input device */
   \   00000006   0x....             LDR.N    R4,??DataTable21_1
   \   00000008   0x68A5             LDR      R5,[R4, #+8]
    628          	xfunc_in = func;		/* Switch input to specified device */
   \   0000000A   0x60A0             STR      R0,[R4, #+8]
    629          	n = xgets(buff, len);	/* Get a line */
   \   0000000C   0x4618             MOV      R0,R3
   \   0000000E   0x.... 0x....      BL       xgets
    630          	xfunc_in = pf;			/* Restore input device */
   \   00000012   0x60A5             STR      R5,[R4, #+8]
    631              
    632          	return n;
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    633          }
    634          
    635          
    636          /*----------------------------------------------*/
    637          /* Get a value of the string                    */
    638          /*----------------------------------------------*/
    639          /*	"123 -5   0x3ff 0b1111 0377  w "
    640          ^                           1st call returns 123 and next ptr
    641          ^                        2nd call returns -5 and next ptr
    642          ^                3rd call returns 1023 and next ptr
    643          ^         4th call returns 15 and next ptr
    644          ^    5th call returns 255 and next ptr
    645          ^ 6th call fails and returns 0
    646          */
    647          

   \                                 In section .text, align 2, keep-with-next
    648          int xatoi (			/* 0:Failed, 1:Successful */
    649                     char **str,		/* Pointer to pointer to the string */
    650                     long *res		/* Pointer to the valiable to store the value */
    651                         )
    652          {
   \                     xatoi: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    653          	unsigned long val;
    654          	unsigned char c, r, s = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    655              
    656              
    657          	*res = 0;
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0x600B             STR      R3,[R1, #+0]
   \   00000008   0xE001             B.N      ??xatoi_0
    658              
    659          	while ((c = **str) == ' ') (*str)++;	/* Skip leading spaces */
   \                     ??xatoi_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \   0000000C   0x6003             STR      R3,[R0, #+0]
   \                     ??xatoi_0: (+1)
   \   0000000E   0x6803             LDR      R3,[R0, #+0]
   \   00000010   0x781C             LDRB     R4,[R3, #+0]
   \   00000012   0x4625             MOV      R5,R4
   \   00000014   0x2C20             CMP      R4,#+32
   \   00000016   0xD0F8             BEQ.N    ??xatoi_1
    660              
    661          	if (c == '-') {		/* negative? */
   \   00000018   0x2D2D             CMP      R5,#+45
   \   0000001A   0xD103             BNE.N    ??xatoi_2
    662          		s = 1;
   \   0000001C   0x2201             MOVS     R2,#+1
    663          		c = *(++(*str));
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0x6003             STR      R3,[R0, #+0]
   \   00000022   0x781D             LDRB     R5,[R3, #+0]
    664          	}
    665              
    666          	if (c == '0') {
   \                     ??xatoi_2: (+1)
   \   00000024   0x2D30             CMP      R5,#+48
   \   00000026   0xD11C             BNE.N    ??xatoi_3
    667          		c = *(++(*str));
   \   00000028   0x6803             LDR      R3,[R0, #+0]
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \   0000002C   0x6003             STR      R3,[R0, #+0]
   \   0000002E   0x781D             LDRB     R5,[R3, #+0]
    668          		switch (c) {
   \   00000030   0x462C             MOV      R4,R5
   \   00000032   0x2C62             CMP      R4,#+98
   \   00000034   0xD006             BEQ.N    ??xatoi_4
   \   00000036   0x2C78             CMP      R4,#+120
   \   00000038   0xD109             BNE.N    ??xatoi_5
    669          		case 'x':		/* hexdecimal */
    670          			r = 16; c = *(++(*str));
   \   0000003A   0x2410             MOVS     R4,#+16
   \   0000003C   0x1C5B             ADDS     R3,R3,#+1
   \   0000003E   0x6003             STR      R3,[R0, #+0]
   \   00000040   0x781D             LDRB     R5,[R3, #+0]
    671          			break;
   \   00000042   0xE013             B.N      ??xatoi_6
    672          		case 'b':		/* binary */
    673          			r = 2; c = *(++(*str));
   \                     ??xatoi_4: (+1)
   \   00000044   0x2402             MOVS     R4,#+2
   \   00000046   0x1C5B             ADDS     R3,R3,#+1
   \   00000048   0x6003             STR      R3,[R0, #+0]
   \   0000004A   0x781D             LDRB     R5,[R3, #+0]
    674          			break;
   \   0000004C   0xE00E             B.N      ??xatoi_6
    675          		default:
    676          			if (c <= ' ') return 1;	/* single zero */
   \                     ??xatoi_5: (+1)
   \   0000004E   0x2D21             CMP      R5,#+33
   \   00000050   0xDA01             BGE.N    ??xatoi_7
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE029             B.N      ??xatoi_8
    677          			if (c < '0' || c > '9') return 0;	/* invalid char */
   \                     ??xatoi_7: (+1)
   \   00000056   0xF1A5 0x0330      SUB      R3,R5,#+48
   \   0000005A   0x2B0A             CMP      R3,#+10
   \   0000005C   0xD21E             BCS.N    ??xatoi_9
    678          			r = 8;		/* octal */
   \   0000005E   0x2408             MOVS     R4,#+8
   \   00000060   0xE004             B.N      ??xatoi_6
    679          		}
    680          	} else {
    681          		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
   \                     ??xatoi_3: (+1)
   \   00000062   0xF1A5 0x0330      SUB      R3,R5,#+48
   \   00000066   0x2B0A             CMP      R3,#+10
   \   00000068   0xD218             BCS.N    ??xatoi_9
    682          		r = 10;			/* decimal */
   \   0000006A   0x240A             MOVS     R4,#+10
    683          	}
    684              
    685          	val = 0;
   \                     ??xatoi_6: (+1)
   \   0000006C   0x2300             MOVS     R3,#+0
   \   0000006E   0xE005             B.N      ??xatoi_10
    686          	while (c > ' ') {
    687          		if (c >= 'a') c -= 0x20;
    688          		c -= '0';
    689          		if (c >= 17) {
    690          			c -= 7;
    691          			if (c <= 9) return 0;	/* invalid char */
    692          		}
    693          		if (c >= r) return 0;		/* invalid char for current radix */
    694          		val = val * r + c;
   \                     ??xatoi_11: (+1)
   \   00000070   0xFB04 0x5303      MLA      R3,R4,R3,R5
    695          		c = *(++(*str));
   \   00000074   0x6805             LDR      R5,[R0, #+0]
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
   \   00000078   0x6005             STR      R5,[R0, #+0]
   \   0000007A   0x782D             LDRB     R5,[R5, #+0]
   \                     ??xatoi_10: (+1)
   \   0000007C   0x2D21             CMP      R5,#+33
   \   0000007E   0xDB0F             BLT.N    ??xatoi_12
   \   00000080   0x2D61             CMP      R5,#+97
   \   00000082   0xDB01             BLT.N    ??xatoi_13
   \   00000084   0x3D20             SUBS     R5,R5,#+32
   \   00000086   0xB2ED             UXTB     R5,R5
   \                     ??xatoi_13: (+1)
   \   00000088   0x3D30             SUBS     R5,R5,#+48
   \   0000008A   0xB2ED             UXTB     R5,R5
   \   0000008C   0x2D11             CMP      R5,#+17
   \   0000008E   0xDB03             BLT.N    ??xatoi_14
   \   00000090   0x1FED             SUBS     R5,R5,#+7
   \   00000092   0xB2ED             UXTB     R5,R5
   \   00000094   0x2D0A             CMP      R5,#+10
   \   00000096   0xDB01             BLT.N    ??xatoi_9
   \                     ??xatoi_14: (+1)
   \   00000098   0x42A5             CMP      R5,R4
   \   0000009A   0xDBE9             BLT.N    ??xatoi_11
   \                     ??xatoi_9: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE004             B.N      ??xatoi_8
    696          	}
    697          	if (s) val = 0 - val;			/* apply sign if needed */
   \                     ??xatoi_12: (+1)
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0xD000             BEQ.N    ??xatoi_15
   \   000000A4   0x425B             RSBS     R3,R3,#+0
    698              
    699          	*res = val;
   \                     ??xatoi_15: (+1)
   \   000000A6   0x600B             STR      R3,[R1, #+0]
    700          	return 1;
   \   000000A8   0x2001             MOVS     R0,#+1
   \                     ??xatoi_8: (+1)
   \   000000AA   0xBC30             POP      {R4,R5}
   \   000000AC   0x4770             BX       LR               ;; return
    701          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     xfunc_out

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x........         DC32     ??bytes_read

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x30          DC8 "%08lX "
   \              0x38 0x6C    
   \              0x58 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x20 0x25          DC8 " %02X"
   \              0x30 0x32    
   \              0x58 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x20 0x25          DC8 " %04X"
   \              0x30 0x34    
   \              0x58 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x20 0x25          DC8 " %08LX"
   \              0x30 0x38    
   \              0x4C 0x58    
   \              0x00         
   \   00000007   0x00               DC8 0
    702          
    703          #endif /* _USE_XFUNC_IN */
    704          //
    705          ///*----------------------------------------------------------------------------
    706          //名    称：   RecData
    707          //功    能：   接
    708          //入口参数：   无
    709          //出口参数：   无
    710          //---------------------------------------------------------------------------- */
    711          //uint8_t  RecData(uint8_t  *RecBuf,uint8_t  RecLen,uint8_t  *DataBuf,uint8_t  DataLen)
    712          //{
    713          //    uint16_t	i,j,k;
    714          //    uint8_t		Tmp;
    715          //    uint16_t	RecCRC16,Check16;
    716          //    uint8_t		HostCode,CodeType;
    717          //	
    718          //	uint16_t	RecDataLen;
    719          //	uint16_t	ReCopyTime;
    720          //	uint8_t		IDNum;
    721          //    
    722          //  	ReCopyTime = 0;
    723          //	for(j = 0;j < RecLen -1 - ReCopyTime ;j++ )											//去7d5c
    724          //	{
    725          //		if(	RecBuf[j] 	== HDLC_CODE0   					
    726          //           && 	((RecBuf[j+1]) == HDLC_CODE1)
    727          //               )
    728          //		{
    729          //			RecBuf[j] = FRAM_HERD0;														//7c
    730          //			for(k = j+1;k < RecLen-1; k++)
    731          //			{
    732          //				Tmp	 = RecBuf[k+1];
    733          //				
    734          //				RecBuf[k] = Tmp;
    735          //			}
    736          //			ReCopyTime++;
    737          //		}
    738          //		
    739          //		if(	RecBuf[j] 	== HDLC_CODE0   												//去7d5e
    740          //           && 	((RecBuf[j+1]) == HDLC_CODE2)
    741          //               )
    742          //		{
    743          //			RecBuf[j] = FRAM_END0;														//7e
    744          //			for(k = j+1;k < RecLen-1; k++)
    745          //			{
    746          //				Tmp	 = RecBuf[k+1];
    747          //				
    748          //				RecBuf[k] = Tmp;
    749          //			}
    750          //			ReCopyTime++;			
    751          //		}
    752          //		
    753          //		if(	RecBuf[j] 	== HDLC_CODE0   												//去7d5d
    754          //           && 	((RecBuf[j+1]) == HDLC_CODE3)
    755          //               )
    756          //		{
    757          //			RecBuf[j] = HDLC_CODE0;														//7d
    758          //			for(k = j+1;k < RecLen; k++)
    759          //			{
    760          //				Tmp	 = RecBuf[k+1];
    761          //				
    762          //				RecBuf[k] = Tmp;
    763          //			}
    764          //			ReCopyTime++;
    765          //		}					
    766          //	}
    767          //	
    768          //    for(i = 0; i < RecLen - 10;i++)												       //循环遍历
    769          //    {
    770          //		if(		((RecBuf[i+0]) == FRAM_HERD0)  				//报头
    771          //           &&	((RecBuf[i+1]) == HOST_ID) 
    772          //               &&	((RecBuf[i+2]) == DEVICE_ID0)  	 
    773          //                   )											
    774          //		{				
    775          //			RecDataLen  = RecBuf[i+3];
    776          //			RecDataLen  += RecBuf[i+4]*256;
    777          //			
    778          //			DataLen    =  RecDataLen;
    779          //			HostCode   =  RecBuf[i+5];
    780          //			IDNum	   =  RecBuf[i+6];
    781          //			CodeType   =  RecBuf[i+8];
    782          //			
    783          //			if(		(	HostCode 	!= HOST_CODE_FLG) 
    784          //               ||	(   IDNum       != ID_NUM   )
    785          //                   ||  (   CodeType       != CODE_TYPE   )
    786          //                       )
    787          //            {	
    788          //			 	i = i + 8;															//地址不对或帧尾错误，跳过此帧
    789          //			 	continue;
    790          //            }			
    791          //            
    792          //			RecCRC16 = ((uint16_t)RecBuf[i+5+RecDataLen]) *256 + RecBuf[i+6+RecDataLen];	//校验	
    793          //            
    794          //			Check16 = GetCrc16Check(&RecBuf[i+5],DataLen);	
    795          //			
    796          //			if(		RecCRC16  ==	Check16 		
    797          //               )
    798          //			{
    799          //                memcpy(DataBuf,&RecBuf[i+5],DataLen);				//数据拷贝
    800          //                
    801          //                return	1;
    802          //			}
    803          //		}
    804          //	}
    805          //   	
    806          //   	DataLen = 0;
    807          //    return	0;
    808          //}
    809          //
    810          //#define		ENERGY_DATA_LEN	40
    811          //#define		ATHER_DATA_LEN	4
    812          //void	Sendrs485(uint8_t	*DataBuf,uint32_t	DataLen,uint8_t	CheckNum)
    813          //{
    814          //	uint8_t		SndBuf[100] = {0};
    815          //	uint8_t		SndBufTmp[100] = {0};
    816          //	uint16_t	Crc16;
    817          //	uint16_t	AddHeadNum;
    818          //	uint16_t	i;
    819          //	uint8_t		ByteStation;
    820          //    
    821          //	static	uint8_t		Test = 0x02;
    822          //    
    823          //	ByteStation = 0;
    824          //	SndBuf[ByteStation++] = FRAM_HERD0;
    825          //	SndBuf[ByteStation++] = DEVICE_ID0;
    826          //	SndBuf[ByteStation++] = HOST_ID;	 
    827          //	SndBuf[ByteStation++] = ENERGY_DATA_LEN+ATHER_DATA_LEN;	
    828          //	SndBuf[ByteStation++] = 0;	
    829          //	SndBuf[ByteStation++] = DEVICE_CODE_FLG;	
    830          //	SndBuf[ByteStation++] = ID_NUM;
    831          //	
    832          //	memcpy(&SndBuf[ByteStation],DataBuf,DataLen);
    833          //	
    834          //	SndBuf[ByteStation+DataLen+0] = Test;			//数据备用起始位置(电能量标志位)
    835          //	SndBuf[ByteStation+DataLen+1] = CheckNum;
    836          //	
    837          //	Crc16 = GetCrc16Check(&SndBuf[1+4],2+DataLen+2);//帧头（1）+帧长度前包字节（4）
    838          //	
    839          //    
    840          //	SndBuf[ByteStation+DataLen+3] = Crc16;
    841          //	SndBuf[ByteStation+DataLen+2] = Crc16>>8;
    842          //	
    843          //    //////////////////////////////////////////////////////////
    844          //	SndBufTmp[0] = SndBuf[0];						//准备数据发送
    845          //    
    846          //	AddHeadNum = 0;
    847          //	for(i = 1; i< ByteStation+DataLen+4;i++ )				//数据，补移位 FRAM_HERD0
    848          //	{
    849          //		
    850          //		if(SndBuf[i] == FRAM_HERD0)					//7c
    851          //		{
    852          //			SndBufTmp[i+AddHeadNum] = HDLC_CODE0;
    853          //			AddHeadNum++;
    854          //			SndBufTmp[i+AddHeadNum] = HDLC_CODE1;
    855          //		}
    856          //		else if(SndBuf[i] == FRAM_END0)				//7e
    857          //		{
    858          //			SndBufTmp[i+AddHeadNum] = HDLC_CODE0;
    859          //			AddHeadNum++;
    860          //			SndBufTmp[i+AddHeadNum] = HDLC_CODE2;
    861          //		}
    862          //		else if(SndBuf[i] == HDLC_CODE0)			//7d		
    863          //		{
    864          //			SndBufTmp[i+AddHeadNum] = HDLC_CODE0;
    865          //			AddHeadNum++;
    866          //			SndBufTmp[i+AddHeadNum] = HDLC_CODE3;
    867          //		}	
    868          //		else
    869          //		{
    870          //			SndBufTmp[i+AddHeadNum] = SndBuf[i];
    871          //		}
    872          //	}
    873          //    
    874          //	SndBufTmp[ByteStation+DataLen+4 +AddHeadNum] = FRAM_END0;
    875          //	
    876          //    RS485_SET_TX_Mode();	
    877          //    RS485_SET_TX_Mode();		
    878          //	SendCOM2(SndBufTmp,ByteStation+DataLen+4 +AddHeadNum + 1);  // 数据标号+1=数据长度
    879          //	RS485_SET_RX_Mode();			
    880          //}
    881          //
    882          //
    883          //#define		BUF_LEN		256
    884          //
    885          //uint8_t	g_NoRs485ComFlg = 0;
    886          ///*----------------------------------------------------------------------------
    887          //名    称：   void  RecTAX2Info(void)
    888          //功    能：   接收TAX2信息。
    889          //入口参数：   无
    890          //出口参数：   无
    891          //---------------------------------------------------------------------------- */
    892          //void  RecRs485(void)
    893          //{
    894          //	static	uint8_t		RecBuf[BUF_LEN] = {0};								//接收缓冲区
    895          //	static	uint8_t		DataBuf[BUF_LEN/2] = {0};								//
    896          //	static	uint8_t		SendEnergyBuf[ENERGY_DATA_LEN] = {0};		
    897          //    
    898          //	static uint8_t	    LifeInfo = 0;
    899          //	uint8_t		        HostCodeFlg;		
    900          //	uint8_t		        CodeType;	
    901          //	uint8_t		        IDNum;	
    902          //	    
    903          //	uint32_t	        RecLen;		
    904          //	uint32_t	        DataLen = 250;
    905          //	
    906          //	uint32_t            S_VOLTAGE;
    907          //	uint32_t            S_CURRENT;
    908          //	int32_t             S_FREQ;
    909          //	int32_t             S_FACTOR;
    910          //    
    911          //    
    912          //	if( GetFramRecEndFlg() == 1)								//有新的帧尾，进行数据处理
    913          //	{
    914          //		printf("\n\r  有新的帧尾，进行数据处理\n");	
    915          //		RecLen 	= ReadRs485Data(RecBuf);
    916          //		
    917          //		ClearFramRecEndFlg();									//清标志，可重新取数
    918          //		
    919          //		if(!RecData(RecBuf,RecLen,DataBuf,DataLen))	{			//接受数据
    920          //            printf("\r\n RS485数据接收失败!");
    921          //		} else {
    922          //			printf("\r\n RS485数据接收成功!");
    923          //            
    924          //			//////////////////////////////对数据解析
    925          //			HostCodeFlg = DataBuf[0];			   //源地址标识
    926          //			IDNum		= DataBuf[1];			   //目的地址标识
    927          //			LifeInfo 	= DataBuf[2];			   //动态识别码
    928          //			CodeType 	= DataBuf[3];			   //命令类型
    929          //			
    930          //			if(	HostCodeFlg == HOST_CODE_FLG 			
    931          //                &&	IDNum	== ID_NUM						
    932          //                &&	CodeType== CODE_TYPE ) {			
    933          //				printf("\r\n 请求数据发送!");
    934          //				g_DipDisVal[0] =  AC.PPpower_NUM & 0xFF;			   //将电量数据转存到缓冲区
    935          //				g_DipDisVal[1] = (AC.PPpower_NUM >> 8) & 0xFF;	   //低字节在前，高字节在后
    936          //				g_DipDisVal[2] = (AC.PPpower_NUM >> 16) & 0xFF;
    937          //				g_DipDisVal[3] = (AC.PPpower_NUM >> 24) & 0xFF;
    938          //                
    939          //				g_DipDisVal[4] =  AC.NPpower_NUM & 0xFF;			   //将电量数据转存到缓冲区
    940          //				g_DipDisVal[5] = (AC.NPpower_NUM >> 8) & 0xFF;	   //低字节在前，高字节在后
    941          //				g_DipDisVal[6] = (AC.NPpower_NUM >> 16) & 0xFF;
    942          //				g_DipDisVal[7] = (AC.NPpower_NUM >> 24) & 0xFF;
    943          //                
    944          //				g_DipDisVal[8] =   AC.PQpower_NUM & 0xFF;			   //将电量数据转存到缓冲区
    945          //				g_DipDisVal[9] =  (AC.PQpower_NUM >> 8) & 0xFF;	   //低字节在前，高字节在后
    946          //				g_DipDisVal[10] = (AC.PQpower_NUM >> 16) & 0xFF;
    947          //				g_DipDisVal[11] = (AC.PQpower_NUM >> 24) & 0xFF;
    948          //                
    949          //				g_DipDisVal[12] =  AC.NQpower_NUM & 0xFF;			   //将电量数据转存到缓冲区
    950          //				g_DipDisVal[13] = (AC.NQpower_NUM >> 8) & 0xFF;	   //低字节在前，高字节在后
    951          //				g_DipDisVal[14] = (AC.NQpower_NUM >> 16) & 0xFF;
    952          //				g_DipDisVal[15] = (AC.NQpower_NUM >> 24) & 0xFF;
    953          //                
    954          //				S_VOLTAGE = AC.U_RMS * 1000;
    955          //				if(S_VOLTAGE < 200)
    956          //					S_VOLTAGE = 0;
    957          //				g_DipDisVal[16] =  S_VOLTAGE & 0xFF;			   //将电量数据转存到缓冲区
    958          //				g_DipDisVal[17] = (S_VOLTAGE >> 8) & 0xFF;	       //低字节在前，高字节在后
    959          //				g_DipDisVal[18] = (S_VOLTAGE >> 16) & 0xFF;
    960          //				g_DipDisVal[19] = (S_VOLTAGE >> 24) & 0xFF;
    961          //                
    962          //				S_CURRENT = AC.I_RMS * 1000;
    963          //				if(S_CURRENT < 100)
    964          //					S_CURRENT = 0;
    965          //				g_DipDisVal[20] =  S_CURRENT & 0xFF;			   //将电量数据转存到缓冲区
    966          //				g_DipDisVal[21] = (S_CURRENT >> 8) & 0xFF;	   //低字节在前，高字节在后
    967          //				g_DipDisVal[22] = (S_CURRENT >> 16) & 0xFF;
    968          //				g_DipDisVal[23] = (S_CURRENT >> 24) & 0xFF;
    969          //                
    970          //				S_FREQ = AC.Power_Freq * 1000;
    971          //				g_DipDisVal[24] =  S_FREQ & 0xFF;			//将频率数据转存到缓冲区
    972          //				g_DipDisVal[25] = (S_FREQ >> 8) & 0xFF;	   //低字节在前，高字节在后
    973          //				g_DipDisVal[26] = (S_FREQ >> 16) & 0xFF;
    974          //				g_DipDisVal[27] = (S_FREQ >> 24) & 0xFF;
    975          //                
    976          //				S_FACTOR = AC.Power_Factor * 1000;
    977          //				g_DipDisVal[28] =  S_FACTOR & 0xFF;			   //将电量数据转存到缓冲区
    978          //				g_DipDisVal[29] = (S_FACTOR >> 8) & 0xFF;	   //低字节在前，高字节在后
    979          //				g_DipDisVal[30] = (S_FACTOR >> 16) & 0xFF;
    980          //				g_DipDisVal[31] = (S_FACTOR >> 24) & 0xFF;
    981          //                
    982          //				g_DipDisVal[32] =  AC.ACTIVE_POWER & 0xFF;			   //将电量数据转存到缓冲区
    983          //				g_DipDisVal[33] = (AC.ACTIVE_POWER >> 8) & 0xFF;	   //低字节在前，高字节在后
    984          //				g_DipDisVal[34] = (AC.ACTIVE_POWER >> 16) & 0xFF;
    985          //				g_DipDisVal[35] = (AC.ACTIVE_POWER >> 24) & 0xFF;
    986          //                
    987          //				g_DipDisVal[36] =  AC.REACTIVE_POWER & 0xFF;			   //将电量数据转存到缓冲区
    988          //				g_DipDisVal[37] = (AC.REACTIVE_POWER >> 8) & 0xFF;	   //低字节在前，高字节在后
    989          //				g_DipDisVal[38] = (AC.REACTIVE_POWER >> 16) & 0xFF;
    990          //				g_DipDisVal[39] = (AC.REACTIVE_POWER >> 24) & 0xFF;
    991          //				
    992          //				memcpy(&SendEnergyBuf[0],(uint8_t *)&g_DipDisVal,sizeof(g_DipDisVal));
    993          //				
    994          //				Sendrs485(SendEnergyBuf,sizeof(SendEnergyBuf),LifeInfo);	//发送数据			
    995          //				
    996          //				g_NoRs485ComFlg = 0;								//置通讯标志	通讯成功 
    997          //			}
    998          //            
    999          //		}
   1000          //        
   1001          //	}
   1002          //}
   1003          
   1004          
   1005          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RS485_DIR_Config
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
       0   RS485_SET_RX_Mode
         0   -> GPIO_ResetBits
       0   RS485_SET_TX_Mode
         0   -> GPIO_SetBits
      16   SendCOM2
        16   -> RS485_SET_RX_Mode
        16   -> USART_GetFlagStatus
        16   -> putchar
        16   -> xUSART2_putchar
      16   put_dump
        16   -> xprintf
         0   -> xputc
        16   -> xputc
      24   xPrintf_Init
        24   -> RS485_DIR_Config
        24   -> SystemCoreClockUpdate
        24   -> __SZ_STM32_COMInit
       8   xUSART1_ValidInput
         8   -> USART_GetFlagStatus
       8   xUSART1_getchar
         8   -> USART_GetFlagStatus
      16   xUSART1_putchar
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
       8   xUSART2_ValidInput
         8   -> USART_GetFlagStatus
       8   xUSART2_getchar
         8   -> USART_GetFlagStatus
      16   xUSART2_putchar
        16   -> Delay
        16   -> RS485_SET_RX_Mode
        16   -> RS485_SET_TX_Mode
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
       8   xatoi
      16   xfgets
        16   -> xgets
      24   xfprintf
        24   -> xvprintf
      16   xfputs
        16   -> xputc
      24   xgets
        24   -- Indirect call
        24   -> xputc
      16   xgets_nowait
        16   -> xUSART2_ValidInput
        16   -> xUSART2_getchar
        16   -> xUSART2_putchar
      16   xprintf
        16   -> xvprintf
       0   xputc
         0   -- Indirect call
       8   xputs
         8   -> xputc
      16   xsprintf
        16   -> xvprintf
      56   xvprintf
        56   -> xputc
        56   -> xputs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
      40  RS485_DIR_Config
      10  RS485_SET_RX_Mode
      10  RS485_SET_TX_Mode
      58  SendCOM2
       4  bytes_read
     126  put_dump
      60  xPrintf_Init
      20  xUSART1_ValidInput
      22  xUSART1_getchar
      32  xUSART1_putchar
      20  xUSART2_ValidInput
      22  xUSART2_getchar
      52  xUSART2_putchar
     174  xatoi
      22  xfgets
      28  xfprintf
      32  xfputs
      12  xfunc_out
          outptr
          xfunc_in
      84  xgets
     116  xgets_nowait
      14  xprintf
      30  xputc
      22  xputs
      32  xsprintf
     432  xvprintf

 
    16 bytes in section .bss
 1 510 bytes in section .text
 
 1 510 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
