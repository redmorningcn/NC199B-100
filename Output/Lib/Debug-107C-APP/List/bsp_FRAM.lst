###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  20:53:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_FRAM.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_FRAM.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -D DEBUG -D IMAGE_A -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\List\bsp_FRAM.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-107C-APP\Obj\bsp_FRAM.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\BSP\Driver\bsp_FRAM.c
      1          /*******************************************************************************
      2           *   Revised:       $Date: 2017-05-15$
      3           *   Revision:      $
      4           *   Writer:	    redmorningcn.
      5           *
      6           *   Description:
      7           *   Notes:
      8           *     				E-mail:redmorningcn@qq.com
      9           *
     10           *   All copyrights reserved to redmorningcn.
     11           *
     12           *******************************************************************************/
     13          
     14          /*******************************************************************************
     15          * INCLUDES
     16          */
     17          #include <includes.h>
     18          #include "bsp_FRAM.h"
     19          
     20          
     21          
     22          /***********************************************
     23          * 描述: OS接口
     24          */
     25          #if UCOS_EN     == DEF_ENABLED
     26              #if OS_VERSION > 30000U
     27          //    static  OS_SEM			Bsp_Fram_Sem;    	//信号量
     28              #else
     29              static  OS_EVENT		*Bsp_Fram_Sem;    //信号量
     30              #endif
     31          #endif
     32              
     33          
     34          #if (UCOS_EN     == DEF_ENABLED)
     35          /*******************************************************************************
     36          * 名    称： 		FRAM_WaitEvent
     37          * 功    能： 		等待信号量
     38          * 入口参数： 	无
     39          * 出口参数：  	0（操作有误），1（操作成功）
     40          * 作　 　者： 	redmorningcn
     41          * 创建日期： 	2017-05-15
     42          * 修    改：
     43          * 修改日期：
     44          * 备    注： 仅在使用UCOS操作系统时使用
     45          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     46          static uint8_t FRAM_WaitEvent(void)
     47          {
     48              /***********************************************
     49              * 描述： OS接口
     50              */
     51          
     52          //#if OS_VERSION > 30000U
     53          //    return BSP_OS_SemWait(&Bsp_Fram_Sem,0);           	// 等待信号量
     54          //#else
     55          //    uint8_t       err;
     56          //    OSSemPend(Bsp_Fram_Sem,0,&err);                   		// 等待信号量
     57          //    if ( err = OS_ERR_NONE )
     58          //      return TRUE;
     59          //    else
     60          //      return FALSE;
     61          //#endif
     62              return 1;
   \                     FRAM_WaitEvent: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     63          }
     64          
     65          /*******************************************************************************
     66          * 名    称：	 	FRAM_SendEvent
     67          * 功    能： 		释放信号量
     68          * 入口参数： 	无
     69          * 出口参数： 	无
     70          * 作　 　者： 	redmorningcn
     71          * 创建日期： 	2017-05-15
     72          * 修    改：
     73          * 修改日期：
     74          * 备    注： 仅在使用UCOS操作系统时使用
     75          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     76          static void FRAM_SendEvent(void)
     77          {
     78          //    /***********************************************
     79          //    * 描述： OS接口
     80          //    */
     81          //#if OS_VERSION > 30000U
     82          //    BSP_OS_SemPost(&Bsp_Fram_Sem);                        	// 发送信号量
     83          //#else
     84          //    uint8_t       err;
     85          //    OSSemPost(Bsp_Fram_Sem);                             		 // 发送信号量
     86          //#endif
     87          }
   \                     FRAM_SendEvent: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     88          
     89          #endif /* end of (UCOS_EN     == DEF_ENABLED)*/
     90          
     91          
     92          //-------------------------------------------------------------------------------------------------------
     93          //函数名称: 		WriteFM24CL16()
     94          //功    能:			对FM24CL16指定地址进行写数据
     95          //入口参数:         ADDR:       操作地址    地址：0 ~ sizeof(FM24CL16)
     96          //                  		*DataBuf:   数据缓冲
     97          //                  Len: 	数据长度
     98          //作　 　者： 	redmorningcn
     99          //创建日期： 	2017-05-15
    100          //出口参数:    	无
    101          //说明：            
    102          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    103          uint8 WriteFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen)            
    104          {
   \                     WriteFM24CL64: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    105              uint32  i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    106              uint8   SlaveAddr;                                      //从机地址
    107              uint16  AddrTemp = 0;                                   //地址缓存
    108              
    109              AddrTemp = Addr;
    110              AddrTemp += FRAM_START_ADDR;                            //计算地址
    111          
    112              if( (uint16)AddrTemp + DataBufLen > FRAM_END_ADDR ) 
   \   0000000A   0x1930             ADDS     R0,R6,R4
   \   0000000C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000010   0xD901             BLS.N    ??WriteFM24CL64_0
    113              {
    114                  return  FALSE;                                      			//地址未超阶
   \   00000012   0x4638             MOV      R0,R7
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    115              }
    116                  
    117              SlaveAddr = FRAM_DIVICE_ADDR & (~(0x01));               //求FM24CL64设备写地址
    118              
    119              StartI2C();                                             //启动IIC总线
   \                     ??WriteFM24CL64_0: (+1)
   \   00000016   0x.... 0x....      BL       StartI2C
    120              
    121              WriteByteWithI2C(SlaveAddr);                            //写FM24CL64地址
   \   0000001A   0x20A0             MOVS     R0,#+160
   \   0000001C   0x.... 0x....      BL       WriteByteWithI2C
    122              CheckSlaveAckI2C();
   \   00000020   0x.... 0x....      BL       CheckSlaveAckI2C
    123           
    124              WriteByteWithI2C(Addr >> 8);                            //写FM24CL64高位地址
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x0A00             LSRS     R0,R0,#+8
   \   00000028   0x.... 0x....      BL       WriteByteWithI2C
    125              CheckSlaveAckI2C();
   \   0000002C   0x.... 0x....      BL       CheckSlaveAckI2C
    126              
    127              WriteByteWithI2C( Addr );                               //写FM24CL64低位地址
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x.... 0x....      BL       WriteByteWithI2C
    128              CheckSlaveAckI2C();     
   \   00000038   0x.... 0x....      BL       CheckSlaveAckI2C
    129            
    130              for(i = 0; i < DataBufLen; i++)                         //发送数据
   \   0000003C   0xE005             B.N      ??WriteFM24CL64_1
    131              {
    132                  WriteByteWithI2C(DataBuf[i]);                       //写数据
   \                     ??WriteFM24CL64_2: (+1)
   \   0000003E   0x5D78             LDRB     R0,[R7, R5]
   \   00000040   0x.... 0x....      BL       WriteByteWithI2C
    133                  CheckSlaveAckI2C();                                 //读从机应答信号
   \   00000044   0x.... 0x....      BL       CheckSlaveAckI2C
    134              }
   \   00000048   0x1C7F             ADDS     R7,R7,#+1
   \                     ??WriteFM24CL64_1: (+1)
   \   0000004A   0x42B7             CMP      R7,R6
   \   0000004C   0xD3F7             BCC.N    ??WriteFM24CL64_2
    135              
    136              StopI2C();                                              //停止IIC操作   
   \   0000004E   0x.... 0x....      BL       StopI2C
    137              
    138              return  TRUE;                                           //正确
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    139          }
    140          
    141          //-------------------------------------------------------------------------------------------------------
    142          //函数名称:         ReadFM24CL16()
    143          //功    能:         读取FM24CL16指定地址进行数据
    144          //入口参数:         ADDR:       操作地址   地址：0 ~ sizeof(FM24CL16)
    145          //                  *DataBuf:   数据缓冲 
    146          //                  Len:        数据长度
    147          //出口参数:         无
    148          //作　 　者： 	redmorningcn
    149          //创建日期： 	2017-05-15
    150          //说明：            
    151          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    152          uint8 ReadFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen)            
    153          {
   \                     ReadFM24CL64: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    154              uint32  i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    155              uint8   SlaveAddr;                                      //从机地址
    156              uint16  AddrTemp;                                       //地址缓存
    157              
    158              AddrTemp = Addr;
    159              
    160              AddrTemp += FRAM_START_ADDR;                            //计算地址
    161              
    162              if( (uint16)AddrTemp + DataBufLen > FRAM_END_ADDR ) 
   \   0000000A   0x1930             ADDS     R0,R6,R4
   \   0000000C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000010   0xD901             BLS.N    ??ReadFM24CL64_0
    163              {
    164                  return  FALSE;                                      //地址未超阶
   \   00000012   0x4638             MOV      R0,R7
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    165              }
    166              
    167              SlaveAddr = FRAM_DIVICE_ADDR & (~(0x01));               //求FM24CL64设备写地址
    168              
    169              StartI2C();                                             //启动IIC总线
   \                     ??ReadFM24CL64_0: (+1)
   \   00000016   0x.... 0x....      BL       StartI2C
    170              
    171              WriteByteWithI2C(SlaveAddr);                            //写FM24CL64设备写地址
   \   0000001A   0x20A0             MOVS     R0,#+160
   \   0000001C   0x.... 0x....      BL       WriteByteWithI2C
    172              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000020   0x.... 0x....      BL       CheckSlaveAckI2C
    173              
    174              WriteByteWithI2C(Addr >> 8 );                           //写数据高位地址
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x0A00             LSRS     R0,R0,#+8
   \   00000028   0x.... 0x....      BL       WriteByteWithI2C
    175              CheckSlaveAckI2C();                                     //读从机应答信号
   \   0000002C   0x.... 0x....      BL       CheckSlaveAckI2C
    176              
    177              WriteByteWithI2C( Addr );                               //写数据低位地址
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x.... 0x....      BL       WriteByteWithI2C
    178              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000038   0x.... 0x....      BL       CheckSlaveAckI2C
    179                  
    180              SlaveAddr = (FRAM_DIVICE_ADDR)|(0x01);                  //求FM24CL64设备读地址
    181              
    182              StartI2C();                                             //启动IIC总线
   \   0000003C   0x.... 0x....      BL       StartI2C
    183              
    184              WriteByteWithI2C(SlaveAddr);                            //写FM24CL16地址
   \   00000040   0x20A1             MOVS     R0,#+161
   \   00000042   0x.... 0x....      BL       WriteByteWithI2C
    185              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000046   0x.... 0x....      BL       CheckSlaveAckI2C
    186             
    187              for(i = 0; i < (DataBufLen -1); i++)                    //发送数据
   \   0000004A   0xE005             B.N      ??ReadFM24CL64_1
    188              {
    189                  DataBuf[i] = ReadByteWithI2C();                     //写数据
   \                     ??ReadFM24CL64_2: (+1)
   \   0000004C   0x.... 0x....      BL       ReadByteWithI2C
   \   00000050   0x5578             STRB     R0,[R7, R5]
    190                  MasterAckI2C();                                     //主机应答从机
   \   00000052   0x.... 0x....      BL       MasterAckI2C
    191              }
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
   \                     ??ReadFM24CL64_1: (+1)
   \   00000058   0x1E70             SUBS     R0,R6,#+1
   \   0000005A   0x4287             CMP      R7,R0
   \   0000005C   0xD3F6             BCC.N    ??ReadFM24CL64_2
    192              DataBuf[i] = ReadByteWithI2C();                         //写数据
   \   0000005E   0x.... 0x....      BL       ReadByteWithI2C
   \   00000062   0x5578             STRB     R0,[R7, R5]
    193              
    194              MasterNoAckI2C();                                       //主机应答从机
   \   00000064   0x.... 0x....      BL       MasterNoAckI2C
    195              
    196              StopI2C();
   \   00000068   0x.... 0x....      BL       StopI2C
    197              
    198              return  TRUE;                                           //正确
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    199          }
    200          
    201          
    202          //  RecNumMgr
    203          //
    204          //-------------------------------------------------------------------------------------------------------
    205          //函数名称	:       FRAM_StoreRecNumMgr()
    206          //功    		能	:       存储数据记录管理地址
    207          //入口参数	:       待存储的数据记录指针
    208          //出口参数  :       成功TURE，失败FALSE
    209          //作　 　者： 	redmorningcn
    210          //创建日期： 	2017-05-15
    211          //说		 明：            
    212          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    213          uint8 FRAM_StoreRecNumMgr(stcRecNumMgr  *SRecNumMgr)
    214          {
   \                     FRAM_StoreRecNumMgr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    215          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    216          	
    217          //	FRAM_WaitEvent();
    218              
    219              CPU_SR  cpu_sr;
    220          CPU_CRITICAL_ENTER() ;
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x4606             MOV      R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    221          	if(!WriteFM24CL64(FRAM_RECNUM_MGR_ADDR, (uint8 *)SRecNumMgr, sizeof(stcRecNumMgr)))		//存数据管理
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x.... 0x....      BL       WriteFM24CL64
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD100             BNE.N    ??FRAM_StoreRecNumMgr_0
    222          		flg = FALSE;
   \   0000001E   0x2500             MOVS     R5,#+0
    223          CPU_CRITICAL_EXIT();
   \                     ??FRAM_StoreRecNumMgr_0: (+1)
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
    224          //	FRAM_SendEvent();
    225          	return	flg;
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    226          }
    227          
    228          
    229          //-------------------------------------------------------------------------------------------------------
    230          //函数名称	:      FRAM_ReadRecNumMgr()
    231          //功    		能	:      读数据记录管理指令
    232          //入口参数	:      待读取的数据记录的储存位置
    233          //出口参数  :      成功TURE，失败FALSE
    234          //作　 　者 ： 	redmorningcn
    235          //创建日期  ： 	2017-05-15
    236          //说		 明：  
    237          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    238          uint8 FRAM_ReadRecNumMgr(stcRecNumMgr  *SRecNumMgr)
    239          {
   \                     FRAM_ReadRecNumMgr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    240          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    241          	
    242          //	FRAM_WaitEvent();
    243              
    244              CPU_SR  cpu_sr;
    245          CPU_CRITICAL_ENTER() ;
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x4606             MOV      R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    246          	if(!ReadFM24CL64(FRAM_RECNUM_MGR_ADDR, (uint8 *)SRecNumMgr, sizeof(stcRecNumMgr)))		//读数据管理
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x.... 0x....      BL       ReadFM24CL64
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD100             BNE.N    ??FRAM_ReadRecNumMgr_0
    247          		flg = FALSE;
   \   0000001E   0x2500             MOVS     R5,#+0
    248          CPU_CRITICAL_EXIT();	
   \                     ??FRAM_ReadRecNumMgr_0: (+1)
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
    249          //	FRAM_SendEvent();
    250          	return	flg;
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    251          }
    252          
    253          //  ProductInfo
    254          //
    255          //-------------------------------------------------------------------------------------------------------
    256          //函数名称:       FRAM_StoreProductInfo()
    257          //功    能:       存产品信息
    258          //入口参数:      
    259          //出口参数:       
    260          //作　 　者： 	    redmorningcn
    261          //创建日期： 	    2017-05-15
    262          //说		 明：            
    263          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    264          uint8 FRAM_StoreProductInfo(stcProductInfo  *sProductInfo)
    265          {
   \                     FRAM_StoreProductInfo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    266          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    267          	
    268          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    269          	if(!WriteFM24CL64(FRAM_PRODUCT_INFO_ADDR, (uint8 *)sProductInfo, sizeof(stcProductInfo)))		
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x2014             MOVS     R0,#+20
   \   00000010   0x.... 0x....      BL       WriteFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD100             BNE.N    ??FRAM_StoreProductInfo_0
    270          		flg = FALSE;
   \   00000018   0x2500             MOVS     R5,#+0
    271          	
    272          	FRAM_SendEvent();
   \                     ??FRAM_StoreProductInfo_0: (+1)
   \   0000001A   0x.... 0x....      BL       FRAM_SendEvent
    273          	return	flg;
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    274          }
    275          
    276          //-------------------------------------------------------------------------------------------------------
    277          //函数名称	:      FRAM_ReadProductInfo()
    278          //功    		能	:      读产品信息
    279          //入口参数	:      产品的
    280          //出口参数  :       
    281          //作　 　者 ： 	redmorningcn
    282          //创建日期  ： 	2017-05-15
    283          //说		 明：  
    284          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    285          uint8 FRAM_ReadProductInfo(stcProductInfo  *sProductInfo)
    286          {
   \                     FRAM_ReadProductInfo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    287          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    288          	
    289          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    290          	if(!ReadFM24CL64(FRAM_PRODUCT_INFO_ADDR, (uint8 *)sProductInfo, sizeof(stcProductInfo)))		
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x2014             MOVS     R0,#+20
   \   00000010   0x.... 0x....      BL       ReadFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD100             BNE.N    ??FRAM_ReadProductInfo_0
    291          		flg = FALSE;
   \   00000018   0x2500             MOVS     R5,#+0
    292          	
    293          	FRAM_SendEvent();
   \                     ??FRAM_ReadProductInfo_0: (+1)
   \   0000001A   0x.... 0x....      BL       FRAM_SendEvent
    294          	return	flg;
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    295          }
    296          
    297          
    298          
    299          //  currecord
    300          //
    301          //-------------------------------------------------------------------------------------------------------
    302          //函数名称	:      FRAM_StoreCurRecord()
    303          //功    		能	:      存当前记录的 
    304          //入口参数	:      
    305          //出口参数  :       
    306          //作　 　者 ： 	redmorningcn
    307          //创建日期  ： 	2017-05-15
    308          //说		 明：            
    309          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    310          uint8 FRAM_StoreCurRecord(stcFlshRec  *sFlshRec)
    311          {
   \                     FRAM_StoreCurRecord: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    312          	uint8	flg = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
    313          	
    314          	//FRAM_WaitEvent();
    315          	if(!WriteFM24CL64(FRAM_REC_ADDR, (uint8 *)sFlshRec, sizeof(stcFlshRec)))		
   \   00000004   0x2280             MOVS     R2,#+128
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x.... 0x....      BL       WriteFM24CL64
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE.N    ??FRAM_StoreCurRecord_0
    316          		flg = FALSE;
   \   00000012   0x2400             MOVS     R4,#+0
    317          	
    318          	//FRAM_SendEvent();
    319          	return	flg;
   \                     ??FRAM_StoreCurRecord_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    320          }
    321          
    322          //-------------------------------------------------------------------------------------------------------
    323          //函数名称	:      FRAM_ReadProductInfo()
    324          //功    		能	:      读当前记录的 
    325          //入口参数	:      产品的
    326          //出口参数  :       
    327          //作　 　者 ： 	redmorningcn
    328          //创建日期  ： 	2017-05-15
    329          //说		 明：  
    330          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    331          uint8 FRAM_ReadCurRecord(stcFlshRec  *sFlshRec)
    332          {
   \                     FRAM_ReadCurRecord: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    333          	uint8	flg = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
    334          	
    335          	//FRAM_WaitEvent();
    336          	if(!ReadFM24CL64(FRAM_REC_ADDR, (uint8 *)sFlshRec, sizeof(stcFlshRec)))		
   \   00000004   0x2280             MOVS     R2,#+128
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x.... 0x....      BL       ReadFM24CL64
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE.N    ??FRAM_ReadCurRecord_0
    337          		flg = FALSE;
   \   00000012   0x2400             MOVS     R4,#+0
    338          	
    339          	//FRAM_SendEvent();
    340          	return	flg;
   \                     ??FRAM_ReadCurRecord_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    341          }
    342          
    343          //  oilpara
    344          //
    345          //-------------------------------------------------------------------------------------------------------
    346          //函数名称	:      FRAM_StoreOilPara()
    347          //功    		能	:      
    348          //入口参数	:      
    349          //出口参数  :       
    350          //作　 　者 ： 	redmorningcn
    351          //创建日期  ： 	2017-05-15
    352          //说		 明：            
    353          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    354          uint8 FRAM_StoreAirPara(stcAirPara  *sAir)
    355          {
   \                     FRAM_StoreAirPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    356          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    357          	
    358          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    359          	if(!WriteFM24CL64(FRAM_AIR_PARA_ADDR, (uint8 *)sAir, sizeof(stcAirPara)))		
   \   0000000A   0x2228             MOVS     R2,#+40
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x20A0             MOVS     R0,#+160
   \   00000010   0x.... 0x....      BL       WriteFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD100             BNE.N    ??FRAM_StoreAirPara_0
    360          		flg = FALSE;
   \   00000018   0x2500             MOVS     R5,#+0
    361          	
    362          	FRAM_SendEvent();
   \                     ??FRAM_StoreAirPara_0: (+1)
   \   0000001A   0x.... 0x....      BL       FRAM_SendEvent
    363          	return	flg;
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    364          }
    365          
    366          //-------------------------------------------------------------------------------------------------------
    367          //函数名称	:      FRAM_ReadOilPara()
    368          //功    		能	:      
    369          //入口参数	:     
    370          //出口参数  :       
    371          //作　 　者 ： 	redmorningcn
    372          //创建日期  ： 	2017-05-15
    373          //说		 明：  
    374          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    375          uint8 FRAM_ReadAirPara(stcAirPara  *sAir)
    376          {
   \                     FRAM_ReadAirPara: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x4604             MOV      R4,R0
    377          	uint8	flg = TRUE;
    378          	stcAirPara  sAirTmp;
    379              
    380              
    381          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    382             
    383          //	if(!ReadFM24CL64(FRAM_AIR_PARA_ADDR, (uint8 *)sAir, sizeof(stcAirPara)))		
    384          //		flg = FALSE;
    385              //数据有效性判断
    386              if(ReadFM24CL64(FRAM_AIR_PARA_ADDR, (uint8 *)&sAirTmp, sizeof(stcAirPara)))
   \   0000000A   0x2228             MOVS     R2,#+40
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x20A0             MOVS     R0,#+160
   \   00000010   0x.... 0x....      BL       ReadFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD026             BEQ.N    ??FRAM_ReadAirPara_0
    387              {
    388                  if(         sAirTmp.sStandard_Dust.GoodLimit    == 0 
    389                         ||   sAirTmp.sStandard_Dust.NormalLimit  == 0
    390                         ||   sAirTmp.sStandard_Dust.NormalLimit <= sAirTmp.sStandard_Dust.GoodLimit 
    391                     )
   \   00000018   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD01B             BEQ.N    ??FRAM_ReadAirPara_1
   \   00000020   0xF8BD 0x100A      LDRH     R1,[SP, #+10]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD017             BEQ.N    ??FRAM_ReadAirPara_1
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD215             BCS.N    ??FRAM_ReadAirPara_1
    392                      return 0;
    393                  
    394                  if(         sAirTmp.sStandard_VOC.GoodLimit    == 0 
    395                         ||   sAirTmp.sStandard_VOC.NormalLimit  == 0
    396                         ||   sAirTmp.sStandard_VOC.NormalLimit <= sAirTmp.sStandard_VOC.GoodLimit 
    397                      )
   \   0000002C   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD011             BEQ.N    ??FRAM_ReadAirPara_1
   \   00000034   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD00D             BEQ.N    ??FRAM_ReadAirPara_1
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD20B             BCS.N    ??FRAM_ReadAirPara_1
    398                      return 0;     
    399                  
    400                  if(         sAirTmp.sStandard_Hum.GoodLimit    == 0 
    401                         ||   sAirTmp.sStandard_Hum.NormalLimit  == 0
    402                         ||   sAirTmp.sStandard_Hum.NormalLimit <= sAirTmp.sStandard_Hum.GoodLimit 
    403                      )
   \   00000040   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD007             BEQ.N    ??FRAM_ReadAirPara_1
   \   00000048   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD003             BEQ.N    ??FRAM_ReadAirPara_1
   \   00000050   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000054   0x4281             CMP      R1,R0
   \   00000056   0xD301             BCC.N    ??FRAM_ReadAirPara_2
    404                      return 0;
   \                     ??FRAM_ReadAirPara_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE007             B.N      ??FRAM_ReadAirPara_3
    405                  
    406                  memcpy((uint8 *)sAir,(uint8 *)&sAirTmp,sizeof(stcAirPara));         //数据有效，退出
   \                     ??FRAM_ReadAirPara_2: (+1)
   \   0000005C   0x2228             MOVS     R2,#+40
   \   0000005E   0x4669             MOV      R1,SP
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy
    407              }
    408          
    409          	FRAM_SendEvent();
   \                     ??FRAM_ReadAirPara_0: (+1)
   \   00000066   0x.... 0x....      BL       FRAM_SendEvent
    410          	return	flg;
   \   0000006A   0x2001             MOVS     R0,#+1
   \                     ??FRAM_ReadAirPara_3: (+1)
   \   0000006C   0xB00A             ADD      SP,SP,#+40
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    411          }
    412          
    413          
    414          //  runpara
    415          //
    416          //-------------------------------------------------------------------------------------------------------
    417          //函数名称	:      FRAM_StoreRunPara()
    418          //功    		能	:      
    419          //入口参数	:      
    420          //出口参数  :       
    421          //作　 　者 ： 	redmorningcn
    422          //创建日期  ： 	2017-05-15
    423          //说		 明：            
    424          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    425          uint8 FRAM_StoreRunPara(stcRunPara  *sRunPara)
    426          {
   \                     FRAM_StoreRunPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    427          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    428          	
    429          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    430          	
    431          	if(!WriteFM24CL64(FRAM_RUN_PARA_ADDR, (uint8 *)sRunPara, sizeof(stcRunPara)))		
   \   0000000A   0x2228             MOVS     R2,#+40
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x20C8             MOVS     R0,#+200
   \   00000010   0x.... 0x....      BL       WriteFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD100             BNE.N    ??FRAM_StoreRunPara_0
    432          		flg = FALSE;
   \   00000018   0x2500             MOVS     R5,#+0
    433          	
    434          	FRAM_SendEvent();
   \                     ??FRAM_StoreRunPara_0: (+1)
   \   0000001A   0x.... 0x....      BL       FRAM_SendEvent
    435          	return	flg;
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    436          }
    437          
    438          //-------------------------------------------------------------------------------------------------------
    439          //函数名称	:      FRAM_ReadRunPara()
    440          //功    		能	:      
    441          //入口参数	:     
    442          //出口参数  :       
    443          //作　 　者 ： 	redmorningcn
    444          //创建日期  ： 	2017-05-15
    445          //说		 明：  
    446          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    447          uint8 FRAM_ReadRunPara(stcRunPara  *sRunPara)
    448          {
   \                     FRAM_ReadRunPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    449          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    450          	
    451          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    452          	
    453          	if(!ReadFM24CL64(FRAM_RUN_PARA_ADDR, (uint8 *)sRunPara, sizeof(stcRunPara)))		
   \   0000000A   0x2228             MOVS     R2,#+40
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x20C8             MOVS     R0,#+200
   \   00000010   0x.... 0x....      BL       ReadFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD100             BNE.N    ??FRAM_ReadRunPara_0
    454          		flg = FALSE;
   \   00000018   0x2500             MOVS     R5,#+0
    455          	
    456          	FRAM_SendEvent();
   \                     ??FRAM_ReadRunPara_0: (+1)
   \   0000001A   0x.... 0x....      BL       FRAM_SendEvent
    457          	return	flg;
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    458          }
    459          
    460          
    461          //#endif
    462              

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   FRAM_ReadAirPara
        48   -> FRAM_SendEvent
        48   -> FRAM_WaitEvent
        48   -> ReadFM24CL64
        48   -> __aeabi_memcpy
       8   FRAM_ReadCurRecord
         8   -> ReadFM24CL64
      16   FRAM_ReadProductInfo
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> ReadFM24CL64
      16   FRAM_ReadRecNumMgr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> ReadFM24CL64
      16   FRAM_ReadRunPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> ReadFM24CL64
       0   FRAM_SendEvent
      16   FRAM_StoreAirPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
       8   FRAM_StoreCurRecord
         8   -> WriteFM24CL64
      16   FRAM_StoreProductInfo
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
      16   FRAM_StoreRecNumMgr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> WriteFM24CL64
      16   FRAM_StoreRunPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
       0   FRAM_WaitEvent
      24   ReadFM24CL64
        24   -> CheckSlaveAckI2C
        24   -> MasterAckI2C
        24   -> MasterNoAckI2C
        24   -> ReadByteWithI2C
        24   -> StartI2C
        24   -> StopI2C
        24   -> WriteByteWithI2C
      24   WriteFM24CL64
        24   -> CheckSlaveAckI2C
        24   -> StartI2C
        24   -> StopI2C
        24   -> WriteByteWithI2C


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     112  FRAM_ReadAirPara
      24  FRAM_ReadCurRecord
      34  FRAM_ReadProductInfo
      46  FRAM_ReadRecNumMgr
      34  FRAM_ReadRunPara
       2  FRAM_SendEvent
      34  FRAM_StoreAirPara
      24  FRAM_StoreCurRecord
      34  FRAM_StoreProductInfo
      46  FRAM_StoreRecNumMgr
      34  FRAM_StoreRunPara
       4  FRAM_WaitEvent
     112  ReadFM24CL64
      86  WriteFM24CL64

 
 626 bytes in section .text
 
 626 bytes of CODE memory

Errors: none
Warnings: none
