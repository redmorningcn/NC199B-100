###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:47:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_ctr.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_ctr.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\aes_ctr.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\aes_ctr.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_ctr.c
      1          /** crypto/aes/aes_ctr.c -*- mode:C; c-file-style: "eay" -*- */
      2          /** ====================================================================
      3           * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          
     52          #ifndef AES_DEBUG
     53          # ifndef NDEBUG
     54          #  define NDEBUG
     55          # endif
     56          #endif
     57          #include <assert.h>
     58          
     59          #include <aes.h>
     60          #include "aes_locl.h"
     61          
     62          /** NOTE: the IV/counter CTR mode is big-endian.  The rest of the AES code
     63           * is endian-neutral. */
     64          
     65          /** increment counter (128-bit int) by 1 */

   \                                 In section .text, align 2, keep-with-next
     66          static void AES_ctr128_inc(unsigned char *counter) {
     67          	unsigned long c;
     68          
     69          	/** Grab bottom dword of counter and increment */
     70          	c = GETU32(counter + 12);
     71          	c++;	c &= 0xFFFFFFFF;
   \                     AES_ctr128_inc: (+1)
   \   00000000   0x7B01             LDRB     R1,[R0, #+12]
   \   00000002   0x0609             LSLS     R1,R1,#+24
   \   00000004   0x7B42             LDRB     R2,[R0, #+13]
   \   00000006   0x0412             LSLS     R2,R2,#+16
   \   00000008   0x404A             EORS     R2,R2,R1
   \   0000000A   0x7B81             LDRB     R1,[R0, #+14]
   \   0000000C   0x020B             LSLS     R3,R1,#+8
   \   0000000E   0x4053             EORS     R3,R3,R2
   \   00000010   0x7BC1             LDRB     R1,[R0, #+15]
   \   00000012   0x4059             EORS     R1,R1,R3
   \   00000014   0x1C49             ADDS     R1,R1,#+1
     72          	PUTU32(counter + 12, c);
   \   00000016   0x0E0A             LSRS     R2,R1,#+24
   \   00000018   0x7302             STRB     R2,[R0, #+12]
   \   0000001A   0x0C0A             LSRS     R2,R1,#+16
   \   0000001C   0x7342             STRB     R2,[R0, #+13]
   \   0000001E   0x0A0A             LSRS     R2,R1,#+8
   \   00000020   0x7382             STRB     R2,[R0, #+14]
   \   00000022   0x000A             MOVS     R2,R1
   \   00000024   0x73C1             STRB     R1,[R0, #+15]
     73          
     74          	/** if no overflow, we're done */
     75          	if (c)
   \   00000026   0xD139             BNE      ??AES_ctr128_inc_0
     76          		return;
     77          
     78          	/** Grab 1st dword of counter and increment */
     79          	c = GETU32(counter +  8);
     80          	c++;	c &= 0xFFFFFFFF;
   \   00000028   0x7A01             LDRB     R1,[R0, #+8]
   \   0000002A   0x0609             LSLS     R1,R1,#+24
   \   0000002C   0x7A42             LDRB     R2,[R0, #+9]
   \   0000002E   0x0412             LSLS     R2,R2,#+16
   \   00000030   0x404A             EORS     R2,R2,R1
   \   00000032   0x7A81             LDRB     R1,[R0, #+10]
   \   00000034   0x020B             LSLS     R3,R1,#+8
   \   00000036   0x4053             EORS     R3,R3,R2
   \   00000038   0x7AC1             LDRB     R1,[R0, #+11]
   \   0000003A   0x4059             EORS     R1,R1,R3
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
     81          	PUTU32(counter +  8, c);
   \   0000003E   0x0E0A             LSRS     R2,R1,#+24
   \   00000040   0x7202             STRB     R2,[R0, #+8]
   \   00000042   0x0C0A             LSRS     R2,R1,#+16
   \   00000044   0x7242             STRB     R2,[R0, #+9]
   \   00000046   0x0A0A             LSRS     R2,R1,#+8
   \   00000048   0x7282             STRB     R2,[R0, #+10]
   \   0000004A   0x000A             MOVS     R2,R1
   \   0000004C   0x72C1             STRB     R1,[R0, #+11]
     82          
     83          	/** if no overflow, we're done */
     84          	if (c)
   \   0000004E   0xD125             BNE      ??AES_ctr128_inc_0
     85          		return;
     86          
     87          	/** Grab 2nd dword of counter and increment */
     88          	c = GETU32(counter +  4);
     89          	c++;	c &= 0xFFFFFFFF;
   \   00000050   0x7901             LDRB     R1,[R0, #+4]
   \   00000052   0x0609             LSLS     R1,R1,#+24
   \   00000054   0x7942             LDRB     R2,[R0, #+5]
   \   00000056   0x0412             LSLS     R2,R2,#+16
   \   00000058   0x404A             EORS     R2,R2,R1
   \   0000005A   0x7981             LDRB     R1,[R0, #+6]
   \   0000005C   0x020B             LSLS     R3,R1,#+8
   \   0000005E   0x4053             EORS     R3,R3,R2
   \   00000060   0x79C1             LDRB     R1,[R0, #+7]
   \   00000062   0x4059             EORS     R1,R1,R3
   \   00000064   0x1C49             ADDS     R1,R1,#+1
     90          	PUTU32(counter +  4, c);
   \   00000066   0x0E0A             LSRS     R2,R1,#+24
   \   00000068   0x7102             STRB     R2,[R0, #+4]
   \   0000006A   0x0C0A             LSRS     R2,R1,#+16
   \   0000006C   0x7142             STRB     R2,[R0, #+5]
   \   0000006E   0x0A0A             LSRS     R2,R1,#+8
   \   00000070   0x7182             STRB     R2,[R0, #+6]
   \   00000072   0x000A             MOVS     R2,R1
   \   00000074   0x71C1             STRB     R1,[R0, #+7]
     91          
     92          	/** if no overflow, we're done */
     93          	if (c)
   \   00000076   0xD111             BNE      ??AES_ctr128_inc_0
     94          		return;
     95          
     96          	/** Grab top dword of counter and increment */
     97          	c = GETU32(counter +  0);
     98          	c++;	c &= 0xFFFFFFFF;
   \   00000078   0x7801             LDRB     R1,[R0, #+0]
   \   0000007A   0x0609             LSLS     R1,R1,#+24
   \   0000007C   0x7842             LDRB     R2,[R0, #+1]
   \   0000007E   0x0412             LSLS     R2,R2,#+16
   \   00000080   0x404A             EORS     R2,R2,R1
   \   00000082   0x7881             LDRB     R1,[R0, #+2]
   \   00000084   0x020B             LSLS     R3,R1,#+8
   \   00000086   0x4053             EORS     R3,R3,R2
   \   00000088   0x78C1             LDRB     R1,[R0, #+3]
   \   0000008A   0x4059             EORS     R1,R1,R3
   \   0000008C   0x1C49             ADDS     R1,R1,#+1
     99          	PUTU32(counter +  0, c);
   \   0000008E   0x0E0A             LSRS     R2,R1,#+24
   \   00000090   0x7002             STRB     R2,[R0, #+0]
   \   00000092   0x0C0A             LSRS     R2,R1,#+16
   \   00000094   0x7042             STRB     R2,[R0, #+1]
   \   00000096   0x0A0A             LSRS     R2,R1,#+8
   \   00000098   0x7082             STRB     R2,[R0, #+2]
   \   0000009A   0x70C1             STRB     R1,[R0, #+3]
    100          }
   \                     ??AES_ctr128_inc_0: (+1)
   \   0000009C   0x4770             BX       LR               ;; return
    101          
    102          /** The input encrypted as though 128bit counter mode is being
    103           * used.  The extra state information to record how much of the
    104           * 128bit block we have used is contained in *num, and the
    105           * encrypted counter is kept in ecount_buf.  Both *num and
    106           * ecount_buf must be initialised with zeros before the first
    107           * call to AES_ctr128_encrypt().
    108           *
    109           * This algorithm assumes that the counter is in the x lower bits
    110           * of the IV (ivec), and that the application has full control over
    111           * overflow and the rest of the IV.  This implementation takes NO
    112           * responsability for checking that the counter doesn't overflow
    113           * into the rest of the IV when incremented.
    114           */

   \                                 In section .text, align 2, keep-with-next
    115          void AES_ctr128_encrypt(const unsigned char *in, unsigned char *out,
    116          	const unsigned long length, const AES_KEY *key,
    117          	unsigned char ivec[AES_BLOCK_SIZE],
    118          	unsigned char ecount_buf[AES_BLOCK_SIZE],
    119          	unsigned int *num) {
   \                     AES_ctr128_encrypt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000D             MOVS     R5,R1
    120          
    121          	unsigned int n;
    122          	unsigned long l=length;
    123          
    124          	assert(in && out && key && counter && num);
    125          	assert(*num < AES_BLOCK_SIZE);
    126          
    127          	n = *num;
   \   00000006   0x9808             LDR      R0,[SP, #+32]
   \   00000008   0x6804             LDR      R4,[R0, #+0]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD017             BEQ      ??AES_ctr128_encrypt_0
   \   0000000E   0x0017             MOVS     R7,R2
    128          
    129          	while (l--) {
    130          		if (n == 0) {
   \                     ??AES_ctr128_encrypt_1: (+1)
   \   00000010   0x1E7F             SUBS     R7,R7,#+1
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD107             BNE      ??AES_ctr128_encrypt_2
    131          			AES_encrypt(ivec, ecount_buf, key);
   \   00000016   0x9A00             LDR      R2,[SP, #+0]
   \   00000018   0x9907             LDR      R1,[SP, #+28]
   \   0000001A   0x9806             LDR      R0,[SP, #+24]
   \   0000001C   0x.... 0x....      BL       AES_encrypt
    132           			AES_ctr128_inc(ivec);
   \   00000020   0x9806             LDR      R0,[SP, #+24]
   \   00000022   0x.... 0x....      BL       AES_ctr128_inc
    133          		}
    134          		*(out++) = *(in++) ^ ecount_buf[n];
   \                     ??AES_ctr128_encrypt_2: (+1)
   \   00000026   0x7830             LDRB     R0,[R6, #+0]
   \   00000028   0x9907             LDR      R1,[SP, #+28]
   \   0000002A   0x5D09             LDRB     R1,[R1, R4]
   \   0000002C   0x4041             EORS     R1,R1,R0
   \   0000002E   0x7029             STRB     R1,[R5, #+0]
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
    135          		n = (n+1) % AES_BLOCK_SIZE;
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0x0724             LSLS     R4,R4,#+28
   \   00000038   0x0F24             LSRS     R4,R4,#+28
    136          	}
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD1E8             BNE      ??AES_ctr128_encrypt_1
    137          
    138          	*num=n;
   \                     ??AES_ctr128_encrypt_0: (+1)
   \   0000003E   0x9808             LDR      R0,[SP, #+32]
   \   00000040   0x6004             STR      R4,[R0, #+0]
    139          }
   \   00000042   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    140          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   AES_ctr128_encrypt
        24   -> AES_ctr128_inc
        24   -> AES_encrypt
       0   AES_ctr128_inc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  AES_ctr128_encrypt
     158  AES_ctr128_inc

 
 226 bytes in section .text
 
 226 bytes of CODE memory

Errors: none
Warnings: none
