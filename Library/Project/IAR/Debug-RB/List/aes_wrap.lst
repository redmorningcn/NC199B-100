###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_wrap.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_wrap.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\aes_wrap.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\aes_wrap.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\APP\AES\aes_wrap.c
      1          /** crypto/aes/aes_wrap.c */
      2          /** Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
      3           * project.
      4           */
      5          /** ====================================================================
      6           * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions
     10           * are met:
     11           *
     12           * 1. Redistributions of source code must retain the above copyright
     13           *    notice, this list of conditions and the following disclaimer. 
     14           *
     15           * 2. Redistributions in binary form must reproduce the above copyright
     16           *    notice, this list of conditions and the following disclaimer in
     17           *    the documentation and/or other materials provided with the
     18           *    distribution.
     19           *
     20           * 3. All advertising materials mentioning features or use of this
     21           *    software must display the following acknowledgment:
     22           *    "This product includes software developed by the OpenSSL Project
     23           *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
     24           *
     25           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     26           *    endorse or promote products derived from this software without
     27           *    prior written permission. For written permission, please contact
     28           *    licensing@OpenSSL.org.
     29           *
     30           * 5. Products derived from this software may not be called "OpenSSL"
     31           *    nor may "OpenSSL" appear in their names without prior written
     32           *    permission of the OpenSSL Project.
     33           *
     34           * 6. Redistributions of any form whatsoever must retain the following
     35           *    acknowledgment:
     36           *    "This product includes software developed by the OpenSSL Project
     37           *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
     38           *
     39           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     40           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     41           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     42           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     43           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     44           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     45           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     46           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     47           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     48           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     49           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     50           * OF THE POSSIBILITY OF SUCH DAMAGE.
     51           * ====================================================================
     52           */
     53          
     54          #include <aes.h>
     55          

   \                                 In section .text, align 4, keep-with-next
     56          static const unsigned char default_iv[] = {
   \                     default_iv:
   \   00000000   0xA6 0xA6          DC8 166, 166, 166, 166, 166, 166, 166, 166
   \              0xA6 0xA6    
   \              0xA6 0xA6    
   \              0xA6 0xA6    
     57            0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6,
     58          };
     59          

   \                                 In section .text, align 4, keep-with-next
     60          int AES_wrap_key(AES_KEY *key, 
     61                           const unsigned char *iv,
     62                           unsigned char *out,
     63                           const unsigned char *in, 
     64                           unsigned int inlen)
     65          {
   \                     AES_wrap_key: (+1)
   \   00000000   0xB5F5             PUSH     {R0,R2,R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0019             MOVS     R1,R3
     66          	unsigned char *A, B[16], *R;
     67          	unsigned int i, j, t;
     68          	if ((inlen & 0x7) || (inlen < 8))
   \   00000008   0x980C             LDR      R0,[SP, #+48]
   \   0000000A   0x0740             LSLS     R0,R0,#+29
   \   0000000C   0xD102             BNE      ??AES_wrap_key_0
   \   0000000E   0x980C             LDR      R0,[SP, #+48]
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD202             BCS      ??AES_wrap_key_1
     69          		return -1;
   \                     ??AES_wrap_key_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000018   0xE03A             B        ??AES_wrap_key_2
     70          	A = B;
     71          	t = 1;
   \                     ??AES_wrap_key_1: (+1)
   \   0000001A   0x2601             MOVS     R6,#+1
     72          	memcpy(out + 8, in, inlen);
   \   0000001C   0x0002             MOVS     R2,R0
   \   0000001E   0x9806             LDR      R0,[SP, #+24]
   \   00000020   0x3008             ADDS     R0,R0,#+8
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
     73          	if (!iv)
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD101             BNE      ??AES_wrap_key_3
     74          		iv = default_iv;
   \   0000002A   0x46C0             Nop      
   \   0000002C   0x....             ADR.N    R4,default_iv
     75          
     76          	memcpy(A, iv, 8);
   \                     ??AES_wrap_key_3: (+1)
   \   0000002E   0x2208             MOVS     R2,#+8
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0xA801             ADD      R0,SP,#+4
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy
     77          
     78          	for (j = 0; j < 6; j++)
   \   00000038   0x2006             MOVS     R0,#+6
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAF01             ADD      R7,SP,#+4
     79          		{
     80          		R = out + 8;
   \                     ??AES_wrap_key_4: (+1)
   \   0000003E   0x9C06             LDR      R4,[SP, #+24]
   \   00000040   0x3408             ADDS     R4,R4,#+8
     81          		for (i = 0; i < inlen; i += 8, t++, R += 8)
   \   00000042   0x2500             MOVS     R5,#+0
     82          			{
     83          			memcpy(B + 8, R, 8);
   \                     ??AES_wrap_key_5: (+1)
   \   00000044   0x2208             MOVS     R2,#+8
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x3008             ADDS     R0,R0,#+8
   \   0000004C   0x.... 0x....      BL       __aeabi_memcpy
     84          			AES_encrypt(B, B, key);
   \   00000050   0x9A05             LDR      R2,[SP, #+20]
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       AES_encrypt
     85          			A[7] ^= (unsigned char)(t & 0xff);
   \   0000005A   0x79F8             LDRB     R0,[R7, #+7]
   \   0000005C   0x0031             MOVS     R1,R6
   \   0000005E   0x4041             EORS     R1,R1,R0
   \   00000060   0x71F9             STRB     R1,[R7, #+7]
     86          			if (t > 0xff)	
     87          				{
     88          				A[6] ^= (unsigned char)((t & 0xff) >> 8);
     89          				A[5] ^= (unsigned char)((t & 0xff) >> 16);
     90          				A[4] ^= (unsigned char)((t & 0xff) >> 24);
     91          				}
     92          			memcpy(R, B + 8, 8);
   \   00000062   0x2208             MOVS     R2,#+8
   \   00000064   0x0039             MOVS     R1,R7
   \   00000066   0x3108             ADDS     R1,R1,#+8
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       __aeabi_memcpy
     93          			}
   \   0000006E   0x3508             ADDS     R5,R5,#+8
   \   00000070   0x1C76             ADDS     R6,R6,#+1
   \   00000072   0x3408             ADDS     R4,R4,#+8
   \   00000074   0x980C             LDR      R0,[SP, #+48]
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD3E4             BCC      ??AES_wrap_key_5
     94          		}
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x9000             STR      R0,[SP, #+0]
   \   00000080   0xD1DD             BNE      ??AES_wrap_key_4
     95          	memcpy(out, A, 8);
   \   00000082   0x2208             MOVS     R2,#+8
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0x9806             LDR      R0,[SP, #+24]
   \   00000088   0x.... 0x....      BL       __aeabi_memcpy
     96          	return inlen + 8;
   \   0000008C   0x980C             LDR      R0,[SP, #+48]
   \   0000008E   0x3008             ADDS     R0,R0,#+8
   \                     ??AES_wrap_key_2: (+1)
   \   00000090   0xB007             ADD      SP,SP,#+28
   \   00000092   0xBDF0             POP      {R4-R7,PC}       ;; return
     97          	}
     98          

   \                                 In section .text, align 4, keep-with-next
     99          int AES_unwrap_key(AES_KEY *key, 
    100                             const unsigned char *iv,
    101                             unsigned char *out,
    102                             const unsigned char *in, 
    103                             unsigned int inlen)
    104          {
   \                     AES_unwrap_key: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x001D             MOVS     R5,R3
    105          	unsigned char *A, B[16], *R;
    106          	unsigned int i, j, t;
    107          	inlen -= 8;
   \   00000008   0x980E             LDR      R0,[SP, #+56]
   \   0000000A   0x3808             SUBS     R0,R0,#+8
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    108          	if (inlen & 0x7)
   \   0000000E   0x0740             LSLS     R0,R0,#+29
   \   00000010   0xD102             BNE      ??AES_unwrap_key_0
    109          		return -1;
    110          	if (inlen < 8)
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x2808             CMP      R0,#+8
   \   00000016   0xD202             BCS      ??AES_unwrap_key_1
    111          		return -1;
   \                     ??AES_unwrap_key_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000001C   0xE046             B        ??AES_unwrap_key_2
    112          	A = B;
    113          	t =  6 * (inlen >> 3);
   \                     ??AES_unwrap_key_1: (+1)
   \   0000001E   0x08C0             LSRS     R0,R0,#+3
   \   00000020   0x0041             LSLS     R1,R0,#+1
   \   00000022   0x180E             ADDS     R6,R1,R0
   \   00000024   0x0076             LSLS     R6,R6,#+1
    114          	memcpy(A, in, 8);
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xA803             ADD      R0,SP,#+12
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
    115          	memcpy(out, in + 8, inlen);
   \   00000030   0x9A00             LDR      R2,[SP, #+0]
   \   00000032   0x3508             ADDS     R5,R5,#+8
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    116          	for (j = 0; j < 6; j++)
   \   0000003C   0x2006             MOVS     R0,#+6
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x1820             ADDS     R0,R4,R0
   \   00000044   0x3808             SUBS     R0,R0,#+8
   \   00000046   0x9002             STR      R0,[SP, #+8]
   \   00000048   0xAF03             ADD      R7,SP,#+12
    117          		{
    118          		R = out + inlen - 8;
   \                     ??AES_unwrap_key_3: (+1)
   \   0000004A   0x9C02             LDR      R4,[SP, #+8]
    119          		for (i = 0; i < inlen; i += 8, t--, R -= 8)
   \   0000004C   0x2500             MOVS     R5,#+0
    120          			{
    121          			A[7] ^= (unsigned char)(t & 0xff);
   \                     ??AES_unwrap_key_4: (+1)
   \   0000004E   0x79F8             LDRB     R0,[R7, #+7]
   \   00000050   0x0031             MOVS     R1,R6
   \   00000052   0x4041             EORS     R1,R1,R0
   \   00000054   0x71F9             STRB     R1,[R7, #+7]
    122          			if (t > 0xff)	
    123          				{
    124          				A[6] ^= (unsigned char)((t & 0xff) >> 8);
    125          				A[5] ^= (unsigned char)((t & 0xff) >> 16);
    126          				A[4] ^= (unsigned char)((t & 0xff) >> 24);
    127          				}
    128          			memcpy(B + 8, R, 8);
   \   00000056   0x2208             MOVS     R2,#+8
   \   00000058   0x0021             MOVS     R1,R4
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x3008             ADDS     R0,R0,#+8
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy
    129          			AES_decrypt(B, B, key);
   \   00000062   0x9A07             LDR      R2,[SP, #+28]
   \   00000064   0xA903             ADD      R1,SP,#+12
   \   00000066   0xA803             ADD      R0,SP,#+12
   \   00000068   0x.... 0x....      BL       AES_decrypt
    130          			memcpy(R, B + 8, 8);
   \   0000006C   0x2208             MOVS     R2,#+8
   \   0000006E   0x0039             MOVS     R1,R7
   \   00000070   0x3108             ADDS     R1,R1,#+8
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy
    131          			}
   \   00000078   0x3508             ADDS     R5,R5,#+8
   \   0000007A   0x1E76             SUBS     R6,R6,#+1
   \   0000007C   0x3C08             SUBS     R4,R4,#+8
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x4285             CMP      R5,R0
   \   00000082   0xD3E4             BCC      ??AES_unwrap_key_4
    132          		}
   \   00000084   0x9801             LDR      R0,[SP, #+4]
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0xD1DE             BNE      ??AES_unwrap_key_3
    133          	if (!iv)
   \   0000008C   0x9808             LDR      R0,[SP, #+32]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD102             BNE      ??AES_unwrap_key_5
    134          		iv = default_iv;
   \   00000092   0x46C0             Nop      
   \   00000094   0x....             ADR.N    R0,default_iv
   \   00000096   0x9008             STR      R0,[SP, #+32]
    135          	if (memcmp(A, iv, 8))
   \                     ??AES_unwrap_key_5: (+1)
   \   00000098   0x2208             MOVS     R2,#+8
   \   0000009A   0x9908             LDR      R1,[SP, #+32]
   \   0000009C   0xA803             ADD      R0,SP,#+12
   \   0000009E   0x.... 0x....      BL       memcmp
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD001             BEQ      ??AES_unwrap_key_6
    136          		{
    137          		OPENSSL_cleanse(out, inlen);
    138          		return 0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE000             B        ??AES_unwrap_key_2
    139          		}
    140          	return inlen;
   \                     ??AES_unwrap_key_6: (+1)
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
   \                     ??AES_unwrap_key_2: (+1)
   \   000000AC   0xB009             ADD      SP,SP,#+36
   \   000000AE   0xBDF0             POP      {R4-R7,PC}       ;; return
    141          	}
    142          
    143          #ifdef AES_WRAP_TEST
    144          
    145          int AES_wrap_unwrap_test(const unsigned char *kek, 
    146                                   int keybits,
    147                                   const unsigned char *iv,
    148                                   const unsigned char *eout,
    149                                   const unsigned char *key, 
    150                                   int keylen)
    151          {
    152          	unsigned char *otmp = NULL, *ptmp = NULL;
    153          	int r, ret = 0;
    154          	AES_KEY wctx;
    155          	otmp = OPENSSL_malloc(keylen + 8);
    156          	ptmp = OPENSSL_malloc(keylen);
    157          	if (!otmp || !ptmp)
    158          		return 0;
    159          	if (AES_set_encrypt_key(kek, keybits, &wctx))
    160          		goto err;
    161          	r = AES_wrap_key(&wctx, iv, otmp, key, keylen);
    162          	if (r <= 0)
    163          		goto err;
    164          
    165          	if (eout && memcmp(eout, otmp, keylen))
    166          		goto err;
    167          		
    168          	if (AES_set_decrypt_key(kek, keybits, &wctx))
    169          		goto err;
    170          	r = AES_unwrap_key(&wctx, iv, ptmp, otmp, r);
    171          
    172          	if (memcmp(key, ptmp, keylen))
    173          		goto err;
    174          
    175          	ret = 1;
    176          
    177          	err:
    178          	if (otmp)
    179          		OPENSSL_free(otmp);
    180          	if (ptmp)
    181          		OPENSSL_free(ptmp);
    182          
    183          	return ret;
    184          
    185          	}
    186          
    187          
    188          
    189          int main(int argc, char **argv)
    190          {
    191          
    192          static const unsigned char kek[] = {
    193            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    194            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    195            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    196            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    197          };
    198          
    199          static const unsigned char key[] = {
    200            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    201            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    202            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    203            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    204          };
    205          
    206          static const unsigned char e1[] = {
    207            0x1f, 0xa6, 0x8b, 0x0a, 0x81, 0x12, 0xb4, 0x47,
    208            0xae, 0xf3, 0x4b, 0xd8, 0xfb, 0x5a, 0x7b, 0x82,
    209            0x9d, 0x3e, 0x86, 0x23, 0x71, 0xd2, 0xcf, 0xe5
    210          };
    211          
    212          static const unsigned char e2[] = {
    213            0x96, 0x77, 0x8b, 0x25, 0xae, 0x6c, 0xa4, 0x35,
    214            0xf9, 0x2b, 0x5b, 0x97, 0xc0, 0x50, 0xae, 0xd2,
    215            0x46, 0x8a, 0xb8, 0xa1, 0x7a, 0xd8, 0x4e, 0x5d
    216          };
    217          
    218          static const unsigned char e3[] = {
    219            0x64, 0xe8, 0xc3, 0xf9, 0xce, 0x0f, 0x5b, 0xa2,
    220            0x63, 0xe9, 0x77, 0x79, 0x05, 0x81, 0x8a, 0x2a,
    221            0x93, 0xc8, 0x19, 0x1e, 0x7d, 0x6e, 0x8a, 0xe7
    222          };
    223          
    224          static const unsigned char e4[] = {
    225            0x03, 0x1d, 0x33, 0x26, 0x4e, 0x15, 0xd3, 0x32,
    226            0x68, 0xf2, 0x4e, 0xc2, 0x60, 0x74, 0x3e, 0xdc,
    227            0xe1, 0xc6, 0xc7, 0xdd, 0xee, 0x72, 0x5a, 0x93,
    228            0x6b, 0xa8, 0x14, 0x91, 0x5c, 0x67, 0x62, 0xd2
    229          };
    230          
    231          static const unsigned char e5[] = {
    232            0xa8, 0xf9, 0xbc, 0x16, 0x12, 0xc6, 0x8b, 0x3f,
    233            0xf6, 0xe6, 0xf4, 0xfb, 0xe3, 0x0e, 0x71, 0xe4,
    234            0x76, 0x9c, 0x8b, 0x80, 0xa3, 0x2c, 0xb8, 0x95,
    235            0x8c, 0xd5, 0xd1, 0x7d, 0x6b, 0x25, 0x4d, 0xa1
    236          };
    237          
    238          static const unsigned char e6[] = {
    239            0x28, 0xc9, 0xf4, 0x04, 0xc4, 0xb8, 0x10, 0xf4,
    240            0xcb, 0xcc, 0xb3, 0x5c, 0xfb, 0x87, 0xf8, 0x26,
    241            0x3f, 0x57, 0x86, 0xe2, 0xd8, 0x0e, 0xd3, 0x26,
    242            0xcb, 0xc7, 0xf0, 0xe7, 0x1a, 0x99, 0xf4, 0x3b,
    243            0xfb, 0x98, 0x8b, 0x9b, 0x7a, 0x02, 0xdd, 0x21
    244          };
    245          
    246          	AES_KEY wctx, xctx;
    247          	int ret;
    248          	ret = AES_wrap_unwrap_test(kek, 128, NULL, e1, key, 16);
    249          	fprintf(stderr, "Key test result %d\n", ret);
    250          	ret = AES_wrap_unwrap_test(kek, 192, NULL, e2, key, 16);
    251          	fprintf(stderr, "Key test result %d\n", ret);
    252          	ret = AES_wrap_unwrap_test(kek, 256, NULL, e3, key, 16);
    253          	fprintf(stderr, "Key test result %d\n", ret);
    254          	ret = AES_wrap_unwrap_test(kek, 192, NULL, e4, key, 24);
    255          	fprintf(stderr, "Key test result %d\n", ret);
    256          	ret = AES_wrap_unwrap_test(kek, 256, NULL, e5, key, 24);
    257          	fprintf(stderr, "Key test result %d\n", ret);
    258          	ret = AES_wrap_unwrap_test(kek, 256, NULL, e6, key, 32);
    259          	fprintf(stderr, "Key test result %d\n", ret);
    260          }
    261          	
    262          	
    263          #endif
    264          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   AES_unwrap_key
        56   -> AES_decrypt
        56   -> __aeabi_memcpy
        56   -> memcmp
      48   AES_wrap_key
        48   -> AES_encrypt
        48   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     176  AES_unwrap_key
     148  AES_wrap_key
       8  default_iv

 
 332 bytes in section .text
 
 332 bytes of CODE memory

Errors: none
Warnings: none
