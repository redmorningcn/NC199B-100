###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       13/Dec/2017  10:37:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_sem.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_sem.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\os_sem.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\os_sem.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_sem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                 SEMAPHORE MANAGEMENT
     10          *
     11          * File    : OS_SEM.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_sem__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_SEM_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                                  CREATE A SEMAPHORE
     45          *
     46          * Description: This function creates a semaphore.
     47          *
     48          * Arguments  : p_sem         is a pointer to the semaphore to initialize.  Your application is responsible for
     49          *                            allocating storage for the semaphore.
     50          *
     51          *              p_name        is a pointer to the name you would like to give the semaphore.
     52          *
     53          *              cnt           is the initial value for the semaphore.
     54          *                            If used to share resources, you should initialize to the number of resources available.
     55          *                            If used to signal the occurrence of event(s) then you should initialize to 0.
     56          *
     57          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     58          *
     59          *                                OS_ERR_NONE                    if the call was successful
     60          *                                OS_ERR_CREATE_ISR              if you called this function from an ISR
     61          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the semaphore after you
     62          *                                                                 called OSSafetyCriticalStart().
     63          *                                OS_ERR_NAME                    if 'p_name' is a NULL pointer
     64          *                                OS_ERR_OBJ_CREATED             if the semaphore has already been created
     65          *                                OS_ERR_OBJ_PTR_NULL            if 'p_sem'  is a NULL pointer
     66          *                                OS_ERR_OBJ_TYPE                if 'p_sem' has already been initialized to a different
     67          *                                                               object type
     68          *
     69          * Returns    : none
     70          ************************************************************************************************************************
     71          */
     72          
     73          
     74          /***********************************************
     75          * 描述： 传入的参数分别为： OS_SEM结构体地址、
     76          *                           信号量名、
     77          *                           初始信号量计数值、
     78          *                           错误代号。
     79          */

   \                                 In section .text, align 2, keep-with-next
     80          void  OSSemCreate (OS_SEM      *p_sem,
     81                             CPU_CHAR    *p_name,
     82                             OS_SEM_CTR   cnt,
     83                             OS_ERR      *p_err)
     84          {
   \                     OSSemCreate: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x461C             MOV      R4,R3
     85              CPU_SR_ALLOC();
     86          
     87          
     88          
     89          #ifdef OS_SAFETY_CRITICAL
     90              if (p_err == (OS_ERR *)0) {
     91                  OS_SAFETY_CRITICAL_EXCEPTION();
     92                  return;
     93              }
     94          #endif
     95          
     96          #ifdef OS_SAFETY_CRITICAL_IEC61508
     97              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     98                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     99                  return;
    100              }
    101          #endif
    102          
    103          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    104              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSSemCreate_0
    105                 *p_err = OS_ERR_CREATE_ISR;
   \   00000016   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
    106                  return;
   \   0000001C   0xE037             B.N      ??OSSemCreate_1
    107              }
    108          #endif
    109          
    110          #if OS_CFG_ARG_CHK_EN > 0u
    111              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemCreate_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD103             BNE.N    ??OSSemCreate_2
    112                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    113                  return;
   \   00000028   0xE031             B.N      ??OSSemCreate_1
    114              }
    115          #endif
    116          
    117              OS_CRITICAL_ENTER();
   \                     ??OSSemCreate_2: (+1)
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   \   0000002E   0x4681             MOV      R9,R0
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000034   0x.... 0x....      LDR.W    R8,??DataTable9_1
   \   00000038   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       CPU_SR_Restore
    118              p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x414d4553
   \   00000050   0x6028             STR      R0,[R5, #+0]
    119              p_sem->Ctr     = cnt;                                   /* Set semaphore value                                    */
   \   00000052   0x616F             STR      R7,[R5, #+20]
    120              p_sem->TS      = (CPU_TS)0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x61A8             STR      R0,[R5, #+24]
    121              p_sem->NamePtr = p_name;                                /* Save the name of the semaphore                         */
   \   00000058   0x606E             STR      R6,[R5, #+4]
    122              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \   0000005A   0xF105 0x0008      ADD      R0,R5,#+8
   \   0000005E   0x.... 0x....      BL       OS_PendListInit
    123          
    124          #if OS_CFG_DBG_EN > 0u
    125              OS_SemDbgListAdd(p_sem);
    126          #endif
    127              OSSemQty++;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000066   0x8801             LDRH     R1,[R0, #+0]
   \   00000068   0x1C49             ADDS     R1,R1,#+1
   \   0000006A   0x8001             STRH     R1,[R0, #+0]
    128          
    129              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000006C   0x.... 0x....      BL       CPU_SR_Save
   \   00000070   0x4605             MOV      R5,R0
   \   00000072   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000076   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    130             *p_err = OS_ERR_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x8020             STRH     R0,[R4, #+0]
    131          }
   \                     ??OSSemCreate_1: (+1)
   \   0000008E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    132          
    133          /*$PAGE*/
    134          /*
    135          ************************************************************************************************************************
    136          *                                                  DELETE A SEMAPHORE
    137          *
    138          * Description: This function deletes a semaphore.
    139          *
    140          * Arguments  : p_sem         is a pointer to the semaphore to delete
    141          *
    142          *              opt           determines delete options as follows:
    143          *
    144          *                                OS_OPT_DEL_NO_PEND          Delete semaphore ONLY if no task pending
    145          *                                OS_OPT_DEL_ALWAYS           Deletes the semaphore even if tasks are waiting.
    146          *                                                            In this case, all the tasks pending will be readied.
    147          *
    148          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    149          *
    150          *                                OS_ERR_NONE                 The call was successful and the semaphore was deleted
    151          *                                OS_ERR_DEL_ISR              If you attempted to delete the semaphore from an ISR
    152          *                                OS_ERR_OBJ_PTR_NULL         If 'p_sem' is a NULL pointer.
    153          *                                OS_ERR_OBJ_TYPE             If 'p_sem' is not pointing at a semaphore
    154          *                                OS_ERR_OPT_INVALID          An invalid option was specified
    155          *                                OS_ERR_TASK_WAITING         One or more tasks were waiting on the semaphore
    156          *
    157          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    158          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    159          *
    160          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the semaphore
    161          *                 MUST check the return code of OSSemPend().
    162          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted.
    163          *              3) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in applications where
    164          *                 the semaphore is used for mutual exclusion because the resource(s) will no longer be guarded by the
    165          *                 semaphore.
    166          ************************************************************************************************************************
    167          */
    168          
    169          #if OS_CFG_SEM_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    170          OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
    171                                OS_OPT   opt,
    172                                OS_ERR  *p_err)
    173          {
   \                     OSSemDel: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4615             MOV      R5,R2
    174              OS_OBJ_QTY     cnt;
    175              OS_OBJ_QTY     nbr_tasks;
    176              OS_PEND_DATA  *p_pend_data;
    177              OS_PEND_LIST  *p_pend_list;
    178              OS_TCB        *p_tcb;
    179              CPU_TS         ts;
    180              CPU_SR_ALLOC();
    181          
    182          
    183          
    184          #ifdef OS_SAFETY_CRITICAL
    185              if (p_err == (OS_ERR *)0) {
    186                  OS_SAFETY_CRITICAL_EXCEPTION();
    187                  return ((OS_OBJ_QTY)0);
    188              }
    189          #endif
    190          
    191          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    192              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSSemDel_0
    193                 *p_err = OS_ERR_DEL_ISR;
   \   00000014   0xF243 0x20C9      MOVW     R0,#+13001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    194                  return ((OS_OBJ_QTY)0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE084             B.N      ??OSSemDel_1
    195              }
    196          #endif
    197          
    198          #if OS_CFG_ARG_CHK_EN > 0u
    199              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemDel_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD104             BNE.N    ??OSSemDel_2
    200                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    201                  return ((OS_OBJ_QTY)0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE07D             B.N      ??OSSemDel_1
    202              }
    203              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemDel_2: (+1)
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD827             BHI.N    ??OSSemDel_3
    204                  case OS_OPT_DEL_NO_PEND:
    205                  case OS_OPT_DEL_ALWAYS:
    206                       break;
    207          
    208                  default:
    209                      *p_err = OS_ERR_OPT_INVALID;
    210                       return ((OS_OBJ_QTY)0);
    211              }
    212          #endif
    213          
    214          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    215              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x414d4553
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD127             BNE.N    ??OSSemDel_4
    216                 *p_err = OS_ERR_OBJ_TYPE;
    217                  return ((OS_OBJ_QTY)0);
    218              }
    219          #endif
    220          
    221              CPU_CRITICAL_ENTER();
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x4606             MOV      R6,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    222              p_pend_list = &p_sem->PendList;
   \   00000046   0xF104 0x0908      ADD      R9,R4,#+8
    223              cnt         = p_pend_list->NbrEntries;
   \   0000004A   0xF8B9 0xA008      LDRH     R10,[R9, #+8]
    224              nbr_tasks   = cnt;
   \   0000004E   0x4657             MOV      R7,R10
    225              switch (opt) {
   \   00000050   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000054   0xD003             BEQ.N    ??OSSemDel_5
   \   00000056   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000005A   0xD025             BEQ.N    ??OSSemDel_6
   \   0000005C   0xE05B             B.N      ??OSSemDel_7
    226                  case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
    227                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSSemDel_5: (+1)
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD119             BNE.N    ??OSSemDel_8
    228          #if OS_CFG_DBG_EN > 0u
    229                           OS_SemDbgListRemove(p_sem);
    230          #endif
    231                           OSSemQty--;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000066   0x8801             LDRH     R1,[R0, #+0]
   \   00000068   0x1E49             SUBS     R1,R1,#+1
   \   0000006A   0x8001             STRH     R1,[R0, #+0]
    232                           OS_SemClr(p_sem);
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       OS_SemClr
    233                           CPU_CRITICAL_EXIT();
   \   00000072   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
    234                          *p_err = OS_ERR_NONE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x8028             STRH     R0,[R5, #+0]
   \   00000080   0xE051             B.N      ??OSSemDel_9
    235                       } else {
   \                     ??OSSemDel_3: (+1)
   \   00000082   0xF645 0x6025      MOVW     R0,#+24101
   \   00000086   0x8028             STRH     R0,[R5, #+0]
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE04D             B.N      ??OSSemDel_1
   \                     ??OSSemDel_4: (+1)
   \   0000008C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000090   0x8028             STRH     R0,[R5, #+0]
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE048             B.N      ??OSSemDel_1
    236                           CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_8: (+1)
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0x.... 0x....      BL       CPU_SR_Restore
    237                          *p_err = OS_ERR_TASK_WAITING;
   \   000000A0   0xF247 0x105F      MOVW     R0,#+29023
   \   000000A4   0x8028             STRH     R0,[R5, #+0]
   \   000000A6   0xE03E             B.N      ??OSSemDel_9
    238                       }
    239                       break;
    240          
    241                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
    242                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemDel_6: (+1)
   \   000000A8   0x.... 0x....      LDR.W    R8,??DataTable9_1
   \   000000AC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BA   0x4630             MOV      R0,R6
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    243                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
   \   000000C0   0xE008             B.N      ??OSSemDel_10
    244                       while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
    245                           p_pend_data = p_pend_list->HeadPtr;
    246                           p_tcb       = p_pend_data->TCBPtr;
    247                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
    248                                         p_tcb,
    249                                         ts);
   \                     ??OSSemDel_11: (+1)
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000C8   0x6881             LDR      R1,[R0, #+8]
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       OS_PendObjDel
    250                           cnt--;
   \   000000D0   0xF1AA 0x0A01      SUB      R10,R10,#+1
    251                       }
   \                     ??OSSemDel_10: (+1)
   \   000000D4   0xFA1F 0xFA8A      UXTH     R10,R10
   \   000000D8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000DC   0xD1F1             BNE.N    ??OSSemDel_11
    252          #if OS_CFG_DBG_EN > 0u
    253                       OS_SemDbgListRemove(p_sem);
    254          #endif
    255                       OSSemQty--;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   000000E2   0x8801             LDRH     R1,[R0, #+0]
   \   000000E4   0x1E49             SUBS     R1,R1,#+1
   \   000000E6   0x8001             STRH     R1,[R0, #+0]
    256                       OS_SemClr(p_sem);
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       OS_SemClr
    257                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000EE   0x.... 0x....      BL       CPU_SR_Save
   \   000000F2   0x4606             MOV      R6,R0
   \   000000F4   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000F8   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000FC   0x1E40             SUBS     R0,R0,#+1
   \   000000FE   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000102   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000106   0x4630             MOV      R0,R6
   \   00000108   0x.... 0x....      BL       CPU_SR_Restore
    258                       OSSched();                                     /* Find highest priority task ready to run                */
   \   0000010C   0x.... 0x....      BL       OSSched
    259                      *p_err = OS_ERR_NONE;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x8028             STRH     R0,[R5, #+0]
    260                       break;
   \   00000114   0xE007             B.N      ??OSSemDel_9
    261          
    262                  default:
    263                       CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_7: (+1)
   \   00000116   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011A   0x4630             MOV      R0,R6
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
    264                      *p_err = OS_ERR_OPT_INVALID;
   \   00000120   0xF645 0x6025      MOVW     R0,#+24101
   \   00000124   0x8028             STRH     R0,[R5, #+0]
    265                       break;
    266              }
    267              return ((OS_OBJ_QTY)nbr_tasks);
   \                     ??OSSemDel_9: (+1)
   \   00000126   0x4638             MOV      R0,R7
   \                     ??OSSemDel_1: (+1)
   \   00000128   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    268          }
    269          #endif
    270          
    271          /*$PAGE*/
    272          /*
    273          ************************************************************************************************************************
    274          *                                                  PEND ON SEMAPHORE
    275          *
    276          * Description: This function waits for a semaphore.
    277          *
    278          * Arguments  : p_sem         is a pointer to the semaphore
    279          *
    280          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    281          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    282          *                            0, however, your task will wait forever at the specified semaphore or, until the resource
    283          *                            becomes available (or the event occurs).
    284          *
    285          *              opt           determines whether the user wants to block if the semaphore is not available or not:
    286          *
    287          *                                OS_OPT_PEND_BLOCKING
    288          *                                OS_OPT_PEND_NON_BLOCKING
    289          *
    290          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
    291          *                            or pend aborted or the semaphore deleted.  If you pass a NULL pointer (i.e. (CPU_TS*)0)
    292          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid
    293          *                            and indicates that you don't need the timestamp.
    294          *
    295          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    296          *
    297          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    298          *                                                          or, the event you are waiting for occurred.
    299          *                                OS_ERR_OBJ_DEL            If 'p_sem' was deleted
    300          *                                OS_ERR_OBJ_PTR_NULL       If 'p_sem' is a NULL pointer.
    301          *                                OS_ERR_OBJ_TYPE           If 'p_sem' is not pointing at a semaphore
    302          *                                OS_ERR_OPT_INVALID        If you specified an invalid value for 'opt'
    303          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    304          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    305          *                                                          would lead to a suspension.
    306          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the semaphore was not
    307          *                                                          available.
    308          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    309          *                                OS_ERR_STATUS_INVALID     Pend status is invalid
    310          *                                OS_ERR_TIMEOUT            The semaphore was not received within the specified
    311          *                                                          timeout.
    312          *
    313          *
    314          * Returns    : The current value of the semaphore counter or 0 if not available.
    315          ************************************************************************************************************************
    316          */
    317          
    318          
    319          /***********************************************
    320          * 描述： 传入的参数分别为 OS_SEM结构体地址、
    321          *                   等待期满值、
    322          *                   信号量失效模式、
    323          *                   时间戳、
    324          *                   错误代号
    325          */

   \                                 In section .text, align 4, keep-with-next
    326          OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
    327                                 OS_TICK   timeout,
    328                                 OS_OPT    opt,
    329                                 CPU_TS   *p_ts,
    330                                 OS_ERR   *p_err)
    331          {
   \                     OSSemPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4691             MOV      R9,R2
   \   0000000C   0x461D             MOV      R5,R3
   \   0000000E   0x9E10             LDR      R6,[SP, #+64]
    332              OS_SEM_CTR    ctr;
    333              OS_PEND_DATA  pend_data;
    334              CPU_SR_ALLOC();
    335          
    336          
    337          
    338          #ifdef OS_SAFETY_CRITICAL
    339              if (p_err == (OS_ERR *)0) {
    340                  OS_SAFETY_CRITICAL_EXCEPTION();
    341                  return ((OS_SEM_CTR)0);
    342              }
    343          #endif
    344          
    345          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    346              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSSemPend_1
    347                 *p_err = OS_ERR_PEND_ISR;
   \   0000001A   0xF246 0x10AE      MOVW     R0,#+25006
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    348                  return ((OS_SEM_CTR)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE094             B.N      ??OSSemPend_2
    349              }
    350          #endif
    351          
    352          #if OS_CFG_ARG_CHK_EN > 0u
    353              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemPend_1: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD104             BNE.N    ??OSSemPend_3
    354                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
    355                  return ((OS_SEM_CTR)0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE08D             B.N      ??OSSemPend_2
    356              }
    357              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPend_3: (+1)
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ.N    ??OSSemPend_4
   \   00000038   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003C   0xD124             BNE.N    ??OSSemPend_5
    358                  case OS_OPT_PEND_BLOCKING:
    359                  case OS_OPT_PEND_NON_BLOCKING:
    360                       break;
    361          
    362                  default:
    363                      *p_err = OS_ERR_OPT_INVALID;
    364                       return ((OS_SEM_CTR)0);
    365              }
    366          #endif
    367          
    368          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    369              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPend_4: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x414d4553
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD124             BNE.N    ??OSSemPend_6
    370                 *p_err = OS_ERR_OBJ_TYPE;
    371                  return ((OS_SEM_CTR)0);
    372              }
    373          #endif
    374          
    375              if (p_ts != (CPU_TS *)0) {
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD001             BEQ.N    ??OSSemPend_7
    376                 *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6028             STR      R0,[R5, #+0]
    377              }
    378              CPU_CRITICAL_ENTER();
   \                     ??OSSemPend_7: (+1)
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x4607             MOV      R7,R0
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStart
    379              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
   \   0000005A   0xF8D4 0xA014      LDR      R10,[R4, #+20]
   \   0000005E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000062   0xD01B             BEQ.N    ??OSSemPend_8
    380                  p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
   \   00000064   0xF1AA 0x0001      SUB      R0,R10,#+1
   \   00000068   0x6160             STR      R0,[R4, #+20]
    381                  if (p_ts != (CPU_TS *)0) {
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD001             BEQ.N    ??OSSemPend_9
    382                     *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
   \   0000006E   0x69A0             LDR      R0,[R4, #+24]
   \   00000070   0x6028             STR      R0,[R5, #+0]
    383                  }
    384                  ctr   = p_sem->Ctr;
   \                     ??OSSemPend_9: (+1)
   \   00000072   0xF8D4 0xA014      LDR      R10,[R4, #+20]
    385                  CPU_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4638             MOV      R0,R7
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
    386                 *p_err = OS_ERR_NONE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x8030             STRH     R0,[R6, #+0]
    387                  return (ctr);
   \   00000084   0x4650             MOV      R0,R10
   \   00000086   0xE062             B.N      ??OSSemPend_2
    388              }
   \                     ??OSSemPend_5: (+1)
   \   00000088   0xF645 0x6025      MOVW     R0,#+24101
   \   0000008C   0x8030             STRH     R0,[R6, #+0]
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE05D             B.N      ??OSSemPend_2
   \                     ??OSSemPend_6: (+1)
   \   00000092   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000096   0x8030             STRH     R0,[R6, #+0]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE058             B.N      ??OSSemPend_2
    389          
    390              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSSemPend_8: (+1)
   \   0000009C   0xEA5F 0x4009      LSLS     R0,R9,#+16
   \   000000A0   0xD509             BPL.N    ??OSSemPend_10
    391                  ctr   = p_sem->Ctr;                                 /* No                                                     */
    392                  CPU_CRITICAL_EXIT();
   \   000000A2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A6   0x4638             MOV      R0,R7
   \   000000A8   0x.... 0x....      BL       CPU_SR_Restore
    393                 *p_err = OS_ERR_PEND_WOULD_BLOCK;
   \   000000AC   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000B0   0x8030             STRH     R0,[R6, #+0]
    394                  return (ctr);
   \   000000B2   0x4650             MOV      R0,R10
   \   000000B4   0xE04B             B.N      ??OSSemPend_2
    395              } else {                                                /* Yes                                                    */
    396                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSSemPend_10: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R9,??DataTable9_1
   \   000000BA   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD009             BEQ.N    ??OSSemPend_11
    397                      CPU_CRITICAL_EXIT();
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x4638             MOV      R0,R7
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    398                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000CC   0xF646 0x5063      MOVW     R0,#+28003
   \   000000D0   0x8030             STRH     R0,[R6, #+0]
    399                      return ((OS_SEM_CTR)0);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE03B             B.N      ??OSSemPend_2
    400                  }
    401              }
    402                                                                      /* Lock the scheduler/re-enable interrupts                */
    403              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPend_11: (+1)
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000DC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
    404              OS_Pend(&pend_data,                                     /* Block task pending on Semaphore                        */
    405                      (OS_PEND_OBJ *)((void *)p_sem),
    406                      OS_TASK_PEND_ON_SEM,
    407                      timeout);
   \   000000E6   0x4643             MOV      R3,R8
   \   000000E8   0x2206             MOVS     R2,#+6
   \   000000EA   0x4621             MOV      R1,R4
   \   000000EC   0x4668             MOV      R0,SP
   \   000000EE   0x.... 0x....      BL       OS_Pend
    408          
    409              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000F2   0x.... 0x....      BL       CPU_SR_Save
   \   000000F6   0x4607             MOV      R7,R0
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000FC   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000100   0x1E40             SUBS     R0,R0,#+1
   \   00000102   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000106   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010A   0x4638             MOV      R0,R7
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
    410          
    411              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   00000110   0x.... 0x....      BL       OSSched
    412          
    413              CPU_CRITICAL_ENTER();
   \   00000114   0x.... 0x....      BL       CPU_SR_Save
   \   00000118   0x4607             MOV      R7,R0
   \   0000011A   0x.... 0x....      BL       CPU_IntDisMeasStart
    414              switch (OSTCBCurPtr->PendStatus) {
   \   0000011E   0x....             LDR.N    R0,??DataTable9_4
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0xF890 0x1035      LDRB     R1,[R0, #+53]
   \   00000126   0x2903             CMP      R1,#+3
   \   00000128   0xD82C             BHI.N    ??OSSemPend_12
   \   0000012A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??OSSemPend_0:
   \   0000012E   0x02 0x13          DC8      0x2,0x13,0x23,0x1B
   \              0x23 0x1B    
    415                  case OS_STATUS_PEND_OK:                             /* We got the semaphore                                   */
    416                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_13: (+1)
   \   00000132   0x2D00             CMP      R5,#+0
   \   00000134   0xD001             BEQ.N    ??OSSemPend_14
    417                          *p_ts  =  OSTCBCurPtr->TS;
   \   00000136   0x6C00             LDR      R0,[R0, #+64]
   \   00000138   0x6028             STR      R0,[R5, #+0]
    418                       }
    419                      *p_err = OS_ERR_NONE;
   \                     ??OSSemPend_14: (+1)
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x8030             STRH     R0,[R6, #+0]
    420                       break;
    421          
    422                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    423                       if (p_ts != (CPU_TS *)0) {
    424                          *p_ts  =  OSTCBCurPtr->TS;
    425                       }
    426                      *p_err = OS_ERR_PEND_ABORT;
    427                       break;
    428          
    429                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
    430                       if (p_ts != (CPU_TS *)0) {
    431                          *p_ts  = (CPU_TS  )0;
    432                       }
    433                      *p_err = OS_ERR_TIMEOUT;
    434                       break;
    435          
    436                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    437                       if (p_ts != (CPU_TS *)0) {
    438                          *p_ts  =  OSTCBCurPtr->TS;
    439                       }
    440                      *p_err = OS_ERR_OBJ_DEL;
    441                       break;
    442          
    443                  default:
    444                      *p_err = OS_ERR_STATUS_INVALID;
    445                       CPU_CRITICAL_EXIT();
    446                       return ((OS_SEM_CTR)0);
    447              }
    448              ctr = p_sem->Ctr;
   \                     ??OSSemPend_15: (+1)
   \   0000013E   0xF8D4 0xA014      LDR      R10,[R4, #+20]
    449              CPU_CRITICAL_EXIT();
   \   00000142   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000146   0x4638             MOV      R0,R7
   \   00000148   0x.... 0x....      BL       CPU_SR_Restore
    450              return (ctr);
   \   0000014C   0x4650             MOV      R0,R10
   \                     ??OSSemPend_2: (+1)
   \   0000014E   0xB008             ADD      SP,SP,#+32
   \   00000150   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??OSSemPend_16: (+1)
   \   00000154   0x2D00             CMP      R5,#+0
   \   00000156   0xD001             BEQ.N    ??OSSemPend_17
   \   00000158   0x6C00             LDR      R0,[R0, #+64]
   \   0000015A   0x6028             STR      R0,[R5, #+0]
   \                     ??OSSemPend_17: (+1)
   \   0000015C   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000160   0x8030             STRH     R0,[R6, #+0]
   \   00000162   0xE7EC             B.N      ??OSSemPend_15
   \                     ??OSSemPend_18: (+1)
   \   00000164   0x2D00             CMP      R5,#+0
   \   00000166   0xD001             BEQ.N    ??OSSemPend_19
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x6028             STR      R0,[R5, #+0]
   \                     ??OSSemPend_19: (+1)
   \   0000016C   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000170   0x8030             STRH     R0,[R6, #+0]
   \   00000172   0xE7E4             B.N      ??OSSemPend_15
   \                     ??OSSemPend_20: (+1)
   \   00000174   0x2D00             CMP      R5,#+0
   \   00000176   0xD001             BEQ.N    ??OSSemPend_21
   \   00000178   0x6C00             LDR      R0,[R0, #+64]
   \   0000017A   0x6028             STR      R0,[R5, #+0]
   \                     ??OSSemPend_21: (+1)
   \   0000017C   0xF645 0x50C2      MOVW     R0,#+24002
   \   00000180   0x8030             STRH     R0,[R6, #+0]
   \   00000182   0xE7DC             B.N      ??OSSemPend_15
   \                     ??OSSemPend_12: (+1)
   \   00000184   0xF646 0x602E      MOVW     R0,#+28206
   \   00000188   0x8030             STRH     R0,[R6, #+0]
   \   0000018A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000018E   0x4638             MOV      R0,R7
   \   00000190   0x.... 0x....      BL       CPU_SR_Restore
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0xE7DA             B.N      ??OSSemPend_2
    451          }
    452          
    453          /*$PAGE*/
    454          /*
    455          ************************************************************************************************************************
    456          *                                             ABORT WAITING ON A SEMAPHORE
    457          *
    458          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function should be used
    459          *              to fault-abort the wait on the semaphore, rather than to normally signal the semaphore via OSSemPost().
    460          *
    461          * Arguments  : p_sem     is a pointer to the semaphore
    462          *
    463          *              opt       determines the type of ABORT performed:
    464          *
    465          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the semaphore
    466          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the semaphore
    467          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    468          *
    469          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    470          *
    471          *                            OS_ERR_NONE                  At least one task waiting on the semaphore was readied and
    472          *                                                         informed of the aborted wait; check return value for the
    473          *                                                         number of tasks whose wait on the semaphore was aborted.
    474          *                            OS_ERR_OBJ_PTR_NULL          If 'p_sem' is a NULL pointer.
    475          *                            OS_ERR_OBJ_TYPE              If 'p_sem' is not pointing at a semaphore
    476          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    477          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    478          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    479          *
    480          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    481          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    482          ************************************************************************************************************************
    483          */
    484          
    485          #if OS_CFG_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    486          OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
    487                                      OS_OPT   opt,
    488                                      OS_ERR  *p_err)
    489          {
   \                     OSSemPendAbort: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    490              OS_PEND_LIST  *p_pend_list;
    491              OS_TCB        *p_tcb;
    492              CPU_TS         ts;
    493              OS_OBJ_QTY     nbr_tasks;
    494              CPU_SR_ALLOC();
    495          
    496          
    497          
    498          #ifdef OS_SAFETY_CRITICAL
    499              if (p_err == (OS_ERR *)0) {
    500                  OS_SAFETY_CRITICAL_EXCEPTION();
    501                  return ((OS_OBJ_QTY)0u);
    502              }
    503          #endif
    504          
    505          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    506              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   0000000A   0x....             LDR.N    R0,??DataTable9
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSSemPendAbort_0
    507                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000012   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000016   0x8030             STRH     R0,[R6, #+0]
    508                  return ((OS_OBJ_QTY)0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE069             B.N      ??OSSemPendAbort_1
    509              }
    510          #endif
    511          
    512          #if OS_CFG_ARG_CHK_EN > 0u
    513              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemPendAbort_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSSemPendAbort_2
    514                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8030             STRH     R0,[R6, #+0]
    515                  return ((OS_OBJ_QTY)0u);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE062             B.N      ??OSSemPendAbort_1
    516              }
    517              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPendAbort_2: (+1)
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0xD008             BEQ.N    ??OSSemPendAbort_3
   \   0000002E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000032   0xD005             BEQ.N    ??OSSemPendAbort_3
   \   00000034   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000038   0xD002             BEQ.N    ??OSSemPendAbort_3
   \   0000003A   0xF5B0 0x4F01      CMP      R0,#+33024
   \   0000003E   0xD118             BNE.N    ??OSSemPendAbort_4
    518                  case OS_OPT_PEND_ABORT_1:
    519                  case OS_OPT_PEND_ABORT_ALL:
    520                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    521                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    522                       break;
    523          
    524                  default:
    525                      *p_err =  OS_ERR_OPT_INVALID;
    526                       return ((OS_OBJ_QTY)0u);
    527              }
    528          #endif
    529          
    530          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    531              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPendAbort_3: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x....             LDR.N    R1,??DataTable9_2  ;; 0x414d4553
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD119             BNE.N    ??OSSemPendAbort_5
    532                 *p_err =  OS_ERR_OBJ_TYPE;
    533                  return ((OS_OBJ_QTY)0u);
    534              }
    535          #endif
    536          
    537              CPU_CRITICAL_ENTER();
   \   00000048   0x.... 0x....      BL       CPU_SR_Save
   \   0000004C   0x4607             MOV      R7,R0
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStart
    538              p_pend_list = &p_sem->PendList;
   \   00000052   0xF104 0x0808      ADD      R8,R4,#+8
    539              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
   \   00000056   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD113             BNE.N    ??OSSemPendAbort_6
    540                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x4638             MOV      R0,R7
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
    541                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000068   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000006C   0x8030             STRH     R0,[R6, #+0]
    542                  return ((OS_OBJ_QTY)0u);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE03E             B.N      ??OSSemPendAbort_1
    543              }
   \                     ??OSSemPendAbort_4: (+1)
   \   00000072   0xF645 0x6025      MOVW     R0,#+24101
   \   00000076   0x8030             STRH     R0,[R6, #+0]
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE039             B.N      ??OSSemPendAbort_1
   \                     ??OSSemPendAbort_5: (+1)
   \   0000007C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000080   0x8030             STRH     R0,[R6, #+0]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE034             B.N      ??OSSemPendAbort_1
    544          
    545              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPendAbort_6: (+1)
   \   00000086   0x.... 0x....      LDR.W    R9,??DataTable9_1
   \   0000008A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000098   0x4638             MOV      R0,R7
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
    546              nbr_tasks = 0u;
   \   0000009E   0xF04F 0x0A00      MOV      R10,#+0
    547              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
    548              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSSemPendAbort_7: (+1)
   \   000000A2   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD00B             BEQ.N    ??OSSemPendAbort_8
    549                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
    550                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
    551                               p_tcb,
    552                               ts);
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B0   0x6881             LDR      R1,[R0, #+8]
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       OS_PendAbort
    553                  nbr_tasks++;
   \   000000B8   0xF10A 0x0A01      ADD      R10,R10,#+1
    554                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000BC   0xF5B5 0x7F80      CMP      R5,#+256
   \   000000C0   0xD0EF             BEQ.N    ??OSSemPendAbort_7
    555                      break;                                          /* No                                                     */
    556                  }
    557              }
    558              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSSemPendAbort_8: (+1)
   \   000000C2   0x.... 0x....      BL       CPU_SR_Save
   \   000000C6   0x4607             MOV      R7,R0
   \   000000C8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000CC   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000D6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000DA   0x4638             MOV      R0,R7
   \   000000DC   0x.... 0x....      BL       CPU_SR_Restore
    559          
    560              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   000000E0   0x0428             LSLS     R0,R5,#+16
   \   000000E2   0xD401             BMI.N    ??OSSemPendAbort_9
    561                  OSSched();                                          /* Run the scheduler                                      */
   \   000000E4   0x.... 0x....      BL       OSSched
    562              }
    563          
    564             *p_err = OS_ERR_NONE;
   \                     ??OSSemPendAbort_9: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x8030             STRH     R0,[R6, #+0]
    565              return (nbr_tasks);
   \   000000EC   0x4650             MOV      R0,R10
   \   000000EE   0xB280             UXTH     R0,R0
   \                     ??OSSemPendAbort_1: (+1)
   \   000000F0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    566          }
    567          #endif
    568          
    569          /*$PAGE*/
    570          /*
    571          ************************************************************************************************************************
    572          *                                                 POST TO A SEMAPHORE
    573          *
    574          * Description: This function signals a semaphore
    575          *
    576          * Arguments  : p_sem    is a pointer to the semaphore
    577          *
    578          *              opt      determines the type of POST performed:
    579          *
    580          *                           OS_OPT_POST_1            POST and ready only the highest priority task waiting on semaphore
    581          *                                                    (if tasks are waiting).
    582          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    583          *
    584          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    585          *
    586          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    587          *
    588          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    589          *
    590          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    591          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    592          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    593          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    594          *
    595          * Returns    : The current value of the semaphore counter or 0 upon error.
    596          ************************************************************************************************************************
    597          */
    598          

   \                                 In section .text, align 2, keep-with-next
    599          OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
    600                                 OS_OPT   opt,
    601                                 OS_ERR  *p_err)
    602          {
   \                     OSSemPost: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    603              OS_SEM_CTR  ctr;
    604              CPU_TS      ts;
    605          
    606          
    607          
    608          #ifdef OS_SAFETY_CRITICAL
    609              if (p_err == (OS_ERR *)0) {
    610                  OS_SAFETY_CRITICAL_EXCEPTION();
    611                  return ((OS_SEM_CTR)0);
    612              }
    613          #endif
    614          
    615          #if OS_CFG_ARG_CHK_EN > 0u
    616              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD104             BNE.N    ??OSSemPost_0
    617                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000006   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000000A   0x8010             STRH     R0,[R2, #+0]
    618                  return ((OS_SEM_CTR)0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE02F             B.N      ??OSSemPost_1
    619              }
    620              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPost_0: (+1)
   \   00000010   0x000B             MOVS     R3,R1
   \   00000012   0xD008             BEQ.N    ??OSSemPost_2
   \   00000014   0xF5B3 0x7F00      CMP      R3,#+512
   \   00000018   0xD005             BEQ.N    ??OSSemPost_2
   \   0000001A   0xF5B3 0x4F00      CMP      R3,#+32768
   \   0000001E   0xD002             BEQ.N    ??OSSemPost_2
   \   00000020   0xF5B3 0x4F02      CMP      R3,#+33280
   \   00000024   0xD114             BNE.N    ??OSSemPost_3
    621                  case OS_OPT_POST_1:
    622                  case OS_OPT_POST_ALL:
    623                  case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
    624                  case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    625                       break;
    626          
    627                  default:
    628                      *p_err =  OS_ERR_OPT_INVALID;
    629                       return ((OS_SEM_CTR)0u);
    630              }
    631          #endif
    632          
    633          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    634              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPost_2: (+1)
   \   00000026   0x....             LDR.N    R4,??DataTable9_2  ;; 0x414d4553
   \   00000028   0x6803             LDR      R3,[R0, #+0]
   \   0000002A   0x42A3             CMP      R3,R4
   \   0000002C   0xD115             BNE.N    ??OSSemPost_4
    635                 *p_err = OS_ERR_OBJ_TYPE;
    636                  return ((OS_SEM_CTR)0);
    637              }
    638          #endif
    639          
    640              ts = OS_TS_GET();                                       /* Get timestamp                                          */
    641          
    642          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    643              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \   0000002E   0x....             LDR.N    R3,??DataTable9
   \   00000030   0x781B             LDRB     R3,[R3, #+0]
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD016             BEQ.N    ??OSSemPost_5
    644                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_SEM,           /* Post to ISR queue                                      */
    645                              (void      *)p_sem,
    646                              (void      *)0,
    647                              (OS_MSG_SIZE)0,
    648                              (OS_FLAGS   )0,
    649                              (OS_OPT     )opt,
    650                              (CPU_TS     )ts,
    651                              (OS_ERR    *)p_err);
   \   00000036   0x9203             STR      R2,[SP, #+12]
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x9202             STR      R2,[SP, #+8]
   \   0000003C   0x9101             STR      R1,[SP, #+4]
   \   0000003E   0x4611             MOV      R1,R2
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x460B             MOV      R3,R1
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       OS_IntQPost
    652                  return ((OS_SEM_CTR)0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE00F             B.N      ??OSSemPost_1
    653              }
   \                     ??OSSemPost_3: (+1)
   \   00000050   0xF645 0x6025      MOVW     R0,#+24101
   \   00000054   0x8010             STRH     R0,[R2, #+0]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE00A             B.N      ??OSSemPost_1
   \                     ??OSSemPost_4: (+1)
   \   0000005A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000005E   0x8010             STRH     R0,[R2, #+0]
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE005             B.N      ??OSSemPost_1
    654          #endif
    655          
    656              ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
    657                               opt,
    658                               ts,
    659                               p_err);
    660          
    661              return (ctr);
   \                     ??OSSemPost_5: (+1)
   \   00000064   0x4613             MOV      R3,R2
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0xB004             ADD      SP,SP,#+16
   \   0000006A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006E   0x....             B.N      OS_SemPost
   \                     ??OSSemPost_1: (+1)
   \   00000070   0xB004             ADD      SP,SP,#+16
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
    662          }
    663          
    664          /*$PAGE*/
    665          /*
    666          ************************************************************************************************************************
    667          *                                                    SET SEMAPHORE
    668          *
    669          * Description: This function sets the semaphore count to the value specified as an argument.  Typically, this value
    670          *              would be 0 but of course, we can set the semaphore to any value.
    671          *
    672          *              You would typically use this function when a semaphore is used as a signaling mechanism
    673          *              and, you want to reset the count value.
    674          *
    675          * Arguments  : p_sem     is a pointer to the semaphore
    676          *
    677          *              cnt       is the new value for the semaphore count.  You would pass 0 to reset the semaphore count.
    678          *
    679          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    680          *
    681          *                            OS_ERR_NONE           The call was successful and the semaphore value was set.
    682          *                            OS_ERR_OBJ_PTR_NULL   If 'p_sem' is a NULL pointer.
    683          *                            OS_ERR_OBJ_TYPE       If 'p_sem' is not pointing to a semaphore.
    684          *                            OS_ERR_TASK_WAITING   If tasks are waiting on the semaphore.
    685          *
    686          * Returns    : None
    687          ************************************************************************************************************************
    688          */
    689          
    690          #if OS_CFG_SEM_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    691          void  OSSemSet (OS_SEM      *p_sem,
    692                          OS_SEM_CTR   cnt,
    693                          OS_ERR      *p_err)
    694          {
   \                     OSSemSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
    695              OS_PEND_LIST  *p_pend_list;
    696              CPU_SR_ALLOC();
    697          
    698          
    699          
    700          #ifdef OS_SAFETY_CRITICAL
    701              if (p_err == (OS_ERR *)0) {
    702                  OS_SAFETY_CRITICAL_EXCEPTION();
    703                  return;
    704              }
    705          #endif
    706          
    707          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    708              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \   00000008   0x....             LDR.N    R0,??DataTable9
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSemSet_0
    709                 *p_err = OS_ERR_SET_ISR;
   \   00000010   0xF646 0x50C6      MOVW     R0,#+28102
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    710                  return;
   \   00000016   0xBDF1             POP      {R0,R4-R7,PC}
    711              }
    712          #endif
    713          
    714          #if OS_CFG_ARG_CHK_EN > 0u
    715              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemSet_0: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD103             BNE.N    ??OSSemSet_1
    716                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001C   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    717                  return;
   \   00000022   0xBDF1             POP      {R0,R4-R7,PC}
    718              }
    719          #endif
    720          
    721          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    722              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemSet_1: (+1)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable9_2  ;; 0x414d4553
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD003             BEQ.N    ??OSSemSet_2
    723                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000030   0x8020             STRH     R0,[R4, #+0]
    724                  return;
   \   00000032   0xBDF1             POP      {R0,R4-R7,PC}
    725              }
    726          #endif
    727          
    728             *p_err = OS_ERR_NONE;
   \                     ??OSSemSet_2: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    729              CPU_CRITICAL_ENTER();
   \   00000038   0x.... 0x....      BL       CPU_SR_Save
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStart
    730              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
   \   00000042   0x6968             LDR      R0,[R5, #+20]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ.N    ??OSSemSet_3
    731                  p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
   \   00000048   0x616E             STR      R6,[R5, #+20]
   \   0000004A   0xE007             B.N      ??OSSemSet_4
    732              } else {
    733                  p_pend_list = &p_sem->PendList;                     /* No                                                     */
    734                  if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
   \                     ??OSSemSet_3: (+1)
   \   0000004C   0x8A28             LDRH     R0,[R5, #+16]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD101             BNE.N    ??OSSemSet_5
    735                      p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
   \   00000052   0x616E             STR      R6,[R5, #+20]
   \   00000054   0xE002             B.N      ??OSSemSet_4
    736                  } else {
    737                     *p_err      = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_5: (+1)
   \   00000056   0xF247 0x105F      MOVW     R0,#+29023
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    738                  }
    739              }
    740              CPU_CRITICAL_EXIT();
   \                     ??OSSemSet_4: (+1)
   \   0000005C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000066   0x.... 0x....      B.W      CPU_SR_Restore
    741          }
    742          #endif
    743          
    744          /*$PAGE*/
    745          /*
    746          ************************************************************************************************************************
    747          *                                           CLEAR THE CONTENTS OF A SEMAPHORE
    748          *
    749          * Description: This function is called by OSSemDel() to clear the contents of a semaphore
    750          *
    751          
    752          * Argument(s): p_sem      is a pointer to the semaphore to clear
    753          *              -----
    754          *
    755          * Returns    : none
    756          *
    757          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    758          ************************************************************************************************************************
    759          */
    760          

   \                                 In section .text, align 2, keep-with-next
    761          void  OS_SemClr (OS_SEM  *p_sem)
    762          {
    763              p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
   \                     OS_SemClr: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9_5  ;; 0x454e4f4e
   \   00000002   0x6001             STR      R1,[R0, #+0]
    764              p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    765              p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
   \   00000008   0x6181             STR      R1,[R0, #+24]
    766              p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
   \   0000000A   0x.... 0x....      ADR.W    R1,?_0
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    767              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \   00000010   0x3008             ADDS     R0,R0,#+8
   \   00000012   0x.... 0x....      B.W      OS_PendListInit
    768          }
    769          
    770          /*$PAGE*/
    771          /*
    772          ************************************************************************************************************************
    773          *                                        ADD/REMOVE SEMAPHORE TO/FROM DEBUG LIST
    774          *
    775          * Description: These functions are called by uC/OS-III to add or remove a semaphore to/from the debug list.
    776          *
    777          * Arguments  : p_sem     is a pointer to the semaphore to add/remove
    778          *
    779          * Returns    : none
    780          *
    781          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    782          ************************************************************************************************************************
    783          */
    784          
    785          
    786          #if OS_CFG_DBG_EN > 0u
    787          void  OS_SemDbgListAdd (OS_SEM  *p_sem)
    788          {
    789              p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    790              p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    791              if (OSSemDbgListPtr == (OS_SEM *)0) {
    792                  p_sem->DbgNextPtr           = (OS_SEM   *)0;
    793              } else {
    794                  p_sem->DbgNextPtr           =  OSSemDbgListPtr;
    795                  OSSemDbgListPtr->DbgPrevPtr =  p_sem;
    796              }
    797              OSSemDbgListPtr                 =  p_sem;
    798          }
    799          
    800          
    801          
    802          void  OS_SemDbgListRemove (OS_SEM  *p_sem)
    803          {
    804              OS_SEM  *p_sem_next;
    805              OS_SEM  *p_sem_prev;
    806          
    807          
    808              p_sem_prev = p_sem->DbgPrevPtr;
    809              p_sem_next = p_sem->DbgNextPtr;
    810          
    811              if (p_sem_prev == (OS_SEM *)0) {
    812                  OSSemDbgListPtr = p_sem_next;
    813                  if (p_sem_next != (OS_SEM *)0) {
    814                      p_sem_next->DbgPrevPtr = (OS_SEM *)0;
    815                  }
    816                  p_sem->DbgNextPtr = (OS_SEM *)0;
    817          
    818              } else if (p_sem_next == (OS_SEM *)0) {
    819                  p_sem_prev->DbgNextPtr = (OS_SEM *)0;
    820                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
    821          
    822              } else {
    823                  p_sem_prev->DbgNextPtr =  p_sem_next;
    824                  p_sem_next->DbgPrevPtr =  p_sem_prev;
    825                  p_sem->DbgNextPtr      = (OS_SEM *)0;
    826                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
    827              }
    828          }
    829          #endif
    830          
    831          /*$PAGE*/
    832          /*
    833          ************************************************************************************************************************
    834          *                                                SEMAPHORE INITIALIZATION
    835          *
    836          * Description: This function is called by OSInit() to initialize the semaphore management.
    837          *
    838          
    839          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
    840          *
    841          *                                OS_ERR_NONE     the call was successful
    842          *
    843          * Returns    : none
    844          *
    845          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    846          ************************************************************************************************************************
    847          */
    848          

   \                                 In section .text, align 2, keep-with-next
    849          void  OS_SemInit (OS_ERR  *p_err)
    850          {
    851          #ifdef OS_SAFETY_CRITICAL
    852              if (p_err == (OS_ERR *)0) {
    853                  OS_SAFETY_CRITICAL_EXCEPTION();
    854                  return;
    855              }
    856          #endif
    857          
    858          #if OS_CFG_DBG_EN > 0u
    859              OSSemDbgListPtr = (OS_SEM *)0;
    860          #endif
    861          
    862              OSSemQty        = (OS_OBJ_QTY)0;
   \                     OS_SemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable9_3
   \   00000004   0x8011             STRH     R1,[R2, #+0]
    863             *p_err           = OS_ERR_NONE;
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    864          }
   \   00000008   0x4770             BX       LR               ;; return
    865          
    866          /*$PAGE*/
    867          /*
    868          ************************************************************************************************************************
    869          *                                                 POST TO A SEMAPHORE
    870          *
    871          * Description: This function signals a semaphore
    872          *
    873          * Arguments  : p_sem    is a pointer to the semaphore
    874          *
    875          *              opt      determines the type of POST performed:
    876          *
    877          *                           OS_OPT_POST_1            POST to a single waiting task
    878          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    879          *
    880          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    881          *
    882          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    883          *
    884          *              ts       is a timestamp indicating when the post occurred.
    885          *
    886          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    887          *
    888          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    889          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    890          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    891          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    892          *
    893          * Returns    : The current value of the semaphore counter or 0 upon error.
    894          *
    895          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    896          ************************************************************************************************************************
    897          */
    898          

   \                                 In section .text, align 2, keep-with-next
    899          OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
    900                                  OS_OPT   opt,
    901                                  CPU_TS   ts,
    902                                  OS_ERR  *p_err)
    903          {
   \                     OS_SemPost: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    904              OS_OBJ_QTY     cnt;
    905              OS_SEM_CTR     ctr;
    906              OS_PEND_LIST  *p_pend_list;
    907              OS_PEND_DATA  *p_pend_data;
    908              OS_PEND_DATA  *p_pend_data_next;
    909              OS_TCB        *p_tcb;
    910              CPU_SR_ALLOC();
    911          
    912          
    913          
    914              CPU_CRITICAL_ENTER();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x4681             MOV      R9,R0
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStart
    915              p_pend_list = &p_sem->PendList;
   \   00000018   0xF104 0x0A08      ADD      R10,R4,#+8
    916              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on semaphore?                         */
   \   0000001C   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD11B             BNE.N    ??OS_SemPost_0
    917                  switch (sizeof(OS_SEM_CTR)) {
    918                      case 1u:
    919                           if (p_sem->Ctr == DEF_INT_08U_MAX_VAL) {
    920                               CPU_CRITICAL_EXIT();
    921                              *p_err = OS_ERR_SEM_OVF;
    922                               return ((OS_SEM_CTR)0);
    923                           }
    924                           break;
    925          
    926                      case 2u:
    927                           if (p_sem->Ctr == DEF_INT_16U_MAX_VAL) {
    928                               CPU_CRITICAL_EXIT();
    929                              *p_err = OS_ERR_SEM_OVF;
    930                               return ((OS_SEM_CTR)0);
    931                           }
    932                           break;
    933          
    934                      case 4u:
    935                           if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
   \   00000024   0x6960             LDR      R0,[R4, #+20]
   \   00000026   0xF110 0x0F01      CMN      R0,#+1
   \   0000002A   0xD109             BNE.N    ??OS_SemPost_1
    936                               CPU_CRITICAL_EXIT();
   \   0000002C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000030   0x4648             MOV      R0,R9
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
    937                              *p_err = OS_ERR_SEM_OVF;
   \   00000036   0xF646 0x50C5      MOVW     R0,#+28101
   \   0000003A   0x8030             STRH     R0,[R6, #+0]
    938                               return ((OS_SEM_CTR)0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE049             B.N      ??OS_SemPost_2
    939                           }
    940                           break;
    941          
    942                      default:
    943                           break;
    944                  }
    945                  p_sem->Ctr++;                                       /* No                                                     */
   \                     ??OS_SemPost_1: (+1)
   \   00000040   0xF100 0x0A01      ADD      R10,R0,#+1
   \   00000044   0xF8C4 0xA014      STR      R10,[R4, #+20]
    946                  ctr       = p_sem->Ctr;
    947                  p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
   \   00000048   0x61A5             STR      R5,[R4, #+24]
    948                  CPU_CRITICAL_EXIT();
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000004E   0x4648             MOV      R0,R9
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
    949                 *p_err     = OS_ERR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    950                  return (ctr);
   \   00000058   0x4650             MOV      R0,R10
   \   0000005A   0xE03B             B.N      ??OS_SemPost_2
    951              }
    952          
    953              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OS_SemPost_0: (+1)
   \   0000005C   0x....             LDR.N    R7,??DataTable9_1
   \   0000005E   0x7838             LDRB     R0,[R7, #+0]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x7038             STRB     R0,[R7, #+0]
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    954              if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
   \   0000006E   0xEA5F 0x5088      LSLS     R0,R8,#+22
   \   00000072   0xD502             BPL.N    ??OS_SemPost_3
    955                  cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
   \   00000074   0xF8BA 0x9008      LDRH     R9,[R10, #+8]
   \   00000078   0xE001             B.N      ??OS_SemPost_4
    956              } else {
    957                  cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
   \                     ??OS_SemPost_3: (+1)
   \   0000007A   0xF04F 0x0901      MOV      R9,#+1
    958              }
    959              p_pend_data = p_pend_list->HeadPtr;
   \                     ??OS_SemPost_4: (+1)
   \   0000007E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000082   0xE00B             B.N      ??OS_SemPost_5
    960              while (cnt > 0u) {
    961                  p_tcb            = p_pend_data->TCBPtr;
    962                  p_pend_data_next = p_pend_data->NextPtr;
   \                     ??OS_SemPost_6: (+1)
   \   00000084   0xF8D0 0xA004      LDR      R10,[R0, #+4]
    963                  OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    964                          p_tcb,
    965                          (void      *)0,
    966                          (OS_MSG_SIZE)0,
    967                          ts);
   \   00000088   0x9500             STR      R5,[SP, #+0]
   \   0000008A   0x2300             MOVS     R3,#+0
   \   0000008C   0x461A             MOV      R2,R3
   \   0000008E   0x6881             LDR      R1,[R0, #+8]
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       OS_Post
    968                  p_pend_data = p_pend_data_next;
   \   00000096   0x4650             MOV      R0,R10
    969                  cnt--;
   \   00000098   0xF1A9 0x0901      SUB      R9,R9,#+1
    970              }
   \                     ??OS_SemPost_5: (+1)
   \   0000009C   0xFA1F 0xF989      UXTH     R9,R9
   \   000000A0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A4   0xD1EE             BNE.N    ??OS_SemPost_6
    971              ctr = p_sem->Ctr;
   \   000000A6   0xF8D4 0xA014      LDR      R10,[R4, #+20]
    972              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000AA   0x.... 0x....      BL       CPU_SR_Save
   \   000000AE   0x4681             MOV      R9,R0
   \   000000B0   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000B4   0x7838             LDRB     R0,[R7, #+0]
   \   000000B6   0x1E40             SUBS     R0,R0,#+1
   \   000000B8   0x7038             STRB     R0,[R7, #+0]
   \   000000BA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BE   0x4648             MOV      R0,R9
   \   000000C0   0x.... 0x....      BL       CPU_SR_Restore
    973              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   000000C4   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   000000C8   0xD401             BMI.N    ??OS_SemPost_7
    974                  OSSched();                                          /* Run the scheduler                                      */
   \   000000CA   0x.... 0x....      BL       OSSched
    975              }
    976             *p_err = OS_ERR_NONE;
   \                     ??OS_SemPost_7: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x8030             STRH     R0,[R6, #+0]
    977              return (ctr);
   \   000000D2   0x4650             MOV      R0,R10
   \                     ??OS_SemPost_2: (+1)
   \   000000D4   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    978          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x3F 0x53          DC8 "?SEM"
   \              0x45 0x4D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    979          
    980          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSSemCreate
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_PendListInit
      32   OSSemDel
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendObjDel
        32   -> OS_SemClr
      64   OSSemPend
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OS_Pend
      32   OSSemPendAbort
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      24   OSSemPost
        24   -> OS_IntQPost
         0   -> OS_SemPost
      24   OSSemSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   OS_SemClr
         0   -> OS_PendListInit
       0   OS_SemInit
      40   OS_SemPost
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_Post


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       8  ?_0
     146  OSSemCreate
     300  OSSemDel
     408  OSSemPend
     244  OSSemPendAbort
     116  OSSemPost
     106  OSSemSet
      22  OS_SemClr
      10  OS_SemInit
     216  OS_SemPost

 
 1 600 bytes in section .text
 
 1 600 bytes of CODE memory

Errors: none
Warnings: none
