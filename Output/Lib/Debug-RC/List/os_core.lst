###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:40:24
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_core.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_core.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\os_core.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\os_core.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_core.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                    CORE FUNCTIONS
     10          *
     11          * File    : OS_CORE.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_core__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                    INITIALIZATION
     43          *
     44          * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
     45          *              creating any uC/OS-III object and, prior to calling OS_Start().
     46          *
     47          * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
     48          *
     49          *                                OS_ERR_NONE    Initialization was successful
     50          *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
     51          * Returns    : none
     52          ************************************************************************************************************************
     53          */
     54          

   \                                 In section .text, align 2, keep-with-next
     55          void  OSInit (OS_ERR  *p_err)
     56          {
   \                     OSInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     57              CPU_STK      *p_stk;
     58              CPU_STK_SIZE  size;
     59          
     60          
     61          
     62          #ifdef OS_SAFETY_CRITICAL
     63              if (p_err == (OS_ERR *)0) {
     64                  OS_SAFETY_CRITICAL_EXCEPTION();
     65                  return;
     66              }
     67          #endif
     68          
     69              OSInitHook();                                           /* Call port specific initialization code                 */
   \   00000004   0x.... 0x....      BL       OSInitHook
     70          
     71              OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
     72          
     73              OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000014   0x7008             STRB     R0,[R1, #+0]
     74          
     75              OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
     76          
     77              OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000020   0x6008             STR      R0,[R1, #+0]
     78              OSTCBHighRdyPtr                 = (OS_TCB *)0;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000026   0x6008             STR      R0,[R1, #+0]
     79          
     80              OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
     81              OSPrioHighRdy                   = (OS_PRIO)0;
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000032   0x7008             STRB     R0,[R1, #+0]
     82              OSPrioSaved                     = (OS_PRIO)0;
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000038   0x7008             STRB     R0,[R1, #+0]
     83          
     84          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
     85              OSSchedLockTimeBegin            = (CPU_TS)0;
     86              OSSchedLockTimeMax              = (CPU_TS)0;
     87              OSSchedLockTimeMaxCur           = (CPU_TS)0;
     88          #endif
     89          
     90          #ifdef OS_SAFETY_CRITICAL_IEC61508
     91              OSSafetyCriticalStartFlag       =  DEF_FALSE;
     92          #endif
     93          
     94          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
     95              OSSchedRoundRobinEn             = DEF_FALSE;
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_8
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
     96              OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x210A             MOVS     R1,#+10
   \   00000048   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   00000050   0x6008             STR      R0,[R1, #+0]
     97          #endif
     98          
     99              if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD00B             BEQ.N    ??OSInit_0
    100                  p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   00000060   0x6809             LDR      R1,[R1, #+0]
    101                  if (p_stk != (CPU_STK *)0) {
   \   00000062   0x2900             CMP      R1,#+0
   \   00000064   0xD006             BEQ.N    ??OSInit_0
    102                      size  = OSCfg_ISRStkSize;
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xE002             B.N      ??OSInit_1
    103                      while (size > (CPU_STK_SIZE)0) {
    104                          size--;
   \                     ??OSInit_2: (+1)
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
    105                         *p_stk = (CPU_STK)0;
   \   0000006E   0xF841 0x2B04      STR      R2,[R1], #+4
    106                          p_stk++;
    107                      }
   \                     ??OSInit_1: (+1)
   \   00000072   0xD1FB             BNE.N    ??OSInit_2
    108                  }
    109              }
    110          
    111          #if OS_CFG_APP_HOOKS_EN > 0u
    112              OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
   \                     ??OSInit_0: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable17_13
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    113              OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable17_14
   \   00000080   0x6008             STR      R0,[R1, #+0]
    114              OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable17_15
   \   00000086   0x6008             STR      R0,[R1, #+0]
    115          
    116              OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    117              OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable17_17
   \   00000092   0x6008             STR      R0,[R1, #+0]
    118              OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \   00000098   0x6008             STR      R0,[R1, #+0]
    119              OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable17_19
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    120          #endif
    121          
    122          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    123              OSTaskRegNextAvailID    = (OS_REG_ID)0;
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable17_20
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    124          #endif
    125          
    126              OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
   \   000000A6   0x.... 0x....      BL       OS_PrioInit
    127          
    128              OS_RdyListInit();                                       /* Initialize the Ready List                              */
   \   000000AA   0x.... 0x....      BL       OS_RdyListInit
    129          
    130              
    131          #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
    132              OS_FlagInit(p_err);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       OS_FlagInit
    133              if (*p_err != OS_ERR_NONE) {
   \   000000B4   0x8820             LDRH     R0,[R4, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD12D             BNE.N    ??OSInit_3
    134                  return;
    135              }
    136          #endif
    137          
    138          
    139          #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
    140              OS_MemInit(p_err);
    141              if (*p_err != OS_ERR_NONE) {
    142                  return;
    143              }
    144          #endif
    145          
    146          
    147          #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
    148              OS_MsgPoolInit(p_err);
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       OS_MsgPoolInit
    149              if (*p_err != OS_ERR_NONE) {
   \   000000C0   0x8820             LDRH     R0,[R4, #+0]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD127             BNE.N    ??OSInit_3
    150                  return;
    151              }
    152          #endif
    153          
    154          
    155          #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
    156              OS_MutexInit(p_err);
    157              if (*p_err != OS_ERR_NONE) {
    158                  return;
    159              }
    160          #endif
    161          
    162          
    163          #if OS_CFG_Q_EN > 0u
    164              OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       OS_QInit
    165              if (*p_err != OS_ERR_NONE) {
   \   000000CC   0x8820             LDRH     R0,[R4, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD121             BNE.N    ??OSInit_3
    166                  return;
    167              }
    168          #endif
    169          
    170          
    171          #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
    172              OS_SemInit(p_err);
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       OS_SemInit
    173              if (*p_err != OS_ERR_NONE) {
   \   000000D8   0x8820             LDRH     R0,[R4, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD11B             BNE.N    ??OSInit_3
    174                  return;
    175              }
    176          #endif
    177          
    178          
    179          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    180              OS_TLS_Init(p_err);                                     /* Initialize Task Local Storage, before creating tasks   */
    181              if (*p_err != OS_ERR_NONE) {
    182                  return;
    183              }
    184          #endif
    185          
    186          
    187              OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       OS_TaskInit
    188              if (*p_err != OS_ERR_NONE) {
   \   000000E4   0x8820             LDRH     R0,[R4, #+0]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD115             BNE.N    ??OSInit_3
    189                  return;
    190              }
    191          
    192          
    193          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    194              OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
    195              if (*p_err != OS_ERR_NONE) {
    196                  return;
    197              }
    198          #endif
    199          
    200              
    201              OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       OS_IdleTaskInit
    202              if (*p_err != OS_ERR_NONE) {
   \   000000F0   0x8820             LDRH     R0,[R4, #+0]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD10F             BNE.N    ??OSInit_3
    203                  return;
    204              }
    205          
    206          
    207              OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       OS_TickTaskInit
    208              if (*p_err != OS_ERR_NONE) {
   \   000000FC   0x8820             LDRH     R0,[R4, #+0]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD109             BNE.N    ??OSInit_3
    209                  return;
    210              }
    211          
    212          
    213          #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
    214              OS_StatTaskInit(p_err);
    215              if (*p_err != OS_ERR_NONE) {
    216                  return;
    217              }
    218          #endif
    219          
    220          
    221          #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
    222              OS_TmrInit(p_err);
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0x.... 0x....      BL       OS_TmrInit
    223              if (*p_err != OS_ERR_NONE) {
   \   00000108   0x8820             LDRH     R0,[R4, #+0]
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD103             BNE.N    ??OSInit_3
    224                  return;
    225              }
    226          #endif
    227          
    228          
    229          #if OS_CFG_DBG_EN > 0u
    230              OS_Dbg_Init();
    231          #endif
    232          
    233          
    234              OSCfg_Init();
   \   0000010E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000112   0x.... 0x....      B.W      OSCfg_Init
   \                     ??OSInit_3: (+1)
   \   00000116   0xBD10             POP      {R4,PC}          ;; return
    235          }
    236          
    237          /*$PAGE*/
    238          /*
    239          ************************************************************************************************************************
    240          *                                                      ENTER ISR
    241          *
    242          * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
    243          *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
    244          *              the last nested ISR.
    245          *
    246          * Arguments  : none
    247          *
    248          * Returns    : none
    249          *
    250          * Note(s)    : 1) This function MUST be called with interrupts already disabled
    251          *
    252          *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
    253          *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
    254          *                 uC/OS-III variables.
    255          *
    256          *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
    257          *
    258          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    259          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    260          *                 at the end of the ISR.
    261          *
    262          *              5) You are allowed to nest interrupts up to 250 levels deep.
    263          ************************************************************************************************************************
    264          */
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void  OSIntEnter (void)
    267          {
    268              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
   \                     OSIntEnter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD106             BNE.N    ??OSIntEnter_0
    269                  return;                                             /* No                                                     */
    270              }
    271          
    272              if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000E   0x7801             LDRB     R1,[R0, #+0]
   \   00000010   0x29FA             CMP      R1,#+250
   \   00000012   0xDA01             BGE.N    ??OSIntEnter_0
    273                  return;                                             /* Yes                                                    */
    274              }
    275          
    276              OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    277          }
   \                     ??OSIntEnter_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    278          
    279          /*$PAGE*/
    280          /*
    281          ************************************************************************************************************************
    282          *                                                       EXIT ISR
    283          *
    284          * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
    285          *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
    286          *              ready to run.
    287          *
    288          * Arguments  : none
    289          *
    290          * Returns    : none
    291          *
    292          * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    293          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    294          *                 at the end of the ISR.
    295          *
    296          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    297          ************************************************************************************************************************
    298          */
    299          

   \                                 In section .text, align 2, keep-with-next
    300          void  OSIntExit (void)
    301          {
   \                     OSIntExit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    302              CPU_SR_ALLOC();
    303          
    304          
    305          
    306              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD14C             BNE.N    ??OSIntExit_0
    307                  return;                                             /* No                                                     */
    308              }
    309          
    310              CPU_INT_DIS();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   \   00000010   0x4604             MOV      R4,R0
    311              if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000016   0x7801             LDRB     R1,[R0, #+0]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD104             BNE.N    ??OSIntExit_1
    312                  CPU_INT_EN();
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      CPU_SR_Restore
    313                  return;
    314              }
    315              OSIntNestingCtr--;
   \                     ??OSIntExit_1: (+1)
   \   00000026   0x1E49             SUBS     R1,R1,#+1
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    316              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
   \   0000002A   0xB2C9             UXTB     R1,R1
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD004             BEQ.N    ??OSIntExit_2
    317                  CPU_INT_EN();                                       /* Yes                                                    */
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xE8BD 0x4010      POP      {R4,LR}
   \   00000036   0x.... 0x....      B.W      CPU_SR_Restore
    318                  return;
    319              }
    320          
    321              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
   \                     ??OSIntExit_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??OSIntExit_3
    322                  CPU_INT_EN();                                       /* Yes                                                    */
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x.... 0x....      B.W      CPU_SR_Restore
    323                  return;
    324              }
    325          
    326              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
   \                     ??OSIntExit_3: (+1)
   \   0000004E   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    327              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \   0000005C   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000060   0x0090             LSLS     R0,R2,#+2
   \   00000062   0x5840             LDR      R0,[R0, R1]
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000068   0x6008             STR      R0,[R1, #+0]
    328              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD104             BNE.N    ??OSIntExit_4
    329                  CPU_INT_EN();                                       /* Yes                                                    */
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0xE8BD 0x4010      POP      {R4,LR}
   \   0000007A   0x.... 0x....      B.W      CPU_SR_Restore
    330                  return;
    331              }
    332          
    333          #if OS_CFG_TASK_PROFILE_EN > 0u
    334              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
   \                     ??OSIntExit_4: (+1)
   \   0000007E   0xF8D0 0x1090      LDR      R1,[R0, #+144]
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \   00000084   0xF8C0 0x1090      STR      R1,[R0, #+144]
    335          #endif
    336              OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable17_22
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0x1C49             ADDS     R1,R1,#+1
   \   00000090   0x6001             STR      R1,[R0, #+0]
    337          
    338          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    339              OS_TLS_TaskSw();
    340          #endif
    341          
    342              OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
   \   00000092   0xF04F 0x5080      MOV      R0,#+268435456
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable17_23  ;; 0xe000ed04
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    343              CPU_INT_EN();
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A2   0x.... 0x....      B.W      CPU_SR_Restore
   \                     ??OSIntExit_0: (+1)
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
    344          }
    345          
    346          /*$PAGE*/
    347          /*
    348          ************************************************************************************************************************
    349          *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    350          *
    351          * Description: This function is called by the application code to indicate that all initialization has been completed
    352          *              and that kernel objects are no longer allowed to be created.
    353          *
    354          * Arguments  : none
    355          *
    356          * Returns    : none
    357          *
    358          * Note(s)    : none
    359          ************************************************************************************************************************
    360          */
    361          
    362          #ifdef OS_SAFETY_CRITICAL_IEC61508
    363          void  OSSafetyCriticalStart (void)
    364          {
    365              OSSafetyCriticalStartFlag = DEF_TRUE;
    366          }
    367          
    368          #endif
    369          
    370          /*$PAGE*/
    371          /*
    372          ************************************************************************************************************************
    373          *                                                      SCHEDULER
    374          *
    375          * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
    376          *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
    377          *              from ISRs (see OSIntExit() for ISR rescheduling).
    378          *
    379          * Arguments  : none
    380          *
    381          * Returns    : none
    382          *
    383          * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    384          ************************************************************************************************************************
    385          */
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void  OSSched (void)
    388          {
    389              CPU_SR_ALLOC();
    390          
    391          
    392          
    393              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
   \                     OSSched: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD000             BEQ.N    ??OSSched_0
   \   0000000A   0x4770             BX       LR
    394                  return;                                             /* Yes ... only schedule when no nested ISRs              */
    395              }
    396          
    397              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
   \                     ??OSSched_0: (+1)
   \   0000000C   0xB510             PUSH     {R4,LR}
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD12E             BNE.N    ??OSSched_1
    398                  return;                                             /* Yes                                                    */
    399              }
    400          
    401              CPU_INT_DIS();
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x4604             MOV      R4,R0
    402              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
   \   0000001E   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    403              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \   0000002C   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000030   0x0090             LSLS     R0,R2,#+2
   \   00000032   0x5840             LDR      R0,[R0, R1]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000038   0x6008             STR      R0,[R1, #+0]
    404              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD104             BNE.N    ??OSSched_2
    405                  CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x.... 0x....      B.W      CPU_SR_Restore
    406                  return;
    407              }
    408          
    409          #if OS_CFG_TASK_PROFILE_EN > 0u
    410              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
   \                     ??OSSched_2: (+1)
   \   0000004E   0xF8D0 0x1090      LDR      R1,[R0, #+144]
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \   00000054   0xF8C0 0x1090      STR      R1,[R0, #+144]
    411          #endif
    412              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable17_22
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x1C49             ADDS     R1,R1,#+1
   \   00000060   0x6001             STR      R1,[R0, #+0]
    413          
    414          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    415              OS_TLS_TaskSw();
    416          #endif
    417          
    418              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   \   00000062   0xF04F 0x5080      MOV      R0,#+268435456
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable17_23  ;; 0xe000ed04
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    419              CPU_INT_EN();
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000072   0x.... 0x....      B.W      CPU_SR_Restore
   \                     ??OSSched_1: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    420          }
    421          
    422          /*$PAGE*/
    423          /*
    424          ************************************************************************************************************************
    425          *                                                 PREVENT SCHEDULING
    426          *
    427          * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
    428          *              context switches until you are ready to permit context switching.
    429          *
    430          * Arguments  : p_err     is a pointer to a variable that will receive an error code:
    431          *
    432          *                            OS_ERR_NONE                 The scheduler is locked
    433          *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
    434          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet.
    435          *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR.
    436          *
    437          * Returns    : none
    438          *
    439          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    440          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    441          ************************************************************************************************************************
    442          */
    443          

   \                                 In section .text, align 2, keep-with-next
    444          void  OSSchedLock (OS_ERR  *p_err)
    445          {
   \                     OSSchedLock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    446              CPU_SR_ALLOC();
    447          
    448          
    449          
    450          #ifdef OS_SAFETY_CRITICAL
    451              if (p_err == (OS_ERR *)0) {
    452                  OS_SAFETY_CRITICAL_EXCEPTION();
    453                  return;
    454              }
    455          #endif
    456          
    457          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    458              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??OSSchedLock_0
    459                 *p_err = OS_ERR_SCHED_LOCK_ISR;
   \   0000000E   0xF646 0x5062      MOVW     R0,#+28002
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    460                  return;
   \   00000014   0xBD70             POP      {R4-R6,PC}
    461              }
    462          #endif
    463          
    464              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
   \                     ??OSSchedLock_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD003             BEQ.N    ??OSSchedLock_1
    465                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000020   0xF645 0x6089      MOVW     R0,#+24201
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    466                  return;
   \   00000026   0xBD70             POP      {R4-R6,PC}
    467              }
    468          
    469              if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
   \                     ??OSSchedLock_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable17_2
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x28FA             CMP      R0,#+250
   \   00000030   0xDB03             BLT.N    ??OSSchedLock_2
    470                 *p_err = OS_ERR_LOCK_NESTING_OVF;
   \   00000032   0xF245 0x2009      MOVW     R0,#+21001
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    471                  return;
   \   00000038   0xBD70             POP      {R4-R6,PC}
    472              }
    473          
    474              CPU_CRITICAL_ENTER();
   \                     ??OSSchedLock_2: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4606             MOV      R6,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
    475              OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
   \   00000044   0x7828             LDRB     R0,[R5, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x7028             STRB     R0,[R5, #+0]
    476          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    477              OS_SchedLockTimeMeasStart();
    478          #endif
    479              CPU_CRITICAL_EXIT();
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
    480             *p_err = OS_ERR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x8020             STRH     R0,[R4, #+0]
    481          }
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    482          
    483          /*$PAGE*/
    484          /*
    485          ************************************************************************************************************************
    486          *                                                  ENABLE SCHEDULING
    487          *
    488          * Description: This function is used to re-allow rescheduling.
    489          *
    490          * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
    491          *
    492          *                            OS_ERR_NONE
    493          *                            OS_ERR_OS_NOT_RUNNING       The scheduler has been enabled
    494          *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
    495          *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
    496          *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR.
    497          *
    498          * Returns    : none
    499          *
    500          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
    501          *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
    502          ************************************************************************************************************************
    503          */
    504          

   \                                 In section .text, align 2, keep-with-next
    505          void  OSSchedUnlock (OS_ERR  *p_err)
    506          {
   \                     OSSchedUnlock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    507              CPU_SR_ALLOC();
    508          
    509          
    510          
    511          #ifdef OS_SAFETY_CRITICAL
    512              if (p_err == (OS_ERR *)0) {
    513                  OS_SAFETY_CRITICAL_EXCEPTION();
    514                  return;
    515              }
    516          #endif
    517          
    518          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    519              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??OSSchedUnlock_0
    520                 *p_err = OS_ERR_SCHED_UNLOCK_ISR;
   \   0000000E   0xF646 0x5065      MOVW     R0,#+28005
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    521                  return;
   \   00000014   0xBD70             POP      {R4-R6,PC}
    522              }
    523          #endif
    524          
    525              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
   \                     ??OSSchedUnlock_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD003             BEQ.N    ??OSSchedUnlock_1
    526                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000020   0xF645 0x6089      MOVW     R0,#+24201
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    527                  return;
   \   00000026   0xBD70             POP      {R4-R6,PC}
    528              }
    529          
    530              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
   \                     ??OSSchedUnlock_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable17_2
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD103             BNE.N    ??OSSchedUnlock_2
    531                 *p_err = OS_ERR_SCHED_NOT_LOCKED;
   \   00000032   0xF646 0x5064      MOVW     R0,#+28004
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    532                  return;
   \   00000038   0xBD70             POP      {R4-R6,PC}
    533              }
    534          
    535              CPU_CRITICAL_ENTER();
   \                     ??OSSchedUnlock_2: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4606             MOV      R6,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
    536              OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
   \   00000044   0x7828             LDRB     R0,[R5, #+0]
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0x7028             STRB     R0,[R5, #+0]
    537              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
   \   0000004A   0xB2C0             UXTB     R0,R0
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD008             BEQ.N    ??OSSchedUnlock_3
    538                  CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000054   0x4630             MOV      R0,R6
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
    539                 *p_err = OS_ERR_SCHED_LOCKED;
   \   0000005A   0xF646 0x5063      MOVW     R0,#+28003
   \   0000005E   0x8020             STRH     R0,[R4, #+0]
    540                  return;
   \   00000060   0xBD70             POP      {R4-R6,PC}
    541              }
    542          
    543          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    544              OS_SchedLockTimeMeasStop();
    545          #endif
    546          
    547              CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
   \                     ??OSSchedUnlock_3: (+1)
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    548              OSSched();                                              /* Run the scheduler                                      */
   \   0000006C   0x.... 0x....      BL       OSSched
    549             *p_err = OS_ERR_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x8020             STRH     R0,[R4, #+0]
    550          }
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
    551          
    552          /*$PAGE*/
    553          /*
    554          ************************************************************************************************************************
    555          *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
    556          *
    557          * Description: This function is called to change the round-robin scheduling parameters.
    558          *
    559          * Arguments  : en                determines whether round-robin will be enabled (when DEF_EN) or not (when DEF_DIS)
    560          *
    561          *              dflt_time_quanta  default number of ticks between time slices.  0 means assumes OSCfg_TickRate_Hz / 10.
    562          *
    563          *              p_err             is a pointer to a variable that will contain an error code returned by this function.
    564          *
    565          *                                    OS_ERR_NONE    The call was successful
    566          *
    567          * Returns    : none
    568          ************************************************************************************************************************
    569          */
    570          
    571          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    572          void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
    573                                      OS_TICK       dflt_time_quanta,
    574                                      OS_ERR       *p_err)
    575          {
   \                     OSSchedRoundRobinCfg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4614             MOV      R4,R2
    576              CPU_SR_ALLOC();
    577          
    578          
    579          
    580          #ifdef OS_SAFETY_CRITICAL
    581              if (p_err == (OS_ERR *)0) {
    582                  OS_SAFETY_CRITICAL_EXCEPTION();
    583                  return;
    584              }
    585          #endif
    586          
    587              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    588              if (en != DEF_ENABLED) {
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \   00000016   0x2E01             CMP      R6,#+1
   \   00000018   0xD002             BEQ.N    ??OSSchedRoundRobinCfg_0
    589                  OSSchedRoundRobinEn = DEF_DISABLED;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
   \   0000001E   0xE001             B.N      ??OSSchedRoundRobinCfg_1
    590              } else {
    591                  OSSchedRoundRobinEn = DEF_ENABLED;
   \                     ??OSSchedRoundRobinCfg_0: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    592              }
    593          
    594              if (dflt_time_quanta > (OS_TICK)0) {
   \                     ??OSSchedRoundRobinCfg_1: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17_10
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xD001             BEQ.N    ??OSSchedRoundRobinCfg_2
    595                  OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
   \   0000002C   0x6007             STR      R7,[R0, #+0]
   \   0000002E   0xE006             B.N      ??OSSchedRoundRobinCfg_3
    596              } else {
    597                  OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
   \                     ??OSSchedRoundRobinCfg_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable17_9
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x220A             MOVS     R2,#+10
   \   00000038   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    598              }
    599              CPU_CRITICAL_EXIT();
   \                     ??OSSchedRoundRobinCfg_3: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       CPU_SR_Restore
    600             *p_err = OS_ERR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x8020             STRH     R0,[R4, #+0]
    601          }
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    602          #endif
    603          
    604          /*$PAGE*/
    605          /*
    606          ************************************************************************************************************************
    607          *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
    608          *
    609          * Description: This function is called to give up the CPU when it is done executing before its time slice expires.
    610          *
    611          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    612          *
    613          *                             OS_ERR_NONE                   The call was successful
    614          *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
    615          *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
    616          *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
    617          *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
    618          *
    619          * Returns    : none
    620          *
    621          * Note(s)    : 1) This function MUST be called from a task.
    622          ************************************************************************************************************************
    623          */
    624          
    625          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    626          void  OSSchedRoundRobinYield (OS_ERR  *p_err)
    627          {
   \                     OSSchedRoundRobinYield: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    628              OS_RDY_LIST  *p_rdy_list;
    629              OS_TCB       *p_tcb;
    630              CPU_SR_ALLOC();
    631          
    632          
    633          
    634          #ifdef OS_SAFETY_CRITICAL
    635              if (p_err == (OS_ERR *)0) {
    636                  OS_SAFETY_CRITICAL_EXCEPTION();
    637                  return;
    638              }
    639          #endif
    640          
    641          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    642              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??OSSchedRoundRobinYield_0
    643                 *p_err = OS_ERR_YIELD_ISR;
   \   0000000E   0xF248 0x40D1      MOVW     R0,#+34001
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    644                  return;
   \   00000014   0xBD70             POP      {R4-R6,PC}
    645              }
    646          #endif
    647          
    648              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
   \                     ??OSSchedRoundRobinYield_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD003             BEQ.N    ??OSSchedRoundRobinYield_1
    649                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000020   0xF646 0x5063      MOVW     R0,#+28003
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    650                  return;
   \   00000026   0xBD70             POP      {R4-R6,PC}
    651              }
    652          
    653              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
   \                     ??OSSchedRoundRobinYield_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD003             BEQ.N    ??OSSchedRoundRobinYield_2
    654                 *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
   \   00000032   0xF646 0x107B      MOVW     R0,#+27003
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    655                  return;
   \   00000038   0xBD70             POP      {R4-R6,PC}
    656              }
    657          
    658              CPU_CRITICAL_ENTER();
   \                     ??OSSchedRoundRobinYield_2: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4605             MOV      R5,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
    659              p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_21
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000052   0xEB00 0x0682      ADD      R6,R0,R2, LSL #+2
    660              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
   \   00000056   0x8930             LDRH     R0,[R6, #+8]
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xDA08             BGE.N    ??OSSchedRoundRobinYield_3
    661                  CPU_CRITICAL_EXIT();
   \   0000005C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       CPU_SR_Restore
    662                 *p_err = OS_ERR_ROUND_ROBIN_1;
   \   00000066   0xF646 0x107A      MOVW     R0,#+27002
   \   0000006A   0x8020             STRH     R0,[R4, #+0]
    663                  return;
   \   0000006C   0xBD70             POP      {R4-R6,PC}
    664              }
    665          
    666              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
   \                     ??OSSchedRoundRobinYield_3: (+1)
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
    667              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
   \   00000074   0x6830             LDR      R0,[R6, #+0]
    668              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
   \   00000076   0x6D41             LDR      R1,[R0, #+84]
   \   00000078   0x2900             CMP      R1,#+0
   \   0000007A   0xD104             BNE.N    ??OSSchedRoundRobinYield_4
    669                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0x6581             STR      R1,[R0, #+88]
   \   00000084   0xE000             B.N      ??OSSchedRoundRobinYield_5
    670              } else {
    671                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
   \                     ??OSSchedRoundRobinYield_4: (+1)
   \   00000086   0x6581             STR      R1,[R0, #+88]
    672              }
    673          
    674              CPU_CRITICAL_EXIT();
   \                     ??OSSchedRoundRobinYield_5: (+1)
   \   00000088   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
    675          
    676              OSSched();                                              /* Run new task                                           */
   \   00000092   0x.... 0x....      BL       OSSched
    677             *p_err = OS_ERR_NONE;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x8020             STRH     R0,[R4, #+0]
    678          }
   \   0000009A   0xBD70             POP      {R4-R6,PC}       ;; return
    679          #endif
    680          
    681          /*$PAGE*/
    682          /*
    683          ************************************************************************************************************************
    684          *                                                 START MULTITASKING
    685          *
    686          * Description: This function is used to start the multitasking process which lets uC/OS-III manages the task that you
    687          *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
    688          *              one application task.
    689          *
    690          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    691          *
    692          *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned.
    693          *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
    694          *
    695          * Returns    : none
    696          *
    697          * Note(s)    : 1) OSStartHighRdy() MUST:
    698          *                 a) Call OSTaskSwHook() then,
    699          *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
    700          *                 c) Execute the task.
    701          *
    702          *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
    703          ************************************************************************************************************************
    704          */
    705          

   \                                 In section .text, align 2, keep-with-next
    706          void  OSStart (OS_ERR  *p_err)
    707          {
   \                     OSStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    708          #ifdef OS_SAFETY_CRITICAL
    709              if (p_err == (OS_ERR *)0) {
    710                  OS_SAFETY_CRITICAL_EXCEPTION();
    711                  return;
    712              }
    713          #endif
    714          
    715              if (OSRunning == OS_STATE_OS_STOPPED) {
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable17_1
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11B             BNE.N    ??OSStart_0
    716                  OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
   \   0000000E   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    717                  OSPrioCur       = OSPrioHighRdy;
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    718                 
    719                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \   00000022   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000026   0x0090             LSLS     R0,R2,#+2
   \   00000028   0x5840             LDR      R0,[R0, R1]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    720                  OSTCBCurPtr     = OSTCBHighRdyPtr;
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000034   0x6008             STR      R0,[R1, #+0]
    721                  
    722                  OSRunning       = OS_STATE_OS_RUNNING;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7028             STRB     R0,[R5, #+0]
    723                 
    724                  OSStartHighRdy();                                   /* Execute target specific code to start task             */
   \   0000003A   0x.... 0x....      BL       OSStartHighRdy
    725          
    726          
    727                  *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
   \   0000003E   0xF643 0x2099      MOVW     R0,#+15001
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
    728              } else {
    729                 *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
   \                     ??OSStart_0: (+1)
   \   00000046   0xF645 0x608A      MOVW     R0,#+24202
   \   0000004A   0x8020             STRH     R0,[R4, #+0]
    730              }
    731          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    732          
    733          /*$PAGE*/
    734          /*
    735          ************************************************************************************************************************
    736          *                                                    GET VERSION
    737          *
    738          * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
    739          *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
    740          *
    741          * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
    742          *                      variable to
    743          *
    744          *                         OS_ERR_NONE
    745          *
    746          * Returns    : The version number of uC/OS-III multiplied by 10000.
    747          ************************************************************************************************************************
    748          */
    749          

   \                                 In section .text, align 2, keep-with-next
    750          CPU_INT16U  OSVersion (OS_ERR  *p_err)
    751          {
    752          #ifdef OS_SAFETY_CRITICAL
    753              if (p_err == (OS_ERR *)0) {
    754                  OS_SAFETY_CRITICAL_EXCEPTION();
    755                  return ((CPU_INT16U)0u);
    756              }
    757          #endif
    758          
    759             *p_err = OS_ERR_NONE;
   \                     OSVersion: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    760              return (OS_VERSION);
   \   00000004   0xF247 0x605D      MOVW     R0,#+30301
   \   00000008   0x4770             BX       LR               ;; return
    761          }
    762          
    763          /*$PAGE*/
    764          /*
    765          ************************************************************************************************************************
    766          *                                                      IDLE TASK
    767          *
    768          * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
    769          *              they are ALL waiting for event(s) to occur.
    770          *
    771          * Arguments  : p_arg    is an argument passed to the task when the task is created.
    772          *
    773          * Returns    : none
    774          *
    775          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    776          *
    777          *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
    778          *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
    779          *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
    780          *                 uC/OS-III would thus never recognize interrupts.
    781          *
    782          *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
    783          ************************************************************************************************************************
    784          */
    785          

   \                                 In section .text, align 2, keep-with-next
    786          void  OS_IdleTask (void  *p_arg)
    787          {
   \                     OS_IdleTask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    788              CPU_SR_ALLOC();
    789          
    790          
    791          
    792              p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
    793          
    794              while (DEF_ON) {
    795                  CPU_CRITICAL_ENTER();
   \                     ??OS_IdleTask_0: (+1)
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      BL       CPU_IntDisMeasStart
    796                  OSIdleTaskCtr++;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17_24
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    797          #if OS_CFG_STAT_TASK_EN > 0u
    798                  OSStatTaskCtr++;
    799          #endif
    800                  CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    801          
    802                  OSIdleTaskHook();                                   /* Call user definable HOOK                               */
   \   00000020   0x.... 0x....      BL       OSIdleTaskHook
   \   00000024   0xE7ED             B.N      ??OS_IdleTask_0
    803              }
    804          }
    805          
    806          /*$PAGE*/
    807          /*
    808          ************************************************************************************************************************
    809          *                                               INITIALIZE THE IDLE TASK
    810          *
    811          * Description: This function initializes the idle task
    812          *
    813          * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
    814          *
    815          * Returns    : none
    816          *
    817          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    818          ************************************************************************************************************************
    819          */
    820          

   \                                 In section .text, align 2, keep-with-next
    821          void  OS_IdleTaskInit (OS_ERR  *p_err)
    822          {
   \                     OS_IdleTaskInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    823          #ifdef OS_SAFETY_CRITICAL
    824              if (p_err == (OS_ERR *)0) {
    825                  OS_SAFETY_CRITICAL_EXCEPTION();
    826                  return;
    827              }
    828          #endif
    829          
    830              OSIdleTaskCtr = (OS_IDLE_CTR)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable17_24
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    831                                                                      /* ---------------- CREATE THE IDLE TASK ---------------- */
    832              OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
    833                           (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
    834                           (OS_TASK_PTR)OS_IdleTask,
    835                           (void       *)0,
    836                           (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
    837                           (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
    838                           (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
    839                           (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
    840                           (OS_MSG_QTY  )0u,
    841                           (OS_TICK     )0u,
    842                           (void       *)0,
    843                           (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    844                           (OS_ERR     *)p_err);
   \   0000000C   0x9008             STR      R0,[SP, #+32]
   \   0000000E   0x200B             MOVS     R0,#+11
   \   00000010   0x9007             STR      R0,[SP, #+28]
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x9006             STR      R0,[SP, #+24]
   \   00000016   0x9005             STR      R0,[SP, #+20]
   \   00000018   0x9004             STR      R0,[SP, #+16]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17_25
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x9003             STR      R0,[SP, #+12]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x9002             STR      R0,[SP, #+8]
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_27
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x201F             MOVS     R0,#+31
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x460B             MOV      R3,R1
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable17_28
   \   0000003C   0x.... 0x....      ADR.W    R1,?_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_29
   \   00000044   0x.... 0x....      BL       OSTaskCreate
    845          }
   \   00000048   0xB009             ADD      SP,SP,#+36
   \   0000004A   0xBD00             POP      {PC}             ;; return
    846          
    847          /*$PAGE*/
    848          /*
    849          ************************************************************************************************************************
    850          *                                             BLOCK A TASK PENDING ON EVENT
    851          *
    852          * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
    853          *              exist because it is common to a number of OSxxxPend() services.
    854          *
    855          * Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
    856          *              -----------    pending on the desired object.
    857          
    858          *              p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
    859          *              -----          the caller must pass a NULL pointer.
    860          *
    861          *              pending_on     Specifies what the task will be pending on:
    862          *
    863          *                                 OS_TASK_PEND_ON_FLAG
    864          *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
    865          *                                 OS_TASK_PEND_ON_MUTEX
    866          *                                 OS_TASK_PEND_ON_Q
    867          *                                 OS_TASK_PEND_ON_SEM
    868          *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
    869          *
    870          *              timeout        Is the amount of time the task will wait for the event to occur.
    871          *
    872          * Returns    : none
    873          *
    874          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    875          ************************************************************************************************************************
    876          */
    877          

   \                                 In section .text, align 2, keep-with-next
    878          void  OS_Pend (OS_PEND_DATA  *p_pend_data,
    879                         OS_PEND_OBJ   *p_obj,
    880                         OS_STATE       pending_on,
    881                         OS_TICK        timeout)
    882          {
   \                     OS_Pend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4619             MOV      R1,R3
    883              OS_PEND_LIST  *p_pend_list;
    884          
    885          
    886          
    887              OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable17_3
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF880 0x2034      STRB     R2,[R0, #+52]
    888              OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6822             LDR      R2,[R4, #+0]
   \   00000016   0xF882 0x0035      STRB     R0,[R2, #+53]
    889          
    890              OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
    891                           timeout);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       OS_TaskBlock
    892          
    893              if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD00B             BEQ.N    ??OS_Pend_0
    894                  p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
    895                  p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
   \   00000024   0x60EE             STR      R6,[R5, #+12]
    896                  OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
    897                                  (OS_PEND_DATA *)p_pend_data,
    898                                  (OS_OBJ_QTY    )1);
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       OS_PendDataInit
    899                  OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
    900                                        p_pend_data);
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000036   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003A   0x....             B.N      OS_PendListInsertPrio
    901              } else {
    902                  OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
   \                     ??OS_Pend_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x87C8             STRH     R0,[R1, #+62]
    903                  OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6308             STR      R0,[R1, #+48]
    904              }
    905          #if OS_CFG_DBG_EN > 0u
    906              OS_PendDbgNameAdd(p_obj,
    907                                OSTCBCurPtr);
    908          #endif
    909          }
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    910          
    911          /*$PAGE*/
    912          /*
    913          ************************************************************************************************************************
    914          *                                                     ABORT PENDING
    915          *
    916          * Description: This function is called by OSxxxPendAbort() functions to abort pending on an event.
    917          *
    918          * Arguments  : p_obj          Is a pointer to the object to pend abort.
    919          *              -----
    920          *
    921          *              p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
    922          *              -----
    923          *
    924          *              ts             The is a timestamp as to when the pend abort occurred
    925          *
    926          * Returns    : none
    927          *
    928          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    929          ************************************************************************************************************************
    930          */
    931          

   \                                 In section .text, align 2, keep-with-next
    932          void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
    933                              OS_TCB       *p_tcb,
    934                              CPU_TS        ts)
    935          {
   \                     OS_PendAbort: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    936              switch (p_tcb->TaskState) {
   \   00000008   0xF105 0x0734      ADD      R7,R5,#+52
   \   0000000C   0x78B8             LDRB     R0,[R7, #+2]
   \   0000000E   0x1E80             SUBS     R0,R0,#+2
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD903             BLS.N    ??OS_PendAbort_0
   \   00000014   0x1F00             SUBS     R0,R0,#+4
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD919             BLS.N    ??OS_PendAbort_1
   \   0000001A   0xBDF1             POP      {R0,R4-R7,PC}
    937                  case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
    938                  case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
    939                  case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
    940                  case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
    941                       break;
    942          
    943                  case OS_TASK_STATE_PEND:
    944                  case OS_TASK_STATE_PEND_TIMEOUT:
    945                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendAbort_0: (+1)
   \   0000001C   0x7838             LDRB     R0,[R7, #+0]
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD102             BNE.N    ??OS_PendAbort_2
    946                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    947                                         p_tcb,
    948                                         ts);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       OS_PendAbort1
    949                       }
    950          #if (OS_MSG_EN > 0u)
    951                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_PendAbort_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x62B8             STR      R0,[R7, #+40]
    952                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   0000002C   0x85B8             STRH     R0,[R7, #+44]
    953          #endif
    954                       p_tcb->TS         = ts;
   \   0000002E   0x60FE             STR      R6,[R7, #+12]
    955                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD002             BEQ.N    ??OS_PendAbort_3
    956                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       OS_PendListRemove
    957                       }
    958                       OS_TaskRdy(p_tcb);
   \                     ??OS_PendAbort_3: (+1)
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       OS_TaskRdy
    959                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x70B8             STRB     R0,[R7, #+2]
    960                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7078             STRB     R0,[R7, #+1]
    961                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7038             STRB     R0,[R7, #+0]
    962                       break;
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}
    963          
    964                  case OS_TASK_STATE_PEND_SUSPENDED:
    965                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    966                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendAbort_1: (+1)
   \   0000004E   0x7838             LDRB     R0,[R7, #+0]
   \   00000050   0x2803             CMP      R0,#+3
   \   00000052   0xD102             BNE.N    ??OS_PendAbort_4
    967                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    968                                         p_tcb,
    969                                         ts);
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       OS_PendAbort1
    970                       }
    971          #if (OS_MSG_EN > 0u)
    972                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_PendAbort_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x62B8             STR      R0,[R7, #+40]
    973                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   0000005E   0x85B8             STRH     R0,[R7, #+44]
    974          #endif
    975                       p_tcb->TS         = ts;
   \   00000060   0x60FE             STR      R6,[R7, #+12]
    976                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD002             BEQ.N    ??OS_PendAbort_5
    977                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       OS_PendListRemove
    978                       }
    979                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   \                     ??OS_PendAbort_5: (+1)
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       OS_TickListRemove
    980                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x70B8             STRB     R0,[R7, #+2]
    981                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x7078             STRB     R0,[R7, #+1]
    982                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7038             STRB     R0,[R7, #+0]
    983                       break;
    984          
    985                  default:
    986                       break;
    987              }
    988          }
   \   0000007E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    989          
    990          /*$PAGE*/
    991          /*
    992          ************************************************************************************************************************
    993          *                                           PEND ABORT A TASK PENDING ON MULTIPLE OBJECTS
    994          *
    995          * Description: This function is called when a task is pending on multiple objects and one of the objects has been pend
    996          *              aborted.  This function needs to indicate to the caller which object was pend aborted by placing the
    997          *              address of the object in the OS_PEND_DATA table corresponding to the pend aborted object.
    998          *
    999          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1000          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries of the
   1001          *              OS_TCB would be set to six (6) in this case.  As shown, when the pend call returns because a task pend
   1002          *              aborted 'Obj C' then, only the one entry contains the .RdyObjPtr filled in data and the other entries
   1003          *              contains NULL pointers and zero data.
   1004          *
   1005          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1006          *
   1007          *
   1008          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1009          *                                         +--------------+--------------+--------------+--------------+--------------+
   1010          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1011          *                                         +--------------+--------------+--------------+--------------+--------------+
   1012          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1013          *                                         +--------------+--------------+--------------+--------------+--------------+
   1014          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
   1015          *                                         +--------------+--------------+--------------+--------------+--------------+
   1016          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1017          *                                         +--------------+--------------+--------------+--------------+--------------+
   1018          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1019          *                                         +--------------+--------------+--------------+--------------+--------------+
   1020          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1021          *                                         +--------------+--------------+--------------+--------------+--------------+
   1022          *
   1023          *
   1024          * Arguments  : p_obj        is a pointer to the object being pend aborted to
   1025          *              -----
   1026          *
   1027          *              p_tcb        is a pointer to the OS_TCB of the task that we'll abort he pend for
   1028          *              -----
   1029          *
   1030          *              ts           is the time stamp of when the pend abort occurred
   1031          *
   1032          * Returns    : none
   1033          *
   1034          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1035          ************************************************************************************************************************
   1036          */
   1037          

   \                                 In section .text, align 2, keep-with-next
   1038          void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
   1039                               OS_TCB       *p_tcb,
   1040                               CPU_TS        ts)
   1041          {
   \                     OS_PendAbort1: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1042              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1043              OS_PEND_DATA   *p_pend_data;
   1044          
   1045          
   1046          
   1047              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000002   0x6B0B             LDR      R3,[R1, #+48]
   1048              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000004   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000006   0xE001             B.N      ??OS_PendAbort1_0
   1049          
   1050              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1051                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
   1052                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   1053                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
   1054                      break;
   1055                  }
   1056                  p_pend_data++;
   \                     ??OS_PendAbort1_1: (+1)
   \   00000008   0x3320             ADDS     R3,R3,#+32
   1057                  n_pend_list--;
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \                     ??OS_PendAbort1_0: (+1)
   \   0000000C   0xB289             UXTH     R1,R1
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ.N    ??OS_PendAbort1_2
   \   00000012   0x68DC             LDR      R4,[R3, #+12]
   \   00000014   0x42A0             CMP      R0,R4
   \   00000016   0xD1F7             BNE.N    ??OS_PendAbort1_1
   \   00000018   0x6118             STR      R0,[R3, #+16]
   \   0000001A   0x61DA             STR      R2,[R3, #+28]
   1058              }
   1059          }
   \                     ??OS_PendAbort1_2: (+1)
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
   1060          
   1061          /*$PAGE*/
   1062          /*
   1063          ************************************************************************************************************************
   1064          *                                              INITIALIZE A WAIT LIST TABLE
   1065          *
   1066          * Description: This function is called to initialize the fields of a table of OS_PEND_DATA entries.  It's assumed that
   1067          *              the .PendObjPtr field of each entry in the table is set by the caller and thus will NOT be touched by
   1068          *              this function.
   1069          *
   1070          * Arguments  : p_tcb              is a pointer to the TCB of the task that we want to pend abort.
   1071          *              -----
   1072          *
   1073          *              p_pend_data_tbl    is a pointer to a table (see below) of OS_PEND_DATA elements to initialize.
   1074          *              ---------------
   1075          *
   1076          *                                  .PendObjPtr .RdyObjPtr .RdyMsgPtr .RdyMsgSize .RdyTS .TCBPtr .NextPtr .PrevPtr
   1077          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    ^
   1078          *               p_pend_data_tbl-> |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1079          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1080          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1081          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1082          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1083          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+  size
   1084          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1085          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1086          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1087          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1088          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1089          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    V
   1090          *
   1091          *              tbl_size           is the size of the table in number of entries
   1092          *
   1093          * Returns    : none
   1094          *
   1095          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1096          *
   1097          *              2) It's possible for the table to be of size 1 when multi-pend is not used
   1098          *
   1099          *              3) Note that the .PendObjPtr is NOT touched because it's assumed to be set by the caller.
   1100          ************************************************************************************************************************
   1101          */
   1102          

   \                                 In section .text, align 2, keep-with-next
   1103          void  OS_PendDataInit (OS_TCB        *p_tcb,
   1104                                 OS_PEND_DATA  *p_pend_data_tbl,
   1105                                 OS_OBJ_QTY     tbl_size)
   1106          {
   \                     OS_PendDataInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1107              OS_OBJ_QTY  i;
   1108          
   1109          
   1110          
   1111              p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
   \   00000002   0x87C2             STRH     R2,[R0, #+62]
   1112              p_tcb->PendDataTblPtr     = p_pend_data_tbl;
   \   00000004   0x6301             STR      R1,[R0, #+48]
   1113          
   1114              for (i = 0u; i < tbl_size; i++) {
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x461C             MOV      R4,R3
   \   0000000A   0xE008             B.N      ??OS_PendDataInit_0
   1115                  p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
   \                     ??OS_PendDataInit_1: (+1)
   \   0000000C   0x604C             STR      R4,[R1, #+4]
   1116                  p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
   \   0000000E   0x600C             STR      R4,[R1, #+0]
   1117                  p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
   \   00000010   0x610C             STR      R4,[R1, #+16]
   1118                  p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
   \   00000012   0x614C             STR      R4,[R1, #+20]
   1119                  p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
   \   00000014   0x830C             STRH     R4,[R1, #+24]
   1120                  p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
   \   00000016   0x61CC             STR      R4,[R1, #+28]
   1121                  p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
   \   00000018   0x6088             STR      R0,[R1, #+8]
   1122                  p_pend_data_tbl++;
   \   0000001A   0x3120             ADDS     R1,R1,#+32
   1123              }
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OS_PendDataInit_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x4293             CMP      R3,R2
   \   00000022   0xD3F3             BCC.N    ??OS_PendDataInit_1
   1124          }
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
   1125          
   1126          /*$PAGE*/
   1127          /*
   1128          ************************************************************************************************************************
   1129          *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
   1130          *
   1131          * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
   1132          *              using a kernel aware tool.
   1133          *
   1134          * Arguments  : p_obj              is a pointer to the object being pended on
   1135          *
   1136          *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
   1137          *
   1138          * Returns    : none
   1139          *
   1140          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
   1141          ************************************************************************************************************************
   1142          */
   1143          
   1144          
   1145          #if OS_CFG_DBG_EN > 0u
   1146          void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
   1147                                   OS_TCB       *p_tcb)
   1148          {
   1149              OS_PEND_LIST  *p_pend_list;
   1150              OS_PEND_DATA  *p_pend_data;
   1151              OS_TCB        *p_tcb1;
   1152          
   1153          
   1154              if (p_obj != (OS_PEND_OBJ *)0) {
   1155                  p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
   1156                  p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
   1157                  p_pend_data       =  p_pend_list->HeadPtr;
   1158                  p_tcb1            =  p_pend_data->TCBPtr;
   1159                  p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
   1160              } else {
   1161                  switch (p_tcb->PendOn) {
   1162                      case OS_TASK_PEND_ON_TASK_Q:
   1163                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   1164                           break;
   1165          
   1166                      case OS_TASK_PEND_ON_TASK_SEM:
   1167                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   1168                           break;
   1169          
   1170                      default:
   1171                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   1172                           break;
   1173                  }
   1174              }
   1175          }
   1176          
   1177          
   1178          
   1179          void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
   1180                                      OS_TCB       *p_tcb)
   1181          {
   1182              OS_PEND_LIST  *p_pend_list;
   1183              OS_PEND_DATA  *p_pend_data;
   1184              OS_TCB        *p_tcb1;
   1185          
   1186          
   1187              p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
   1188              p_pend_list       = &p_obj->PendList;
   1189              p_pend_data       =  p_pend_list->HeadPtr;
   1190              if (p_pend_data  != (OS_PEND_DATA *)0) {
   1191                  p_tcb1            = p_pend_data->TCBPtr;
   1192                  p_obj->DbgNamePtr = p_tcb1->NamePtr;
   1193              } else {
   1194                  p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
   1195              }
   1196          }
   1197          #endif
   1198          
   1199          /*$PAGE*/
   1200          /*
   1201          ************************************************************************************************************************
   1202          *                               CHANGE THE PRIORITY OF A TASK WAITING IN ONE OR MORE PEND LISTS
   1203          *
   1204          * Description: This function is called to change the position of a task waiting in one or more pend lists.  Because a
   1205          *              task can be waiting on multiple objects then each pend list needs to be updated.  Specifically, the
   1206          *              task can be the highest priority task waiting on one pend list, the lowest priority task waiting in yet
   1207          *              another pend list or somewhere else in another pend list.  Because of this, we need to be able to change
   1208          *              each of those pend lists individually.
   1209          *
   1210          *              The drawing below shows an example of a task (OS_TCB) that belongs to 3 separate pend lists.  Each
   1211          *              pend list can contain multiple tasks (the .PrevPtr and .NextPtr show a '?' to indicate this).  The OS_TCB
   1212          *              contains a pointer (.PendDataTblPtr) to the first entry in the list of pend lists.
   1213          *
   1214          *                                                                                                          OS_TCB
   1215          *                                                                                                   +--------------------+
   1216          *                                                                                                   |                    |
   1217          *                                                                                                   +--------------------+
   1218          *                                                                                                   | PendDataTblEntries |
   1219          *                                      Point to first entry in the OS_PEND_DATA table (i.e. [0])    +--------------------+
   1220          *                                          /-----------------------------<------------------------- | PendDataTblPtr     |
   1221          *                                          |                                                        +--------------------+
   1222          *                                          |                                                                 ^
   1223          *              OS_PEND_LIST                |                                                                 |
   1224          *              +------------+              |                                                                 |
   1225          *              | TailPtr    |              |                                                                 |
   1226          *              +------------+              |                                                                 |
   1227          *              | HeadPtr    |              |                                                                 |
   1228          *              +------------+              |                                        /---------->-------------/
   1229          *              | NbrEntries |              |                                        |                        |
   1230          *              +------------+     [0]      V   OS_PEND_DATA                         |                        |
   1231          *                                     +---------+------------+-------+---------+--------+---------+          |
   1232          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1233          *                                     +---------+------------+-------+---------+--------+---------+          |
   1234          *                                                                                                            |
   1235          *                                                                                                            |
   1236          *                                                                                                            |
   1237          *                                                                                                            |
   1238          *                                                                                                            |
   1239          *              OS_PEND_LIST                                                                Point back to TCB |
   1240          *              +------------+                                                                                |
   1241          *              | TailPtr    |                                                                                |
   1242          *              +------------+                                                                                |
   1243          *              | HeadPtr    |                                                                                |
   1244          *              +------------+                                                      /----------->-------------/
   1245          *              | NbrEntries |                                                      |                         |
   1246          *              +------------+     [1]          OS_PEND_DATA                        |                         |
   1247          *                                     +---------+------------+-------+---------+--------+---------+          |
   1248          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1249          *                                     +---------+------------+-------+---------+--------+---------+          |
   1250          *                                                                                                            |
   1251          *                                                                                                            |
   1252          *                                                                                                            |
   1253          *                                                                                                            |
   1254          *                                                                                                            |
   1255          *              OS_PEND_LIST                                                                                  |
   1256          *              +------------+                                                                                |
   1257          *              | TailPtr    |                                                                                |
   1258          *              +------------+                                                                                |
   1259          *              | HeadPtr    |                                                                                |
   1260          *              +------------+                                                      /----------->-------------/
   1261          *              | NbrEntries |                                                      |
   1262          *              +------------+     [2]          OS_PEND_DATA                        |
   1263          *                                     +---------+------------+-------+---------+--------+---------+
   1264          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | ----> ?
   1265          *                                     +---------+------------+-------+---------+--------+---------+
   1266          *
   1267          *
   1268          * Arguments  : p_tcb       is a pointer to the TCB of the task to move
   1269          *              -----
   1270          *
   1271          *              prio_new    is the new priority for the task
   1272          *
   1273          * Returns    : none
   1274          *
   1275          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1276          *
   1277          *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1278          ************************************************************************************************************************
   1279          */
   1280          

   \                                 In section .text, align 2, keep-with-next
   1281          void  OS_PendListChangePrio (OS_TCB   *p_tcb,
   1282                                       OS_PRIO   prio_new)
   1283          {
   \                     OS_PendListChangePrio: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1284              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1285              OS_PEND_DATA   *p_pend_data;
   1286              OS_PEND_LIST   *p_pend_list;
   1287              OS_PEND_OBJ    *p_obj;
   1288          
   1289          
   1290              p_tcb->Prio = prio_new;
   \   00000002   0x3030             ADDS     R0,R0,#+48
   \   00000004   0x71C1             STRB     R1,[R0, #+7]
   1291              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
   \   00000006   0x6804             LDR      R4,[R0, #+0]
   1292              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
   \   00000008   0x89C5             LDRH     R5,[R0, #+14]
   \   0000000A   0xE00F             B.N      ??OS_PendListChangePrio_0
   1293          
   1294              while (n_pend_list > 0u) {
   1295                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   1296                  p_pend_list = &p_obj->PendList;
   \                     ??OS_PendListChangePrio_1: (+1)
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0xF100 0x0608      ADD      R6,R0,#+8
   1297                  if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
   \   00000012   0x8930             LDRH     R0,[R6, #+8]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD307             BCC.N    ??OS_PendListChangePrio_2
   1298                      OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
   1299                                         p_pend_data);
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x.... 0x....      BL       OS_PendListRemove1
   1300                      OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
   1301                                            p_pend_data);
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       OS_PendListInsertPrio
   1302                  }
   1303                  p_pend_data++;                                              /* Point to next wait list                        */
   \                     ??OS_PendListChangePrio_2: (+1)
   \   00000028   0x3420             ADDS     R4,R4,#+32
   1304                  n_pend_list--;
   \   0000002A   0x1E6D             SUBS     R5,R5,#+1
   1305              }
   \                     ??OS_PendListChangePrio_0: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD1EC             BNE.N    ??OS_PendListChangePrio_1
   1306          }
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
   1307          
   1308          /*$PAGE*/
   1309          /*
   1310          ************************************************************************************************************************
   1311          *                                                INITIALIZE A WAIT LIST
   1312          *
   1313          * Description: This function is called to initialize the fields of an OS_PEND_LIST.
   1314          *
   1315          * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
   1316          *              -----------
   1317          *
   1318          * Returns    : none
   1319          *
   1320          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1321          ************************************************************************************************************************
   1322          */
   1323          

   \                                 In section .text, align 2, keep-with-next
   1324          void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
   1325          {
   1326              p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
   \                     OS_PendListInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1327              p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
   \   00000004   0x6041             STR      R1,[R0, #+4]
   1328              p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
   \   00000006   0x8101             STRH     R1,[R0, #+8]
   1329          }
   \   00000008   0x4770             BX       LR               ;; return
   1330          
   1331          /*$PAGE*/
   1332          /*
   1333          ************************************************************************************************************************
   1334          *                                     INSERT PEND DATA AT THE BEGINNING OF A WAIT LIST
   1335          *
   1336          * Description: This function is called to place an OS_PEND_DATA entry at the beginning of a linked list as follows:
   1337          *
   1338          *              CASE 0: Insert in an empty list.
   1339          *
   1340          *                     OS_PEND_LIST
   1341          *                     +--------------+
   1342          *                     | TailPtr      |-> 0
   1343          *                     +--------------+
   1344          *                     | HeadPtr      |-> 0
   1345          *                     +--------------+
   1346          *                     | NbrEntries=0 |
   1347          *                     +--------------+
   1348          *
   1349          *
   1350          *
   1351          *              CASE 1: Insert BEFORE the current head of list
   1352          *
   1353          *                     OS_PEND_LIST
   1354          *                     +--------------+         OS_PEND_DATA
   1355          *                     | TailPtr      |--+---> +------------+
   1356          *                     +--------------+  |     | NextPtr    |->0
   1357          *                     | HeadPtr      |--/     +------------+
   1358          *                     +--------------+     0<-| PrevPtr    |
   1359          *                     | NbrEntries=1 |        +------------+
   1360          *                     +--------------+        |            |
   1361          *                                             +------------+
   1362          *                                             |            |
   1363          *                                             +------------+
   1364          *
   1365          *
   1366          * Arguments  : p_pend_list    is a pointer to a wait list found inside an object.  The OS_PEND_DATA entry will be
   1367          *              -----------    inserted at the head of the list.
   1368          *
   1369          *              p_pend_data    is a pointer to the OS_PEND_DATA entry to add to the list
   1370          *              -----------
   1371          *
   1372          * Returns    : none
   1373          *
   1374          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1375          ************************************************************************************************************************
   1376          */
   1377          

   \                                 In section .text, align 2, keep-with-next
   1378          void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
   1379                                       OS_PEND_DATA  *p_pend_data)
   1380          {
   1381              OS_PEND_DATA  *p_pend_data_next;
   1382          
   1383          
   1384          
   1385              p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
   \                     OS_PendListInsertHead: (+1)
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0x1C52             ADDS     R2,R2,#+1
   \   00000004   0x8102             STRH     R2,[R0, #+8]
   1386              p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x604A             STR      R2,[R1, #+4]
   1387              p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   1388              p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   1389              if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD000             BEQ.N    ??OS_PendListInsertHead_0
   1390                  p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
   \   00000014   0x6011             STR      R1,[R2, #+0]
   1391              }
   1392              p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
   \                     ??OS_PendListInsertHead_0: (+1)
   \   00000016   0x6001             STR      R1,[R0, #+0]
   1393              if (p_pend_list->NbrEntries == 1u) {
   \   00000018   0x8902             LDRH     R2,[R0, #+8]
   \   0000001A   0x2A01             CMP      R2,#+1
   \   0000001C   0xD100             BNE.N    ??OS_PendListInsertHead_1
   1394                  p_pend_list->TailPtr = p_pend_data;
   \   0000001E   0x6041             STR      R1,[R0, #+4]
   1395              }
   1396          }
   \                     ??OS_PendListInsertHead_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1397          
   1398          /*$PAGE*/
   1399          /*
   1400          ************************************************************************************************************************
   1401          *                                   INSERT PEND DATA BASED ON IT'S PRIORITY IN A LIST
   1402          *
   1403          * Description: This function is called to place an OS_PEND_DATA entry in a linked list based on its priority.  The
   1404          *              highest priority being placed at the head of the list.  It's assumed that the OS_PEND_DATA entry to
   1405          *              insert points to the TCB of the task being inserted.  The TCB is also assumed to contain the priority
   1406          *              of the task in its .Prio field.
   1407          *
   1408          *              CASE 0: Insert in an empty list.
   1409          *
   1410          *                     OS_PEND_LIST
   1411          *                     +---------------+
   1412          *                     | TailPtr       |-> 0
   1413          *                     +---------------+
   1414          *                     | HeadPtr       |-> 0
   1415          *                     +---------------+
   1416          *                     | NbrEntries=0  |
   1417          *                     +---------------+
   1418          *
   1419          *
   1420          *
   1421          *              CASE 1: Insert BEFORE or AFTER an OS_TCB
   1422          *
   1423          *                     OS_PEND_LIST
   1424          *                     +--------------+         OS_PEND_DATA
   1425          *                     | TailPtr      |--+---> +------------+
   1426          *                     +--------------+  |     | NextPtr    |->0
   1427          *                     | HeadPtr      |--/     +------------+
   1428          *                     +--------------+     0<-| PrevPtr    |
   1429          *                     | NbrEntries=1 |        +------------+
   1430          *                     +--------------+        |            |
   1431          *                                             +------------+
   1432          *                                             |            |
   1433          *                                             +------------+
   1434          *
   1435          *
   1436          *                     OS_PEND_LIST
   1437          *                     +--------------+
   1438          *                     | TailPtr      |-----------------------------------------------+
   1439          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1440          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1441          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1442          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1443          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1444          *                                             +------------+       +------------+        +------------+
   1445          *                                             |            |       |            |        |            |
   1446          *                                             +------------+       +------------+        +------------+
   1447          *                                             |            |       |            |        |            |
   1448          *                                             +------------+       +------------+        +------------+
   1449          *
   1450          *
   1451          * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_PEND_DATA entry will be inserted
   1452          *              -----------
   1453          *
   1454          *              p_pend_data    is the OS_PEND_DATA to insert in the list
   1455          *              -----------
   1456          *
   1457          * Returns    : none
   1458          *
   1459          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1460          *
   1461          *              2) 'p_pend_data->TCBPtr->Prio' contains the priority of the TCB associated with the entry to insert.
   1462          *                 We can compare this priority with the priority of other entries in the list.
   1463          ************************************************************************************************************************
   1464          */
   1465          

   \                                 In section .text, align 2, keep-with-next
   1466          void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
   1467                                       OS_PEND_DATA  *p_pend_data)
   1468          {
   \                     OS_PendListInsertPrio: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1469              OS_PRIO        prio;
   1470              OS_TCB        *p_tcb;
   1471              OS_TCB        *p_tcb_next;
   1472              OS_PEND_DATA  *p_pend_data_prev;
   1473              OS_PEND_DATA  *p_pend_data_next;
   1474          
   1475          
   1476          
   1477              p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
   1478              prio  = p_tcb->Prio;
   \   00000002   0x688A             LDR      R2,[R1, #+8]
   \   00000004   0xF892 0x2037      LDRB     R2,[R2, #+55]
   1479              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
   \   00000008   0x8903             LDRH     R3,[R0, #+8]
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD107             BNE.N    ??OS_PendListInsertPrio_0
   1480                  p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x8102             STRH     R2,[R0, #+8]
   1481                  p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x604A             STR      R2,[R1, #+4]
   1482                  p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
   \   00000016   0x600A             STR      R2,[R1, #+0]
   1483                  p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
   \   00000018   0x6001             STR      R1,[R0, #+0]
   1484                  p_pend_list->TailPtr    = p_pend_data;
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   \   0000001C   0xE021             B.N      ??OS_PendListInsertPrio_1
   1485              } else {
   1486                  p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
   \                     ??OS_PendListInsertPrio_0: (+1)
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0x8103             STRH     R3,[R0, #+8]
   1487                  p_pend_data_next = p_pend_list->HeadPtr;
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0xE000             B.N      ??OS_PendListInsertPrio_2
   1488                  while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
   1489                      p_tcb_next   = p_pend_data_next->TCBPtr;
   1490                      if (prio < p_tcb_next->Prio) {
   1491                          break;                                                /*         Found! ... insert BEFORE current     */
   1492                      } else {
   1493                          p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
   \                     ??OS_PendListInsertPrio_3: (+1)
   \   00000026   0x685B             LDR      R3,[R3, #+4]
   1494                      }
   \                     ??OS_PendListInsertPrio_2: (+1)
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD004             BEQ.N    ??OS_PendListInsertPrio_4
   \   0000002C   0x689C             LDR      R4,[R3, #+8]
   \   0000002E   0xF894 0x4037      LDRB     R4,[R4, #+55]
   \   00000032   0x42A2             CMP      R2,R4
   \   00000034   0xD2F7             BCS.N    ??OS_PendListInsertPrio_3
   1495                  }
   1496                  if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
   \                     ??OS_PendListInsertPrio_4: (+1)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD106             BNE.N    ??OS_PendListInsertPrio_5
   1497                      p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x604A             STR      R2,[R1, #+4]
   1498                      p_pend_data_prev          = p_pend_list->TailPtr;
   \   0000003E   0x6842             LDR      R2,[R0, #+4]
   1499                      p_pend_data->PrevPtr      = p_pend_data_prev;
   \   00000040   0x600A             STR      R2,[R1, #+0]
   1500                      p_pend_data_prev->NextPtr = p_pend_data;
   \   00000042   0x6051             STR      R1,[R2, #+4]
   1501                      p_pend_list->TailPtr      = p_pend_data;
   \   00000044   0x6041             STR      R1,[R0, #+4]
   \   00000046   0xE00C             B.N      ??OS_PendListInsertPrio_1
   1502                  } else {
   1503                      if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
   \                     ??OS_PendListInsertPrio_5: (+1)
   \   00000048   0x681A             LDR      R2,[R3, #+0]
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD105             BNE.N    ??OS_PendListInsertPrio_6
   1504                          p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
   \   0000004E   0x6019             STR      R1,[R3, #+0]
   1505                          p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x600A             STR      R2,[R1, #+0]
   1506                          p_pend_data->NextPtr       = p_pend_data_next;
   \   00000054   0x604B             STR      R3,[R1, #+4]
   1507                          p_pend_list->HeadPtr       = p_pend_data;
   \   00000056   0x6001             STR      R1,[R0, #+0]
   \   00000058   0xE003             B.N      ??OS_PendListInsertPrio_1
   1508                      } else {
   1509                          p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
   1510                          p_pend_data->PrevPtr       = p_pend_data_prev;
   \                     ??OS_PendListInsertPrio_6: (+1)
   \   0000005A   0x600A             STR      R2,[R1, #+0]
   1511                          p_pend_data->NextPtr       = p_pend_data_next;
   \   0000005C   0x604B             STR      R3,[R1, #+4]
   1512                          p_pend_data_prev->NextPtr  = p_pend_data;
   \   0000005E   0x6051             STR      R1,[R2, #+4]
   1513                          p_pend_data_next->PrevPtr  = p_pend_data;
   \   00000060   0x6019             STR      R1,[R3, #+0]
   1514                      }
   1515                  }
   1516              }
   1517          }
   \                     ??OS_PendListInsertPrio_1: (+1)
   \   00000062   0xBC10             POP      {R4}
   \   00000064   0x4770             BX       LR               ;; return
   1518          
   1519          /*$PAGE*/
   1520          /*
   1521          ************************************************************************************************************************
   1522          *                           REMOVE TASK FROM PEND LIST(s) KNOWING ONLY WHICH TCB TO REMOVE
   1523          *
   1524          * Description: This function is called to remove a task from a pend list knowing only the TCB of the task to remove
   1525          *
   1526          *
   1527          *              CASE 0: OS_PEND_DATA list is empty, nothing to do.
   1528          *
   1529          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1530          *
   1531          *                     OS_PEND_LIST
   1532          *                     +--------------+         OS_PEND_DATA
   1533          *                     | TailPtr      |--+---> +------------+
   1534          *                     +--------------+  |     | NextPtr    |->0
   1535          *                     | HeadPtr      |--/     +------------+
   1536          *                     +--------------+     0<-| PrevPtr    |
   1537          *                     | NbrEntries=1 |        +------------+
   1538          *                     +--------------+        |            |
   1539          *                                             +------------+
   1540          *                                             |            |
   1541          *                                             +------------+
   1542          *
   1543          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1544          *
   1545          *                     OS_PEND_LIST
   1546          *                     +--------------+
   1547          *                     | TailPtr      |-----------------------------------------------+
   1548          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1549          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1550          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1551          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1552          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1553          *                                             +------------+       +------------+        +------------+
   1554          *                                             |            |       |            |        |            |
   1555          *                                             +------------+       +------------+        +------------+
   1556          *                                             |            |       |            |        |            |
   1557          *                                             +------------+       +------------+        +------------+
   1558          *
   1559          *
   1560          * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from all pend lists
   1561          *              -----
   1562          *
   1563          * Returns    : none
   1564          *
   1565          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1566          ************************************************************************************************************************
   1567          */
   1568          

   \                                 In section .text, align 2, keep-with-next
   1569          void  OS_PendListRemove (OS_TCB  *p_tcb)
   1570          {
   \                     OS_PendListRemove: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1571              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1572              OS_PEND_DATA   *p_pend_data;
   1573              OS_PEND_LIST   *p_pend_list;
   1574              OS_PEND_OBJ    *p_obj;
   1575          
   1576          
   1577          
   1578              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000004   0x6B25             LDR      R5,[R4, #+48]
   1579              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000006   0x8FE6             LDRH     R6,[R4, #+62]
   \   00000008   0xE006             B.N      ??OS_PendListRemove_0
   1580          
   1581              while (n_pend_list > (OS_OBJ_QTY)0) {
   1582                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   1583                  p_pend_list = &p_obj->PendList;
   1584                  OS_PendListRemove1(p_pend_list,
   1585                                     p_pend_data);
   \                     ??OS_PendListRemove_1: (+1)
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x68E8             LDR      R0,[R5, #+12]
   \   0000000E   0x3008             ADDS     R0,R0,#+8
   \   00000010   0x.... 0x....      BL       OS_PendListRemove1
   1586                  p_pend_data++;
   \   00000014   0x3520             ADDS     R5,R5,#+32
   1587                  n_pend_list--;
   \   00000016   0x1E76             SUBS     R6,R6,#+1
   1588              }
   \                     ??OS_PendListRemove_0: (+1)
   \   00000018   0xB2B6             UXTH     R6,R6
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD1F5             BNE.N    ??OS_PendListRemove_1
   1589              p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x87E0             STRH     R0,[R4, #+62]
   1590              p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
   \   00000022   0x6320             STR      R0,[R4, #+48]
   1591          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
   1592          
   1593          /*$PAGE*/
   1594          /*
   1595          ************************************************************************************************************************
   1596          *                               REMOVE AN 'OS_PEND_DATA' ENTRY from a 'OS_PEND_LIST'
   1597          *
   1598          * Description: This function is called to remove a task from a wait list knowing only the TCB of the task to remove
   1599          *
   1600          *
   1601          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1602          *
   1603          *                     OS_PEND_LIST
   1604          *                     +--------------+         OS_PEND_DATA
   1605          *                     | TailPtr      |--+---> +------------+
   1606          *                     +--------------+  |     | NextPtr    |->0
   1607          *                     | HeadPtr      |--/      +------------+
   1608          *                     +--------------+     0<-| PrevPtr    |
   1609          *                     | NbrEntries=1 |        +------------+
   1610          *                     +--------------+        |            |
   1611          *                                             +------------+
   1612          *                                             |            |
   1613          *                                             +------------+
   1614          *
   1615          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1616          *
   1617          *                     OS_PEND_LIST
   1618          *                     +--------------+
   1619          *                     | TailPtr      |-----------------------------------------------+
   1620          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1621          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1622          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1623          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1624          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1625          *                                             +------------+       +------------+        +------------+
   1626          *                                             |            |       |            |        |            |
   1627          *                                             +------------+       +------------+        +------------+
   1628          *                                             |            |       |            |        |            |
   1629          *                                             +------------+       +------------+        +------------+
   1630          *
   1631          *
   1632          * Arguments  : p_pend_list     is a pointer to the pend list where 'p_pend_data' will be removed from
   1633          *              -----------
   1634          *
   1635          *              p_pend_data     is a pointer to the OS_PEND_DATA to remove from the pend list
   1636          *              -----------
   1637          *
   1638          * Returns    : none
   1639          *
   1640          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1641          ************************************************************************************************************************
   1642          */
   1643          

   \                                 In section .text, align 2, keep-with-next
   1644          void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
   1645                                    OS_PEND_DATA  *p_pend_data)
   1646          {
   1647              OS_PEND_DATA  *p_prev;
   1648              OS_PEND_DATA  *p_next;
   1649          
   1650          
   1651          
   1652              if (p_pend_list->NbrEntries == 1u) {
   \                     OS_PendListRemove1: (+1)
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD103             BNE.N    ??OS_PendListRemove1_0
   1653                  p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x6002             STR      R2,[R0, #+0]
   1654                  p_pend_list->TailPtr = (OS_PEND_DATA *)0;
   \   0000000A   0x6042             STR      R2,[R0, #+4]
   \   0000000C   0xE00F             B.N      ??OS_PendListRemove1_1
   1655          
   1656              } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
   \                     ??OS_PendListRemove1_0: (+1)
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0x680B             LDR      R3,[R1, #+0]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD103             BNE.N    ??OS_PendListRemove1_2
   1657                  p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
   1658                  p_next->PrevPtr      = (OS_PEND_DATA *)0;
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x6013             STR      R3,[R2, #+0]
   1659                  p_pend_list->HeadPtr = p_next;
   \   0000001A   0x6002             STR      R2,[R0, #+0]
   \   0000001C   0xE007             B.N      ??OS_PendListRemove1_1
   1660          
   1661              } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
   \                     ??OS_PendListRemove1_2: (+1)
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD103             BNE.N    ??OS_PendListRemove1_3
   1662                  p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
   1663                  p_prev->NextPtr      = (OS_PEND_DATA *)0;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x605A             STR      R2,[R3, #+4]
   1664                  p_pend_list->TailPtr = p_prev;
   \   00000026   0x6043             STR      R3,[R0, #+4]
   \   00000028   0xE001             B.N      ??OS_PendListRemove1_1
   1665          
   1666              } else {
   1667                  p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
   1668                  p_next               = p_pend_data->NextPtr;
   1669                  p_prev->NextPtr      = p_next;
   \                     ??OS_PendListRemove1_3: (+1)
   \   0000002A   0x605A             STR      R2,[R3, #+4]
   1670                  p_next->PrevPtr      = p_prev;
   \   0000002C   0x6013             STR      R3,[R2, #+0]
   1671              }
   1672              p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
   \                     ??OS_PendListRemove1_1: (+1)
   \   0000002E   0x8902             LDRH     R2,[R0, #+8]
   \   00000030   0x1E52             SUBS     R2,R2,#+1
   \   00000032   0x8102             STRH     R2,[R0, #+8]
   1673              p_pend_data->NextPtr = (OS_PEND_DATA *)0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6048             STR      R0,[R1, #+4]
   1674              p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1675          }
   \   0000003A   0x4770             BX       LR               ;; return
   1676          
   1677          /*$PAGE*/
   1678          /*
   1679          ************************************************************************************************************************
   1680          *                                READY A TASK THAT WAS PENDING ON AN OBJECT BEING DELETED
   1681          *
   1682          * Description: This function is called to make a task ready-to-run because an object is being deleted
   1683          *
   1684          * Arguments  : p_obj          is a pointer to the object being deleted
   1685          *              -----
   1686          *
   1687          *              p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   1688          *              -----
   1689          *
   1690          *              ts             is a timestamp to indicate when the object was deleted
   1691          *
   1692          * Returns    : none
   1693          *
   1694          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1695          ************************************************************************************************************************
   1696          */
   1697          

   \                                 In section .text, align 2, keep-with-next
   1698          void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
   1699                               OS_TCB       *p_tcb,
   1700                               CPU_TS        ts)
   1701          {
   \                     OS_PendObjDel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4616             MOV      R6,R2
   1702              switch (p_tcb->TaskState) {
   \   00000006   0xF105 0x0434      ADD      R4,R5,#+52
   \   0000000A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000C   0x1E89             SUBS     R1,R1,#+2
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD903             BLS.N    ??OS_PendObjDel_0
   \   00000012   0x1F09             SUBS     R1,R1,#+4
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD917             BLS.N    ??OS_PendObjDel_1
   \   00000018   0xBD70             POP      {R4-R6,PC}
   1703                  case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
   1704                  case OS_TASK_STATE_DLY:
   1705                  case OS_TASK_STATE_SUSPENDED:
   1706                  case OS_TASK_STATE_DLY_SUSPENDED:
   1707                       break;
   1708          
   1709                  case OS_TASK_STATE_PEND:
   1710                  case OS_TASK_STATE_PEND_TIMEOUT:
   1711                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendObjDel_0: (+1)
   \   0000001A   0x7821             LDRB     R1,[R4, #+0]
   \   0000001C   0x2903             CMP      R1,#+3
   \   0000001E   0xD102             BNE.N    ??OS_PendObjDel_2
   1712                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1713                                          p_tcb,
   1714                                          ts);
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x.... 0x....      BL       OS_PendObjDel1
   1715                       }
   1716          #if (OS_MSG_EN > 0u)
   1717                       p_tcb->MsgPtr     = (void *)0;
   \                     ??OS_PendObjDel_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x62A0             STR      R0,[R4, #+40]
   1718                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   0000002A   0x85A0             STRH     R0,[R4, #+44]
   1719          #endif
   1720                       p_tcb->TS         = ts;
   \   0000002C   0x60E6             STR      R6,[R4, #+12]
   1721                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       OS_PendListRemove
   1722                       OS_TaskRdy(p_tcb);
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       OS_TaskRdy
   1723                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x70A0             STRB     R0,[R4, #+2]
   1724                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x7060             STRB     R0,[R4, #+1]
   1725                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7020             STRB     R0,[R4, #+0]
   1726                       break;
   \   00000046   0xBD70             POP      {R4-R6,PC}
   1727          
   1728                  case OS_TASK_STATE_PEND_SUSPENDED:
   1729                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1730                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendObjDel_1: (+1)
   \   00000048   0x7821             LDRB     R1,[R4, #+0]
   \   0000004A   0x2903             CMP      R1,#+3
   \   0000004C   0xD102             BNE.N    ??OS_PendObjDel_3
   1731                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1732                                          p_tcb,
   1733                                          ts);
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x.... 0x....      BL       OS_PendObjDel1
   1734                       }
   1735          #if (OS_MSG_EN > 0u)
   1736                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_PendObjDel_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x62A0             STR      R0,[R4, #+40]
   1737                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   00000058   0x85A0             STRH     R0,[R4, #+44]
   1738          #endif
   1739                       p_tcb->TS         = ts;
   \   0000005A   0x60E6             STR      R6,[R4, #+12]
   1740                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       OS_TickListRemove
   1741                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       OS_PendListRemove
   1742                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x70A0             STRB     R0,[R4, #+2]
   1743                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x7060             STRB     R0,[R4, #+1]
   1744                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7020             STRB     R0,[R4, #+0]
   1745                       break;
   1746          
   1747                  default:
   1748                       break;
   1749              }
   1750          }
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
   1751          
   1752          /*$PAGE*/
   1753          /*
   1754          ************************************************************************************************************************
   1755          *                                    DELETE AN OBJECT FROM A TASK PENDING ON MULTIPLE OBJECTS
   1756          *
   1757          * Description: This function is called when a task is pending on multiple objects and the object is being deleted.
   1758          *              This function needs to indicate to the caller which object was deleted by placing the address of the
   1759          *              object in the OS_PEND_DATA table corresponding to the deleted object.
   1760          *
   1761          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1762          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1763          *              set to six (6) in this case.  As shown, when the pend call returns because a task deleted 'Obj C' then,
   1764          *              only the one entry contains the filled in data and the other entries contains NULL pointers and zero
   1765          *              data.
   1766          *
   1767          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1768          *
   1769          *
   1770          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1771          *                                         +--------------+--------------+--------------+--------------+--------------+
   1772          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1773          *                                         +--------------+--------------+--------------+--------------+--------------+
   1774          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1775          *                                         +--------------+--------------+--------------+--------------+--------------+
   1776          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
   1777          *                                         +--------------+--------------+--------------+--------------+--------------+
   1778          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1779          *                                         +--------------+--------------+--------------+--------------+--------------+
   1780          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1781          *                                         +--------------+--------------+--------------+--------------+--------------+
   1782          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1783          *                                         +--------------+--------------+--------------+--------------+--------------+
   1784          *
   1785          *
   1786          * Arguments  : p_obj        is a pointer to the object being deleted
   1787          *              -----
   1788          *
   1789          *              p_tcb        is the OS_TCB of the task pending on the object being deleted
   1790          *              -----
   1791          *
   1792          *              ts           is the time stamp of when the object was deleted
   1793          *
   1794          * Returns    : none
   1795          *
   1796          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1797          ************************************************************************************************************************
   1798          */
   1799          

   \                                 In section .text, align 2, keep-with-next
   1800          void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
   1801                                OS_TCB       *p_tcb,
   1802                                CPU_TS        ts)
   1803          {
   \                     OS_PendObjDel1: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1804              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1805              OS_PEND_DATA   *p_pend_data;
   1806          
   1807          
   1808          
   1809              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000002   0x6B0B             LDR      R3,[R1, #+48]
   1810              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000004   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000006   0xE001             B.N      ??OS_PendObjDel1_0
   1811          
   1812              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1813                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
   1814                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   1815                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
   1816                      break;
   1817                  }
   1818                  p_pend_data++;
   \                     ??OS_PendObjDel1_1: (+1)
   \   00000008   0x3320             ADDS     R3,R3,#+32
   1819                  n_pend_list--;
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \                     ??OS_PendObjDel1_0: (+1)
   \   0000000C   0xB289             UXTH     R1,R1
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ.N    ??OS_PendObjDel1_2
   \   00000012   0x68DC             LDR      R4,[R3, #+12]
   \   00000014   0x42A0             CMP      R0,R4
   \   00000016   0xD1F7             BNE.N    ??OS_PendObjDel1_1
   \   00000018   0x6118             STR      R0,[R3, #+16]
   \   0000001A   0x61DA             STR      R2,[R3, #+28]
   1820              }
   1821          }
   \                     ??OS_PendObjDel1_2: (+1)
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
   1822          
   1823          /*$PAGE*/
   1824          /*
   1825          ************************************************************************************************************************
   1826          *                                                   POST TO A TASK
   1827          *
   1828          * Description: This function is called to post to a task.  This function exist because it is common to a number of
   1829          *              OSxxxPost() services.
   1830          *
   1831          * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
   1832          *              -----
   1833          *
   1834          *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
   1835          *              -----
   1836          *
   1837          *              p_void         If we are posting a message to a task, this is the message that the task will receive
   1838          *
   1839          *              msg_size       If we are posting a message to a task, this is the size of the message
   1840          *
   1841          *              ts             The timestamp as to when the post occurred
   1842          *
   1843          * Returns    : none
   1844          *
   1845          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1846          ************************************************************************************************************************
   1847          */
   1848          

   \                                 In section .text, align 2, keep-with-next
   1849          void  OS_Post (OS_PEND_OBJ  *p_obj,
   1850                         OS_TCB       *p_tcb,
   1851                         void         *p_void,
   1852                         OS_MSG_SIZE   msg_size,
   1853                         CPU_TS        ts)
   1854          {
   \                     OS_Post: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   1855              switch (p_tcb->TaskState) {
   \   00000008   0xF106 0x0434      ADD      R4,R6,#+52
   \   0000000C   0x9806             LDR      R0,[SP, #+24]
   \   0000000E   0x78A1             LDRB     R1,[R4, #+2]
   \   00000010   0x1E89             SUBS     R1,R1,#+2
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD903             BLS.N    ??OS_Post_0
   \   00000016   0x1F09             SUBS     R1,R1,#+4
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD919             BLS.N    ??OS_Post_1
   \   0000001C   0xBD73             POP      {R0,R1,R4-R6,PC}
   1856                  case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
   1857                  case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
   1858                  case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
   1859                  case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
   1860                       break;
   1861          
   1862                  case OS_TASK_STATE_PEND:
   1863                  case OS_TASK_STATE_PEND_TIMEOUT:
   1864                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_Post_0: (+1)
   \   0000001E   0x7821             LDRB     R1,[R4, #+0]
   \   00000020   0x2903             CMP      R1,#+3
   \   00000022   0xD105             BNE.N    ??OS_Post_2
   1865                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1866                                    p_tcb,
   1867                                    p_void,
   1868                                    msg_size,
   1869                                    ts);
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x4631             MOV      R1,R6
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       OS_Post1
   \   0000002E   0xE002             B.N      ??OS_Post_3
   1870                       } else {
   1871          #if (OS_MSG_EN > 0u)
   1872                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   \                     ??OS_Post_2: (+1)
   \   00000030   0x62A2             STR      R2,[R4, #+40]
   1873                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   \   00000032   0x85A3             STRH     R3,[R4, #+44]
   1874          #endif
   1875                           p_tcb->TS      = ts;
   \   00000034   0x60E0             STR      R0,[R4, #+12]
   1876                       }
   1877                       if (p_obj != (OS_PEND_OBJ *)0) {
   \                     ??OS_Post_3: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD002             BEQ.N    ??OS_Post_4
   1878                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       OS_PendListRemove
   1879          #if OS_CFG_DBG_EN > 0u
   1880                           OS_PendDbgNameRemove(p_obj,
   1881                                                p_tcb);
   1882          #endif
   1883                       }
   1884                       OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
   \                     ??OS_Post_4: (+1)
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0x.... 0x....      BL       OS_TaskRdy
   1885                       p_tcb->TaskState  = OS_TASK_STATE_RDY;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x70A0             STRB     R0,[R4, #+2]
   1886                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   \   0000004A   0x7060             STRB     R0,[R4, #+1]
   1887                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
   1888                       break;
   \   0000004E   0xBD73             POP      {R0,R1,R4-R6,PC}
   1889          
   1890                  case OS_TASK_STATE_PEND_SUSPENDED:
   1891                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1892                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_Post_1: (+1)
   \   00000050   0x7821             LDRB     R1,[R4, #+0]
   \   00000052   0x2903             CMP      R1,#+3
   \   00000054   0xD105             BNE.N    ??OS_Post_5
   1893                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1894                                    p_tcb,
   1895                                    p_void,
   1896                                    msg_size,
   1897                                    ts);
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x4631             MOV      R1,R6
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       OS_Post1
   \   00000060   0xE002             B.N      ??OS_Post_6
   1898                       } else {
   1899          #if (OS_MSG_EN > 0u)
   1900                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   \                     ??OS_Post_5: (+1)
   \   00000062   0x62A2             STR      R2,[R4, #+40]
   1901                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   \   00000064   0x85A3             STRH     R3,[R4, #+44]
   1902          #endif
   1903                           p_tcb->TS      = ts;
   \   00000066   0x60E0             STR      R0,[R4, #+12]
   1904                       }
   1905                       OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
   \                     ??OS_Post_6: (+1)
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0x.... 0x....      BL       OS_TickListRemove
   1906                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD002             BEQ.N    ??OS_Post_7
   1907                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x.... 0x....      BL       OS_PendListRemove
   1908          #if OS_CFG_DBG_EN > 0u
   1909                           OS_PendDbgNameRemove(p_obj,
   1910                                                p_tcb);
   1911          #endif
   1912                       }
   1913                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_Post_7: (+1)
   \   00000078   0x2004             MOVS     R0,#+4
   \   0000007A   0x70A0             STRB     R0,[R4, #+2]
   1914                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7060             STRB     R0,[R4, #+1]
   1915                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   00000080   0x7020             STRB     R0,[R4, #+0]
   1916                       break;
   1917          
   1918                  default:
   1919                       break;
   1920              }
   1921          }
   \   00000082   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1922          
   1923          /*$PAGE*/
   1924          /*
   1925          ************************************************************************************************************************
   1926          *                                           POST TO A TASK PENDING ON MULTIPLE OBJECTS
   1927          *
   1928          * Description: This function is called when a task is pending on multiple objects and the object has been posted to.
   1929          *              This function needs to indicate to the caller which object was posted to by placing the address of the
   1930          *              object in the OS_PEND_DATA table corresponding to the posted object.
   1931          *
   1932          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1933          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1934          *              set to six (6) in this case.  As shown, when the pend call returns because a task or an ISR posted to
   1935          *              'Obj C' then, only the one entry contains the filled in data and the other entries contains NULL pointers
   1936          *              and zero data.
   1937          *
   1938          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1939          *
   1940          *
   1941          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1942          *                                         +--------------+--------------+--------------+--------------+--------------+
   1943          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1944          *                                         +--------------+--------------+--------------+--------------+--------------+
   1945          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1946          *                                         +--------------+--------------+--------------+--------------+--------------+
   1947          *                                         |  Obj C       |  Obj C       | Msg Ptr      | Msg Size     | TS           |
   1948          *                                         +--------------+--------------+--------------+--------------+--------------+
   1949          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1950          *                                         +--------------+--------------+--------------+--------------+--------------+
   1951          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1952          *                                         +--------------+--------------+--------------+--------------+--------------+
   1953          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1954          *                                         +--------------+--------------+--------------+--------------+--------------+
   1955          *
   1956          *
   1957          * Arguments  : p_obj        is a pointer to the object being posted to
   1958          *              -----
   1959          *
   1960          *              p_tcb        is the OS_TCB of the task receiving the signal or the message
   1961          *              -----
   1962          *
   1963          *              p_void       is the actual message (assuming posting to a message queue).  A NULL pointer otherwise.
   1964          *
   1965          *              msg_size     is the size of the message sent (if posted to a message queue)
   1966          *
   1967          *              ts           is the time stamp of when the post occurred
   1968          *
   1969          * Returns    : none
   1970          *
   1971          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1972          ************************************************************************************************************************
   1973          */
   1974          

   \                                 In section .text, align 2, keep-with-next
   1975          void  OS_Post1 (OS_PEND_OBJ  *p_obj,
   1976                          OS_TCB       *p_tcb,
   1977                          void         *p_void,
   1978                          OS_MSG_SIZE   msg_size,
   1979                          CPU_TS        ts)
   1980          {
   \                     OS_Post1: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1981              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1982              OS_PEND_DATA   *p_pend_data;
   1983          
   1984          
   1985          
   1986              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000002   0x6B0C             LDR      R4,[R1, #+48]
   1987              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000004   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000006   0xE001             B.N      ??OS_Post1_0
   1988          
   1989              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1990                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
   1991                      p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
   1992                      p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
   1993                      p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
   1994                      p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
   1995                      break;
   1996                  }
   1997                  p_pend_data++;
   \                     ??OS_Post1_1: (+1)
   \   00000008   0x3420             ADDS     R4,R4,#+32
   1998                  n_pend_list--;
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \                     ??OS_Post1_0: (+1)
   \   0000000C   0xB289             UXTH     R1,R1
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD007             BEQ.N    ??OS_Post1_2
   \   00000012   0x68E5             LDR      R5,[R4, #+12]
   \   00000014   0x42A8             CMP      R0,R5
   \   00000016   0xD1F7             BNE.N    ??OS_Post1_1
   \   00000018   0x6120             STR      R0,[R4, #+16]
   \   0000001A   0x6162             STR      R2,[R4, #+20]
   \   0000001C   0x8323             STRH     R3,[R4, #+24]
   \   0000001E   0x9802             LDR      R0,[SP, #+8]
   \   00000020   0x61E0             STR      R0,[R4, #+28]
   1999              }
   2000          }
   \                     ??OS_Post1_2: (+1)
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
   2001          
   2002          /*$PAGE*/
   2003          /*
   2004          ************************************************************************************************************************
   2005          *                                                    INITIALIZATION
   2006          *                                               READY LIST INITIALIZATION
   2007          *
   2008          * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
   2009          *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
   2010          *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
   2011          *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   2012          *
   2013          *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
   2014          *              to.
   2015          *
   2016          *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   2017          *
   2018          *                               +---------------+--------------+
   2019          *                               |               | TailPtr      |-----> 0
   2020          *                          [0]  | NbrEntries=0  +--------------+
   2021          *                               |               | HeadPtr      |-----> 0
   2022          *                               +---------------+--------------+
   2023          *                               |               | TailPtr      |-----> 0
   2024          *                          [1]  | NbrEntries=0  +--------------+
   2025          *                               |               | HeadPtr      |-----> 0
   2026          *                               +---------------+--------------+
   2027          *                                       :              :
   2028          *                                       :              :
   2029          *                                       :              :
   2030          *                               +---------------+--------------+
   2031          *                               |               | TailPtr      |-----> 0
   2032          *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   2033          *                               |               | HeadPtr      |-----> 0
   2034          *                               +---------------+--------------+
   2035          *
   2036          *
   2037          * Arguments  : none
   2038          *
   2039          * Returns    : none
   2040          *
   2041          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2042          ************************************************************************************************************************
   2043          */
   2044          

   \                                 In section .text, align 2, keep-with-next
   2045          void  OS_RdyListInit (void)
   2046          {
   2047              OS_PRIO       i;
   2048              OS_RDY_LIST  *p_rdy_list;
   2049          
   2050          
   2051          
   2052              for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
   \                     OS_RdyListInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE009             B.N      ??OS_RdyListInit_0
   2053                  p_rdy_list = &OSRdyList[i];
   \                     ??OS_RdyListInit_1: (+1)
   \   00000004   0x....             LDR.N    R1,??DataTable17_21
   \   00000006   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   0000000A   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   2054                  p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x810A             STRH     R2,[R1, #+8]
   2055                  p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   \   00000012   0x600A             STR      R2,[R1, #+0]
   2056                  p_rdy_list->TailPtr    = (OS_TCB   *)0;
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2057              }
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \                     ??OS_RdyListInit_0: (+1)
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xD3F3             BCC.N    ??OS_RdyListInit_1
   2058          }
   \   0000001C   0x4770             BX       LR               ;; return
   2059          
   2060          /*$PAGE*/
   2061          /*
   2062          ************************************************************************************************************************
   2063          *                                             INSERT TCB IN THE READY LIST
   2064          *
   2065          * Description: This function is called to insert a TCB in the ready list.
   2066          *
   2067          *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
   2068          *              current task.  The TCB is inserted at the head of the list if not.
   2069          *
   2070          * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
   2071          *              -----
   2072          *
   2073          * Returns    : none
   2074          *
   2075          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2076          ************************************************************************************************************************
   2077          */
   2078          

   \                                 In section .text, align 2, keep-with-next
   2079          void  OS_RdyListInsert (OS_TCB  *p_tcb)
   2080          {
   \                     OS_RdyListInsert: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2081              OS_PrioInsert(p_tcb->Prio);
   \   00000004   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000008   0x.... 0x....      BL       OS_PrioInsert
   2082              if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
   \   0000000C   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000010   0x....             LDR.N    R1,??DataTable17_5
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xD102             BNE.N    ??OS_RdyListInsert_0
   2083                  OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x....             B.N      OS_RdyListInsertTail
   2084              } else {
   2085                  OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
   \                     ??OS_RdyListInsert_0: (+1)
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024                      REQUIRE OS_RdyListInsertHead
   \   00000024                      ;; // Fall through to label OS_RdyListInsertHead
   2086              }
   2087          }
   2088          
   2089          
   2090          /*
   2091          ************************************************************************************************************************
   2092          *                                          INSERT TCB AT THE BEGINNING OF A LIST
   2093          *
   2094          * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
   2095          *
   2096          *              CASE 0: Insert in an empty list.
   2097          *
   2098          *                     OS_RDY_LIST
   2099          *                     +--------------+
   2100          *                     | TailPtr      |-> 0
   2101          *                     +--------------+
   2102          *                     | HeadPtr      |-> 0
   2103          *                     +--------------+
   2104          *                     | NbrEntries=0 |
   2105          *                     +--------------+
   2106          *
   2107          *
   2108          *
   2109          *              CASE 1: Insert BEFORE the current head of list
   2110          *
   2111          *                     OS_RDY_LIST
   2112          *                     +--------------+          OS_TCB
   2113          *                     | TailPtr      |--+---> +------------+
   2114          *                     +--------------+  |     | NextPtr    |->0
   2115          *                     | HeadPtr      |--/     +------------+
   2116          *                     +--------------+     0<-| PrevPtr    |
   2117          *                     | NbrEntries=1 |        +------------+
   2118          *                     +--------------+        :            :
   2119          *                                             :            :
   2120          *                                             +------------+
   2121          *
   2122          *
   2123          *                     OS_RDY_LIST
   2124          *                     +--------------+
   2125          *                     | TailPtr      |-----------------------------------------------+
   2126          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2127          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2128          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2129          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2130          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2131          *                                             +------------+       +------------+        +------------+
   2132          *                                             :            :       :            :        :            :
   2133          *                                             :            :       :            :        :            :
   2134          *                                             +------------+       +------------+        +------------+
   2135          *
   2136          *
   2137          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2138          *              -----
   2139          *
   2140          * Returns    : none
   2141          *
   2142          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2143          ************************************************************************************************************************
   2144          */
   2145          

   \                                 In section .text, align 2, keep-with-next
   2146          void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
   2147          {
   2148              OS_RDY_LIST  *p_rdy_list;
   2149              OS_TCB       *p_tcb2;
   2150          
   2151          
   2152          
   2153              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertHead: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_21
   \   00000002   0xF890 0x2037      LDRB     R2,[R0, #+55]
   \   00000006   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   0000000A   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   2154              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   \   0000000E   0x890A             LDRH     R2,[R1, #+8]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD107             BNE.N    ??OS_RdyListInsertHead_0
   2155                  p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x810A             STRH     R2,[R1, #+8]
   2156                  p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x60C2             STR      R2,[R0, #+12]
   2157                  p_tcb->PrevPtr         =  (OS_TCB   *)0;
   \   0000001C   0x6102             STR      R2,[R0, #+16]
   2158                  p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   2159                  p_rdy_list->TailPtr    =  p_tcb;
   \   00000020   0x6048             STR      R0,[R1, #+4]
   \   00000022   0x4770             BX       LR
   2160              } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
   2161                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   \                     ??OS_RdyListInsertHead_0: (+1)
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0x810A             STRH     R2,[R1, #+8]
   2162                  p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   2163                  p_tcb->PrevPtr         = (OS_TCB    *)0;
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x6102             STR      R2,[R0, #+16]
   2164                  p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
   2165                  p_tcb2->PrevPtr        = p_tcb;
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0x6110             STR      R0,[R2, #+16]
   2166                  p_rdy_list->HeadPtr    = p_tcb;
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2167              }
   2168          }
   \   00000036   0x4770             BX       LR               ;; return
   2169          
   2170          /*$PAGE*/
   2171          /*
   2172          ************************************************************************************************************************
   2173          *                                           INSERT TCB AT THE END OF A LIST
   2174          *
   2175          * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
   2176          *
   2177          *              CASE 0: Insert in an empty list.
   2178          *
   2179          *                     OS_RDY_LIST
   2180          *                     +--------------+
   2181          *                     | TailPtr      |-> 0
   2182          *                     +--------------+
   2183          *                     | HeadPtr      |-> 0
   2184          *                     +--------------+
   2185          *                     | NbrEntries=0 |
   2186          *                     +--------------+
   2187          *
   2188          *
   2189          *
   2190          *              CASE 1: Insert AFTER the current tail of list
   2191          *
   2192          *                     OS_RDY_LIST
   2193          *                     +--------------+          OS_TCB
   2194          *                     | TailPtr      |--+---> +------------+
   2195          *                     +--------------+  |     | NextPtr    |->0
   2196          *                     | HeadPtr      |--/     +------------+
   2197          *                     +--------------+     0<-| PrevPtr    |
   2198          *                     | NbrEntries=1 |        +------------+
   2199          *                     +--------------+        :            :
   2200          *                                             :            :
   2201          *                                             +------------+
   2202          *
   2203          *
   2204          *                     OS_RDY_LIST
   2205          *                     +--------------+
   2206          *                     | TailPtr      |-----------------------------------------------+
   2207          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2208          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2209          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2210          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2211          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2212          *                                             +------------+       +------------+        +------------+
   2213          *                                             :            :       :            :        :            :
   2214          *                                             :            :       :            :        :            :
   2215          *                                             +------------+       +------------+        +------------+
   2216          *
   2217          *
   2218          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2219          *              -----
   2220          *
   2221          * Returns    : none
   2222          *
   2223          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2224          ************************************************************************************************************************
   2225          */
   2226          

   \                                 In section .text, align 2, keep-with-next
   2227          void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
   2228          {
   2229              OS_RDY_LIST  *p_rdy_list;
   2230              OS_TCB       *p_tcb2;
   2231          
   2232          
   2233          
   2234              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertTail: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_21
   \   00000002   0xF890 0x2037      LDRB     R2,[R0, #+55]
   \   00000006   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   0000000A   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   2235              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   \   0000000E   0x890A             LDRH     R2,[R1, #+8]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD107             BNE.N    ??OS_RdyListInsertTail_0
   2236                  p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x810A             STRH     R2,[R1, #+8]
   2237                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x60C2             STR      R2,[R0, #+12]
   2238                  p_tcb->PrevPtr          = (OS_TCB   *)0;
   \   0000001C   0x6102             STR      R2,[R0, #+16]
   2239                  p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   2240                  p_rdy_list->TailPtr     = p_tcb;
   \   00000020   0x6048             STR      R0,[R1, #+4]
   \   00000022   0x4770             BX       LR
   2241              } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
   2242                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   \                     ??OS_RdyListInsertTail_0: (+1)
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0x810A             STRH     R2,[R1, #+8]
   2243                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   2244                  p_tcb2                  = p_rdy_list->TailPtr;
   \   0000002C   0x684A             LDR      R2,[R1, #+4]
   2245                  p_tcb->PrevPtr          = p_tcb2;
   \   0000002E   0x6102             STR      R2,[R0, #+16]
   2246                  p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   2247                  p_rdy_list->TailPtr     = p_tcb;
   \   00000032   0x6048             STR      R0,[R1, #+4]
   2248              }
   2249          }
   \   00000034   0x4770             BX       LR               ;; return
   2250          
   2251          /*$PAGE*/
   2252          /*
   2253          ************************************************************************************************************************
   2254          *                                                MOVE TCB AT HEAD TO TAIL
   2255          *
   2256          * Description: This function is called to move the current head of a list to the tail of the list.
   2257          *
   2258          *
   2259          *              CASE 0: TCB list is empty, nothing to do.
   2260          *
   2261          *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   2262          *
   2263          *              CASE 2: Only 2 OS_TCBs in the list.
   2264          *
   2265          *                     OS_RDY_LIST
   2266          *                     +--------------+
   2267          *                     | TailPtr      |--------------------------+
   2268          *                     +--------------+          OS_TCB          |     OS_TCB
   2269          *                     | HeadPtr      |------> +------------+    +-> +------------+
   2270          *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
   2271          *                     | NbrEntries=2 |        +------------+        +------------+
   2272          *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
   2273          *                                             +------------+        +------------+
   2274          *                                             :            :        :            :
   2275          *                                             :            :        :            :
   2276          *                                             +------------+        +------------+
   2277          *
   2278          *
   2279          *              CASE N: More than 2 OS_TCBs in the list.
   2280          *
   2281          *                     OS_RDY_LIST
   2282          *                     +--------------+
   2283          *                     | TailPtr      |-----------------------------------------------+
   2284          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2285          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2286          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2287          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2288          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2289          *                                             +------------+       +------------+        +------------+
   2290          *                                             :            :       :            :        :            :
   2291          *                                             :            :       :            :        :            :
   2292          *                                             +------------+       +------------+        +------------+
   2293          *
   2294          *
   2295          * Arguments  : p_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
   2296          *              ------
   2297          *
   2298          * Returns    : none
   2299          *
   2300          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2301          ************************************************************************************************************************
   2302          */
   2303          

   \                                 In section .text, align 2, keep-with-next
   2304          void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
   2305          {
   2306              OS_TCB  *p_tcb1;
   2307              OS_TCB  *p_tcb2;
   2308              OS_TCB  *p_tcb3;
   2309          
   2310          
   2311          
   2312              switch (p_rdy_list->NbrEntries) {
   \                     OS_RdyListMoveHeadToTail: (+1)
   \   00000000   0x8901             LDRH     R1,[R0, #+8]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD100             BNE.N    ??OS_RdyListMoveHeadToTail_0
   \   00000006   0x4770             BX       LR
   \                     ??OS_RdyListMoveHeadToTail_0: (+1)
   \   00000008   0xB410             PUSH     {R4}
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD001             BEQ.N    ??OS_RdyListMoveHeadToTail_1
   \   0000000E   0xD314             BCC.N    ??OS_RdyListMoveHeadToTail_2
   \   00000010   0xE009             B.N      ??OS_RdyListMoveHeadToTail_3
   2313                  case 0:
   2314                  case 1:
   2315                       break;
   2316          
   2317                  case 2:                                             /* SWAP the TCBs                                          */
   2318                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   \                     ??OS_RdyListMoveHeadToTail_1: (+1)
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   2319                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   \   00000014   0x6842             LDR      R2,[R0, #+4]
   2320                       p_tcb1->PrevPtr     = p_tcb2;
   \   00000016   0x610A             STR      R2,[R1, #+16]
   2321                       p_tcb1->NextPtr     = (OS_TCB *)0;
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x60CB             STR      R3,[R1, #+12]
   2322                       p_tcb2->PrevPtr     = (OS_TCB *)0;
   \   0000001C   0x6113             STR      R3,[R2, #+16]
   2323                       p_tcb2->NextPtr     = p_tcb1;
   \   0000001E   0x60D1             STR      R1,[R2, #+12]
   2324                       p_rdy_list->HeadPtr = p_tcb2;
   \   00000020   0x6002             STR      R2,[R0, #+0]
   2325                       p_rdy_list->TailPtr = p_tcb1;
   \   00000022   0x6041             STR      R1,[R0, #+4]
   2326                       break;
   \   00000024   0xE009             B.N      ??OS_RdyListMoveHeadToTail_2
   2327          
   2328                  default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
   2329                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   \                     ??OS_RdyListMoveHeadToTail_3: (+1)
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   2330                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   \   00000028   0x6842             LDR      R2,[R0, #+4]
   2331                       p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
   \   0000002A   0x68CB             LDR      R3,[R1, #+12]
   2332                       p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
   \   0000002C   0x2400             MOVS     R4,#+0
   \   0000002E   0x611C             STR      R4,[R3, #+16]
   2333                       p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
   \   00000030   0x60CC             STR      R4,[R1, #+12]
   2334                       p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
   \   00000032   0x610A             STR      R2,[R1, #+16]
   2335                       p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
   \   00000034   0x60D1             STR      R1,[R2, #+12]
   2336                       p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
   \   00000036   0x6003             STR      R3,[R0, #+0]
   2337                       p_rdy_list->TailPtr = p_tcb1;
   \   00000038   0x6041             STR      R1,[R0, #+4]
   2338                       break;
   2339              }
   2340          }
   \                     ??OS_RdyListMoveHeadToTail_2: (+1)
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
   2341          
   2342          /*$PAGE*/
   2343          /*
   2344          ************************************************************************************************************************
   2345          *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
   2346          *
   2347          * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
   2348          *              remove.
   2349          *
   2350          *
   2351          *              CASE 0: TCB list is empty, nothing to do.
   2352          *
   2353          *              CASE 1: Only 1 OS_TCBs in the list.
   2354          *
   2355          *                     OS_RDY_LIST
   2356          *                     +--------------+          OS_TCB
   2357          *                     | TailPtr      |--+---> +------------+
   2358          *                     +--------------+  |     | NextPtr    |->0
   2359          *                     | HeadPtr      |--/     +------------+
   2360          *                     +--------------+     0<-| PrevPtr    |
   2361          *                     | NbrEntries=1 |        +------------+
   2362          *                     +--------------+        :            :
   2363          *                                             :            :
   2364          *                                             +------------+
   2365          *
   2366          *              CASE N: Two or more OS_TCBs in the list.
   2367          *
   2368          *                     OS_RDY_LIST
   2369          *                     +--------------+
   2370          *                     | TailPtr      |-----------------------------------------------+
   2371          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2372          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2373          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2374          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2375          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2376          *                                             +------------+       +------------+        +------------+
   2377          *                                             :            :       :            :        :            :
   2378          *                                             :            :       :            :        :            :
   2379          *                                             +------------+       +------------+        +------------+
   2380          *
   2381          *
   2382          * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
   2383          *              -----
   2384          *
   2385          * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
   2386          *
   2387          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2388          ************************************************************************************************************************
   2389          */
   2390          

   \                                 In section .text, align 2, keep-with-next
   2391          void  OS_RdyListRemove (OS_TCB  *p_tcb)
   2392          {
   \                     OS_RdyListRemove: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2393              OS_RDY_LIST  *p_rdy_list;
   2394              OS_TCB       *p_tcb1;
   2395              OS_TCB       *p_tcb2;
   2396          
   2397          
   2398          
   2399              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \   00000002   0x....             LDR.N    R1,??DataTable17_21
   \   00000004   0xF890 0x2037      LDRB     R2,[R0, #+55]
   \   00000008   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   0000000C   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   2400              p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
   \   00000010   0xF100 0x040C      ADD      R4,R0,#+12
   \   00000014   0x6862             LDR      R2,[R4, #+4]
   2401              p_tcb2     = p_tcb->NextPtr;
   \   00000016   0x6823             LDR      R3,[R4, #+0]
   2402              if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD111             BNE.N    ??OS_RdyListRemove_0
   2403                  if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD108             BNE.N    ??OS_RdyListRemove_1
   2404                      p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x810A             STRH     R2,[R1, #+8]
   2405                      p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   \   00000024   0x600A             STR      R2,[R1, #+0]
   2406                      p_rdy_list->TailPtr    = (OS_TCB   *)0;
   \   00000026   0x604A             STR      R2,[R1, #+4]
   2407                      OS_PrioRemove(p_tcb->Prio);
   \   00000028   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   0000002C   0x.... 0x....      BL       OS_PrioRemove
   \   00000030   0xE00F             B.N      ??OS_RdyListRemove_2
   2408                  } else {
   2409                      p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
   \                     ??OS_RdyListRemove_1: (+1)
   \   00000032   0x8908             LDRH     R0,[R1, #+8]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x8108             STRH     R0,[R1, #+8]
   2410                      p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6118             STR      R0,[R3, #+16]
   2411                      p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
   \   0000003C   0x600B             STR      R3,[R1, #+0]
   \   0000003E   0xE008             B.N      ??OS_RdyListRemove_2
   2412                  }
   2413              } else {
   2414                  p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
   \                     ??OS_RdyListRemove_0: (+1)
   \   00000040   0x8908             LDRH     R0,[R1, #+8]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x8108             STRH     R0,[R1, #+8]
   2415                  p_tcb1->NextPtr = p_tcb2;
   \   00000046   0x60D3             STR      R3,[R2, #+12]
   2416                  if (p_tcb2 == (OS_TCB *)0) {
   \   00000048   0x2B00             CMP      R3,#+0
   \   0000004A   0xD101             BNE.N    ??OS_RdyListRemove_3
   2417                      p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
   \   0000004C   0x604A             STR      R2,[R1, #+4]
   \   0000004E   0xE000             B.N      ??OS_RdyListRemove_2
   2418                  } else {
   2419                      p_tcb2->PrevPtr     = p_tcb1;
   \                     ??OS_RdyListRemove_3: (+1)
   \   00000050   0x611A             STR      R2,[R3, #+16]
   2420                  }
   2421              }
   2422              p_tcb->PrevPtr = (OS_TCB *)0;
   \                     ??OS_RdyListRemove_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6060             STR      R0,[R4, #+4]
   2423              p_tcb->NextPtr = (OS_TCB *)0;
   \   00000056   0x6020             STR      R0,[R4, #+0]
   2424          }
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   2425          
   2426          /*$PAGE*/
   2427          /*
   2428          ************************************************************************************************************************
   2429          *                                             SCHEDULE THE ISR HANDLER TASK
   2430          *
   2431          * Description: This function is called by other uC/OS-III services to schedule task at priority 0 which is always the
   2432          *              ISR handler task.
   2433          *
   2434          * Arguments  : none
   2435          *
   2436          * Returns    : none
   2437          *
   2438          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2439          ************************************************************************************************************************
   2440          */
   2441          
   2442          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   2443          void  OS_Sched0 (void)
   2444          {
   2445              CPU_SR_ALLOC();
   2446          
   2447          
   2448          
   2449              CPU_INT_DIS();
   2450              OSPrioHighRdy   = (OS_PRIO)0;                           /* Force the priority to 0                                */
   2451              OSTCBHighRdyPtr = &OSIntQTaskTCB;                       /* Always schedule the ISR handler task                   */
   2452          #if OS_CFG_TASK_PROFILE_EN > 0u
   2453              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
   2454          #endif
   2455              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   2456              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   2457              CPU_INT_EN();
   2458          }
   2459          #endif
   2460          
   2461          /*$PAGE*/
   2462          /*
   2463          ************************************************************************************************************************
   2464          *                                               SCHEDULER LOCK TIME MEASUREMENT
   2465          *
   2466          * Description: These functions are used to measure the peak amount of time that the scheduler is locked
   2467          *
   2468          * Arguments  : none
   2469          *
   2470          * Returns    : none
   2471          *
   2472          * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
   2473          *
   2474          *              2) It's assumed that these functions are called when interrupts are disabled.
   2475          *
   2476          *              3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer.  The reason is that we
   2477          *                 don't expect to have the scheduler locked for 65536 counts even at the rate the TS timer is updated.
   2478          *                 In other words, locking the scheduler for longer than 65536 count would not be a good thing for a
   2479          *                 real-time system.
   2480          ************************************************************************************************************************
   2481          */
   2482          
   2483          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
   2484          void  OS_SchedLockTimeMeasStart (void)
   2485          {
   2486              if (OSSchedLockNestingCtr == 1u) {
   2487                  OSSchedLockTimeBegin = CPU_TS_TmrRd();
   2488              }
   2489          }
   2490          
   2491          
   2492          
   2493          
   2494          void  OS_SchedLockTimeMeasStop (void)
   2495          {
   2496              CPU_TS_TMR  delta;
   2497          
   2498          
   2499              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
   2500                  delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
   2501                        - OSSchedLockTimeBegin;
   2502                  if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
   2503                      OSSchedLockTimeMax    = delta;
   2504                  }
   2505                  if (OSSchedLockTimeMaxCur < delta) {                /* Detect peak value (for resettable value)               */
   2506                      OSSchedLockTimeMaxCur = delta;
   2507                  }
   2508              }
   2509          }
   2510          #endif
   2511          
   2512          /*$PAGE*/
   2513          /*
   2514          ************************************************************************************************************************
   2515          *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
   2516          *
   2517          * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
   2518          *
   2519          *
   2520          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
   2521          *              ----------
   2522          *
   2523          * Returns    : none
   2524          *
   2525          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2526          ************************************************************************************************************************
   2527          */
   2528          
   2529          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2530          void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
   2531          {
   \                     OS_SchedRoundRobin: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2532              OS_TCB   *p_tcb;
   2533              CPU_SR_ALLOC();
   2534          
   2535          
   2536          
   2537              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
   \   00000004   0x....             LDR.N    R0,??DataTable17_8
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD12C             BNE.N    ??OS_SchedRoundRobin_0
   2538                  return;
   2539              }
   2540          
   2541              CPU_CRITICAL_ENTER();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   \   00000010   0x4605             MOV      R5,R0
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasStart
   2542              p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   2543          
   2544              if (p_tcb == (OS_TCB *)0) {
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD01D             BEQ.N    ??OS_SchedRoundRobin_1
   2545                  CPU_CRITICAL_EXIT();
   2546                  return;
   2547              }
   2548          
   2549              if (p_tcb == &OSIdleTaskTCB) {
   \   0000001C   0x....             LDR.N    R1,??DataTable17_29
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD01A             BEQ.N    ??OS_SchedRoundRobin_1
   2550                  CPU_CRITICAL_EXIT();
   2551                  return;
   2552              }
   2553          
   2554              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
   \   00000022   0x6D81             LDR      R1,[R0, #+88]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD001             BEQ.N    ??OS_SchedRoundRobin_2
   2555                  p_tcb->TimeQuantaCtr--;
   \   00000028   0x1E49             SUBS     R1,R1,#+1
   \   0000002A   0x6581             STR      R1,[R0, #+88]
   2556              }
   2557          
   2558              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
   \                     ??OS_SchedRoundRobin_2: (+1)
   \   0000002C   0x6D80             LDR      R0,[R0, #+88]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD112             BNE.N    ??OS_SchedRoundRobin_1
   2559                  CPU_CRITICAL_EXIT();
   2560                  return;
   2561              }
   2562          
   2563              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
   \   00000032   0x8920             LDRH     R0,[R4, #+8]
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xDB0F             BLT.N    ??OS_SchedRoundRobin_1
   2564                  CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
   2565                  return;
   2566              }
   2567          
   2568              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
   \   00000038   0x....             LDR.N    R0,??DataTable17_2
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD10B             BNE.N    ??OS_SchedRoundRobin_1
   2569                  CPU_CRITICAL_EXIT();
   2570                  return;
   2571              }
   2572          
   2573              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
   2574              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   2575              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
   \   00000048   0x6D41             LDR      R1,[R0, #+84]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD103             BNE.N    ??OS_SchedRoundRobin_3
   2576                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   0000004E   0x....             LDR.N    R1,??DataTable17_10
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x6581             STR      R1,[R0, #+88]
   \   00000054   0xE000             B.N      ??OS_SchedRoundRobin_1
   2577              } else {
   2578                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
   \                     ??OS_SchedRoundRobin_3: (+1)
   \   00000056   0x6581             STR      R1,[R0, #+88]
   2579              }
   2580              CPU_CRITICAL_EXIT();
   \                     ??OS_SchedRoundRobin_1: (+1)
   \   00000058   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000062   0x.... 0x....      B.W      CPU_SR_Restore
   \                     ??OS_SchedRoundRobin_0: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2581          }
   2582          #endif
   2583          
   2584          /*$PAGE*/
   2585          /*
   2586          ************************************************************************************************************************
   2587          *                                                     BLOCK A TASK
   2588          *
   2589          * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
   2590          *              the specified timeout is non-zero.
   2591          *
   2592          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
   2593          *              -----
   2594          *
   2595          *              timeout        is the desired timeout
   2596          *
   2597          * Returns    : none
   2598          *
   2599          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2600          ************************************************************************************************************************
   2601          */
   2602          

   \                                 In section .text, align 2, keep-with-next
   2603          void  OS_TaskBlock (OS_TCB   *p_tcb,
   2604                              OS_TICK   timeout)
   2605          {
   \                     OS_TaskBlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   2606              OS_ERR  err;
   2607          
   2608          
   2609              if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD00F             BEQ.N    ??OS_TaskBlock_0
   2610                  OS_TickListInsert(p_tcb,
   2611                                    timeout,
   2612                                    OS_OPT_TIME_TIMEOUT,
   2613                                   &err);
   \   0000000A   0x466B             MOV      R3,SP
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x.... 0x....      BL       OS_TickListInsert
   2614                  if (err == OS_ERR_NONE) {
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD103             BNE.N    ??OS_TaskBlock_1
   2615                      p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   00000020   0xE006             B.N      ??OS_TaskBlock_2
   2616                  } else {
   2617                      p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_1: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   00000028   0xE002             B.N      ??OS_TaskBlock_2
   2618                  }
   2619              } else {
   2620                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_0: (+1)
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x0036      STRB     R0,[R4, #+54]
   2621              }
   2622              OS_RdyListRemove(p_tcb);
   \                     ??OS_TaskBlock_2: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       OS_RdyListRemove
   2623          }
   \   00000036   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2624          
   2625          /*$PAGE*/
   2626          /*
   2627          ************************************************************************************************************************
   2628          *                                                     READY A TASK
   2629          *
   2630          * Description: This function is called to make a task ready-to-run.
   2631          *
   2632          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   2633          *              -----
   2634          *
   2635          * Returns    : none
   2636          *
   2637          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2638          ************************************************************************************************************************
   2639          */
   2640          

   \                                 In section .text, align 2, keep-with-next
   2641          void  OS_TaskRdy (OS_TCB  *p_tcb)
   2642          {
   \                     OS_TaskRdy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2643              OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
   \   00000004   0x.... 0x....      BL       OS_TickListRemove
   2644              if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
   \   00000008   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000000C   0x0740             LSLS     R0,R0,#+29
   \   0000000E   0xD403             BMI.N    ??OS_TaskRdy_0
   2645                  OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x....             B.N      OS_RdyListInsert
   2646              }
   2647          }
   \                     ??OS_TaskRdy_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     OSPrioSaved

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     OSSchedRoundRobinEn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     OSIdleTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0x........         DC32     OS_IdleTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-III Idle Task"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x49 0x20    
   \              0x49 0x64    
   \              0x6C 0x65    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSInit
         0   -> OSCfg_Init
         8   -> OSInitHook
         8   -> OS_FlagInit
         8   -> OS_IdleTaskInit
         8   -> OS_MsgPoolInit
         8   -> OS_PrioInit
         8   -> OS_QInit
         8   -> OS_RdyListInit
         8   -> OS_SemInit
         8   -> OS_TaskInit
         8   -> OS_TickTaskInit
         8   -> OS_TmrInit
       0   OSIntEnter
       8   OSIntExit
         0   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
       8   OSSched
         0   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
      16   OSSchedLock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   OSSchedRoundRobinCfg
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSSchedRoundRobinYield
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListMoveHeadToTail
      16   OSSchedUnlock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
      16   OSStart
        16   -> OSStartHighRdy
        16   -> OS_PrioGetHighest
       0   OSVersion
       8   OS_IdleTask
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIdleTaskHook
      40   OS_IdleTaskInit
        40   -> OSTaskCreate
      16   OS_Pend
        16   -> OS_PendDataInit
         0   -> OS_PendListInsertPrio
        16   -> OS_TaskBlock
      24   OS_PendAbort
        24   -> OS_PendAbort1
        24   -> OS_PendListRemove
        24   -> OS_TaskRdy
        24   -> OS_TickListRemove
       4   OS_PendAbort1
       4   OS_PendDataInit
      16   OS_PendListChangePrio
        16   -> OS_PendListInsertPrio
        16   -> OS_PendListRemove1
       0   OS_PendListInit
       0   OS_PendListInsertHead
       4   OS_PendListInsertPrio
      16   OS_PendListRemove
        16   -> OS_PendListRemove1
       0   OS_PendListRemove1
      16   OS_PendObjDel
        16   -> OS_PendListRemove
        16   -> OS_PendObjDel1
        16   -> OS_TaskRdy
        16   -> OS_TickListRemove
       4   OS_PendObjDel1
      24   OS_Post
        24   -> OS_PendListRemove
        24   -> OS_Post1
        24   -> OS_TaskRdy
        24   -> OS_TickListRemove
       8   OS_Post1
       0   OS_RdyListInit
       8   OS_RdyListInsert
         8   -> OS_PrioInsert
         0   -> OS_RdyListInsertHead
         0   -> OS_RdyListInsertTail
       0   OS_RdyListInsertHead
       0   OS_RdyListInsertTail
       4   OS_RdyListMoveHeadToTail
       8   OS_RdyListRemove
         8   -> OS_PrioRemove
      16   OS_SchedRoundRobin
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_RdyListMoveHeadToTail
      16   OS_TaskBlock
        16   -> OS_RdyListRemove
        16   -> OS_TickListInsert
       8   OS_TaskRdy
         0   -> OS_RdyListInsert
         8   -> OS_TickListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      20  ?_0
     280  OSInit
      26  OSIntEnter
     168  OSIntExit
     120  OSSched
      90  OSSchedLock
      78  OSSchedRoundRobinCfg
     156  OSSchedRoundRobinYield
     118  OSSchedUnlock
      78  OSStart
      10  OSVersion
      38  OS_IdleTask
      76  OS_IdleTaskInit
      72  OS_Pend
     128  OS_PendAbort
      32  OS_PendAbort1
      40  OS_PendDataInit
      52  OS_PendListChangePrio
      10  OS_PendListInit
      34  OS_PendListInsertHead
     102  OS_PendListInsertPrio
      38  OS_PendListRemove
      60  OS_PendListRemove1
     118  OS_PendObjDel
      32  OS_PendObjDel1
     132  OS_Post
      38  OS_Post1
      30  OS_RdyListInit
      36  OS_RdyListInsert
      56  OS_RdyListInsertHead
      54  OS_RdyListInsertTail
      62  OS_RdyListMoveHeadToTail
      90  OS_RdyListRemove
     104  OS_SchedRoundRobin
      56  OS_TaskBlock
      26  OS_TaskRdy

 
 2 780 bytes in section .text
 
 2 780 bytes of CODE memory

Errors: none
Warnings: none
