###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Dec/2017  15:40:24
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_time.c
#    Command line =  
#        F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_time.c -D
#        USE_STDPERIPH_DRIVER -D _STM32F10X_HD -D STM32F10X_CL -D DEBUG -D
#        STM32F103RC -D STM32_FLASH_SIZE=256 -D HSE_VALUE=25000000 -lCN
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\
#        -o
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC199B-100\Library\Project\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\AES\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Config\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\User\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Protocol\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\APP\Iap\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Driver\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\IAR\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\OSAL\OS\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\
#        -I F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\ -I
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\Source\FatFs\option\ -Om
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\List\os_time.lst
#    Object file  =  
#        F:\iar\NC199B-100\Library\Project\IAR\..\..\..\Output\Lib\Debug-RC\Obj\os_time.o
#
###############################################################################

F:\iar\NC199B-100\Library\Source\Micrium\uC-OS-III\Source\os_time.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIME MANAGEMENT
     10          *
     11          * File    : OS_TIME.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_time__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                  DELAY TASK 'n' TICKS
     43          *
     44          * Description: This function is called to delay execution of the currently running task until the specified number of
     45          *              system ticks expires.  This, of course, directly equates to delaying the current task for some time to
     46          *              expire.  No delay will result if the specified delay is 0.  If the specified delay is greater than 0
     47          *              then, a context switch will result.
     48          *
     49          * Arguments  : dly       is a value in 'clock ticks' that the task will either delay for or, the target match value
     50          *                        of the tick counter (OSTickCtr).  Note that specifying 0 means the task is not to delay.
     51          *
     52          *                        depending on the option argument, the task will wake up when OSTickCtr reaches:
     53          *
     54          *                            OS_OPT_TIME_DLY      : OSTickCtr + dly
     55          *                            OS_OPT_TIME_TIMEOUT  : OSTickCtr + dly
     56          *                            OS_OPT_TIME_MATCH    : dly
     57          *                            OS_OPT_TIME_PERIODIC : OSTCBCurPtr->TickCtrPrev + dly
     58          *
     59          *              opt       specifies whether 'dly' represents absolute or relative time; default option marked with *** :
     60          *
     61          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
     62          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
     63          *                            OS_OPT_TIME_MATCH      indicates that 'dly' specifies the absolute value that OSTickCtr
     64          *                                                   must reach before the task will be resumed.
     65          *                            OS_OPT_TIME_PERIODIC   indicates that 'dly' specifies the periodic value that OSTickCtr
     66          *                                                   must reach before the task will be resumed.
     67          *
     68          *              p_err     is a pointer to a variable that will contain an error code from this call.
     69          *
     70          *                            OS_ERR_NONE            the call was successful and the delay occurred.
     71          *                            OS_ERR_OPT_INVALID     if you specified an invalid option for this function.
     72          *                            OS_ERR_SCHED_LOCKED    can't delay when the scheduler is locked.
     73          *                            OS_ERR_TIME_DLY_ISR    if you called this function from an ISR.
     74          *                            OS_ERR_TIME_ZERO_DLY   if you specified a delay of zero.
     75          *
     76          * Returns    : none
     77          ************************************************************************************************************************
     78          */
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void  OSTimeDly (OS_TICK   dly,
     81                           OS_OPT    opt,
     82                           OS_ERR   *p_err)
     83          {
   \                     OSTimeDly: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
     84              CPU_SR_ALLOC();
     85          
     86          
     87          
     88          #ifdef OS_SAFETY_CRITICAL
     89              if (p_err == (OS_ERR *)0) {
     90                  OS_SAFETY_CRITICAL_EXCEPTION();
     91                  return;
     92              }
     93          #endif
     94          
     95          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     96              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   0000000A   0x....             LDR.N    R0,??DataTable5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTimeDly_0
     97                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000012   0xF247 0x2075      MOVW     R0,#+29301
   \   00000016   0x8020             STRH     R0,[R4, #+0]
     98                  return;
   \   00000018   0xE043             B.N      ??OSTimeDly_1
     99              }
    100          #endif
    101          
    102              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
   \                     ??OSTimeDly_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??OSTimeDly_2
    103                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000022   0xF646 0x5063      MOVW     R0,#+28003
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    104                  return;
   \   00000028   0xE03B             B.N      ??OSTimeDly_1
    105              }
    106          
    107              switch (opt) {
   \                     ??OSTimeDly_2: (+1)
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xD005             BEQ.N    ??OSTimeDly_3
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xD003             BEQ.N    ??OSTimeDly_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD00B             BEQ.N    ??OSTimeDly_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD105             BNE.N    ??OSTimeDly_5
    108                  case OS_OPT_TIME_DLY:
    109                  case OS_OPT_TIME_TIMEOUT:
    110                  case OS_OPT_TIME_PERIODIC:
    111                       if (dly == (OS_TICK)0u) {                      /* 0 means no delay!                                      */
   \                     ??OSTimeDly_3: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD107             BNE.N    ??OSTimeDly_4
    112                          *p_err = OS_ERR_TIME_ZERO_DLY;
   \   0000003E   0xF247 0x207E      MOVW     R0,#+29310
   \   00000042   0x8020             STRH     R0,[R4, #+0]
    113                           return;
   \   00000044   0xE02D             B.N      ??OSTimeDly_1
    114                       }
    115                       break;
    116          
    117                  case OS_OPT_TIME_MATCH:
    118                       break;
    119          
    120                  default:
    121                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDly_5: (+1)
   \   00000046   0xF645 0x6025      MOVW     R0,#+24101
   \   0000004A   0x8020             STRH     R0,[R4, #+0]
    122                       return;
   \   0000004C   0xE029             B.N      ??OSTimeDly_1
    123              }
    124          
    125              OS_CRITICAL_ENTER();
   \                     ??OSTimeDly_4: (+1)
   \   0000004E   0x.... 0x....      BL       CPU_SR_Save
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStart
    126              OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \   00000058   0x.... 0x....      LDR.W    R8,??DataTable5_2
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   00000062   0xF881 0x0036      STRB     R0,[R1, #+54]
    127              OS_TickListInsert(OSTCBCurPtr,
    128                                dly,
    129                                opt,
    130                                p_err);
   \   00000066   0x4623             MOV      R3,R4
   \   00000068   0x4632             MOV      R2,R6
   \   0000006A   0x4629             MOV      R1,R5
   \   0000006C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000070   0x.... 0x....      BL       OS_TickListInsert
    131              if (*p_err != OS_ERR_NONE) {
   \   00000074   0x8820             LDRH     R0,[R4, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD006             BEQ.N    ??OSTimeDly_6
    132                   OS_CRITICAL_EXIT_NO_SCHED();
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007E   0x4638             MOV      R0,R7
   \   00000080   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000084   0x.... 0x....      B.W      CPU_SR_Restore
    133                   return;
    134              }
    135              OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                    */
   \                     ??OSTimeDly_6: (+1)
   \   00000088   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000008C   0x.... 0x....      BL       OS_RdyListRemove
    136              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000090   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000094   0x4638             MOV      R0,R7
   \   00000096   0x.... 0x....      BL       CPU_SR_Restore
    137              OSSched();                                              /* Find next task to run!                                 */
   \   0000009A   0x.... 0x....      BL       OSSched
    138             *p_err = OS_ERR_NONE;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x8020             STRH     R0,[R4, #+0]
    139          }
   \                     ??OSTimeDly_1: (+1)
   \   000000A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    140          
    141          /*$PAGE*/
    142          /*
    143          ************************************************************************************************************************
    144          *                                             DELAY TASK FOR SPECIFIED TIME
    145          *
    146          * Description: This function is called to delay execution of the currently running task until some time expires.  This
    147          *              call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
    148          *
    149          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 999 if the tick rate is
    150          *                        1000 Hz or less otherwise, a higher value would overflow a 32-bit unsigned counter).
    151          *
    152          *              minutes   specifies the number of minutes (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    153          *
    154          *              seconds   specifies the number of seconds (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    155          *
    156          *              milli     specifies the number of milliseconds (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    157          *
    158          *              opt       specifies time delay bit-field options logically OR'd; default options marked with *** :
    159          *
    160          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
    161          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
    162          *                            OS_OPT_TIME_MATCH      indicates that the delay specifies the absolute value that OSTickCtr
    163          *                                                   must reach before the task will be resumed.
    164          *                            OS_OPT_TIME_PERIODIC   indicates that the delay specifies the periodic value that OSTickCtr
    165          *                                                   must reach before the task will be resumed.
    166          *
    167          *                        *** OS_OPT_TIME_HMSM_STRICT            strictly allow only hours        (0...99)
    168          *                                                                                   minutes      (0...59)
    169          *                                                                                   seconds      (0...59)
    170          *                                                                                   milliseconds (0...999)
    171          *                            OS_OPT_TIME_HMSM_NON_STRICT        allow any value of  hours        (0...999)
    172          *                                                                                   minutes      (0...9999)
    173          *                                                                                   seconds      (0...65535)
    174          *                                                                                   milliseconds (0...4294967295)
    175          *
    176          *              p_err     is a pointer to a variable that will receive an error code from this call.
    177          *
    178          *                            OS_ERR_NONE                        If the function returns from the desired delay
    179          *                            OS_ERR_OPT_INVALID                 If you specified an invalid option for 'opt'
    180          *                            OS_ERR_SCHED_LOCKED                Can't delay when the scheduler is locked
    181          *                            OS_ERR_TIME_DLY_ISR                If called from an ISR
    182          *                            OS_ERR_TIME_INVALID_HOURS          If you didn't specify a valid value for 'hours'
    183          *                            OS_ERR_TIME_INVALID_MINUTES        If you didn't specify a valid value for 'minutes'
    184          *                            OS_ERR_TIME_INVALID_SECONDS        If you didn't specify a valid value for 'seconds'
    185          *                            OS_ERR_TIME_INVALID_MILLISECONDS   If you didn't specify a valid value for 'milli'
    186          *                            OS_ERR_TIME_ZERO_DLY               If hours, minutes, seconds and milli are all 0
    187          *
    188          * Returns    : none
    189          *
    190          * Note(s)    : 1) The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay
    191          *                 if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay
    192          *                 is rounded to the nearest tick.
    193          *
    194          *              2) Although this function allows you to delay a task for many, many hours, it's not recommended to put
    195          *                 a task to sleep for that long.
    196          ************************************************************************************************************************
    197          */
    198          
    199          #if OS_CFG_TIME_DLY_HMSM_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    200          void  OSTimeDlyHMSM (CPU_INT16U   hours,
    201                               CPU_INT16U   minutes,
    202                               CPU_INT16U   seconds,
    203                               CPU_INT32U   milli,
    204                               OS_OPT       opt,
    205                               OS_ERR      *p_err)
    206          {
   \                     OSTimeDlyHMSM: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x9D07             LDR      R5,[SP, #+28]
    207          #if OS_CFG_ARG_CHK_EN > 0u
    208              CPU_BOOLEAN  opt_invalid;
    209              CPU_BOOLEAN  opt_non_strict;
    210          #endif
    211              OS_OPT       opt_time;
    212              OS_RATE_HZ   tick_rate;
    213              OS_TICK      ticks;
    214              CPU_SR_ALLOC();
    215          
    216          
    217          
    218          #ifdef OS_SAFETY_CRITICAL
    219              if (p_err == (OS_ERR *)0) {
    220                  OS_SAFETY_CRITICAL_EXCEPTION();
    221                  return;
    222              }
    223          #endif
    224          
    225          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    226              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000006   0x....             LDR.N    R4,??DataTable5
   \   00000008   0x7824             LDRB     R4,[R4, #+0]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD003             BEQ.N    ??OSTimeDlyHMSM_0
    227                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   0000000E   0xF247 0x2075      MOVW     R0,#+29301
   \   00000012   0x8028             STRH     R0,[R5, #+0]
    228                  return;
   \   00000014   0xE094             B.N      ??OSTimeDlyHMSM_1
    229              }
    230          #endif
    231          
    232              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
   \                     ??OSTimeDlyHMSM_0: (+1)
   \   00000016   0x....             LDR.N    R4,??DataTable5_1
   \   00000018   0x7824             LDRB     R4,[R4, #+0]
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTimeDlyHMSM_2
    233                 *p_err = OS_ERR_SCHED_LOCKED;
   \   0000001E   0xF646 0x5063      MOVW     R0,#+28003
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    234                  return;
   \   00000024   0xE08C             B.N      ??OSTimeDlyHMSM_1
    235              }
   \                     ??OSTimeDlyHMSM_2: (+1)
   \   00000026   0x9C06             LDR      R4,[SP, #+24]
    236          
    237              opt_time = opt & OS_OPT_TIME_MASK;                      /* Retrieve time options only.                            */
   \   00000028   0xF004 0x060E      AND      R6,R4,#0xE
    238              switch (opt_time) {
   \   0000002C   0x0037             MOVS     R7,R6
   \   0000002E   0xD005             BEQ.N    ??OSTimeDlyHMSM_3
   \   00000030   0x2F02             CMP      R7,#+2
   \   00000032   0xD003             BEQ.N    ??OSTimeDlyHMSM_3
   \   00000034   0x2F04             CMP      R7,#+4
   \   00000036   0xD00B             BEQ.N    ??OSTimeDlyHMSM_4
   \   00000038   0x2F08             CMP      R7,#+8
   \   0000003A   0xD114             BNE.N    ??OSTimeDlyHMSM_5
    239                  case OS_OPT_TIME_DLY:
    240                  case OS_OPT_TIME_TIMEOUT:
    241                  case OS_OPT_TIME_PERIODIC:
    242                       if (milli == (CPU_INT32U)0u) {                 /* Make sure we didn't specify a 0 delay                  */
   \                     ??OSTimeDlyHMSM_3: (+1)
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD107             BNE.N    ??OSTimeDlyHMSM_4
    243                           if (seconds == (CPU_INT16U)0u) {
    244                               if (minutes == (CPU_INT16U)0u) {
    245                                   if (hours == (CPU_INT16U)0u) {
   \   00000040   0xEA41 0x0702      ORR      R7,R1,R2
   \   00000044   0x4307             ORRS     R7,R0,R7
   \   00000046   0xD103             BNE.N    ??OSTimeDlyHMSM_4
    246                                      *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000048   0xF247 0x207E      MOVW     R0,#+29310
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
    247                                       return;
   \   0000004E   0xE077             B.N      ??OSTimeDlyHMSM_1
    248                                   }
    249                               }
    250                           }
    251                       }
    252                       break;
    253          
    254                  case OS_OPT_TIME_MATCH:
    255                       break;
    256          
    257                  default:
    258                      *p_err = OS_ERR_OPT_INVALID;
    259                       return;
    260              }
    261          
    262          #if OS_CFG_ARG_CHK_EN > 0u                                  /* Validate arguments to be within range                  */
    263              opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
   \                     ??OSTimeDlyHMSM_4: (+1)
   \   00000050   0xF64F 0x77E1      MOVW     R7,#+65505
   \   00000054   0xEA07 0x0C04      AND      R12,R7,R4
   \   00000058   0xF1BC 0x0701      SUBS     R7,R12,#+1
   \   0000005C   0x41BF             SBCS     R7,R7,R7
   \   0000005E   0x43FF             MVNS     R7,R7
   \   00000060   0x0FFF             LSRS     R7,R7,#+31
    264              if (opt_invalid == DEF_YES) {
   \   00000062   0x2F01             CMP      R7,#+1
   \   00000064   0xD103             BNE.N    ??OSTimeDlyHMSM_6
    265                 *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDlyHMSM_5: (+1)
   \   00000066   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006A   0x8028             STRH     R0,[R5, #+0]
    266                  return;
   \   0000006C   0xE068             B.N      ??OSTimeDlyHMSM_1
    267              }
    268          
    269              opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
    270              if (opt_non_strict != DEF_YES) {
   \                     ??OSTimeDlyHMSM_6: (+1)
   \   0000006E   0x06E4             LSLS     R4,R4,#+27
   \   00000070   0xD446             BMI.N    ??OSTimeDlyHMSM_7
    271                   if (milli   > (CPU_INT32U)999u) {
   \   00000072   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   00000076   0xD303             BCC.N    ??OSTimeDlyHMSM_8
    272                      *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
   \   00000078   0xF247 0x207B      MOVW     R0,#+29307
   \   0000007C   0x8028             STRH     R0,[R5, #+0]
    273                       return;
   \   0000007E   0xE05F             B.N      ??OSTimeDlyHMSM_1
    274                   }
    275                   if (seconds > (CPU_INT16U)59u) {
   \                     ??OSTimeDlyHMSM_8: (+1)
   \   00000080   0x2A3C             CMP      R2,#+60
   \   00000082   0xDB03             BLT.N    ??OSTimeDlyHMSM_9
    276                      *p_err = OS_ERR_TIME_INVALID_SECONDS;
   \   00000084   0xF247 0x207A      MOVW     R0,#+29306
   \   00000088   0x8028             STRH     R0,[R5, #+0]
    277                       return;
   \   0000008A   0xE059             B.N      ??OSTimeDlyHMSM_1
    278                   }
    279                   if (minutes > (CPU_INT16U)59u) {
   \                     ??OSTimeDlyHMSM_9: (+1)
   \   0000008C   0x293C             CMP      R1,#+60
   \   0000008E   0xDA3B             BGE.N    ??OSTimeDlyHMSM_10
    280                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
    281                       return;
    282                   }
    283                   if (hours   > (CPU_INT16U)99u) {
   \   00000090   0x2864             CMP      R0,#+100
   \   00000092   0xDA40             BGE.N    ??OSTimeDlyHMSM_11
    284                      *p_err = OS_ERR_TIME_INVALID_HOURS;
    285                       return;
    286                   }
    287              } else {
    288                   if (minutes > (CPU_INT16U)9999u) {
    289                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
    290                       return;
    291                   }
    292                   if (hours   > (CPU_INT16U)999u) {
    293                      *p_err = OS_ERR_TIME_INVALID_HOURS;
    294                       return;
    295                   }
    296              }
    297          #endif
    298          
    299                                                                      /* Compute the total number of clock ticks required..     */
    300                                                                      /* .. (rounded to the nearest tick)                       */
    301              tick_rate = OSCfg_TickRate_Hz;
    302              ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
    303                        + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;
   \                     ??OSTimeDlyHMSM_12: (+1)
   \   00000094   0x....             LDR.N    R4,??DataTable5_3
   \   00000096   0x6824             LDR      R4,[R4, #+0]
   \   00000098   0xF44F 0x6761      MOV      R7,#+3600
   \   0000009C   0xEBC1 0x1C01      RSB      R12,R1,R1, LSL #+4
   \   000000A0   0xEA4F 0x018C      LSL      R1,R12,#+2
   \   000000A4   0xFB07 0x1000      MLA      R0,R7,R0,R1
   \   000000A8   0x1810             ADDS     R0,R2,R0
   \   000000AA   0xF44F 0x71FA      MOV      R1,#+500
   \   000000AE   0xFBB1 0xF1F4      UDIV     R1,R1,R4
   \   000000B2   0x18C9             ADDS     R1,R1,R3
   \   000000B4   0x4361             MULS     R1,R1,R4
   \   000000B6   0xF44F 0x727A      MOV      R2,#+1000
   \   000000BA   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000BE   0xFB04 0x1400      MLA      R4,R4,R0,R1
    304          
    305              if (ticks > (OS_TICK)0u) {
   \   000000C2   0x2C00             CMP      R4,#+0
   \   000000C4   0xD039             BEQ.N    ??OSTimeDlyHMSM_13
    306                  OS_CRITICAL_ENTER();
   \   000000C6   0x.... 0x....      BL       CPU_SR_Save
   \   000000CA   0x4607             MOV      R7,R0
   \   000000CC   0x.... 0x....      BL       CPU_IntDisMeasStart
    307                  OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \   000000D0   0x.... 0x....      LDR.W    R8,??DataTable5_2
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   000000DA   0xF881 0x0036      STRB     R0,[R1, #+54]
    308                  OS_TickListInsert(OSTCBCurPtr,
    309                                    ticks,
    310                                    opt_time,
    311                                    p_err);
   \   000000DE   0x462B             MOV      R3,R5
   \   000000E0   0x4632             MOV      R2,R6
   \   000000E2   0x4621             MOV      R1,R4
   \   000000E4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000E8   0x.... 0x....      BL       OS_TickListInsert
    312                  if (*p_err != OS_ERR_NONE) {
   \   000000EC   0x8828             LDRH     R0,[R5, #+0]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD015             BEQ.N    ??OSTimeDlyHMSM_14
    313                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F6   0x4638             MOV      R0,R7
   \   000000F8   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000FC   0x.... 0x....      B.W      CPU_SR_Restore
    314                       return;
    315                  }
   \                     ??OSTimeDlyHMSM_7: (+1)
   \   00000100   0xF242 0x7410      MOVW     R4,#+10000
   \   00000104   0x42A1             CMP      R1,R4
   \   00000106   0xDB03             BLT.N    ??OSTimeDlyHMSM_15
   \                     ??OSTimeDlyHMSM_10: (+1)
   \   00000108   0xF247 0x2079      MOVW     R0,#+29305
   \   0000010C   0x8028             STRH     R0,[R5, #+0]
   \   0000010E   0xE017             B.N      ??OSTimeDlyHMSM_1
   \                     ??OSTimeDlyHMSM_15: (+1)
   \   00000110   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000114   0xDBBE             BLT.N    ??OSTimeDlyHMSM_12
   \                     ??OSTimeDlyHMSM_11: (+1)
   \   00000116   0xF247 0x2078      MOVW     R0,#+29304
   \   0000011A   0x8028             STRH     R0,[R5, #+0]
   \   0000011C   0xE010             B.N      ??OSTimeDlyHMSM_1
    316                  OS_RdyListRemove(OSTCBCurPtr);                      /* Remove current task from ready list                    */
   \                     ??OSTimeDlyHMSM_14: (+1)
   \   0000011E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000122   0x.... 0x....      BL       OS_RdyListRemove
    317                  OS_CRITICAL_EXIT_NO_SCHED();
   \   00000126   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012A   0x4638             MOV      R0,R7
   \   0000012C   0x.... 0x....      BL       CPU_SR_Restore
    318                  OSSched();                                          /* Find next task to run!                                 */
   \   00000130   0x.... 0x....      BL       OSSched
    319                 *p_err = OS_ERR_NONE;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x8028             STRH     R0,[R5, #+0]
   \   00000138   0xE002             B.N      ??OSTimeDlyHMSM_1
    320              } else {
    321                 *p_err = OS_ERR_TIME_ZERO_DLY;
   \                     ??OSTimeDlyHMSM_13: (+1)
   \   0000013A   0xF247 0x207E      MOVW     R0,#+29310
   \   0000013E   0x8028             STRH     R0,[R5, #+0]
    322              }
    323          }
   \                     ??OSTimeDlyHMSM_1: (+1)
   \   00000140   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    324          #endif
    325          /*$PAGE*/
    326          /*
    327          ************************************************************************************************************************
    328          *                                                RESUME A DELAYED TASK
    329          *
    330          * Description: This function is used resume a task that has been delayed through a call to either OSTimeDly() or
    331          *              OSTimeDlyHMSM().  Note that cannot call this function to resume a task that is waiting for an event
    332          *              with timeout.
    333          *
    334          * Arguments  : p_tcb    is a pointer to the TCB of the task to resume.
    335          *
    336          *              p_err    is a pointer to a variable that will receive an error code
    337          *
    338          *                           OS_ERR_NONE                  Task has been resumed
    339          *                           OS_ERR_STATE_INVALID         Task is in an invalid state
    340          *                           OS_ERR_TIME_DLY_RESUME_ISR   If called from an ISR
    341          *                           OS_ERR_TIME_NOT_DLY          Task is not waiting for time to expire
    342          *                           OS_ERR_TASK_SUSPENDED        Task cannot be resumed, it was suspended by OSTaskSuspend()
    343          *
    344          * Note(s)    : none
    345          ************************************************************************************************************************
    346          */
    347          
    348          #if OS_CFG_TIME_DLY_RESUME_EN > 0u

   \                                 In section .text, align 4, keep-with-next
    349          void  OSTimeDlyResume (OS_TCB  *p_tcb,
    350                                 OS_ERR  *p_err)
    351          {
   \                     OSTimeDlyResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    352              CPU_SR_ALLOC();
    353          
    354          
    355          
    356          #ifdef OS_SAFETY_CRITICAL
    357              if (p_err == (OS_ERR *)0) {
    358                  OS_SAFETY_CRITICAL_EXCEPTION();
    359                  return;
    360              }
    361          #endif
    362          
    363          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    364              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??OSTimeDlyResume_1
    365                 *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
   \   0000000E   0xF247 0x2076      MOVW     R0,#+29302
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    366                  return;
   \   00000014   0xBD70             POP      {R4-R6,PC}
    367              }
    368          #endif
    369          
    370          #if OS_CFG_ARG_CHK_EN > 0u
    371              if (p_tcb == (OS_TCB *)0) {                             /* Not possible for the running task to be delayed!       */
   \                     ??OSTimeDlyResume_1: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD103             BNE.N    ??OSTimeDlyResume_2
    372                 *p_err = OS_ERR_TASK_NOT_DLY;
   \   0000001A   0xF247 0x1051      MOVW     R0,#+29009
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
    373                  return;
   \   00000020   0xBD70             POP      {R4-R6,PC}
    374              }
    375          #endif
    376          
    377              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDlyResume_2: (+1)
   \   00000022   0x.... 0x....      BL       CPU_SR_Save
   \   00000026   0x4606             MOV      R6,R0
   \   00000028   0x.... 0x....      BL       CPU_IntDisMeasStart
    378              if (p_tcb == OSTCBCurPtr) {                             /* Not possible for the running task to be delayed!       */
   \   0000002C   0x....             LDR.N    R0,??DataTable5_2
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD109             BNE.N    ??OSTimeDlyResume_3
    379                 *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000034   0xF247 0x1051      MOVW     R0,#+29009
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    380                  CPU_CRITICAL_EXIT();
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000044   0x.... 0x....      B.W      CPU_SR_Restore
    381                  return;
    382              }
    383          
    384              switch (p_tcb->TaskState) {
   \                     ??OSTimeDlyResume_3: (+1)
   \   00000048   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   0000004C   0x2807             CMP      R0,#+7
   \   0000004E   0xD82E             BHI.N    ??OSTimeDlyResume_4
   \   00000050   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??OSTimeDlyResume_0:
   \   00000054   0x24 0x04          DC8      0x24,0x4,0x24,0x24
   \              0x24 0x24    
   \   00000058   0x24 0x15          DC8      0x24,0x15,0x24,0x24
   \              0x24 0x24    
    385                  case OS_TASK_STATE_RDY:                             /* Cannot Abort delay if task is ready                    */
    386                       CPU_CRITICAL_EXIT();
    387                      *p_err = OS_ERR_TASK_NOT_DLY;
    388                       break;
    389          
    390                  case OS_TASK_STATE_DLY:
    391                       OS_CRITICAL_ENTER_CPU_EXIT();
    392                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \                     ??OSTimeDlyResume_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF885 0x0036      STRB     R0,[R5, #+54]
    393                       OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       OS_TickListRemove
    394                       OS_RdyListInsert(p_tcb);                       /* Add to ready list                                      */
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       OS_RdyListInsert
    395                       OS_CRITICAL_EXIT_NO_SCHED();
   \   0000006E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x.... 0x....      BL       CPU_SR_Restore
    396                      *p_err = OS_ERR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x8020             STRH     R0,[R4, #+0]
    397                       break;
   \   0000007C   0xE01F             B.N      ??OSTimeDlyResume_6
    398          
    399                  case OS_TASK_STATE_PEND:
    400                       CPU_CRITICAL_EXIT();
    401                      *p_err = OS_ERR_TASK_NOT_DLY;
    402                       break;
    403          
    404                  case OS_TASK_STATE_PEND_TIMEOUT:
    405                       CPU_CRITICAL_EXIT();
    406                      *p_err = OS_ERR_TASK_NOT_DLY;
    407                       break;
    408          
    409                  case OS_TASK_STATE_SUSPENDED:
    410                       CPU_CRITICAL_EXIT();
    411                      *p_err = OS_ERR_TASK_NOT_DLY;
    412                       break;
    413          
    414                  case OS_TASK_STATE_DLY_SUSPENDED:
    415                       OS_CRITICAL_ENTER_CPU_EXIT();
    416                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OSTimeDlyResume_7: (+1)
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0xF885 0x0036      STRB     R0,[R5, #+54]
    417                       OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       OS_TickListRemove
    418                       OS_CRITICAL_EXIT_NO_SCHED();
   \   0000008A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008E   0x4630             MOV      R0,R6
   \   00000090   0x.... 0x....      BL       CPU_SR_Restore
    419                      *p_err            = OS_ERR_TASK_SUSPENDED;
   \   00000094   0xF247 0x105A      MOVW     R0,#+29018
   \   00000098   0x8020             STRH     R0,[R4, #+0]
    420                       break;
   \   0000009A   0xE010             B.N      ??OSTimeDlyResume_6
    421          
    422                  case OS_TASK_STATE_PEND_SUSPENDED:
    423                       CPU_CRITICAL_EXIT();
    424                      *p_err = OS_ERR_TASK_NOT_DLY;
    425                       break;
    426          
    427                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    428                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_8: (+1)
   \   0000009C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A0   0x4630             MOV      R0,R6
   \   000000A2   0x.... 0x....      BL       CPU_SR_Restore
    429                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   000000A6   0xF247 0x1051      MOVW     R0,#+29009
   \   000000AA   0x8020             STRH     R0,[R4, #+0]
    430                       break;
   \   000000AC   0xE007             B.N      ??OSTimeDlyResume_6
    431          
    432                  default:
    433                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_4: (+1)
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x4630             MOV      R0,R6
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
    434                      *p_err = OS_ERR_STATE_INVALID;
   \   000000B8   0xF646 0x602D      MOVW     R0,#+28205
   \   000000BC   0x8020             STRH     R0,[R4, #+0]
    435                       break;
    436              }
    437          
    438              OSSched();
   \                     ??OSTimeDlyResume_6: (+1)
   \   000000BE   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000C2   0x.... 0x....      B.W      OSSched
    439          }
    440          #endif
    441          /*$PAGE*/
    442          /*
    443          ************************************************************************************************************************
    444          *                                               GET CURRENT SYSTEM TIME
    445          *
    446          * Description: This function is used by your application to obtain the current value of the counter which keeps track of
    447          *              the number of clock ticks.
    448          *
    449          * Arguments  : p_err    is a pointer to a variable that will receive an error code
    450          *
    451          *                           OS_ERR_NONE           If the call was successful
    452          *
    453          * Returns    : The current value of OSTickCtr
    454          ************************************************************************************************************************
    455          */
    456          

   \                                 In section .text, align 2, keep-with-next
    457          OS_TICK  OSTimeGet (OS_ERR  *p_err)
    458          {
   \                     OSTimeGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    459              OS_TICK  ticks;
    460              CPU_SR_ALLOC();
    461          
    462          
    463          
    464          #ifdef OS_SAFETY_CRITICAL
    465              if (p_err == (OS_ERR *)0) {
    466                  OS_SAFETY_CRITICAL_EXCEPTION();
    467                  return ((OS_TICK)0);
    468              }
    469          #endif
    470          
    471              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    472              ticks = OSTickCtr;
   \   0000000E   0x....             LDR.N    R0,??DataTable5_4
   \   00000010   0x6806             LDR      R6,[R0, #+0]
    473              CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       CPU_SR_Restore
    474             *p_err = OS_ERR_NONE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
    475              return (ticks);
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    476          }
    477          
    478          /*
    479          ************************************************************************************************************************
    480          *                                                   SET SYSTEM CLOCK
    481          *
    482          * Description: This function sets the counter which keeps track of the number of clock ticks.
    483          *
    484          * Arguments  : ticks    is the desired tick value
    485          *
    486          *              p_err    is a pointer to a variable that will receive an error code
    487          *
    488          *                           OS_ERR_NONE           If the call was successful
    489          *
    490          * Returns    : none
    491          ************************************************************************************************************************
    492          */
    493          

   \                                 In section .text, align 2, keep-with-next
    494          void  OSTimeSet (OS_TICK   ticks,
    495                           OS_ERR   *p_err)
    496          {
   \                     OSTimeSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    497              CPU_SR_ALLOC();
    498          
    499          
    500          
    501          #ifdef OS_SAFETY_CRITICAL
    502              if (p_err == (OS_ERR *)0) {
    503                  OS_SAFETY_CRITICAL_EXCEPTION();
    504                  return;
    505              }
    506          #endif
    507          
    508              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x4606             MOV      R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    509              OSTickCtr = ticks;
   \   00000010   0x....             LDR.N    R0,??DataTable5_4
   \   00000012   0x6004             STR      R4,[R0, #+0]
    510              CPU_CRITICAL_EXIT();
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x.... 0x....      BL       CPU_SR_Restore
    511             *p_err     = OS_ERR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x8028             STRH     R0,[R5, #+0]
    512          }
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    513          
    514          /*$PAGE*/
    515          /*
    516          ************************************************************************************************************************
    517          *                                                 PROCESS SYSTEM TICK
    518          *
    519          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    520          *              'clock tick').  This function should be called by the tick ISR.
    521          *
    522          * Arguments  : none
    523          *
    524          * Returns    : none
    525          ************************************************************************************************************************
    526          */
    527          

   \                                 In section .text, align 2, keep-with-next
    528          void  OSTimeTick (void)
    529          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    530              OS_ERR  err;
    531          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    532              CPU_TS  ts;
    533          #endif
    534          
    535          
    536              OSTimeTickHook();                                       /* Call user definable hook                               */
   \   00000002   0x.... 0x....      BL       OSTimeTickHook
    537          
    538          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    539          
    540              ts = OS_TS_GET();                                       /* Get timestamp                                          */
    541              OS_IntQPost((OS_OBJ_TYPE) OS_OBJ_TYPE_TICK,             /* Post to ISR queue                                      */
    542                          (void      *)&OSRdyList[OSPrioCur],
    543                          (void      *) 0,
    544                          (OS_MSG_SIZE) 0u,
    545                          (OS_FLAGS   ) 0u,
    546                          (OS_OPT     ) 0u,
    547                          (CPU_TS     ) ts,
    548                          (OS_ERR    *)&err);
    549          
    550          #else
    551          
    552             (void)OSTaskSemPost((OS_TCB *)&OSTickTaskTCB,            /* Signal tick task                                       */
    553                                 (OS_OPT  ) OS_OPT_POST_NONE,
    554                                 (OS_ERR *)&err);
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable5_5
   \   0000000C   0x.... 0x....      BL       OSTaskSemPost
    555          
    556          
    557          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    558              OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
   \   00000010   0x....             LDR.N    R0,??DataTable5_6
   \   00000012   0x....             LDR.N    R1,??DataTable5_7
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   0000001A   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   0000001E   0x.... 0x....      BL       OS_SchedRoundRobin
    559          #endif
    560          
    561          #if OS_CFG_TMR_EN > 0u
    562              OSTmrUpdateCtr--;
   \   00000022   0x....             LDR.N    R0,??DataTable5_8
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x1E49             SUBS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    563              if (OSTmrUpdateCtr == (OS_CTR)0u) {
   \   0000002A   0xD107             BNE.N    ??OSTimeTick_0
    564                  OSTmrUpdateCtr = OSTmrUpdateCnt;
   \   0000002C   0x....             LDR.N    R1,??DataTable5_9
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x6001             STR      R1,[R0, #+0]
    565                  OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
    566                                (OS_OPT  ) OS_OPT_POST_NONE,
    567                                (OS_ERR *)&err);
   \   00000032   0x466A             MOV      R2,SP
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x....             LDR.N    R0,??DataTable5_10
   \   00000038   0x.... 0x....      BL       OSTaskSemPost
    568              }
    569          #endif
    570          
    571          #endif
    572          }
   \                     ??OSTimeTick_0: (+1)
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSTickTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     OSTmrUpdateCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     OSTmrUpdateCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     OSTmrTaskTCB

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTimeDly
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsert
      24   OSTimeDlyHMSM
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsert
      16   OSTimeDlyResume
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
         0   -> OSSched
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
      16   OSTimeGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTimeSet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       8   OSTimeTick
         8   -> OSTaskSemPost
         8   -> OSTimeTickHook
         8   -> OS_SchedRoundRobin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     166  OSTimeDly
     324  OSTimeDlyHMSM
     198  OSTimeDlyResume
      36  OSTimeGet
      36  OSTimeSet
      62  OSTimeTick

 
 866 bytes in section .text
 
 866 bytes of CODE memory

Errors: none
Warnings: none
